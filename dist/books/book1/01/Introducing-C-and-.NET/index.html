<h2>آشنایی با سی‌شارپ و دات‌نت</h2>
<p>سی‌شارپ یک زبان برنامه‌نویسی همه‌منظوره، با امنیت نوع (type-safe) و شی‌ءگرا است. هدف این زبان، افزایش بهره‌وری برنامه‌نویسان است. بدین منظور، سی‌شارپ بین سادگی، گویایی و عملکرد، تعادل ایجاد می‌کند. معمار اصلی این زبان از اولین نسخه آن، آندرس هجسلبرگ (خالق توربو پاسکال و معمار دلفی) بوده است.</p>
<p>سی‌شارپ زبانی مستقل از پلتفرم است و با محیط‌های اجرایی متنوعی که برای پلتفرم‌های مختلف طراحی شده‌اند، سازگار است.</p>
<h2>شی‌ءگرایی</h2>
<p>سی‌شارپ یک پیاده‌سازی غنی از پارادایم شی‌ءگرایی است که شامل کپسوله‌سازی (encapsulation)، وراثت (inheritance) و چندریختی (polymorphism) می‌شود. کپسوله‌سازی به معنای جداسازی رفتار عمومی یک شیء از جزئیات پیاده‌سازی داخلی آن است. در ادامه، ویژگی‌های متمایز سی‌شارپ از منظر شی‌ءگرایی آمده است:</p>
<p>سامانه نوع یکپارچه:
بلوک ساختاری اساسی در سی‌شارپ، یک واحد کپسوله‌شده از داده‌ها و توابع است که نوع نامیده می‌شود. سی‌شارپ دارای یک سامانه نوع یکپارچه است که در آن همه انواع، در نهایت یک نوع پایه مشترک دارند. این بدان معناست که همه انواع، چه نشان‌دهنده اشیاء کسب‌وکار باشند و چه انواع اولیه مانند اعداد، از همان عملکرد پایه مشترک برخوردارند. به عنوان مثال، یک نمونه از هر نوع را می‌توان با فراخوانی متد تبدیل به رشته (ToString) آن، به رشته تبدیل کرد.</p>
<p>کلاس‌ها و رابط‌ها:
در یک پارادایم سنتی شی‌ءگرا، تنها نوع موجود، کلاس است. در سی‌شارپ، چندین نوع دیگر نیز وجود دارد که یکی از آن‌ها رابط است. رابط مانند کلاسی است که نمی‌تواند داده نگه دارد. این بدان معناست که تنها می‌تواند رفتار را تعریف کند (و نه وضعیت را)، که امکان وراثت چندگانه و همچنین جدایی بین مشخصات و پیاده‌سازی را فراهم می‌کند.</p>
<p>خصوصیات، متدها و رویدادها:
در پارادایم شی‌ءگرای محض، همه توابع، متد هستند. در سی‌شارپ، متدها تنها یکی از انواع اعضای تابع هستند که شامل خصوصیات (properties) و رویدادها (events) نیز می‌شوند (انواع دیگری هم وجود دارند). خصوصیات، اعضای تابعی هستند که بخشی از وضعیت یک شیء را کپسوله‌سازی می‌کنند، مانند رنگ یک دکمه یا متن یک برچسب. رویدادها نیز اعضای تابعی هستند که ساده‌سازی واکنش به تغییرات وضعیت شیء را به عهده دارند.</p>
<p>اگرچه سی‌شارپ در درجه اول یک زبان شی‌ءگرا است، اما از پارادایم برنامه‌نویسی تابعی نیز الهام گرفته است، به ویژه در موارد زیر:</p>
<p>توابع را می‌توان به عنوان مقادیر در نظر گرفت:
با استفاده از نمایندگان (delegates)، سی‌شارپ اجازه می‌دهد تا توابع به عنوان مقادیر به توابع دیگر فرستاده و از آن‌ها بازگردانده شوند.</p>
<p>سی‌شارپ از الگوهای برنامه‌نویسی تابعی برای تغییرناپذیری پشتیبانی می‌کند:
هسته اصلی برنامه‌نویسی تابعی، پرهیز از استفاده از متغیرهایی است که مقادیرشان تغییر می‌کند، به نفع الگوهای اعلانی. سی‌شارپ ویژگی‌های کلیدی برای کمک به این الگوها دارد، از جمله توانایی نوشتن توابع بی‌نام به صورت لحظه‌ای که متغیرها را &quot;شکار&quot; می‌کنند (عبارات لامبدا) و توانایی انجام برنامه‌نویسی لیست یا واکنشی از طریق عبارات پرس‌وجو. سی‌شارپ همچنین سوابق (records) را فراهم می‌کند که نوشتن انواع تغییرناپذیر (فقط خواندنی) را آسان می‌کند.</p>
<h2>امنیت نوع</h2>
<p>سی‌شارپ در درجه اول یک زبان با امنیت نوع است، به این معنی که نمونه‌های انواع تنها می‌توانند از طریق پروتکل‌هایی که تعریف می‌کنند با یکدیگر تعامل داشته باشند، که این امر سازگاری داخلی هر نوع را تضمین می‌کند. به عنوان مثال، سی‌شارپ شما را از تعامل با یک نوع رشته به گونه‌ای که گویی یک نوع عدد صحیح است، باز می‌دارد.</p>
<p>به طور خاص‌تر، سی‌شارپ از تایپ ایستا (Static Typing) پشتیبانی می‌کند، به این معنی که زبان، امنیت نوع را در زمان کامپایل (Compile Time) اعمال می‌کند. این علاوه بر امنیت نوع است که در زمان اجرا (Runtime) نیز اعمال می‌شود. تایپ ایستا بخش بزرگی از خطاها را قبل از اجرای برنامه از بین می‌برد. بررسی صحت انواع را از آزمون‌های زمان اجرا به زمان کامپایل منتقل می‌کند. این باعث می‌شود مدیریت برنامه‌های بزرگ بسیار آسان‌تر، قابل پیش‌بینی‌تر و مقاوم‌تر شود. علاوه بر این، تایپ ایستا به ابزارهایی مانند IntelliSense در ویژوال استودیو امکان می‌دهد تا به شما در نوشتن برنامه کمک کنند، زیرا برای یک متغیر مشخص، نوع آن را می‌داند و در نتیجه می‌داند چه متدهایی را می‌توانید روی آن متغیر فراخوانی کنید. چنین ابزارهایی همچنین می‌توانند هر جایی از برنامه شما که یک متغیر، نوع یا متد استفاده شده است را شناسایی کرده و امکان بازسازی (Refactoring) قابل اعتماد را فراهم کنند.</p>
<p>سی‌شارپ همچنین اجازه می‌دهد بخش‌هایی از کد شما از طریق کلمه کلیدی پویا (dynamic) به صورت پویا تایپ شوند. با این حال، سی‌شارپ همچنان یک زبان عمدتاً با تایپ ایستا باقی می‌ماند.</p>
<p>سی‌شارپ همچنین یک زبان قوی‌تایپ (Strongly Typed) نامیده می‌شود، زیرا قوانین نوع آن به شدت اعمال می‌شوند (چه به صورت ایستا و چه در زمان اجرا). به عنوان مثال، نمی‌توانید تابعی را که برای پذیرش یک عدد صحیح طراحی شده است، با یک عدد اعشاری فراخوانی کنید، مگر اینکه ابتدا به صراحت عدد اعشاری را به عدد صحیح تبدیل کنید. این به جلوگیری از اشتباهات کمک می‌کند.</p>
<h2>مدیریت حافظه</h2>
<p>سی‌شارپ برای انجام مدیریت خودکار حافظه، به محیط زمان اجرا (runtime) متکی است. محیط زمان اجرای مشترک (Common Language Runtime) دارای یک پاک‌کننده حافظه (garbage collector) است که به‌عنوان بخشی از برنامه اجرا می‌شود و حافظه اشیائی را که دیگر ارجاعی به آن‌ها وجود ندارد، آزاد می‌کند. این کار برنامه‌نویسان را از آزادسازی صریح حافظه برای یک شیء رها می‌کند و مشکل اشاره‌گرهای نادرست که در زبان‌هایی مانند سی‌پلاس‌پلاس با آن‌ها مواجه می‌شدیم، از بین می‌برد.</p>
<p>سی‌شارپ اشاره‌گرها را به طور کامل حذف نمی‌کند: صرفاً آن‌ها را برای بیشتر وظایف برنامه‌نویسی غیرضروری می‌سازد. برای نقاط حساس به عملکرد (performance-critical hotspots) و تعامل‌پذیری (interoperability)، استفاده از اشاره‌گرها و تخصیص صریح حافظه در بلوک‌هایی که با عنوان &quot;ناامن&quot; (unsafe) علامت‌گذاری شده‌اند، مجاز است.</p>
<h2>پشتیبانی از بسترها</h2>
<p>سی‌شارپ دارای محیط‌های اجرایی است که از بسترهای زیر پشتیبانی می‌کنند:</p>
<p>رومیزی ویندوز ۷ به بالا (برای برنامه‌های مشتری غنی، وب، سرور و خط فرمان)
سیستم‌عامل مک (برای برنامه‌های وب و خط فرمان – و برنامه‌های مشتری غنی از طریق مک کاتالیست)
لینوکس (برای برنامه‌های وب و خط فرمان)
اندروید و آی‌او‌اس (برای برنامه‌های موبایل)
دستگاه‌های ویندوز ۱۰ (ایکس‌باکس، سرفیس هاب و هولولنز) از طریق سکوی برنامه‌نویسی جهانی ویندوز (UWP)
همچنین فناوری‌ای به نام بلِیْزر وجود دارد که می‌تواند سی‌شارپ را به اسمبلیکد وب (web assembly) کامپایل کند که در مرورگر اجرا می‌شود.</p>
<h2>محیط‌های زمان اجرا (CLRs)، کتابخانه‌های کلاس پایه (BCLs) و رانتایم‌ها</h2>
<p>پشتیبانی محیط زمان اجرا برای برنامه‌های سی‌شارپ شامل یک محیط زمان اجرای مشترک و یک کتابخانه کلاس پایه است. یک محیط زمان اجرا همچنین می‌تواند شامل یک لایه کاربردی سطح بالاتر باشد که شامل کتابخانه‌هایی برای توسعه برنامه‌های مشتری غنی، موبایل یا وب است (به تصویر ۱-۱ مراجعه کنید). محیط‌های زمان اجرای مختلف برای انواع مختلفی از برنامه‌ها و همچنین بسترهای متفاوت وجود دارند.</p>
<div align="center">
<p><img src="../../assets/image/01/Runtime-architecture.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>محیط زمان اجرای مشترک</h2>
<p>یک محیط زمان اجرای مشترک (CLR) خدمات اساسی زمان اجرا را فراهم می‌کند، از جمله مدیریت خودکار حافظه و رسیدگی به خطاها. (کلمه &quot;مشترک&quot; به این واقعیت اشاره دارد که همین محیط زمان اجرا می‌تواند توسط سایر زبان‌های برنامه‌نویسی مدیریت شده، مانند اف‌شارپ، ویژوال بیسیک، و سی‌پلاس‌پلاس مدیریت شده، به اشتراک گذاشته شود.)</p>
<p>سی‌شارپ یک زبان &quot;مدیریت شده&quot; نامیده می‌شود، زیرا کد منبع را به کد مدیریت شده (managed code) کامپایل می‌کند که در قالب زبان میانی (Intermediate Language - IL) نمایش داده می‌شود. محیط زمان اجرای مشترک (CLR) زبان میانی را به کد بومی ماشین (native code)، مانند X64 یا X86، معمولاً دقیقاً قبل از اجرا تبدیل می‌کند. به این فرآیند کامپایل در لحظه (Just-In-Time - JIT) گفته می‌شود. کامپایل پیش از زمان اجرا (Ahead-of-Time compilation) نیز برای بهبود زمان راه‌اندازی با مجموعه‌های بزرگ یا دستگاه‌های با منابع محدود (و برای رعایت قوانین فروشگاه برنامه‌های آی‌او‌اس هنگام توسعه برنامه‌های موبایل) در دسترس است.</p>
<p>ظرف حاوی کد مدیریت شده، مجموعه (Assembly) نامیده می‌شود. یک مجموعه نه تنها شامل زبان میانی، بلکه شامل اطلاعات نوع (metadata) نیز هست. وجود اطلاعات نوع به مجموعه‌ها اجازه می‌دهد تا به انواع موجود در سایر مجموعه‌ها بدون نیاز به فایل‌های اضافی ارجاع دهند.</p>
<p>شما می‌توانید محتویات یک مجموعه را با ابزار ildasm مایکروسافت بررسی و جداسازی (disassemble) کنید. و با ابزارهایی مانند ILSpy یا JetBrains dotPeek، می‌توانید فراتر رفته و زبان میانی را به سی‌شارپ دیکامپایل (decompile) کنید. از آنجا که زبان میانی سطح بالاتری نسبت به کد بومی ماشین دارد، ابزارهای دیکامپایلر می‌توانند کار بسیار خوبی در بازسازی سی‌شارپ اصلی انجام دهند.</p>
<p>یک برنامه می‌تواند اطلاعات نوع خودش را پرس‌وجو کند (بازتاب - reflection) و حتی در زمان اجرا، زبان میانی جدیدی تولید کند (reflection.emit).</p>
<h2>کتابخانه کلاس پایه</h2>
<p>یک محیط زمان اجرای مشترک (CLR) همیشه همراه با مجموعه‌ای از کتابخانه‌ها عرضه می‌شود که کتابخانه کلاس پایه (Base Class Library - BCL) نامیده می‌شوند. یک کتابخانه کلاس پایه، قابلیت‌های اصلی را به برنامه‌نویسان ارائه می‌دهد، مانند مجموعه‌ها (collections)، ورودی/خروجی، پردازش متن، مدیریت XML/JSON، شبکه‌سازی، رمزنگاری، تعامل‌پذیری (interop)، همروندی (concurrency) و برنامه‌نویسی موازی.</p>
<p>یک کتابخانه کلاس پایه همچنین انواعی را که خود زبان سی‌شارپ نیاز دارد (برای ویژگی‌هایی مانند شمارش، پرس‌وجو و ناهمگامی) پیاده‌سازی می‌کند و به شما امکان می‌دهد مستقیماً به ویژگی‌های محیط زمان اجرای مشترک (CLR)، مانند بازتاب و مدیریت حافظه، دسترسی پیدا کنید.</p>
<h2>محیط‌های اجرایی</h2>
<p>یک محیط اجرایی (runtime) (که گاهی اوقات &quot;چارچوب&quot; (framework) نیز نامیده می‌شود) یک واحد قابل استقرار است که آن را دانلود و نصب می‌کنید. یک محیط اجرایی از یک محیط زمان اجرای مشترک (CLR) (همراه با کتابخانه کلاس پایه آن) به علاوه یک لایه کاربردی اختیاری خاص برای نوع برنامه‌ای که می‌نویسید – وب، موبایل، مشتری غنی و غیره – تشکیل شده است. (اگر در حال نوشتن یک برنامه کنسولی خط فرمان یا یک کتابخانه بدون رابط کاربری هستید، نیازی به لایه کاربردی ندارید.)</p>
<p>هنگام نوشتن یک برنامه، شما یک محیط اجرایی خاص را هدف قرار می‌دهید، به این معنی که برنامه شما از قابلیت‌هایی که آن محیط اجرایی فراهم می‌کند، استفاده می‌کند و به آن‌ها وابسته است. انتخاب محیط اجرایی شما همچنین تعیین می‌کند که برنامه شما از کدام بسترها پشتیبانی خواهد کرد.</p>
<p>جدول زیر گزینه‌های اصلی محیط‌های اجرایی را فهرست می‌کند:</p>
<div align="center">
<p><img src="../../assets/image/01/Introduction-02.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>تصویر ۱-۲ این اطلاعات را به صورت گرافیکی نمایش می‌دهد و همچنین به عنوان راهنمایی برای مطالبی که در کتاب پوشش داده شده‌اند، عمل می‌کند.</p>
<div align="center">
<p><img src="../../assets/image/01/Introduction-03.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>.NET 8</h2>
<p>دات‌نت ۸ محیط زمان اجرای متن‌باز و پرچم‌دار مایکروسافت است. شما می‌توانید برنامه‌های وب و کنسول را بنویسید که روی ویندوز، لینوکس و سیستم‌عامل مک اجرا می‌شوند؛ برنامه‌های مشتری غنی (rich-client) که روی ویندوز ۱۰ به بالا و سیستم‌عامل مک اجرا می‌شوند؛ و برنامه‌های موبایل که روی آی‌او‌اس و اندروید اجرا می‌شوند. این کتاب بر محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) دات‌نت ۸ تمرکز دارد.</p>
<p>بر خلاف چارچوب دات‌نت (NET Framework.)، دات‌نت ۸ به صورت پیش‌فرض روی دستگاه‌های ویندوزی نصب نیست. اگر سعی کنید یک برنامه دات‌نت ۸ را بدون حضور محیط زمان اجرای صحیح اجرا کنید، پیامی ظاهر می‌شود که شما را به یک صفحه وب برای دانلود محیط زمان اجرا هدایت می‌کند. می‌توانید با ایجاد یک استقرار خودکفا (self-contained deployment)، که شامل بخش‌های مورد نیاز محیط زمان اجرا برای برنامه است، از این امر جلوگیری کنید.</p>
<p>تاریخچه به‌روزرسانی‌های دات‌نت به شرح زیر است: دات‌نت کور ۱.x → دات‌نت کور ۲.x → دات‌نت کور ۳.x → دات‌نت ۵ → دات‌نت ۶ → دات‌نت ۷ → دات‌نت ۸. پس از دات‌نت کور ۳، مایکروسافت واژه &quot;کور&quot; را از نام حذف کرد و از نسخه ۴ صرف‌نظر کرد تا از سردرگمی با چارچوب دات‌نت ۴.x که پیش از تمام محیط‌های اجرایی قبلی قرار دارد اما هنوز پشتیبانی می‌شود و به طور گسترده مورد استفاده است، جلوگیری کند.</p>
<p>این بدان معناست که مجموعه‌های کامپایل شده تحت دات‌نت کور ۱.x تا دات‌نت ۷، در بیشتر موارد، بدون تغییر تحت دات‌نت ۸ اجرا خواهند شد. در مقابل، مجموعه‌های کامپایل شده تحت (هر نسخه‌ای از) چارچوب دات‌نت معمولاً با دات‌نت ۸ ناسازگار هستند.</p>
<h2>Windows Desktop and WinUI 3</h2>
<p>برای نوشتن برنامه‌های مشتری غنی که روی ویندوز ۱۰ به بالا اجرا می‌شوند، می‌توانید بین رابط‌های برنامه‌نویسی کاربردی کلاسیک رومیزی ویندوز (فرم‌های ویندوز و WPF) و رابط کاربری ویندوز ۳ انتخاب کنید. رابط‌های برنامه‌نویسی کاربردی رومیزی ویندوز بخشی از محیط زمان اجرای دسکتاپ دات‌نت هستند، در حالی که رابط کاربری ویندوز ۳ بخشی از بسته توسعه نرم‌افزاری برنامه‌های ویندوز (Windows App SDK) است (یک دانلود جداگانه).</p>
<p>رابط‌های برنامه‌نویسی کاربردی کلاسیک رومیزی ویندوز از سال ۲۰۰۶ وجود داشته‌اند و از پشتیبانی عالی کتابخانه‌های شخص ثالث و همچنین منابع غنی از سوالات پاسخ داده شده در سایت‌هایی مانند استک‌اُوِرفلو برخوردارند. رابط کاربری ویندوز ۳ در سال ۲۰۲۲ منتشر شد و برای نوشتن برنامه‌های غوطه‌ور و مدرن که شامل جدیدترین کنترل‌های ویندوز ۱۰ به بالا هستند، در نظر گرفته شده است. این رابط، جانشین سکوی برنامه‌نویسی جهانی ویندوز (UWP) است.</p>
<h2>MAUI</h2>
<p>مویی (MAUI - رابط کاربری برنامه چندبستری) در درجه اول برای ایجاد برنامه‌های موبایل برای آی‌او‌اس و اندروید طراحی شده است، اگرچه می‌توان از آن برای برنامه‌های رومیزی که روی سیستم‌عامل مک و ویندوز از طریق مک کاتالیست و رابط کاربری ویندوز ۳ اجرا می‌شوند نیز استفاده کرد. مویی تکامل یافته زامارین (Xamarin) است و اجازه می‌دهد یک پروژه واحد چندین بستر را هدف قرار دهد.</p>
<p>برای برنامه‌های رومیزی چندبستری، یک کتابخانه شخص ثالث به نام آوالونیا (Avalonia) جایگزینی برای مویی ارائه می‌دهد. آوالونیا روی لینوکس نیز اجرا می‌شود و از نظر معماری ساده‌تر از مویی است (زیرا بدون لایه غیرمستقیم کاتالیست/رابط کاربری ویندوز عمل می‌کند). آوالونیا یک رابط برنامه‌نویسی کاربردی شبیه به WPF دارد، و همچنین یک افزونه تجاری به نام XPF ارائه می‌دهد که سازگاری تقریباً کاملی با WPF فراهم می‌کند.</p>
<h2>.NET Framework</h2>
<p>چارچوب دات‌نت (NET Framework.)، محیط زمان اجرای اصلی مایکروسافت فقط برای ویندوز است که برای نوشتن برنامه‌های وب و مشتری غنی که (فقط) روی رومیزی/سرور ویندوز اجرا می‌شوند، به کار می‌رود. هیچ نسخه اصلی جدیدی برای آن برنامه‌ریزی نشده است، اگرچه مایکروسافت به دلیل وجود حجم زیادی از برنامه‌های موجود، به پشتیبانی و نگهداری نسخه ۴.۸ فعلی ادامه خواهد داد.</p>
<p>با چارچوب دات‌نت، محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) با لایه کاربردی ادغام شده‌اند. برنامه‌های نوشته شده در چارچوب دات‌نت را می‌توان تحت دات‌نت ۸ مجدداً کامپایل کرد، اگرچه معمولاً نیاز به تغییراتی دارند. برخی از ویژگی‌های چارچوب دات‌نت در دات‌نت ۸ وجود ندارند (و برعکس).</p>
<p>چارچوب دات‌نت به صورت پیش‌فرض با ویندوز نصب می‌شود و به طور خودکار از طریق به‌روزرسانی ویندوز اصلاح (patch) می‌گردد. هنگامی که چارچوب دات‌نت ۴.۸ را هدف قرار می‌دهید، می‌توانید از ویژگی‌های سی‌شارپ ۷.۳ و نسخه‌های قبلی استفاده کنید. (می‌توانید با مشخص کردن یک نسخه زبان جدیدتر در فایل پروژه این را لغو کنید – این کار تمام جدیدترین ویژگی‌های زبان را باز می‌کند، به جز مواردی که نیاز به پشتیبانی از یک محیط زمان اجرای جدیدتر دارند.)</p>
<p>کلمه &quot;دات‌نت&quot; مدت‌هاست که به عنوان یک اصطلاح چترگونه برای هر فناوری‌ای که شامل کلمه &quot;دات‌نت&quot; است (چارچوب دات‌نت، دات‌نت کور، دات‌نت استاندارد و غیره) به کار رفته است.</p>
<p>این بدان معناست که تغییر نام دات‌نت کور به دات‌نت توسط مایکروسافت، ابهام نامطلوبی ایجاد کرده است. در این کتاب، هنگامی که ابهامی پیش می‌آید، به دات‌نت جدید به عنوان &quot;دات‌نت ۵ به بالا&quot; اشاره خواهیم کرد. و برای اشاره به دات‌نت کور و جانشینان آن، از عبارت &quot;دات‌نت کور و دات‌نت ۵ به بالا&quot; استفاده خواهیم کرد.</p>
<p>برای افزودن به سردرگمی، دات‌نت (۵ به بالا) یک چارچوب (framework) است، با این حال بسیار متفاوت از چارچوب دات‌نت (NET Framework.) است. از این رو، هر جا که ممکن باشد، اصطلاح &quot;محیط زمان اجرا&quot; (runtime) را به &quot;چارچوب&quot; (framework) ترجیح می‌دهیم.</p>
<h2>محیط‌های اجرایی خاص Niche Runtimes</h2>
<p>همچنین محیط‌های اجرایی خاص زیر وجود دارند:</p>
<p>یونیتی (Unity): یک سکوی توسعه بازی است که اجازه می‌دهد منطق بازی با سی‌شارپ نوشته شود.</p>
<p>سکوی برنامه‌نویسی جهانی ویندوز (UWP): برای نوشتن برنامه‌های لمسی‌محور (touch-first) طراحی شده بود که روی رومیزی ویندوز ۱۰ به بالا و دستگاه‌ها، از جمله ایکس‌باکس، سرفیس هاب و هولولنز اجرا می‌شوند. برنامه‌های سکوی برنامه‌نویسی جهانی ویندوز در محیط ایزوله (sandboxed) اجرا می‌شوند و از طریق فروشگاه ویندوز منتشر می‌گردند. سکوی برنامه‌نویسی جهانی ویندوز از نسخه‌ای از محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) دات‌نت کور ۲.۲ استفاده می‌کند و بعید است که این وابستگی به‌روزرسانی شود؛ در عوض، مایکروسافت توصیه کرده است که کاربران به جایگزین مدرن آن، یعنی رابط کاربری ویندوز ۳، روی بیاورند. اما از آنجا که رابط کاربری ویندوز ۳ تنها از رومیزی ویندوز پشتیبانی می‌کند، سکوی برنامه‌نویسی جهانی ویندوز همچنان برای هدف قرار دادن ایکس‌باکس، سرفیس هاب و هولولنز یک کاربرد خاص دارد.</p>
<p>چارچوب کوچک دات‌نت (NET Micro Framework.): برای اجرای کدهای دات‌نت روی دستگاه‌های تعبیه شده با منابع بسیار محدود (زیر یک مگابایت) است.</p>
<p>همچنین امکان اجرای کد مدیریت شده در داخل اس‌کیو‌ال سرور نیز وجود دارد. با ادغام محیط زمان اجرای مشترک (CLR) اس‌کیو‌ال سرور، می‌توانید توابع سفارشی، رویه‌های ذخیره شده (stored procedures) و تجمعات (aggregations) را در سی‌شارپ بنویسید و سپس آن‌ها را از اس‌کیو‌ال فراخوانی کنید. این قابلیت در ترکیب با چارچوب دات‌نت و یک محیط زمان اجرای مشترک &quot;میزبان شده&quot; (hosted CLR) کار می‌کند که یک محیط ایزوله را برای محافظت از یکپارچگی فرآیند اس‌کیو‌ال سرور اعمال می‌کند.</p>
<h2>تاریخچه‌ای کوتاه از سی‌شارپ</h2>
<p>در ادامه، یک گاه‌شمار معکوس از ویژگی‌های جدید در هر نسخه سی‌شارپ، برای خوانندگانی که قبلاً با نسخه قدیمی‌تر زبان آشنا هستند، آورده شده است.</p>
<h2>تازه‌های سی‌شارپ ۱۲</h2>
<p>سی‌شارپ ۱۲ همراه با ویژوال استودیو ۲۰۲۲ عرضه می‌شود و هنگامی که دات‌نت ۸ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h2>Collection expressions</h2>
<p>به جای مقداردهی اولیه یک آرایه به شکل زیر:</p>
<pre><code class="language-C#">char[] vowels = {'a','e','i','o','u'};
</code></pre>
<p>اکنون می‌توانید از براکت‌های مربعی (که یک عبارت مجموعه است) استفاده کنید:</p>
<pre><code class="language-C#">char[] vowels = ['a','e','i','o','u'];
</code></pre>
<p>عبارات مجموعه دو مزیت عمده دارند. اول اینکه، همین نحو برای انواع مجموعه‌ای دیگر، مانند لیست‌ها و مجموعه‌ها (و حتی انواع اسپَن سطح پایین) نیز کار می‌کند:</p>
<pre><code class="language-C#">List list         = ['a','e','i','o','u'];
HashSet set       = ['a','e','i','o','u'];
ReadOnlySpan span = ['a','e','i','o','u'];
</code></pre>
<p>دوم اینکه، آن‌ها نوع-هدف هستند، به این معنی که در سناریوهای دیگری که کامپایلر می‌تواند نوع را استنباط کند، می‌توانید نوع را حذف کنید، مانند هنگام فراخوانی متدها:</p>
<pre><code class="language-C#">Foo (['a','e','i','o','u']);
void Foo (char[] letters) { ... }
</code></pre>
<p>برای جزئیات بیشتر، به &quot;مقداردهنده‌های اولیه مجموعه و عبارات مجموعه&quot; در صفحه ۲۰۵ مراجعه کنید.</p>
<h2>سازنده‌های اصلی در کلاس‌ها و ساختارها  Primary constructors in classes and structs</h2>
<p>از سی‌شارپ ۱۲ به بعد، می‌توانید یک لیست پارامتر را مستقیماً پس از اعلان کلاس (یا ساختار) قرار دهید:</p>
<pre><code class="language-C#">
class Person (string firstName, string lastName)
{
  public void Print() =&gt; Console.WriteLine (firstName + &quot; &quot; + lastName);
}
</code></pre>
<p>این دستور به کامپایلر می‌گوید که به طور خودکار یک سازنده اصلی بسازد، که امکان استفاده زیر را فراهم می‌کند:</p>
<pre><code class="language-C#">
Person p = new Person (&quot;Alice&quot;, &quot;Jones&quot;);
p.Print();    // Alice Jones
</code></pre>
<p>این ویژگی از سی‌شارپ ۹ با رِکوردها وجود داشته است—که در آنجا رفتار کمی متفاوتی دارند. با رِکوردها، کامپایلر (به طور پیش‌فرض) یک خصوصیت init-only عمومی برای هر پارامتر سازنده اصلی ایجاد می‌کند. این مورد در کلاس‌ها و ساختارها صدق نمی‌کند؛ برای دستیابی به همین نتیجه، باید آن خصوصیات را به صراحت تعریف کنید:</p>
<pre><code class="language-C#">
class Person (string firstName, string lastName)
{
 public string FirstName { get; set; } = firstName;
 public string LastName { get; set; } = lastName;
 }
</code></pre>
<p>سازنده‌های اصلی در سناریوهای ساده به خوبی کار می‌کنند. ما ظرایف و محدودیت‌های آن‌ها را در &quot;سازنده‌های اصلی (سی‌شارپ ۱۲)&quot; در صفحه ۱۱۹ شرح می‌دهیم.</p>
<h2>پارامترهای پیش‌فرض عبارت‌های لامبدا Default lambda parameters</h2>
<p>همانطور که متدهای عادی می‌توانند پارامترهایی با مقادیر پیش‌فرض تعریف کنند:</p>
<pre><code class="language-C#">
void Print (string message = &quot;&quot;) =&gt; Console.WriteLine (message);
</code></pre>
<p>عبارت‌های لامبدا نیز می‌توانند:</p>
<p>C#</p>
<p>var print = (string message = &quot;&quot;) =&gt; Console.WriteLine (message);
print (&quot;Hello&quot;);
print ();
این ویژگی با کتابخانه‌هایی مانند رابط برنامه‌نویسی کاربردی حداقلی ای‌اس‌پی‌نت مفید است.</p>
<h2>نام مستعار برای هر نوع Alias any type</h2>
<p>سی‌شارپ همیشه به شما اجازه داده است که با استفاده از دستور using، یک نام مستعار برای یک نوع ساده یا عمومی ایجاد کنید:</p>
<pre><code class="language-C#">
using ListOfInt = System.Collections.Generic.List;
var list = new ListOfInt();
</code></pre>
<p>از سی‌شارپ ۱۲ به بعد، این رویکرد با انواع دیگر نیز کار می‌کند، مانند آرایه‌ها و تاپِل‌ها:</p>
<pre><code class="language-C#">
using NumberList = double[];
using Point = (int X, int Y);
NumberList numbers = { 2.5, 3.5 };
Point p = (3, 4);
</code></pre>
<h2>سایر ویژگی‌های جدید</h2>
<p>سی‌شارپ ۱۲ همچنین از آرایه‌های درون‌خطی، از طریق خصیصه [System.Runtime.CompilerServices.InlineArray] پشتیبانی می‌کند. این امکان ایجاد آرایه‌های با اندازه ثابت در یک ساختار را بدون نیاز به یک زمینه ناامن فراهم می‌کند و در درجه اول برای استفاده در رابط‌های برنامه‌نویسی کاربردی زمان اجرا در نظر گرفته شده است.</p>
<h2>تازه‌های سی‌شارپ ۱۱</h2>
<p>سی‌شارپ ۱۱ همراه با ویژوال استودیو ۲۰۲۲ عرضه شد و به طور پیش‌فرض زمانی که دات‌نت ۷ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h2>عبارات رشته خام  Raw string literals</h2>
<p>قرار دادن یک رشته در سه یا چند علامت نقل قول، یک عبارت رشته خام (raw string literal) ایجاد می‌کند که می‌تواند تقریباً هر توالی از کاراکترها را بدون نیاز به فرار (escaping) یا تکرار، شامل شود. این کار نمایش متن‌هایی مانند جیسون، اِکس‌اِم‌ال و اچ‌تی‌اِم‌ال، و همچنین عبارات منظم و کدهای منبع را آسان می‌کند:</p>
<pre><code class="language-C#">
 string raw = &quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;;
</code></pre>
<p>عبارات رشته خام می‌توانند چندخطی باشند و از درون‌یابی (interpolation) از طریق پیشوند $ پشتیبانی می‌کنند:</p>
<pre><code class="language-C#">
string multiLineRaw = $&quot;&quot;&quot;
  Line 1
  Line 2
  The date and time is {DateTime.Now}
 &quot;&quot;&quot;;
</code></pre>
<p>استفاده از دو (یا بیشتر) علامت $ در پیشوند یک عبارت رشته خام، توالی درون‌یابی را از یک براکت آکولاد به دو (یا بیشتر) براکت آکولاد تغییر می‌دهد و به شما امکان می‌دهد براکت‌ها را در خود رشته نیز قرار دهید:</p>
<pre><code class="language-C#">
Console.WriteLine ($$&quot;&quot;&quot;{ &quot;TimeStamp&quot;: &quot;&quot; }&quot;&quot;&quot;);
// Output: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }
</code></pre>
<p>ما ظرایف این ویژگی را در &quot;عبارات رشته خام (سی‌شارپ ۱۱)&quot; در صفحه ۵۹ و &quot;درون‌یابی رشته&quot; در صفحه ۶۰ پوشش می‌دهیم.</p>
<h2>UTF-8 strings</h2>
<p>با پسوند u8، شما عبارت‌های رشته‌ای را ایجاد می‌کنید که به جای یوتی‌اف-۱۶، در یوتی‌اف-۸ کدگذاری شده‌اند. این ویژگی برای سناریوهای پیشرفته مانند مدیریت سطح پایین متن‌های جیسون در نقاط حساس به عملکرد در نظر گرفته شده است:</p>
<pre><code class="language-C#">
ReadOnlySpan&lt;byte&gt; utf8 = &quot;ab→cd&quot;u8;  // Arrow symbol consumes 3 bytes
Console.WriteLine (utf8.Length);      // 7
</code></pre>
<p>نوع زیربنایی، ReadOnlySpan<byte> (فصل ۲۳) است، که می‌توانید با فراخوانی متد ToArray() آن را به یک آرایه بایت تبدیل کنید.</p>
<h2>الگوهای لیست</h2>
<p>الگوهای لیست با مجموعه‌ای از عناصر در براکت‌های مربعی مطابقت دارند و با هر نوع مجموعه‌ای که قابل شمارش (با خصوصیت Count یا Length) و قابل اندیس‌گذاری (با یک اندیس‌گذار از نوع int یا System.Index) باشد، کار می‌کنند:</p>
<pre><code class="language-C#">
int[] numbers = { 0, 1, 2, 3, 4 };
Console.WriteLine (numbers is [0, 1, 2, 3, 4]);   // True
</code></pre>
<p>یک زیرخط با یک عنصر منفرد از هر مقداری مطابقت دارد، و دو نقطه با صفر یا بیشتر عنصر (یک برش) مطابقت دارند:</p>
<pre><code class="language-C#">
Console.WriteLine (numbers is [_, 1, .., 4]);     // True
</code></pre>
<p>یک برش می‌تواند با الگوی var دنبال شود – برای جزئیات به &quot;الگوهای لیست&quot; در صفحه ۲۴۳ مراجعه کنید.</p>
<h2>Required members</h2>
<p>اعمال اصلاح‌کننده required به یک فیلد یا خصوصیت، مصرف‌کنندگان آن کلاس یا ساختار را مجبور می‌کند تا هنگام ساخت شیء، آن عضو را از طریق یک مقداردهنده اولیه شیء (object initializer) مقداردهی کنند:</p>
<pre><code class="language-C#">
Asset a1 = new Asset { Name = &quot;House&quot; };  // OK
Asset a2 = new Asset();                   // Error: will not compile!
class Asset { public required string Name; }
</code></pre>
<p>با این ویژگی، می‌توانید از نوشتن سازنده‌هایی با لیست‌های پارامتر طولانی اجتناب کنید، که می‌تواند زیرکلاس‌سازی را ساده‌تر کند. اگر مایل به نوشتن یک سازنده نیز باشید، می‌توانید خصیصه [SetsRequiredMembers] را اعمال کنید تا محدودیت عضو مورد نیاز را برای آن سازنده نادیده بگیرید – برای جزئیات به &quot;اعضای مورد نیاز (سی‌شارپ ۱۱)&quot; در صفحه ۱۳۶ مراجعه کنید.</p>
<h2>اعضای رابط استاتیک مجازی/انتزاعی Static virtual/abstract interface members</h2>
<p>از سی‌شارپ ۱۱، رابط‌ها می‌توانند اعضا را به صورت static virtual یا static abstract اعلان کنند:</p>
<pre><code class="language-C#">
public interface IParsable
{
 static abstract TSelf Parse (string s);
}
</code></pre>
<p>این اعضا به عنوان توابع static در کلاس‌ها یا ساختارها پیاده‌سازی می‌شوند و می‌توانند به صورت چندریختی از طریق یک پارامتر نوع مقید فراخوانی شوند:</p>
<pre><code class="language-C#">
T ParseAny (string s) where T : IParsable =&gt; T.Parse (s);
</code></pre>
<p>توابع عملگر (Operator functions) نیز می‌توانند به صورت static virtual یا static abstract اعلان شوند. برای جزئیات، به &quot;اعضای رابط استاتیک مجازی/انتزاعی&quot; در صفحه ۱۵۳ و &quot;چندریختی استاتیک&quot; در صفحه ۲۶۰ مراجعه کنید. همچنین نحوه فراخوانی اعضای انتزاعی استاتیک از طریق بازتاب را در &quot;فراخوانی اعضای رابط استاتیک مجازی/انتزاعی&quot; در صفحه ۸۲۶ شرح می‌دهیم.</p>
<h2>ریاضیات عمومی</h2>
<p>رابط System.Numerics.INumber (جدید در دات‌نت ۷) عملیات حسابی را در تمام انواع عددی یکپارچه می‌کند و امکان نوشتن متدهای عمومی مانند زیر را فراهم می‌سازد:</p>
<pre><code class="language-C#">
T Sum (T[] numbers) where T : INumber
{
  T total = T.Zero;
  foreach (T n in numbers)
    total += n;      // Invokes addition operator for any numeric type
  return total;
}
int intSum = Sum (3, 5, 7);
double doubleSum = Sum (3.2, 5.3, 7.1);
decimal decimalSum = Sum (3.2m, 5.3m, 7.1m);
</code></pre>
<p>INumber توسط تمام انواع عددی حقیقی و صحیح در دات‌نت (و همچنین char) پیاده‌سازی می‌شود و شامل چندین رابط است که تعریف‌های عملگر انتزاعی استاتیک مانند زیر را در بر می‌گیرد:</p>
<pre><code class="language-C#">
static abstract TResult operator + (TSelf left, TOther right);
</code></pre>
<p>ما این مبحث را در &quot;عملگرهای چندریختی&quot; در صفحه ۲۶۱ و &quot;ریاضیات عمومی&quot; در صفحه ۲۶۲ پوشش می‌دهیم.</p>
<h2>سایر ویژگی‌های جدید</h2>
<p>نوعی که با اصلاح‌کننده دسترسی file مشخص می‌شود، تنها از درون همان فایل قابل دسترسی است و برای استفاده در مولدهای منبع (source generators) در نظر گرفته شده است:</p>
<pre><code class="language-C#">
file class Foo { ... }
</code></pre>
<p>سی‌شارپ ۱۱ همچنین عملگرهای بررسی‌شده (checked operators) را معرفی کرد (به &quot;عملگرهای بررسی‌شده&quot; در صفحه ۲۵۸ مراجعه کنید)، برای تعریف توابع عملگر که در بلوک‌های checked فراخوانی شوند (این مورد برای پیاده‌سازی کامل ریاضیات عمومی لازم بود). سی‌شارپ ۱۱ همچنین الزام به مقداردهی همه فیلدها در سازنده یک ساختار را کاهش داد (به &quot;معناشناسی ساختاردهی ساختار&quot; در صفحه ۱۴۲ مراجعه کنید).</p>
<p>در نهایت، انواع اعداد صحیح بومی‌اندازه nint و nuint که در سی‌شارپ ۹ معرفی شده بودند تا با فضای آدرس فرآیند در زمان اجرا (۳۲ یا ۶۴ بیت) مطابقت داشته باشند، در سی‌شارپ ۱۱ هنگامی که دات‌نت ۷ یا بالاتر را هدف قرار می‌دهید، بهبود یافتند. به طور خاص، تمایز زمان کامپایل بین این انواع و انواع زمان اجرای زیربنایی آن‌ها (IntPtr و UIntPtr) هنگام هدف قرار دادن دات‌نت ۷ به بالا، از بین رفته است. برای بحث کامل‌تر به &quot;اعداد صحیح بومی‌اندازه&quot; در صفحه ۲۶۶ مراجعه کنید.</p>
<h2>تازه‌های سی‌شارپ ۱۰</h2>
<p>سی‌شارپ ۱۰ همراه با ویژوال استودیو ۲۰۲۲ عرضه شد و زمانی که دات‌نت ۶ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>فضاهای نام محدود به فایل</h3>
<p>در حالت رایجی که تمام انواع یک فایل در یک فضای نام واحد تعریف می‌شوند، اعلان فضای نام محدود به فایل در سی‌شارپ ۱۰ از شلوغی کم می‌کند و یک سطح تورفتگی غیرضروری را حذف می‌کند:</p>
<pre><code class="language-C#">
namespace MyNamespace;  // Applies to everything that follows in the file.
class Class1 {}         // inside MyNamespace
class Class2 {}         // inside MyNamespace
</code></pre>
<h3>دستور using سراسری</h3>
<p>هنگامی که یک دستور using را با کلمه کلیدی global پیشوند می‌کنید، این دستور به تمام فایل‌های پروژه اعمال می‌شود:</p>
<pre><code class="language-C#">
global using System;
global using System.Collection.Generic;
</code></pre>
<p>این به شما امکان می‌دهد از تکرار دستورات یکسان در هر فایل جلوگیری کنید. دستورات global using با using static نیز کار می‌کنند.</p>
<p>علاوه بر این، پروژه‌های دات‌نت ۶ اکنون از دستورات global using ضمنی پشتیبانی می‌کنند: اگر عنصر ImplicitUsings در فایل پروژه روی true تنظیم شود، رایج‌ترین فضاهای نام به طور خودکار وارد می‌شوند (بر اساس نوع پروژه کیت توسعه نرم‌افزاری). برای جزئیات بیشتر به &quot;دستور global using&quot; در صفحه ۹۶ مراجعه کنید.</p>
<h3>تغییر غیرمخرب برای انواع بی‌نام</h3>
<p>سی‌شارپ ۹ کلمه کلیدی with را برای انجام تغییر غیرمخرب بر روی رِکوردها معرفی کرد. در سی‌شارپ ۱۰، کلمه کلیدی with با انواع بی‌نام نیز کار می‌کند:</p>
<pre><code class="language-C#">
var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 }; 
Console.WriteLine (a2);      // { A = 1, B = 2, C = 3, D = 4, E = 10 }
</code></pre>
<h3>نحو جدید تفکیک ساختار</h3>
<p>سی‌شارپ ۷ نحو تفکیک ساختار (deconstruction syntax) را برای تاپِل‌ها (یا هر نوعی با متد Deconstruct) معرفی کرد. سی‌شارپ ۱۰ این نحو را فراتر برده و به شما اجازه می‌دهد انتساب و اعلان را در یک عملیات تفکیک ساختار ترکیب کنید:</p>
<pre><code class="language-C#">
var point = (3, 4);
double x = 0;
(x, double y) = point;
</code></pre>
<h3>مقداردهنده‌های اولیه فیلد و سازنده‌های بدون پارامتر در ساختارها</h3>
<p>از سی‌شارپ ۱۰ به بعد، می‌توانید مقداردهنده‌های اولیه فیلد و سازنده‌های بدون پارامتر را در ساختارها قرار دهید (به &quot;ساختارها&quot; در صفحه ۱۴۲ مراجعه کنید). این‌ها تنها زمانی اجرا می‌شوند که سازنده به صراحت فراخوانی شود، و بنابراین به راحتی می‌توان آن‌ها را نادیده گرفت – مثلاً از طریق کلمه کلیدی default. این ویژگی در درجه اول به منظور بهره‌مندی رِکورد ساختارها معرفی شد.</p>
<h3>رِکورد ساختارها</h3>
<p>رِکوردها ابتدا در سی‌شارپ ۹ معرفی شدند، جایی که به عنوان یک کلاس با قابلیت‌های کامپایلر-افزوده عمل می‌کردند. در سی‌شارپ ۱۰، رِکوردها می‌توانند ساختار نیز باشند:</p>
<pre><code class="language-C#">
record struct Point (int X, int Y);
</code></pre>
<p>قوانین در سایر موارد مشابه هستند: رِکورد ساختارها ویژگی‌های بسیار مشابهی با رِکورد کلاس‌ها دارند (به &quot;رِکوردها&quot; در صفحه ۲۲۷ مراجعه کنید). یک استثنا این است که خصوصیات تولید شده توسط کامپایلر در رِکورد ساختارها قابل نوشتن هستند، مگر اینکه اعلان رِکورد را با کلمه کلیدی readonly پیشوند کنید.</p>
<h3>بهبودهای عبارات لامبدا</h3>
<p>نحو مربوط به عبارات لامبدا به روش‌های مختلفی بهبود یافته است. اول اینکه، تایپ ضمنی (var) مجاز است:</p>
<pre><code class="language-C#">
var greeter = () =&gt; &quot;Hello, world&quot;;
</code></pre>
<p>نوع ضمنی برای یک عبارت لامبدا، یک دلیگیت Action یا Func است، بنابراین greeter در این حالت، از نوع Func است. شما باید به صراحت انواع پارامترها را بیان کنید:</p>
<pre><code class="language-C#">
var square = (int x) =&gt; x * x;
</code></pre>
<p>دوم، یک عبارت لامبدا می‌تواند یک نوع بازگشتی را مشخص کند:</p>
<pre><code class="language-C#">
var sqr = int (int x) =&gt; x;
</code></pre>
<p>این عمدتاً برای بهبود عملکرد کامپایلر با لامبداهای پیچیده تو در تو است. سوم، می‌توانید یک عبارت لامبدا را به یک پارامتر متد از نوع object، Delegate یا Expression ارسال کنید:</p>
<pre><code class="language-C#">
M1 (() =&gt; &quot;test&quot;);   // Implicitly typed to Func
M2 (() =&gt; &quot;test&quot;);   // Implicitly typed to Func
M3 (() =&gt; &quot;test&quot;);   // Implicitly typed to Expression&lt;Func&lt;string&gt;&gt;
void M1 (object x) {}
void M2 (Delegate x) {}
void M3 (Expression x) {}
</code></pre>
<p>در نهایت، می‌توانید خصیصه‌ها را به متد هدف تولید شده توسط کامپایلر برای یک عبارت لامبدا (و همچنین پارامترها و مقدار بازگشتی آن) اعمال کنید:</p>
<pre><code class="language-C#">
Action a = [Description(&quot;test&quot;)] () =&gt; { };
</code></pre>
<p>برای جزئیات بیشتر به &quot;اعمال خصیصه‌ها به عبارات لامبدا&quot; در صفحه ۲۴۵ مراجعه کنید.</p>
<h3>الگوهای خصوصیت تو در تو</h3>
<p>نحو ساده شده زیر در سی‌شارپ ۱۰ برای تطبیق الگوی خصوصیت تو در تو قانونی است (به &quot;الگوهای خصوصیت&quot; در صفحه ۲۴۱ مراجعه کنید):</p>
<pre><code class="language-C#">
var obj = new Uri (&quot;https://www.linqpad.net&quot;);
if (obj is Uri { Scheme.Length: 5 }) ...
</code></pre>
<p>این معادل با:</p>
<pre><code class="language-C#">
if (obj is Uri { Scheme: { Length: 5 }}) ...
</code></pre>
<h3>عبارت آرگومان فراخواننده</h3>
<p>یک پارامتر متد که به آن خصیصه [CallerArgumentExpression] را اعمال می‌کنید، یک عبارت آرگومان را از محل فراخوانی دریافت می‌کند:</p>
<pre><code class="language-C#">
Print (Math.PI * 2);
void Print (double number,
           [CallerArgumentExpression(&quot;number&quot;)] string expr = null)
  =&gt; Console.WriteLine (expr);
// Output: Math.PI * 2
</code></pre>
<p>این ویژگی عمدتاً برای کتابخانه‌های اعتبار سنجی و ادعا در نظر گرفته شده است (به &quot;عبارت آرگومان فراخواننده&quot; در صفحه ۲۴۷ مراجعه کنید).</p>
<h3>سایر ویژگی‌های جدید</h3>
<p>دستور line# در سی‌شارپ ۱۰ بهبود یافته است تا امکان مشخص کردن یک ستون و محدوده را فراهم کند.</p>
<p>رشته‌های درون‌یابی شده در سی‌شارپ ۱۰ می‌توانند ثابت باشند، تا زمانی که مقادیر درون‌یابی شده نیز ثابت باشند.</p>
<p>رِکوردها می‌توانند متد ToString() را در سی‌شارپ ۱۰ seal کنند.</p>
<p>تحلیل انتساب قطعی سی‌شارپ بهبود یافته است به طوری که عباراتی مانند زیر کار می‌کنند:</p>
<pre><code class="language-C#">
if (foo?.TryParse (&quot;123&quot;, out var number) ?? false)
  Console.WriteLine (number);
</code></pre>
<p>(پیش از سی‌شارپ ۱۰، کامپایلر خطایی تولید می‌کرد: &quot;استفاده از متغیر محلی نامقداری شده 'number'.&quot;)</p>
<h2>تازه‌های سی‌شارپ ۹.۰</h2>
<p>سی‌شارپ ۹.۰ همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و زمانی که دات‌نت ۵ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>دستورات سطح بالا</h3>
<p>با دستورات سطح بالا (به &quot;دستورات سطح بالا&quot; در صفحه ۴۱ مراجعه کنید)، می‌توانید برنامه‌ای را بدون بار اضافه متد Main و کلاس Program بنویسید:</p>
<pre><code class="language-C#">
using System;
Console.WriteLine (&quot;Hello, world&quot;);
</code></pre>
<p>دستورات سطح بالا می‌توانند شامل متدها (که به عنوان متدهای محلی عمل می‌کنند) باشند. همچنین می‌توانید از طریق متغیر &quot;جادویی&quot; args به آرگومان‌های خط فرمان دسترسی پیدا کنید و یک مقدار به فراخواننده برگردانید. دستورات سطح بالا می‌توانند با اعلان‌های نوع و فضای نام دنبال شوند.</p>
<h3>تنظیم‌کننده‌های فقط مقداردهی اولیه</h3>
<p>یک تنظیم‌کننده فقط مقداردهی اولیه (init-only setter) (به &quot;تنظیم‌کننده‌های فقط مقداردهی اولیه&quot; در صفحه ۱۱۶ مراجعه کنید) در اعلان خصوصیت، به جای کلمه کلیدی set از کلمه کلیدی init استفاده می‌کند:</p>
<pre><code class="language-C#">
class Foo { public int ID { get; init; } }
</code></pre>
<p>این خصوصیت مانند یک خصوصیت فقط خواندنی رفتار می‌کند، با این تفاوت که می‌تواند از طریق یک مقداردهنده اولیه شیء (object initializer) نیز تنظیم شود:</p>
<pre><code class="language-C#">
var foo = new Foo { ID = 123 };
</code></pre>
<p>این امر ایجاد انواع تغییرناپذیر (read-only) را که می‌توانند به جای سازنده از طریق یک مقداردهنده اولیه شیء مقداردهی شوند، ممکن می‌سازد و به جلوگیری از ضدالگوی سازنده‌هایی که تعداد زیادی پارامتر اختیاری را می‌پذیرند، کمک می‌کند. تنظیم‌کننده‌های فقط مقداردهی اولیه همچنین در هنگام استفاده در رِکوردها، امکان تغییر غیرمخرب را فراهم می‌کنند.</p>
<h3>رِکوردها</h3>
<p>یک رِکورد (به &quot;رِکوردها&quot; در صفحه ۲۲۷ مراجعه کنید) نوع خاصی از کلاس است که برای کار با داده‌های تغییرناپذیر طراحی شده است. خاص‌ترین ویژگی آن این است که از تغییر غیرمخرب از طریق یک کلمه کلیدی جدید (with) پشتیبانی می‌کند:</p>
<pre><code class="language-C#">
Point p1 = new Point (2, 3);
Point p2 = p1 with { Y = 4 };   // p2 is a copy of p1, but with Y set to 4
Console.WriteLine (p2);         // Point { X = 2, Y = 4 }
</code></pre>
<pre><code class="language-C#">
record Point
 {
  public Point (double x, double y) =&gt; (X, Y) = (x, y);
  public double X { get; init; }
  public double Y { get; init; }    
}
</code></pre>
<p>در موارد ساده، یک رِکورد می‌تواند کد قالبی تعریف خصوصیات و نوشتن سازنده و تفکیک‌کننده را نیز حذف کند. می‌توانیم تعریف رِکورد Point خود را بدون از دست دادن کارایی، با کد زیر جایگزین کنیم:</p>
<pre><code class="language-C#">
record Point (double X, double Y);
</code></pre>
<p>مانند تاپِل‌ها، رِکوردها به طور پیش‌فرض برابری ساختاری را نشان می‌دهند. رِکوردها می‌توانند از رِکوردهای دیگر زیرکلاس بسازند و می‌توانند شامل همان ساختارهایی باشند که کلاس‌ها می‌توانند شامل شوند. کامپایلر رِکوردها را در زمان اجرا به عنوان کلاس پیاده‌سازی می‌کند.</p>
<h3>بهبودهای تطبیق الگو</h3>
<p>الگوی رابطه‌ای (به &quot;الگوها&quot; در صفحه ۲۳۸ مراجعه کنید) به عملگرهای &lt;, &gt;, &lt;=, و &gt;= اجازه می‌دهد در الگوها ظاهر شوند:</p>
<pre><code class="language-C#">
string GetWeightCategory (decimal bmi) =&gt; bmi switch {
 &lt; 18.5m =&gt; &quot;underweight&quot;,
 &lt; 25m =&gt; &quot;normal&quot;,
 &lt; 30m =&gt; &quot;overweight&quot;,
  _ =&gt; &quot;obese&quot; };
</code></pre>
<p>با ترکیب‌کننده‌های الگو، می‌توانید الگوها را از طریق سه کلمه کلیدی جدید (and, or, و not) ترکیب کنید:</p>
<pre><code class="language-C#">
bool IsVowel (char c) =&gt; c is 'a' or 'e' or 'i' or 'o' or 'u';
bool IsLetter (char c) =&gt; c is &gt;= 'a' and &lt;= 'z'
 or &gt;= 'A' and &lt;= 'Z';
</code></pre>
<p>مانند عملگرهای &amp;&amp; و ||، عملگر and اولویت بالاتری نسبت به or دارد. می‌توانید با پرانتز این اولویت را نادیده بگیرید.</p>
<p>ترکیب‌کننده not می‌تواند با الگوی نوع استفاده شود تا آزمایش کند که آیا یک شیء (نه) از یک نوع خاص است:</p>
<pre><code class="language-C#">
if (obj is not string) ...
</code></pre>
<h3>عبارات new نوع-هدف Target-typed new expressions</h3>
<p>هنگام ساخت یک شیء، سی‌شارپ ۹ به شما اجازه می‌دهد نام نوع را زمانی که کامپایلر می‌تواند به طور unambiguous آن را استنباط کند، حذف کنید:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new (&quot;Test&quot;);
</code></pre>
<p>این به ویژه زمانی مفید است که اعلان متغیر و مقداردهی اولیه در بخش‌های مختلف کد شما قرار دارند:</p>
<pre><code class="language-C#">
class Foo
{
 System.Text.StringBuilder sb;
  public Foo (string initialValue) =&gt; sb = new (initialValue);
 }
</code></pre>
<p>و در سناریوی زیر:</p>
<pre><code class="language-C#">
MyMethod (new (&quot;test&quot;));
void MyMethod (System.Text.StringBuilder sb) { ... }
</code></pre>
<p>برای اطلاعات بیشتر به &quot;عبارات new نوع-هدف&quot; در صفحه ۷۷ مراجعه کنید.</p>
<h3>بهبودهای تعامل‌پذیری</h3>
<p>سی‌شارپ ۹ اشاره‌گرهای تابع (function pointers) را معرفی می‌کند (به &quot;اشاره‌گرهای تابع&quot; در صفحه ۲۶۸ و &quot;فراخوانی‌های برگشتی با اشاره‌گرهای تابع&quot; در صفحه ۹۹۱ مراجعه کنید). هدف اصلی آن‌ها این است که به کدهای مدیریت‌نشده اجازه دهند متدهای static را در سی‌شارپ بدون سربار یک نمونه دلیگیت فراخوانی کنند، با قابلیت نادیده گرفتن لایه فراخوانی تابع خارجی (P/Invoke) زمانی که آرگومان‌ها و انواع بازگشتی از نوع blittable هستند (یعنی در هر دو سمت به یک شکل نمایش داده می‌شوند).</p>
<p>سی‌شارپ ۹ همچنین انواع اعداد صحیح بومی‌اندازه nint و nuint را معرفی می‌کند (به &quot;اعداد صحیح بومی‌اندازه&quot; در صفحه ۲۶۶ مراجعه کنید)، که در زمان اجرا به System.IntPtr و System.UIntPtr نگاشت می‌شوند. در زمان کامپایل، آن‌ها مانند انواع عددی با پشتیبانی از عملیات حسابی رفتار می‌کنند.</p>
<h3>سایر ویژگی‌های جدید</h3>
<p>علاوه بر این، سی‌شارپ ۹ اکنون به شما اجازه می‌دهد:</p>
<p>یک متد یا خصوصیت فقط خواندنی را به گونه‌ای بازنویسی کنید که یک نوع مشتق‌شده‌تر را برگرداند (به &quot;انواع بازگشتی کوواریانت&quot; در صفحه ۱۳۱ مراجعه کنید).
خصوصیات (Attributes) را به توابع محلی اعمال کنید (به &quot;خصوصیات&quot; در صفحه ۲۴۳ مراجعه کنید).
کلمه کلیدی static را به عبارات لامبدا یا توابع محلی اعمال کنید تا مطمئن شوید که به طور تصادفی متغیرهای محلی یا نمونه را شکار نمی‌کنید (به &quot;لامبداهای استاتیک&quot; در صفحه ۱۹۲ مراجعه کنید).
با نوشتن یک متد توسعه‌دهنده GetEnumerator، هر نوعی را با دستور foreach سازگار کنید.
یک متد مقداردهنده اولیه ماژول تعریف کنید که با اولین بارگذاری یک اَسمبلی یک بار اجرا می‌شود، با اعمال خصیصه [ModuleInitializer] به یک متد (static void بدون پارامتر).
از یک &quot;بازیافت&quot; (نماد زیرخط) به عنوان آرگومان عبارت لامبدا استفاده کنید.
متدهای partial توسعه‌یافته بنویسید که پیاده‌سازی آن‌ها اجباری است – امکان سناریوهایی مانند مولدهای منبع جدید Roslyn را فراهم می‌کند (به &quot;متدهای partial توسعه‌یافته&quot; در صفحه ۱۲۵ مراجعه کنید).
یک خصیصه را به متدها، انواع یا ماژول‌ها اعمال کنید تا از مقداردهی اولیه متغیرهای محلی توسط زمان اجرا جلوگیری شود (به &quot;[SkipLocalsInit]&quot; در صفحه ۲۶۹ مراجعه کنید).</p>
<h2>تازه‌های سی‌شارپ ۸.۰</h2>
<p>سی‌شارپ ۸.۰ ابتدا همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و امروزه همچنان زمانی که دات‌نت کور ۳ یا دات‌نت استاندارد ۲.۱ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>اندیس‌ها و محدوده‌ها</h3>
<p>اندیس‌ها و محدوده‌ها کار با عناصر یا بخش‌هایی از یک آرایه (یا انواع سطح پایین Span و ReadOnlySpan) را ساده می‌کنند.</p>
<p>اندیس‌ها به شما اجازه می‌دهند با استفاده از عملگر ^ به عناصر نسبت به انتهای یک آرایه ارجاع دهید. ^1 به آخرین عنصر، ^2 به عنصر یکی مانده به آخر و غیره ارجاع می‌دهد:</p>
<pre><code class="language-C#">
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [^1];   // 'u'
char secondToLast = vowels [^2];   // 'o'
</code></pre>
<p>محدوده‌ها به شما اجازه می‌دهند با استفاده از عملگر .. یک آرایه را &quot;برش&quot; دهید:</p>
<pre><code class="language-C#">
char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3]    // 'i'
char[] lastTwo =   vowels [^2..];   // 'o', 'u'
</code></pre>
<p>سی‌شارپ اندیس‌ها و محدوده‌ها را با کمک انواع Index و Range پیاده‌سازی می‌کند:</p>
<pre><code class="language-C#">
Index last = ^1;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'
</code></pre>
<p>شما می‌توانید با تعریف یک اندیس‌گذار با نوع پارامتر Index یا Range، از اندیس‌ها و محدوده‌ها در کلاس‌های خودتان پشتیبانی کنید:</p>
<pre><code class="language-C#">
class Sentence
{
  string[] words = &quot;The quick brown fox&quot;.Split();
  public string this   [Index index] =&gt; words [index];
  public string[] this [Range range] =&gt; words [range];
}
</code></pre>
<p>برای اطلاعات بیشتر، به &quot;اندیس‌ها و محدوده‌ها&quot; در صفحه ۶۳ مراجعه کنید.</p>
<h3>انتساب ترکیبی نال</h3>
<p>عملگر ??= یک متغیر را تنها در صورتی مقداردهی می‌کند که null باشد. به جای:</p>
<pre><code class="language-C#">
if (s == null) s = &quot;Hello, world&quot;;
</code></pre>
<p>اکنون می‌توانید این گونه بنویسید:</p>
<pre><code class="language-C#">
s ??= &quot;Hello, world&quot;;
</code></pre>
<h3>اعلان‌های using</h3>
<p>اگر براکت‌ها و بلوک دستورات پس از یک دستور using را حذف کنید، تبدیل به یک اعلان using می‌شود. سپس منبع زمانی آزاد می‌شود که اجرا از بلوک دستور احاطه‌کننده خارج شود:</p>
<pre><code class="language-C#">
if (File.Exists (&quot;file.txt&quot;))
{
}
using var reader = File.OpenText (&quot;file.txt&quot;);
  Console.WriteLine (reader.ReadLine());
  ...
</code></pre>
<p>در این حالت، reader زمانی آزاد خواهد شد که اجرا از بلوک دستور if خارج شود.</p>
<h3>اعضای فقط خواندنی</h3>
<p>سی‌شارپ ۸ به شما اجازه می‌دهد اصلاح‌کننده readonly را به توابع یک ساختار اعمال کنید، که این امر تضمین می‌کند اگر تابع تلاش کند هر فیلدی را تغییر دهد، یک خطای زمان کامپایل تولید می‌شود:</p>
<pre><code class="language-C#">
struct Point
{
  public int X, Y;
  public readonly void ResetX() =&gt; X = 0;  // Error!
}
</code></pre>
<p>اگر یک تابع readonly تابع غیر readonly را فراخوانی کند، کامپایلر یک هشدار تولید می‌کند (و به صورت دفاعی ساختار را کپی می‌کند تا از احتمال تغییر جلوگیری شود).</p>
<h3>متدهای محلی static</h3>
<p>افزودن اصلاح‌کننده static به یک متد محلی، از دسترسی آن به متغیرهای محلی و پارامترهای متد احاطه‌کننده جلوگیری می‌کند. این کار به کاهش وابستگی (coupling) کمک می‌کند و به متد محلی اجازه می‌دهد متغیرها را به دلخواه خود اعلان کند، بدون خطر برخورد با متغیرهای موجود در متد حاوی.</p>
<h3>اعضای رابط پیش‌فرض</h3>
<p>سی‌شارپ ۸ به شما اجازه می‌دهد یک پیاده‌سازی پیش‌فرض به عضو یک رابط اضافه کنید، که پیاده‌سازی آن را اختیاری می‌کند:</p>
<pre><code class="language-C#">
interface ILogger
{
  void Log (string text) =&gt; Console.WriteLine (text);
}
</code></pre>
<p>این بدان معناست که می‌توانید بدون اینکه پیاده‌سازی‌های موجود را خراب کنید، عضوی را به یک رابط اضافه کنید. پیاده‌سازی‌های پیش‌فرض باید به صراحت از طریق رابط فراخوانی شوند:</p>
<pre><code class="language-C#">
((ILogger)new Logger()).Log (&quot;message&quot;);
</code></pre>
<p>رابط‌ها همچنین می‌توانند اعضای static (شامل فیلدها) را تعریف کنند، که می‌توان از کد داخل پیاده‌سازی‌های پیش‌فرض به آن‌ها دسترسی پیدا کرد:</p>
<pre><code class="language-C#">
interface ILogger
{
  void Log (string text) =&gt; Console.WriteLine (Prefix + text);
 static string Prefix = &quot;&quot;; 
}
</code></pre>
<p>یا از خارج از رابط، مگر اینکه از طریق یک اصلاح‌کننده دسترسی روی عضو static رابط (مانند private, protected, یا internal) محدود شده باشد:</p>
<pre><code class="language-C#">
ILogger.Prefix = &quot;File log: &quot;;
</code></pre>
<p>فیلدهای نمونه ممنوع هستند. برای جزئیات بیشتر، به &quot;اعضای رابط پیش‌فرض&quot; در صفحه ۱۵۱ مراجعه کنید.</p>
<h3>عبارات switch</h3>
<p>از سی‌شارپ ۸ به بعد، می‌توانید از switch در زمینه یک عبارت استفاده کنید:</p>
<pre><code class="language-C#">
string cardName = cardNumber switch
{
    // assuming cardNumber is an int
  13 =&gt; &quot;King&quot;,
  12 =&gt; &quot;Queen&quot;,
  11 =&gt; &quot;Jack&quot;,
 _ =&gt; &quot;Pip card&quot;   // equivalent to 'default'
};
</code></pre>
<p>برای مثال‌های بیشتر، به &quot;عبارات switch&quot; در صفحه ۹۰ مراجعه کنید.</p>
<h3>الگوهای تاپل، موقعیتی و خصوصیت</h3>
<p>سی‌شارپ ۸ از سه الگوی جدید پشتیبانی می‌کند که بیشتر برای بهره‌مندی از دستورات/عبارات switch هستند (به &quot;الگوها&quot; در صفحه ۲۳۸ مراجعه کنید). الگوهای تاپل به شما اجازه می‌دهند بر روی چندین مقدار switch کنید:</p>
<pre><code class="language-C#">
int cardNumber = 12; string suite = &quot;spades&quot;;
string cardName = (cardNumber, suite) switch
{
 (13, &quot;spades&quot;) =&gt; &quot;King of spades&quot;,
 (13, &quot;clubs&quot;) =&gt; &quot;King of clubs&quot;,
  ...
};
</code></pre>
<p>الگوهای موقعیتی (positional patterns) نحو مشابهی را برای اشیائی که یک تفکیک‌کننده (deconstructor) را نمایش می‌دهند، امکان‌پذیر می‌سازند و الگوهای خصوصیت (property patterns) به شما اجازه می‌دهند بر روی خصوصیات یک شیء مطابقت ایجاد کنید. می‌توانید از تمام الگوها هم در switchها و هم با عملگر is استفاده کنید. مثال زیر از یک الگوی خصوصیت استفاده می‌کند تا بررسی کند آیا obj یک رشته با طول ۴ است:</p>
<pre><code class="language-C#">
if (obj is string { Length:4 }) ...
</code></pre>
<h3>انواع ارجاعی با قابلیت تهی (Nullable Reference Types)</h3>
<p>در حالی که انواع مقداری با قابلیت تهی (nullable value types) قابلیت تهی بودن را به انواع مقداری می‌آورند، انواع ارجاعی با قابلیت تهی عکس این کار را می‌کنند و (درجه‌ای از) عدم قابلیت تهی بودن را به انواع ارجاعی می‌آورند، با این هدف که به جلوگیری از خطاهای NullReferenceException کمک کنند. انواع ارجاعی با قابلیت تهی یک سطح از ایمنی را معرفی می‌کنند که صرفاً توسط کامپایلر در قالب هشدارها یا خطاها هنگام تشخیص کدی که در معرض خطر تولید NullReferenceException است، اعمال می‌شود.</p>
<p>انواع ارجاعی با قابلیت تهی می‌توانند یا در سطح پروژه (از طریق عنصر Nullable در فایل پروژه .csproj) یا در کد (از طریق دستور #nullable) فعال شوند. پس از فعال شدن، کامپایلر عدم قابلیت تهی بودن را به پیش‌فرض تبدیل می‌کند: اگر می‌خواهید یک نوع ارجاعی nullها را بپذیرد، باید پسوند ? را برای نشان دادن یک نوع ارجاعی با قابلیت تهی اعمال کنید:</p>
<pre><code class="language-C#">
#nullable enable    // Enable nullable reference types from this point on
string s1 = null;   // Generates a compiler warning! (s1 is non-nullable)
string? s2 = null;  // OK: s2 is nullable reference type
</code></pre>
<p>فیلدهای مقداردهی نشده نیز (اگر نوع به عنوان nullable علامت‌گذاری نشده باشد) یک هشدار تولید می‌کنند، همانطور که لغو ارجاع یک نوع ارجاعی با قابلیت تهی نیز (اگر کامپایلر فکر کند NullReferenceException ممکن است رخ دهد):</p>
<pre><code class="language-C#">
void Foo (string? s) =&gt; Console.Write (s.Length);  // Warning (.Length)
</code></pre>
<p>برای حذف هشدار، می‌توانید از عملگر null-forgiving (!) استفاده کنید:</p>
<pre><code class="language-C#">
void Foo (string? s) =&gt; Console.Write (s!.Length);
</code></pre>
<p>برای بحث کامل، به &quot;انواع ارجاعی با قابلیت تهی&quot; در صفحه ۲۱۵ مراجعه کنید.</p>
<h3>جریان‌های ناهمگام</h3>
<p>پیش از سی‌شارپ ۸، می‌توانستید از yield return برای نوشتن یک تکرارکننده (iterator) یا از await برای نوشتن یک تابع ناهمگام استفاده کنید. اما نمی‌توانستید هر دو را انجام دهید و یک تکرارکننده بنویسید که منتظر بماند (await) و عناصر را به صورت ناهمگام تولید کند. سی‌شارپ ۸ با معرفی جریان‌های ناهمگام (asynchronous streams) این مشکل را برطرف می‌کند:</p>
<pre><code class="language-C#">
async IAsyncEnumerable&lt;int&gt; RangeAsync (
  int start, int count, int delay)
 {
  for (int i = start; i &lt; start + count; i++)
  {
 await Task.Delay (delay);
 yield return i;
}
  }
</code></pre>
<p>دستور await foreach یک جریان ناهمگام را مصرف می‌کند:</p>
<pre><code class="language-C#">
await foreach (var number in RangeAsync (0, 10, 100))
  Console.WriteLine (number);
</code></pre>
<p>برای اطلاعات بیشتر، به &quot;جریان‌های ناهمگام&quot; در صفحه ۶۷۲ مراجعه کنید.</p>
<h2>تازه‌های سی‌شارپ ۷.x</h2>
<p>سی‌شارپ ۷.x ابتدا با ویژوال استودیو ۲۰۱۷ عرضه شد. سی‌شارپ ۷.۳ امروز نیز توسط ویژوال استودیو ۲۰۱۹ زمانی که دات‌نت کور ۲، چارچوب دات‌نت ۴.۶ تا ۴.۸، یا دات‌نت استاندارد ۲.۰ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>سی‌شارپ ۷.۳</h3>
<p>سی‌شارپ ۷.۳ بهبودهای جزئی در ویژگی‌های موجود ایجاد کرد، مانند فعال کردن استفاده از عملگرهای برابری با تاپِل‌ها، بهبود تفکیک بار اضافی متدها (overload resolution) و قابلیت اعمال خصیصه‌ها به فیلدهای پشتیبان خصوصیات خودکار:</p>
<pre><code class="language-C#">
[field:NonSerialized]
public int MyProperty { get; set; }
</code></pre>
<p>سی‌شارپ ۷.۳ همچنین بر پایه ویژگی‌های برنامه‌نویسی پیشرفته با تخصیص حافظه پایین در سی‌شارپ ۷.۲ بنا شد، با قابلیت انتساب مجدد متغیرهای محلی ref، عدم نیاز به پین کردن هنگام اندیس‌گذاری فیلدهای ثابت، و پشتیبانی از مقداردهنده اولیه فیلد با stackalloc:</p>
<pre><code class="language-C#">
int* pointer  = stackalloc int[] {1, 2, 3};
Span&lt;int&gt; arr = stackalloc []    
{1, 2, 3};
</code></pre>
<p>توجه کنید که حافظه تخصیص‌یافته روی پشته (stack-allocated) را می‌توان مستقیماً به یک Span انتساب داد. ما در فصل ۲۳ اسپَن‌ها و دلیل استفاده از آن‌ها را شرح می‌دهیم.</p>
<h3>سی‌شارپ ۷.۲</h3>
<p>سی‌شارپ ۷.۲ اصلاح‌کننده جدید private protected را اضافه کرد (اشتراک internal و protected)، قابلیت دنبال کردن آرگومان‌های نام‌گذاری شده با آرگومان‌های موقعیتی هنگام فراخوانی متدها، و ساختارهای readonly. یک ساختار readonly تضمین می‌کند که تمام فیلدها readonly هستند تا در اعلان نیت کمک کند و به کامپایلر آزادی بهینه‌سازی بیشتری بدهد:</p>
<pre><code class="language-C#">
readonly struct Point
{
  public readonly int X, Y;   // X and Y must be readonly
}
</code></pre>
<p>سی‌شارپ ۷.۲ همچنین ویژگی‌های تخصصی را برای کمک به بهینه‌سازی‌های کوچک و برنامه‌نویسی با تخصیص حافظه پایین اضافه کرد: به &quot;اصلاح‌کننده in&quot; در صفحه ۷۲، &quot;متغیرهای محلی Ref&quot; در صفحه ۷۵، &quot;بازگشت‌های Ref&quot; در صفحه ۷۶، و &quot;ساختارهای Ref&quot; در صفحه ۱۴۴ مراجعه کنید.</p>
<h3>سی‌شارپ ۷.۱</h3>
<p>از سی‌شارپ ۷.۱، در صورت امکان استنباط نوع، می‌توانید هنگام استفاده از کلمه کلیدی default، نوع را حذف کنید:</p>
<pre><code class="language-C#">
decimal number = default;   // number is decimal
</code></pre>
<p>سی‌شارپ ۷.۱ همچنین قوانین مربوط به دستورات switch را آسان‌تر کرد (به طوری که می‌توانید بر روی پارامترهای نوع عمومی تطبیق الگو انجام دهید)، اجازه داد متد Main یک برنامه ناهمگام باشد، و اجازه داد نام عناصر تاپل استنباط شوند:</p>
<pre><code class="language-C#">
var now = DateTime.Now;
var tuple = (now.Hour, now.Minute, now.Second);
</code></pre>
<h3>بهبودهای ثابت‌های عددی</h3>
<p>ثابت‌های عددی در سی‌شارپ ۷ می‌توانند شامل زیرخط‌هایی برای بهبود خوانایی باشند. این‌ها جداکننده‌های ارقام نامیده می‌شوند و توسط کامپایلر نادیده گرفته می‌شوند:</p>
<pre><code class="language-C#">
int million = 1_000_000;
</code></pre>
<p>ثابت‌های دودویی را می‌توان با پیشوند 0b مشخص کرد:</p>
<pre><code class="language-C#">
var b = 0b1010_1011_1100_1101_1110_1111;
</code></pre>
<h3>متغیرهای out و discardها</h3>
<p>سی‌شارپ ۷ فراخوانی متدهایی که شامل پارامترهای out هستند را آسان‌تر می‌کند. اول اینکه، اکنون می‌توانید متغیرهای out را به صورت لحظه‌ای اعلان کنید (به &quot;متغیرهای out و discardها&quot; در صفحه ۷۲):</p>
<pre><code class="language-C#">
bool successful = int.TryParse (&quot;123&quot;, out int result);
Console.WriteLine (result);
</code></pre>
<p>و هنگام فراخوانی متدی با چندین پارامتر out، می‌توانید با کاراکتر زیرخط (_) آن‌هایی را که به آن‌ها علاقه‌ای ندارید، نادیده بگیرید (discard):</p>
<pre><code class="language-C#">
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
Console.WriteLine (x);
</code></pre>
<h3>الگوهای نوع و متغیرهای الگو</h3>
<p>شما می‌توانید متغیرها را به صورت لحظه‌ای با عملگر is نیز معرفی کنید. این‌ها متغیرهای الگو نامیده می‌شوند (به &quot;معرفی یک متغیر الگو&quot; در صفحه ۱۳۰):</p>
<pre><code class="language-C#">
void Foo (object x)
{
  if (x is string s)
    Console.WriteLine (s.Length);
}
</code></pre>
<p>دستور switch نیز از الگوهای نوع پشتیبانی می‌کند، بنابراین می‌توانید علاوه بر ثابت‌ها، بر اساس نوع نیز switch کنید (به &quot;سوئیچ کردن بر روی انواع&quot; در صفحه ۸۹). می‌توانید شرایط را با یک عبارت when مشخص کنید و همچنین بر روی مقدار null نیز switch کنید:</p>
<pre><code class="language-C#">
switch (x)
{
  case int i:
    Console.WriteLine (&quot;It's an int!&quot;);
    break;
  case string s:
    Console.WriteLine (s.Length);    // We can use the s variable
    break;
  case bool b when b == true:        // Matches only when b is true
    Console.WriteLine (&quot;True&quot;);
    break;
  case null:
    Console.WriteLine (&quot;Nothing&quot;);
    break;
}
</code></pre>
<h3>متدهای محلی</h3>
<p>یک متد محلی، متدی است که در داخل تابع دیگری اعلان می‌شود (به &quot;متدهای محلی&quot; در صفحه ۱۰۶):</p>
<pre><code class="language-C#">
void WriteCubes()
{
  Console.WriteLine (Cube (3));
  Console.WriteLine (Cube (4));
  Console.WriteLine (Cube (5));
 int Cube (int value) =&gt; value * value * value;
}
</code></pre>
<p>متدهای محلی فقط برای تابع حاوی قابل مشاهده هستند و می‌توانند متغیرهای محلی را به همان روشی که عبارات لامبدا انجام می‌دهند، شکار کنند.</p>
<h3>اعضای بیشتر با بدنه عبارت</h3>
<p>سی‌شارپ ۶ نحو &quot;پیکان چاق&quot; با بدنه عبارت را برای متدها، خصوصیات فقط خواندنی، عملگرها و اندیس‌گذارها معرفی کرد. سی‌شارپ ۷ این را به سازنده‌ها، خصوصیات خواندنی/نوشتنی و نهایی‌کننده‌ها (finalizers) گسترش می‌دهد:</p>
<pre><code class="language-C#">
public class Person
{
  string name;
 public Person (string name) =&gt; Name = name;
  public string Name
  {
 get =&gt; name;
 set =&gt; name = value ?? &quot;&quot;;
  }
 ~Person () =&gt; Console.WriteLine (&quot;finalize&quot;);
}
</code></pre>
<h3>تفکیک‌کننده‌ها</h3>
<p>سی‌شارپ ۷ الگوی تفکیک‌کننده (deconstructor) را معرفی می‌کند (به &quot;تفکیک‌کننده‌ها&quot; در صفحه ۱۱۰). در حالی که یک سازنده معمولاً مجموعه‌ای از مقادیر (به عنوان پارامتر) را می‌گیرد و به فیلدها انتساب می‌دهد، یک تفکیک‌کننده برعکس عمل می‌کند و فیلدها را به مجموعه‌ای از متغیرها بازگردانده و انتساب می‌دهد. ما می‌توانیم یک تفکیک‌کننده برای کلاس Person در مثال قبلی به شکل زیر بنویسیم (صرف نظر از مدیریت خطا):</p>
<pre><code class="language-C#">
public void Deconstruct (out string firstName, out string lastName)
{
  int spacePos = name.IndexOf (' ');
  firstName = name.Substring (0, spacePos);
  lastName = name.Substring (spacePos + 1);
}
</code></pre>
<p>تفکیک‌کننده‌ها با نحو خاص زیر فراخوانی می‌شوند:</p>
<pre><code class="language-C#">
var joe = new Person (&quot;Joe Bloggs&quot;);
var (first, last) = joe;          // Deconstruction
Console.WriteLine (first);        // Joe
Console.WriteLine (last);         // Bloggs
</code></pre>
<h3>تاپِل‌ها Tuples</h3>
<p>شاید قابل توجه‌ترین بهبود سی‌شارپ ۷، پشتیبانی صریح از تاپِل‌ها باشد (به &quot;تاپِل‌ها&quot; در صفحه ۲۲۲). تاپِل‌ها راهی ساده برای ذخیره مجموعه‌ای از مقادیر مرتبط فراهم می‌کنند:</p>
<pre><code class="language-C#">
var bob = (&quot;Bob&quot;, 23);
Console.WriteLine (bob.Item1);   // Bob
Console.WriteLine (bob.Item2);   // 23
</code></pre>
<p>تاپِل‌های جدید سی‌شارپ، یک قند نحوی (syntactic sugar) برای استفاده از ساختارهای عمومی System.ValueTuple&lt;…&gt; هستند. اما به لطف جادوی کامپایلر، عناصر تاپل می‌توانند نام‌گذاری شوند:</p>
<pre><code class="language-C#">
var tuple = (name:&quot;Bob&quot;, age:23);
Console.WriteLine (tuple.name);     // Bob
Console.WriteLine (tuple.age);      // 23
</code></pre>
<p>با تاپِل‌ها، توابع می‌توانند چندین مقدار را بدون نیاز به پارامترهای out یا سربار نوع اضافی برگردانند:</p>
<pre><code class="language-C#">
static (int row, int column) GetFilePosition() =&gt; (3, 10);
static void Main()
{
  var pos = GetFilePosition();
  Console.WriteLine (pos.row);      // 3
  Console.WriteLine (pos.column);   // 10
}
</code></pre>
<p>تاپِل‌ها به طور ضمنی از الگوی تفکیک ساختار پشتیبانی می‌کنند، بنابراین می‌توانید به راحتی آن‌ها را به متغیرهای فردی تفکیک کنید:</p>
<pre><code class="language-C#">
static void Main()
{
 (int row, int column) = GetFilePosition();   // Creates 2 local variables
  Console.WriteLine (row);      // 3 
  Console.WriteLine (column);   // 10
}
</code></pre>
<h3>عبارات throw</h3>
<p>پیش از سی‌شارپ ۷، throw همیشه یک دستور بود. اکنون می‌تواند به عنوان یک عبارت در توابع با بدنه عبارت نیز ظاهر شود:</p>
<pre><code class="language-C#">
public string Foo() =&gt; throw new NotImplementedException();
</code></pre>
<p>یک عبارت throw می‌تواند در یک عبارت شرطی سه‌تایی نیز ظاهر شود:</p>
<pre><code class="language-C#">
string Capitalize (string value) =&gt;
  value == null ? throw new ArgumentException (&quot;value&quot;) :
  value == &quot;&quot; ? &quot;&quot; :
  char.ToUpper (value[0]) + value.Substring (1);
</code></pre>
<h2>تازه‌های سی‌شارپ ۶.۰</h2>
<p>سی‌شارپ ۶.۰، که همراه با ویژوال استودیو ۲۰۱۵ عرضه شد، شامل یک کامپایلر نسل جدید است که به طور کامل با سی‌شارپ نوشته شده است. این کامپایلر، که به پروژه &quot;Roslyn&quot; معروف است، کل خط لوله کامپایل را از طریق کتابخانه‌ها در معرض دید قرار می‌دهد و به شما امکان می‌دهد تحلیل کد را بر روی کدهای منبع دلخواه انجام دهید. خود کامپایلر متن‌باز است و کد منبع آن در <a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a> در دسترس است.</p>
<p>علاوه بر این، سی‌شارپ ۶.۰ شامل چندین بهبود کوچک اما قابل توجه است که عمدتاً با هدف کاهش درهم‌ریختگی کد طراحی شده‌اند.</p>
<p>عملگر نال‌-شرطی (&quot;اِلویس&quot;) (به &quot;عملگرهای نال&quot; در صفحه ۸۲ مراجعه کنید) از نیاز به بررسی صریح null قبل از فراخوانی یک متد یا دسترسی به عضو یک نوع، جلوگیری می‌کند. در مثال زیر، result به جای پرتاب یک NullReferenceException، به null ارزیابی می‌شود:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
string result = sb?.ToString();      // result is null
</code></pre>
<p>توابع با بدنه عبارت (به &quot;متدها&quot; در صفحه ۱۰۶ مراجعه کنید) به متدها، خصوصیات، عملگرها و اندیس‌گذارها که شامل یک عبارت واحد هستند، اجازه می‌دهد به طور فشرده‌تر و به سبک یک عبارت لامبدا نوشته شوند:</p>
<pre><code class="language-C#">
public int TimesTwo (int x) =&gt; x * 2;
public string SomeProperty =&gt; &quot;Property value&quot;;
</code></pre>
<p>مقداردهنده‌های اولیه خصوصیت (فصل ۳) به شما اجازه می‌دهند یک مقدار اولیه را به یک خصوصیت خودکار انتساب دهید:</p>
<pre><code class="language-C#">
public DateTime TimeCreated { get; set; } = DateTime.Now;
</code></pre>
<p>خصوصیات مقداردهی شده می‌توانند فقط خواندنی نیز باشند:</p>
<pre><code class="language-C#">
public DateTime TimeCreated { get; } = DateTime.Now;
</code></pre>
<p>خصوصیات فقط خواندنی را می‌توان در سازنده نیز تنظیم کرد، که ایجاد انواع تغییرناپذیر (فقط خواندنی) را آسان‌تر می‌کند.</p>
<p>مقداردهنده‌های اولیه اندیس (فصل ۴) امکان مقداردهی اولیه یک مرحله‌ای هر نوعی که یک اندیس‌گذار را نمایش می‌دهد، فراهم می‌کنند:</p>
<pre><code class="language-C#">
var dict = new Dictionary&lt;int, string&gt;()
{
  [3] = &quot;three&quot;,
  [10] = &quot;ten&quot;
};
</code></pre>
<p>درون‌یابی رشته (به &quot;نوع رشته&quot; در صفحه ۵۸ مراجعه کنید) جایگزینی مختصر برای string.Format ارائه می‌دهد:</p>
<pre><code class="language-C#">
string s = $&quot;It is {DateTime.Now.DayOfWeek} today&quot;;
</code></pre>
<p>فیلترهای استثنا (به &quot;دستورات try و استثناها&quot; در صفحه ۱۹۵ مراجعه کنید) به شما اجازه می‌دهند یک شرط را به یک بلوک catch اعمال کنید:</p>
<pre><code class="language-C#">
string html;
try
{
  html = await new HttpClient().GetStringAsync (&quot;http://asef&quot;);
}
catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{
  ...
}
</code></pre>
<p>دستور using static (به &quot;فضاهای نام&quot; در صفحه ۹۵ مراجعه کنید) به شما اجازه می‌دهد تمام اعضای static یک نوع را وارد کنید تا بتوانید از آن اعضا بدون نیاز به نام کامل استفاده کنید:</p>
<pre><code class="language-C#">
using static System.Console;
...
WriteLine (&quot;Hello, world&quot;);  // WriteLine instead of Console.WriteLine
</code></pre>
<p>عملگر nameof (فصل ۳) نام یک متغیر، نوع یا نماد دیگر را به صورت یک رشته برمی‌گرداند. این کار از شکسته شدن کد هنگام تغییر نام یک نماد در ویژوال استودیو جلوگیری می‌کند:</p>
<pre><code class="language-C#">
int capacity = 123;
string x = nameof (capacity);   // x is &quot;capacity&quot;
string y = nameof (Uri.Host);   // y is &quot;Host&quot;
</code></pre>
<p>و در نهایت، اکنون اجازه دارید در بلوک‌های catch و finally از await استفاده کنید.</p>
<h2>تازه‌های سی‌شارپ ۵.۰</h2>
<p>ویژگی بزرگ و جدید سی‌شارپ ۵.۰، پشتیبانی از توابع ناهمگام از طریق دو کلمه کلیدی جدید async و await بود. توابع ناهمگام، دنباله‌های ناهمگام (asynchronous continuations) را امکان‌پذیر می‌سازند، که نوشتن برنامه‌های مشتری غنی پاسخگو و امن از نظر ریسه را آسان‌تر می‌کند. آن‌ها همچنین نوشتن برنامه‌های بسیار همروند و کارآمد با وابستگی به ورودی/خروجی را آسان می‌کنند که یک منبع ریسه را در هر عملیات مشغول نمی‌کنند. ما توابع ناهمگام را به تفصیل در فصل ۱۴ پوشش می‌دهیم.</p>
<h2>تازه‌های سی‌شارپ ۴.۰</h2>
<p>سی‌شارپ ۴.۰ چهار بهبود عمده را معرفی کرد:</p>
<p>بسته‌بندی پویا (Chapters 4 and 19) فرآیند حل انواع و اعضا را از زمان کامپایل به زمان اجرا به تعویق می‌اندازد و در سناریوهایی مفید است که در غیر این صورت به کد بازتابی پیچیده نیاز داشتند. بسته‌بندی پویا همچنین هنگام تعامل با زبان‌های پویا و اجزای COM مفید است.</p>
<p>پارامترهای اختیاری (Chapter 2) به توابع اجازه می‌دهند مقادیر پیش‌فرض پارامتر را مشخص کنند تا فراخوانندگان بتوانند آرگومان‌ها را حذف کنند، و آرگومان‌های نام‌گذاری شده به فراخواننده تابع اجازه می‌دهند یک آرگومان را با نام به جای موقعیت شناسایی کند.</p>
<p>قوانین واریانس نوع در سی‌شارپ ۴.۰ آسان‌تر شد (Chapters 3 and 4)، به طوری که پارامترهای نوع در رابط‌های عمومی و دلیگیت‌های عمومی می‌توانند به عنوان کوواریانت (covariant) یا کنتراواریانت (contravariant) علامت‌گذاری شوند، که تبدیل‌های نوع طبیعی‌تر را امکان‌پذیر می‌سازد.</p>
<p>تعامل‌پذیری COM (Chapter 24) در سی‌شارپ ۴.۰ به سه روش بهبود یافت. اول، آرگومان‌ها را می‌توان با ارجاع و بدون کلمه کلیدی ref ارسال کرد (به ویژه در ترکیب با پارامترهای اختیاری مفید است). دوم، اَسمبلی‌هایی که شامل انواع تعامل‌پذیری COM هستند می‌توانند به جای ارجاع، لینک شوند. انواع تعامل‌پذیری لینک شده از هم‌ارزی نوع پشتیبانی می‌کنند، از نیاز به اَسمبلی‌های تعامل‌پذیری اولیه جلوگیری می‌کنند و به مشکلات نگهداری نسخه و استقرار پایان می‌دهند. سوم، توابعی که انواع COM Variant را از انواع تعامل‌پذیری لینک شده برمی‌گردانند، به dynamic به جای object نگاشت می‌شوند و نیاز به casting را از بین می‌برند.</p>
<h2>تازه‌های سی‌شارپ ۳.۰</h2>
<p>ویژگی‌های اضافه شده به سی‌شارپ ۳.۰ عمدتاً بر قابلیت‌های پرس و جوی یکپارچه با زبان (LINQ) متمرکز بود. LINQ امکان نوشتن پرس و جوها را مستقیماً در یک برنامه سی‌شارپ فراهم می‌کند و صحت آن‌ها را به صورت استاتیک بررسی می‌کند، و هم مجموعه‌های محلی (مانند لیست‌ها یا اسناد XML) و هم منابع داده راه دور (مانند یک پایگاه داده) را پرس و جو می‌کند. ویژگی‌های سی‌شارپ ۳.۰ که برای پشتیبانی از LINQ اضافه شدند شامل متغیرهای محلی با نوع ضمنی، انواع بی‌نام، مقداردهنده‌های اولیه شیء، عبارات لامبدا، متدهای توسعه‌دهنده، عبارات پرس و جو و درختان عبارت بودند.</p>
<p>متغیرهای محلی با نوع ضمنی (کلمه کلیدی var، فصل ۲) به شما اجازه می‌دهند نوع متغیر را در یک دستور اعلان حذف کنید و به کامپایلر اجازه دهید آن را استنباط کند. این کار باعث کاهش شلوغی و همچنین امکان استفاده از انواع بی‌نام (فصل ۴) می‌شود، که کلاس‌های ساده‌ای هستند که به صورت لحظه‌ای ایجاد می‌شوند و معمولاً در خروجی نهایی پرس و جوهای LINQ استفاده می‌شوند. شما همچنین می‌توانید آرایه‌ها را به صورت ضمنی تایپ کنید (فصل ۲).</p>
<p>مقداردهنده‌های اولیه شیء (فصل ۳) با اجازه دادن به شما برای تنظیم خصوصیات به صورت درون‌خطی پس از فراخوانی سازنده، ساخت شیء را ساده می‌کنند. مقداردهنده‌های اولیه شیء با انواع نام‌گذاری شده و بی‌نام کار می‌کنند.</p>
<p>عبارات لامبدا (فصل ۴) توابع مینیاتوری هستند که توسط کامپایلر به صورت لحظه‌ای ایجاد می‌شوند؛ آن‌ها به ویژه در پرس و جوهای LINQ &quot;روان&quot; (fluent) مفید هستند (فصل ۸).</p>
<p>متدهای توسعه‌دهنده (فصل ۴) یک نوع موجود را با متدهای جدید گسترش می‌دهند (بدون تغییر تعریف نوع)، و باعث می‌شوند متدهای static مانند متدهای نمونه عمل کنند. عملگرهای پرس و جوی LINQ به عنوان متدهای توسعه‌دهنده پیاده‌سازی شده‌اند.</p>
<p>عبارات پرس و جو (فصل ۸) نحو سطح بالاتری برای نوشتن پرس و جوهای LINQ فراهم می‌کنند که هنگام کار با توالی‌های متعدد یا متغیرهای محدوده، می‌توانند به طور قابل توجهی ساده‌تر باشند.</p>
<p>درختان عبارت (فصل ۸) مدل‌های شیء سند (DOMs) کد مینیاتوری هستند که عبارات لامبدا را که به نوع خاص Expression<TDelegate> اختصاص داده شده‌اند، توصیف می‌کنند. درختان عبارت امکان اجرای پرس و جوهای LINQ را از راه دور (مثلاً روی یک سرور پایگاه داده) فراهم می‌کنند، زیرا می‌توانند در زمان اجرا بازرسی و ترجمه شوند (مثلاً به یک دستور SQL).</p>
<p>سی‌شارپ ۳.۰ همچنین خصوصیات خودکار و متدهای partial را اضافه کرد.</p>
<p>خصوصیات خودکار (فصل ۳) با واداشتن کامپایلر به انجام خودکار کار، از نوشتن خصوصیات که به سادگی یک فیلد پشتیبان خصوصی را دریافت/تنظیم می‌کنند، می‌کاهد.</p>
<p>متدهای partial (فصل ۳) به یک کلاس partial خودکار تولید شده اجازه می‌دهند هوک‌های قابل سفارشی‌سازی برای نویسندگی دستی فراهم کند که در صورت عدم استفاده &quot;از بین می‌روند&quot;.</p>
<h2>تازه‌های سی‌شارپ ۲.۰</h2>
<p>ویژگی‌های بزرگ و جدید در سی‌شارپ ۲ عمومی‌ها (generics) (فصل ۳)، انواع مقداری با قابلیت تهی (nullable value types) (فصل ۴)، تکرارکننده‌ها (iterators) (فصل ۴) و متدهای بی‌نام (anonymous methods) (پیش‌ساز عبارات لامبدا) بودند. این ویژگی‌ها راه را برای معرفی LINQ در سی‌شارپ ۳ هموار کردند.</p>
<p>سی‌شارپ ۲ همچنین پشتیبانی از کلاس‌های partial، کلاس‌های static، و مجموعه‌ای از ویژگی‌های کوچک و متفرقه مانند تعیین‌کننده نام مستعار فضای نام، اَسمبلی‌های دوست، و بافرهای با اندازه ثابت را اضافه کرد.</p>
<p>معرفی عمومی‌ها به یک محیط زمان اجرای مشترک جدید (CLR 2.0) نیاز داشت، زیرا عمومی‌ها وفاداری کامل نوع را در زمان اجرا حفظ می‌کنند.</p>
