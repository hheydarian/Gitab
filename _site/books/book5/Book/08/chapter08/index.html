

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ترفندهای پیشرفتهٔ صفحه‌کلید</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  @font-face {
    font-family: "Lalezar";
    src: url('fonts/Lalezar.ttf') format('truetype');
    font-display: swap;
}
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
         <a href="/Gitab/giter.html" >دوره ها</a>
          <!-- 
         <a href="/Gitab/translator.html" >مترجمین</a>
           -->
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل ۸ – ترفندهای پیشرفتهٔ صفحه‌کلید</h1>
<hr>
<h2>مقدمه</h2>
<p>تا این‌جا یاد گرفته‌ایم چگونه دستورات را تایپ و اجرا کنیم، خروجی‌ها را هدایت کنیم و رفتار شل را با گسترش‌ها کنترل کنیم.<br>
اما اگر هنگام تایپ اشتباه کنیم، بخواهیم دوباره دستوری طولانی را ویرایش کنیم یا می‌خواهیم از تاریخچهٔ فرمان‌ها بهره ببریم چه؟<br>
خوشبختانه bash (و به طور کلی کتابخانهٔ <code>readline</code> که برای خواندن ورودی از صفحه‌کلید استفاده می‌شود) مجموعه‌ای عظیم از میان‌بُرهای صفحه‌کلید را در اختیارمان می‌گذارد تا تجربهٔ خط فرمان بسیار راحت‌تر و سریع‌تر شود.</p>
<p>در این فصل می‌خوانیم:</p>
<ul>
<li>چگونه با میان‌بُرهای حرکتی، مکان‌نمای خط فرمان را به سرعت جابه‌جا کنیم.</li>
<li>روش‌های ویرایش و اصلاح متون بدون نیاز به پاک کردن تمام خط.</li>
<li>تکنیک‌های «بُرش و چسباندن» متن به کمک حافظهٔ موقت (kill-ring).</li>
<li>تکمیل خودکار دستورها، مسیرها و متغیرها با کلید <code>Tab</code> و حالت‌های مختلف آن.</li>
<li>استفادهٔ مؤثر از تاریخچهٔ فرمان‌ها، جست‌وجوی تعاملی و فراخوانی مجدد دستورات قدیمی.</li>
</ul>
<hr>
<h2>ویرایش خط فرمان</h2>
<p>کتابخانهٔ <code>readline</code> که مسئول خواندن ورودی از صفحه‌کلید است، یک حالت «ویرایش امکانی» فراهم می‌کند.<br>
این یعنی می‌توانیم درست مانند یک ویرایشگر متن کوچک، درون خط فرمان حرکت کنیم، حروف را حذف و اضافه کنیم و حتی قطعه‌ای از متن را جابه‌جا کنیم.</p>
<p>بسیاری از کلیدهای میان‌بر مبتنی بر کنترل (<code>Ctrl</code>) یا متا (<code>Alt</code> یا <code>Esc</code>) هستند.<br>
در جدول‌های زیر، نماد <code>C-</code> به معنی نگه داشتن کلید <code>Ctrl</code> و سپس فشردن کلید بعدی است؛ <code>M-</code> نیز برای <code>Alt</code> یا <code>Meta</code> استفاده می‌شود.<br>
اگر صفحه‌کلید شما کلید <code>Alt</code> ندارد می‌توانید ابتدا <code>Esc</code> را بفشارید و سپس کلید دوم را بزنید.</p>
<h3>جابه‌جایی مکان‌نما</h3>
<table>
<thead>
<tr>
<th>کلید</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-a</code></td>
<td>رفتن به ابتدای خط (مانند Home).</td>
</tr>
<tr>
<td><code>C-e</code></td>
<td>رفتن به انتهای خط.</td>
</tr>
<tr>
<td><code>C-f</code></td>
<td>حرکت یک نویسه به جلو (معادل فلش راست).</td>
</tr>
<tr>
<td><code>C-b</code></td>
<td>حرکت یک نویسه به عقب (معادل فلش چپ).</td>
</tr>
<tr>
<td><code>M-f</code></td>
<td>رفتن به ابتدای واژهٔ بعدی.</td>
</tr>
<tr>
<td><code>M-b</code></td>
<td>رفتن به ابتدای واژهٔ قبلی.</td>
</tr>
<tr>
<td><code>C-l</code></td>
<td>پاک‌سازی صفحه و قرار دادن خط جاری در بالای صفحه (معادل <code>clear</code>).</td>
</tr>
</tbody>
</table>
<h3>ویرایش و اصلاح متن</h3>
<table>
<thead>
<tr>
<th>کلید</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-d</code></td>
<td>حذف نویسهٔ زیر مکان‌نما.</td>
</tr>
<tr>
<td><code>C-h</code></td>
<td>حذف نویسهٔ قبل از مکان‌نما (مثل Backspace).</td>
</tr>
<tr>
<td><code>M-d</code></td>
<td>حذف از مکان‌نما تا انتهای واژهٔ جاری.</td>
</tr>
<tr>
<td><code>M-Backspace</code></td>
<td>حذف واژهٔ پیش از مکان‌نما.</td>
</tr>
<tr>
<td><code>C-t</code></td>
<td>جابه‌جایی دو نویسهٔ مجاور.</td>
</tr>
<tr>
<td><code>M-t</code></td>
<td>جابه‌جایی دو واژهٔ مجاور.</td>
</tr>
<tr>
<td><code>M-u</code></td>
<td>تبدیل واژهٔ پس از مکان‌نما به حروف بزرگ.</td>
</tr>
<tr>
<td><code>M-l</code></td>
<td>تبدیل واژهٔ پس از مکان‌نما به حروف کوچک.</td>
</tr>
<tr>
<td><code>M-c</code></td>
<td>تبدیل حرف نخست واژهٔ بعدی به حروف بزرگ.</td>
</tr>
</tbody>
</table>
<p>بسیاری از این حرکات در حالت Emacs نیز وجود دارند؛ اگر با آن محیط آشنا باشید، حس راحتی خواهید داشت.</p>
<h3>برش، کپی و چسباندن</h3>
<p><code>readline</code> مفهومی به نام kill-ring دارد که مشابه کلیپ‌بورد عمل می‌کند.<br>
با میان‌برهای «kill» بخشی از خط را حذف می‌کنیم و در عین حال در حافظه نگه می‌داریم تا بعداً با «yank» آن را بازگردانیم.</p>
<table>
<thead>
<tr>
<th>کلید</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-k</code></td>
<td>حذف از مکان‌نما تا انتهای خط.</td>
</tr>
<tr>
<td><code>M-k</code></td>
<td>حذف از مکان‌نما تا پایان جمله (نقطه، ! یا ?).</td>
</tr>
<tr>
<td><code>C-u</code></td>
<td>حذف از ابتدای خط تا مکان‌نما.</td>
</tr>
<tr>
<td><code>C-w</code></td>
<td>حذف واژهٔ قبل از مکان‌نما.</td>
</tr>
<tr>
<td><code>M-w</code></td>
<td>کپی واژهٔ قبل از مکان‌نما بدون حذف.</td>
</tr>
<tr>
<td><code>C-y</code></td>
<td>چسباندن آخرین متن حذف‌شده (yank).</td>
</tr>
<tr>
<td><code>M-y</code></td>
<td>در صورت تکرار پس از <code>C-y</code>، متن حذف‌شدهٔ قبلی را برمی‌گرداند (گردش میان kill-ring).</td>
</tr>
</tbody>
</table>
<p>Kill-ring در طول نشست شل فعال است، بنابراین می‌توانید متن حذف‌شده را در دستوری دیگر بازگردانید.</p>
<h3>لغو و تکرار</h3>
<table>
<thead>
<tr>
<th>کلید</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-_</code> یا <code>C-x C-u</code></td>
<td>لغو آخرین تغییر (Undo).</td>
</tr>
<tr>
<td><code>M-r</code></td>
<td>بازنشانی متن خط به حالت اولیهٔ ذخیره‌شده در تاریخچه.</td>
</tr>
</tbody>
</table>
<hr>
<h2>تکمیل خودکار (Tab Completion)</h2>
<p>bash قادر است بسیاری از مقادیر را پس از تایپ چند نویسه و فشردن <code>Tab</code> حدس بزند.<br>
این ویژگی نه‌تنها سرعت تایپ را افزایش می‌دهد، بلکه از خطاهای تایپی جلوگیری می‌کند.</p>
<ul>
<li><strong>تکمیل نام برنامه‌ها</strong>: هنگام تایپ نام دستور، فشردن <code>Tab</code> آن را کامل می‌کند یا فهرست گزینه‌های ممکن را نمایش می‌دهد.</li>
<li><strong>تکمیل مسیر فایل‌ها</strong>: اگر مسیر نسبی یا مطلقی را آغاز کنیم، <code>Tab</code> آن را تا جایی که مبهم نباشد کامل می‌کند.</li>
<li><strong>تکمیل متغیرها، نام‌های کاربری و میزبان</strong>: با نگارش مناسب (<code>$</code>, <code>~</code>, <code>@</code>) می‌توانیم این موارد را نیز کامل کنیم.</li>
</ul>
<p>اگر بیش از یک گزینهٔ ممکن وجود داشته باشد، bash با دوبار فشار دادن <code>Tab</code> فهرستی از گزینه‌ها را نشان می‌دهد.<br>
همچنین برخی توزیع‌ها بستهٔ «bash-completion» را فعال می‌کنند که تکمیل‌های هوشمند برای برنامه‌هایی مانند <code>git</code>, <code>ssh</code> و <code>tar</code> فراهم می‌کند.</p>
<p>می‌توانید با دستور <code>bind -P</code> همهٔ میان‌برهای در حال استفاده را ببینید یا با <code>bind &quot;TAB:menu-complete&quot;</code> رفتار <code>Tab</code> را به حالت منو تغییر دهید تا هر بار فشردن آن گزینهٔ بعدی را انتخاب کند.</p>
<hr>
<h2>تاریخچهٔ فرمان‌ها</h2>
<p>هر بار که دستوری را اجرا می‌کنیم، bash آن را در فایل <code>~/.bash_history</code> ذخیره می‌کند (مگر این‌که تنظیمات دیگری اعمال شده باشد).<br>
با این ویژگی می‌توانیم دستورات گذشته را دوباره فراخوانی کنیم، ویرایش کنیم یا به عنوان الگو برای فرمان‌های جدید استفاده کنیم.</p>
<h3>پیمایش تاریخچه</h3>
<table>
<thead>
<tr>
<th>کلید</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-p</code> یا فلش بالا</td>
<td>رفتن به دستور قبلی.</td>
</tr>
<tr>
<td><code>C-n</code> یا فلش پایین</td>
<td>رفتن به دستور بعدی.</td>
</tr>
<tr>
<td><code>M-&lt;</code></td>
<td>رفتن به قدیمی‌ترین دستور.</td>
</tr>
<tr>
<td><code>M-&gt;</code></td>
<td>رفتن به جدیدترین دستور.</td>
</tr>
</tbody>
</table>
<p>همچنین می‌توانیم با دستور <code>history</code> فهرست تاریخچه را ببینیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">history</span> | <span class="hljs-built_in">tail</span>
</code></pre>
<p>عدد ابتدای هر خط «شمارهٔ تاریخچه» است که می‌توانیم برای فراخوانی سریع دستور استفاده کنیم.</p>
<h3>اجرای مجدد دستورات</h3>
<ul>
<li><code>!!</code> : اجرای آخرین دستور.</li>
<li><code>!n</code> : اجرای دستوری که شمارهٔ تاریخچهٔ آن <code>n</code> است.</li>
<li><code>!-n</code> : اجرای دستوری که <code>n</code> خط قبل اجرا شده است.</li>
<li><code>!string</code> : اجرای جدیدترین دستوری که با <code>string</code> آغاز شده است.</li>
</ul>
<p>پیش از اجرای دستور، bash آن را چاپ می‌کند تا بتوانیم بررسی کنیم.<br>
با استفاده از <code>set -o histverify</code> می‌توانیم کاری کنیم که شل دستور بازبینی‌شده را در خط فرمان قرار دهد تا قبل از اجرا در صورت نیاز ویرایش کنیم.</p>
<h3>جست‌وجوی تعاملی</h3>
<p>اگر <code>C-r</code> را فشار دهیم، bash وارد حالت «جست‌وجوی معکوس» می‌شود.<br>
با تایپ چند نویسه، شل در تاریخچهٔ ما به دنبال نزدیک‌ترین تطابق می‌گردد.</p>
<ul>
<li><code>C-r</code> را چندبار پشت سر هم بزنید تا به جست‌وجوی تطابق‌های قبلی ادامه دهد.</li>
<li>با <code>C-s</code> می‌توانید در جهت رو به جلو جست‌وجو کنید (اگر در ترمینال فعال باشد).</li>
<li>با <code>Enter</code> دستور یافته اجرا می‌شود و با <code>C-y</code> می‌توان آن را روی خط فرمان گذاشت بدون اجرا.</li>
<li>برای خروج از حالت جست‌وجو بدون تغییری، <code>C-g</code> یا <code>Esc</code> را فشار دهید.</li>
</ul>
<h3>تنظیمات تاریخچه</h3>
<p>رفتار تاریخچه را می‌توان با متغیرهای محیطی کنترل کرد:</p>
<ul>
<li><code>HISTSIZE</code> : تعداد خطوطی که در حافظهٔ نشست نگهداری می‌شود.</li>
<li><code>HISTFILESIZE</code> : تعداد خطوط مجاز در فایل تاریخچه.</li>
<li><code>HISTCONTROL</code> : می‌تواند مقادیری مانند <code>ignoredups</code> (نادیده گرفتن دستورات تکراری) یا <code>ignorespace</code> (نادیده گرفتن دستورات آغاز شده با فاصله) داشته باشد.</li>
<li><code>HISTIGNORE</code> : الگوهایی که باید در تاریخچه ذخیره نشوند.</li>
</ul>
<p>برای اعمال تنظیمات، آن‌ها را در <code>~/.bashrc</code> خود قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">export</span> HISTCONTROL=<span class="hljs-string">&quot;ignoredups:ignorespace&quot;</span>
<span class="hljs-built_in">export</span> HISTSIZE=5000
</code></pre>
<hr>
<h2>اجرای مجدد و ویرایش دستورات در ویرایشگر خارجی</h2>
<p>گاهی ویرایش یک دستور بسیار طولانی در خود خط فرمان دشوار است.<br>
bash دستور <code>fc</code> را ارائه می‌دهد که آخرین دستور را در یک ویرایشگر متنی باز می‌کند، اجازه می‌دهد آن را اصلاح کنیم و سپس اجرا می‌کند.</p>
<pre class="hljs"><code><span class="hljs-built_in">fc</span>                <span class="hljs-comment"># باز کردن دستور قبلی در ویرایشگر پیش‌فرض</span>
<span class="hljs-built_in">fc</span> -l 20 30       <span class="hljs-comment"># نمایش دستورات شماره ۲۰ تا ۳۰</span>
<span class="hljs-built_in">fc</span> -s old=new     <span class="hljs-comment"># جایگزینی old با new در دستور قبلی و اجرا</span>
</code></pre>
<p>ویرایشگر پیش‌فرض با متغیر محیطی <code>FCEDIT</code> یا <code>EDITOR</code> مشخص می‌شود.<br>
اگر ترجیح می‌دهید همیشه از برنامه‌ای مانند <code>vim</code> یا <code>nano</code> استفاده کنید، آن را در تنظیمات پوسته تعریف کنید.</p>
<hr>
<h2>شخصی‌سازی میان‌برها</h2>
<p>با دستور <code>bind</code> می‌توانیم میان‌برهای جدید تعریف کنیم یا موجودها را تغییر دهیم.<br>
برای نمونه، اگر بخواهیم <code>C-j</code> مانند <code>Enter</code> عمل کند، می‌توانیم بگوییم:</p>
<pre class="hljs"><code><span class="hljs-built_in">bind</span> <span class="hljs-string">&#x27;&quot;\C-j&quot;:accept-line&#x27;</span>
</code></pre>
<p>همچنین امکان بارگذاری فایل <code>~/.inputrc</code> وجود دارد که مجموعه‌ای از نگاشت‌های دلخواه را برای همهٔ برنامه‌های مبتنی بر <code>readline</code> (مانند <code>bash</code>, <code>ftp</code>, <code>python</code> و غیره) اعمال می‌کند.</p>
<p>نمونه‌ای از <code>~/.inputrc</code>:</p>
<pre class="hljs"><code>set editing-mode vi
set completion-ignore-case on
&quot;\e[A&quot;: history-search-backward
&quot;\e[B&quot;: history-search-forward
</code></pre>
<p>خط نخست حالت ویرایش را به سبک <code>vi</code> تغییر می‌دهد؛ در این حالت باید با کلید <code>Esc</code> وارد حالت فرمان شوید و با <code>i</code> یا <code>a</code> ویرایش را آغاز کنید.<br>
دو خط بعدی ترتیب جست‌وجو در تاریخچه را به گونه‌ای تغییر می‌دهد که با تایپ چند نویسه و فشردن فلش بالا/پایین فقط دستورات دارای همان پیشوند مرور شوند.</p>
<hr>
<h2>جمع‌بندی</h2>
<p>یادگیری چند میان‌بر کلیدی می‌تواند سرعت کار شما را چند برابر کند.<br>
به جای پاک کردن کامل خطوط طولانی، می‌توانید با چند حرکت ساده آن‌ها را اصلاح کنید، از تاریخچه بهره بگیرید و با تکمیل خودکار از اشتباهات جلوگیری نمایید.</p>
<p>در فصل بعد به موضوع مهم «مجوزها و مالکیت فایل‌ها» می‌پردازیم که زیرساخت امنیتی سیستم فایل‌های یونیکسی را تشکیل می‌دهد.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — تمامی حقوق محفوظ است.
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
  
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
