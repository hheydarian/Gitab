<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل پانزدهم:  استریم‌ها و ورودی/خروجی (Streams and I/O)</h1>
<p>این فصل، انواع بنیادی برای <strong>ورودی (Input)</strong> و <strong>خروجی (Output)</strong> در .NET را توضیح می‌دهد، با تمرکز ویژه روی موضوعات زیر:</p>
<ul>
<li>معماری <strong>Stream</strong> در .NET و این‌که چطور یک رابط برنامه‌نویسی (Programming Interface) یکپارچه برای <strong>خواندن</strong> و <strong>نوشتن</strong> روی انواع مختلف I/O فراهم می‌کند.</li>
<li>کلاس‌ها برای کار با <strong>فایل‌ها</strong> و <strong>دایرکتوری‌ها</strong> روی دیسک.</li>
<li>استریم‌های تخصصی برای <strong>فشرده‌سازی (Compression)</strong>، <strong>Named Pipes</strong>، و <strong>Memory-Mapped Files</strong>.</li>
</ul>
<p>این فصل بیشتر روی نوع‌هایی در فضای نام <code>System.IO</code> تمرکز دارد؛ جایی که قابلیت‌های سطح پایین I/O قرار گرفته‌اند.</p>
<hr>
<h2>🏗️ معماری Stream</h2>
<p>معماری Stream در .NET حول سه مفهوم اصلی می‌چرخد:</p>
<ul>
<li><strong>Backing Stores</strong></li>
<li><strong>Decorators</strong></li>
<li><strong>Adapters</strong></li>
</ul>
<p>همان‌طور که در شکل 15-1 نشان داده شده است.</p>
<p><strong>Backing Store</strong> همان نقطه انتهایی است که ورودی و خروجی را کاربردی می‌کند، مثل یک فایل یا اتصال شبکه. به‌طور دقیق‌تر، Backing Store می‌تواند یکی یا هر دوی موارد زیر باشد:</p>
<ul>
<li>یک منبع (Source) که بایت‌ها می‌توانند به‌صورت ترتیبی (Sequential) از آن خوانده شوند.</li>
<li>یک مقصد (Destination) که بایت‌ها می‌توانند به‌صورت ترتیبی در آن نوشته شوند.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>📌 Backing Store</h3>
<p>یک <strong>Backing Store</strong> به‌تنهایی هیچ کاربردی برای برنامه‌نویس ندارد، مگر این‌که در معرض استفاده قرار گیرد. کلاس استاندارد .NET برای این منظور، <strong>Stream</strong> است. این کلاس مجموعه‌ای استاندارد از متدها را برای <strong>خواندن (Reading)</strong>، <strong>نوشتن (Writing)</strong> و <strong>مکان‌یابی (Positioning)</strong> در اختیار قرار می‌دهد.</p>
<p>برخلاف <strong>آرایه (Array)</strong> که همه داده‌های پشتیبان آن به‌طور هم‌زمان در حافظه قرار دارند، <strong>Stream</strong> داده‌ها را به‌صورت <strong>سریالی (Serially)</strong> مدیریت می‌کند—یا یک بایت در هر بار، یا در بلوک‌هایی با اندازه قابل مدیریت. به همین دلیل، یک Stream می‌تواند بدون توجه به اندازه Backing Store، فقط از مقدار کمی حافظه ثابت استفاده کند.</p>
<hr>
<h3>🗂️ دسته‌بندی Streamها</h3>
<p>استریم‌ها به دو دسته تقسیم می‌شوند:</p>
<ol>
<li>
<p><strong>Backing Store Streams</strong>
این استریم‌ها به یک نوع خاص از Backing Store متصل هستند، مثل <code>FileStream</code> یا <code>NetworkStream</code>.</p>
</li>
<li>
<p><strong>Decorator Streams</strong>
این استریم‌ها روی یک استریم دیگر سوار می‌شوند و داده‌ها را به نوعی تغییر می‌دهند، مثل <code>DeflateStream</code> یا <code>CryptoStream</code>.</p>
</li>
</ol>
<hr>
<h3>🌟 مزایای معماری Decorator Streams</h3>
<ul>
<li>آن‌ها استریم‌های Backing Store را از نیاز به پیاده‌سازی ویژگی‌هایی مثل <strong>فشرده‌سازی (Compression)</strong> و <strong>رمزنگاری (Encryption)</strong> آزاد می‌کنند.</li>
<li>وقتی یک استریم با Decorator پوشانده می‌شود، <strong>رابط (Interface)</strong> آن تغییر نمی‌کند.</li>
<li>شما می‌توانید Decoratorها را <strong>در زمان اجرا (Runtime)</strong> متصل کنید.</li>
<li>می‌توان چند Decorator را به هم زنجیر کرد (مثلاً یک <strong>فشرده‌ساز</strong> و سپس یک <strong>رمزنگار</strong>).</li>
</ul>
<hr>
<h3>🔗 نقش Adapter</h3>
<p>هر دو نوع استریم (Backing Store و Decorator) صرفاً با <strong>بایت‌ها</strong> کار می‌کنند. گرچه این رویکرد انعطاف‌پذیر و کارآمد است، ولی بسیاری از برنامه‌ها در سطوح بالاتر کار می‌کنند—مثل <strong>متن (Text)</strong> یا <strong>XML</strong>.</p>
<p>اینجا است که <strong>Adapter</strong> وارد عمل می‌شود. Adapter با <strong>پوشاندن (Wrapping)</strong> یک استریم، متدهایی تخصصی برای یک فرمت خاص ارائه می‌دهد.</p>
<ul>
<li>یک <strong>TextReader</strong> متدی به نام <code>ReadLine</code> دارد.</li>
<li>یک <strong>XmlWriter</strong> متدی به نام <code>WriteAttributes</code> دارد.</li>
</ul>
<p>Adapter درست مثل یک Decorator، یک استریم را می‌پوشاند. اما بر خلاف Decorator، خود یک استریم نیست و معمولاً متدهای <strong>بایت‌محور</strong> را به‌طور کامل پنهان می‌کند.</p>
<hr>
<h3>📝 خلاصه</h3>
<ul>
<li><strong>Backing Store Streams</strong> داده خام را فراهم می‌کنند.</li>
<li><strong>Decorator Streams</strong> تغییرات باینری شفاف مثل رمزنگاری ارائه می‌دهند.</li>
<li><strong>Adapters</strong> متدهای سطح بالاتر برای کار با انواعی مثل رشته‌ها (Strings) و XML فراهم می‌کنند.</li>
</ul>
<p>📊 شکل 15-1 ارتباط میان این اجزاء را نشان می‌دهد. برای ساخت یک زنجیره، کافی است یک شیء را به سازنده (Constructor) شیء دیگر بدهید.</p>
<hr>
<h2>⚙️ استفاده از Streams</h2>
<p>کلاس <strong>Stream</strong> یک کلاس <strong>Abstract</strong> است که پایه‌ای برای تمام استریم‌ها محسوب می‌شود. این کلاس متدها و ویژگی‌هایی برای سه عملیات بنیادی تعریف می‌کند:</p>
<ul>
<li><strong>خواندن (Reading)</strong></li>
<li><strong>نوشتن (Writing)</strong></li>
<li><strong>جستجو یا مکان‌یابی (Seeking)</strong></li>
</ul>
<p>به‌علاوه، برای کارهای مدیریتی مثل:</p>
<ul>
<li><strong>بستن (Closing)</strong></li>
<li><strong>تخلیه یا Flush کردن</strong></li>
<li><strong>پیکربندی Timeoutها</strong></li>
</ul>
<p>نیز متدها و ویژگی‌هایی در اختیار قرار می‌دهد (جدول 15-1 را ببینید).</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>⚡ نسخه‌های Asynchronous</h3>
<p>متدهای <strong>Read</strong> و <strong>Write</strong> نسخه‌های <strong>Asynchronous</strong> هم دارند که مقدار <strong>Task</strong> برمی‌گردانند و به‌صورت اختیاری یک <strong>CancellationToken</strong> می‌پذیرند. همچنین نسخه‌های Overload برای کار با نوع‌های <code>Span&lt;T&gt;</code> و <code>Memory&lt;T&gt;</code> (که در فصل ۲۳ توضیح داده می‌شوند) وجود دارد.</p>
<hr>
<h3>📂 نمونه کد: خواندن، نوشتن و Seek در FileStream</h3>
<pre><code class="language-csharp">using System;
using System.IO;

// ایجاد فایلی به نام test.txt در مسیر جاری:
using (Stream s = new FileStream(&quot;test.txt&quot;, FileMode.Create))
{
    Console.WriteLine(s.CanRead);   // True
    Console.WriteLine(s.CanWrite);  // True
    Console.WriteLine(s.CanSeek);   // True

    s.WriteByte(101);
    s.WriteByte(102);

    byte[] block = { 1, 2, 3, 4, 5 };
    s.Write(block, 0, block.Length);      // نوشتن یک بلوک 5 بایتی

    Console.WriteLine(s.Length);          // 7
    Console.WriteLine(s.Position);        // 7

    s.Position = 0;                       // بازگشت به ابتدای فایل
    Console.WriteLine(s.ReadByte());      // 101
    Console.WriteLine(s.ReadByte());      // 102

    // خواندن داده از استریم و بازنویسی در آرایه block:
    Console.WriteLine(s.Read(block, 0, block.Length));   // 5

    // چون در انتهای فایل هستیم، بار بعدی خواندن 0 برمی‌گرداند:
    Console.WriteLine(s.Read(block, 0, block.Length));   // 0
}
</code></pre>
<hr>
<h3>🌀 نمونه کد: استفاده از متدهای Async</h3>
<p>خواندن یا نوشتن به‌صورت <strong>Asynchronous</strong> فقط به این معنی است که به‌جای <strong>Read/Write</strong>، از <strong>ReadAsync/WriteAsync</strong> استفاده کنید و نتیجه را <code>await</code> کنید (و همچنین باید متد فراخواننده <code>async</code> تعریف شود، همان‌طور که در فصل ۱۴ توضیح داده شد).</p>
<pre><code class="language-csharp">async static void AsyncDemo()
{
    using (Stream s = new FileStream(&quot;test.txt&quot;, FileMode.Create))
    {
        byte[] block = { 1, 2, 3, 4, 5 };

        await s.WriteAsync(block, 0, block.Length);   // نوشتن به‌صورت Async
        s.Position = 0;                               // بازگشت به ابتدای فایل

        // خواندن دوباره داده‌ها از استریم به آرایه block:
        Console.WriteLine(await s.ReadAsync(block, 0, block.Length));   // 5
    }
}
</code></pre>
<p>متدهای Asynchronous کمک می‌کنند برنامه‌های <strong>Responsive</strong> و <strong>Scalable</strong> نوشته شوند که بتوانند با استریم‌های بالقوه کند (به‌ویژه استریم‌های شبکه‌ای) کار کنند، بدون این‌که یک Thread به‌طور کامل مشغول شود.</p>
<blockquote>
<p>برای سادگی، در بیشتر مثال‌های این فصل از متدهای <strong>Synchronous</strong> استفاده می‌کنیم. با این حال، در بیشتر سناریوهای <strong>I/O شبکه‌ای</strong> توصیه می‌شود از متدهای Async استفاده کنید.</p>
</blockquote>
<hr>
<h2>✍️ خواندن و نوشتن (Reading and Writing)</h2>
<p>یک استریم می‌تواند از <strong>خواندن</strong>، <strong>نوشتن</strong> یا هر دو پشتیبانی کند.</p>
<ul>
<li>اگر <code>CanWrite</code> برابر <code>false</code> باشد، استریم <strong>فقط خواندنی</strong> است.</li>
<li>اگر <code>CanRead</code> برابر <code>false</code> باشد، استریم <strong>فقط نوشتنی</strong> است.</li>
</ul>
<p>🔹 متد <code>Read</code> یک بلوک داده از استریم می‌گیرد و آن را درون یک آرایه قرار می‌دهد. این متد تعداد بایت‌های خوانده‌شده را برمی‌گرداند که همیشه <strong>کمتر یا مساوی</strong> با آرگومان <code>count</code> است.</p>
<ul>
<li>اگر مقدار کمتر از <code>count</code> باشد، یعنی یا به انتهای استریم رسیده‌ایم، یا داده‌ها در <strong>قطعات کوچک‌تر</strong> برگردانده می‌شوند (مثل حالت معمول در استریم‌های شبکه‌ای).</li>
<li>در این شرایط، بخش باقی‌مانده از آرایه بدون تغییر باقی می‌ماند.</li>
</ul>
<blockquote>
<p>رسیدن به انتهای استریم فقط زمانی قطعی است که <code>Read</code> مقدار <code>0</code> برگرداند.</p>
</blockquote>
<hr>
<h3>❌ مثال اشتباه</h3>
<p>فرض کنید یک استریم ۱۰۰۰ بایتی داریم:</p>
<pre><code class="language-csharp">// فرض کنید s یک استریم است:
byte[] data = new byte[1000];
s.Read(data, 0, data.Length);
</code></pre>
<p>در این حالت، <code>Read</code> ممکن است هر مقداری بین <strong>۱ تا ۱۰۰۰</strong> برگرداند و بخش باقی‌مانده خوانده نشود.</p>
<hr>
<h3>✅ مثال درست</h3>
<pre><code class="language-csharp">byte[] data = new byte[1000];
// bytesRead در نهایت همیشه 1000 خواهد بود، مگر این‌که طول استریم کمتر باشد:
int bytesRead = 0;
int chunkSize = 1;

while (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; 0)
    bytesRead += chunkSize = s.Read(data, bytesRead, data.Length - bytesRead);
</code></pre>
<hr>
<h3>🆕 متدهای جدید در .NET 7</h3>
<p>از نسخه .NET 7، کلاس <strong>Stream</strong> متدهای کمکی زیر را دارد:</p>
<ul>
<li><code>ReadExactly</code></li>
<li><code>ReadAtLeast</code></li>
</ul>
<p>(به همراه نسخه‌های Async آن‌ها).</p>
<pre><code class="language-csharp">byte[] data = new byte[1000];
s.ReadExactly(data);   // دقیقاً 1000 بایت می‌خواند
</code></pre>
<p>معادل:</p>
<pre><code class="language-csharp">s.ReadExactly(data, offset: 0, count: 1000);
</code></pre>
<hr>
<h3>📦 BinaryReader</h3>
<p>نوع <strong>BinaryReader</strong> راه‌حل دیگری برای این کار است:</p>
<pre><code class="language-csharp">byte[] data = new BinaryReader(s).ReadBytes(1000);
</code></pre>
<ul>
<li>اگر طول استریم کمتر از ۱۰۰۰ بایت باشد، اندازه آرایه متناسب با طول واقعی استریم خواهد بود.</li>
<li>اگر استریم قابلیت <code>Seek</code> داشته باشد، می‌توان با جایگزین کردن ۱۰۰۰ با <code>(int)s.Length</code> کل محتوای آن را خواند.</li>
</ul>
<blockquote>
<p>جزئیات بیشتر درباره BinaryReader در بخش <strong>“Stream Adapters”</strong> (صفحه 709) آمده است.</p>
</blockquote>
<hr>
<h3>🔹 ReadByte و WriteByte</h3>
<ul>
<li>
<p>متد <code>ReadByte</code> یک بایت می‌خواند و در صورت رسیدن به انتهای استریم، <code>-1</code> برمی‌گرداند.
(به همین دلیل مقدار بازگشتی آن <code>int</code> است، چون نوع <code>byte</code> نمی‌تواند <code>-1</code> برگرداند).</p>
</li>
<li>
<p>متدهای <code>Write</code> و <code>WriteByte</code> داده را به استریم می‌فرستند. اگر ارسال کامل بایت‌ها ممکن نباشد، یک <strong>Exception</strong> پرتاب می‌شود.</p>
</li>
</ul>
<hr>
<h2>🎯 جستجو در استریم (Seeking)</h2>
<ul>
<li>آرگومان <code>offset</code> در متدهای <strong>Read/Write</strong> به اندیس شروع در آرایه <strong>Buffer</strong> اشاره دارد، نه به موقعیت در خود استریم.</li>
<li>یک استریم <strong>Seekable</strong> است اگر ویژگی <code>CanSeek</code> آن <code>true</code> باشد (مثل FileStream).</li>
</ul>
<p>با یک استریم Seekable می‌توان:</p>
<ul>
<li>مقدار <code>Length</code> را پرسید یا با <code>SetLength</code> تغییر داد.</li>
<li>در هر لحظه <code>Position</code> را تغییر داد و مشخص کرد از کجا بخواند یا بنویسد.</li>
</ul>
<p>🔹 ویژگی <code>Position</code> نسبت به ابتدای استریم است، اما متد <code>Seek</code> اجازه می‌دهد نسبت به موقعیت فعلی یا انتهای استریم حرکت کنید.</p>
<ul>
<li>تغییر <code>Position</code> در FileStream معمولاً فقط چند میکروثانیه طول می‌کشد. اگر قرار است این کار را <strong>میلیون‌ها بار</strong> در یک حلقه انجام دهید، استفاده از <code>MemoryMappedFile</code> انتخاب بهتری نسبت به FileStream خواهد بود (صفحه 736 را ببینید).</li>
<li>در استریم‌های غیرقابل Seek (مثل استریم رمزنگاری)، تنها راه دانستن طول، خواندن کل آن است. همچنین برای خواندن دوباره یک بخش قبلی، باید استریم را ببندید و یک استریم جدید باز کنید.</li>
</ul>
<hr>
<h2>🔒 بستن و Flush کردن استریم‌ها</h2>
<p>استریم‌ها پس از استفاده باید <strong>Dispose</strong> شوند تا منابع زیربنایی مثل <strong>File Handle</strong> و <strong>Socket Handle</strong> آزاد شوند.</p>
<p>🔹 ساده‌ترین راه تضمین این موضوع، قرار دادن استریم درون یک <strong>بلوک using</strong> است.</p>
<p>قوانین کلی مدیریت استریم‌ها:</p>
<ul>
<li>متدهای <strong>Dispose</strong> و <strong>Close</strong> عملکرد یکسانی دارند.</li>
<li>بستن یا Dispose کردن چندباره یک استریم مشکلی ایجاد نمی‌کند.</li>
<li>بستن یک استریم Decorator باعث بسته شدن خودش و <strong>Backing Store</strong> آن می‌شود.</li>
<li>در یک زنجیره از Decoratorها، بستن Decorator بیرونی کل زنجیره را می‌بندد.</li>
</ul>
<p>برخی استریم‌ها داده‌ها را برای بهبود کارایی در حافظه <strong>Buffer</strong> می‌کنند (مثل FileStream). این باعث می‌شود داده‌ای که به استریم می‌نویسید، بلافاصله وارد Backing Store نشود.</p>
<ul>
<li>متد <strong>Flush</strong> باعث می‌شود داده‌های بافر شده فوراً نوشته شوند.</li>
<li><code>Flush</code> به‌صورت خودکار هنگام بسته شدن استریم صدا زده می‌شود، بنابراین هیچ‌وقت نیازی به نوشتن کدی مثل زیر ندارید:</li>
</ul>
<pre><code class="language-csharp">s.Flush();
s.Close();
</code></pre>
<h2>⏱️ Timeoutها</h2>
<p>یک استریم زمانی از <strong>Timeout</strong> پشتیبانی می‌کند که ویژگی <code>CanTimeout</code> مقدار <code>true</code> داشته باشد.</p>
<ul>
<li>استریم‌های <strong>شبکه‌ای (Network Streams)</strong> از Timeout پشتیبانی می‌کنند.</li>
<li>استریم‌های <strong>فایل (File Streams)</strong> و <strong>حافظه (Memory Streams)</strong> از Timeout پشتیبانی نمی‌کنند.</li>
</ul>
<p>برای استریم‌هایی که Timeout را پشتیبانی می‌کنند:</p>
<ul>
<li>ویژگی‌های <code>ReadTimeout</code> و <code>WriteTimeout</code> مدت زمان Timeout را بر حسب <strong>میلی‌ثانیه</strong> مشخص می‌کنند.</li>
<li>مقدار <code>0</code> یعنی <strong>بدون Timeout</strong>.</li>
<li>اگر Timeout رخ دهد، متدهای <code>Read</code> و <code>Write</code> یک <strong>Exception</strong> پرتاب می‌کنند.</li>
</ul>
<p>⚠️ متدهای Asynchronous (<code>ReadAsync</code>/<code>WriteAsync</code>) از Timeout پشتیبانی نمی‌کنند. در این حالت، می‌توانید یک <strong>CancellationToken</strong> به این متدها بدهید.</p>
<hr>
<h2>🧵 Thread Safety</h2>
<p>به‌طور کلی، استریم‌ها <strong>Thread-Safe</strong> نیستند؛ یعنی دو Thread نمی‌توانند به‌طور هم‌زمان روی یک استریم بخوانند یا بنویسند، چون احتمال خطا وجود دارد.</p>
<p>کلاس <strong>Stream</strong> یک راهکار ساده ارائه می‌دهد: متد استاتیک <code>Synchronized</code>.</p>
<ul>
<li>این متد یک استریم از هر نوع را می‌پذیرد و یک <strong>Wrapper ایمن برای Thread</strong> برمی‌گرداند.</li>
<li>این Wrapper با گرفتن یک <strong>قفل انحصاری (Exclusive Lock)</strong> در اطراف هر عملیات خواندن، نوشتن یا Seek، تضمین می‌کند که فقط یک Thread در هر لحظه بتواند عمل مورد نظر را انجام دهد.</li>
</ul>
<p>🔹 نتیجه عملی این است که چند Thread می‌توانند به‌طور هم‌زمان داده‌ها را به یک استریم <strong>Append</strong> کنند.
اما سایر فعالیت‌ها (مثل خواندن هم‌زمان) نیازمند قفل‌گذاری اضافی هستند تا مطمئن شوید هر Thread دقیقاً به بخش درستی از استریم دسترسی دارد.</p>
<p>📖 جزئیات کامل‌تر درباره <strong>Thread Safety</strong> در فصل ۲۱ توضیح داده می‌شود.</p>
<hr>
<h3>🚀 ویژگی جدید در .NET 6</h3>
<p>از نسخه .NET 6 به بعد، می‌توانید برای عملیات <strong>File I/O ایمن و کارآمد در برابر Thread</strong> از کلاس <strong>RandomAccess</strong> استفاده کنید.</p>
<ul>
<li>این کلاس امکان <strong>Thread-Safe File I/O</strong> با کارایی بالا را فراهم می‌کند.</li>
<li>همچنین اجازه می‌دهد چندین <strong>Buffer</strong> را برای بهبود عملکرد به‌طور هم‌زمان پاس دهید.</li>
</ul>
<hr>
<h2>🗄️ Backing Store Streams</h2>
<p>📊 شکل 15-2 استریم‌های اصلی <strong>Backing Store</strong> که توسط .NET ارائه می‌شوند را نشان می‌دهد.</p>
<p>🔹 علاوه بر این، یک <strong>Null Stream</strong> هم از طریق فیلد استاتیک <code>Stream.Null</code> در دسترس است.</p>
<p><strong>Null Stream</strong> می‌تواند هنگام نوشتن <strong>Unit Test</strong>ها بسیار مفید باشد.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>📂 FileStream</h2>
<p>در بخش‌های بعدی، به بررسی <strong>FileStream</strong> و <strong>MemoryStream</strong> می‌پردازیم؛ و در بخش پایانی این فصل، <strong>IsolatedStorageStream</strong> را معرفی می‌کنیم. در فصل ۱۶ هم به <strong>NetworkStream</strong> خواهیم پرداخت.</p>
<hr>
<h3>✨ ویژگی‌های FileStream</h3>
<p>پیش‌تر استفاده‌ی پایه‌ای از <strong>FileStream</strong> برای خواندن و نوشتن بایت‌ها را دیدیم. حالا بیایید ویژگی‌های خاص این کلاس را دقیق‌تر بررسی کنیم.</p>
<p>🔹 اگر هنوز از <strong>UWP (Universal Windows Platform)</strong> استفاده می‌کنید، می‌توانید عملیات فایل را با نوع‌های موجود در فضای نام <strong>Windows.Storage</strong> انجام دهید. توضیحات بیشتر در <a href="http://www.albahari.com/nutshell">ضمیمه آنلاین</a> آمده است.</p>
<hr>
<h3>🛠️ ساخت یک FileStream</h3>
<p>ساده‌ترین راه برای نمونه‌سازی <strong>FileStream</strong> استفاده از متدهای استاتیک کلاس <strong>File</strong> است:</p>
<pre><code class="language-csharp">FileStream fs1 = File.OpenRead(&quot;readme.bin&quot;);   // فقط خواندن
FileStream fs2 = File.OpenWrite(&quot;writeme.tmp&quot;); // فقط نوشتن
FileStream fs3 = File.Create(&quot;readwrite.tmp&quot;);  // خواندن/نوشتن
</code></pre>
<p>⚠️ تفاوت <code>OpenWrite</code> و <code>Create</code>:</p>
<ul>
<li><code>Create</code> محتوای قبلی فایل را <strong>کامل پاک می‌کند</strong> (truncate).</li>
<li><code>OpenWrite</code> محتوای موجود را نگه می‌دارد و مکان استریم را روی صفر قرار می‌دهد.
اگر کمتر از اندازه‌ی قبلی داده بنویسید، نتیجه ترکیبی از داده‌های قدیمی و جدید خواهد شد.</li>
</ul>
<p>همچنین می‌توانید مستقیم از <strong>سازنده‌ی FileStream</strong> استفاده کنید. سازنده‌ها امکان کنترل کامل روی:</p>
<ul>
<li>نام فایل یا <strong>file handle سطح پایین</strong></li>
<li>حالت‌های ساخت و دسترسی به فایل</li>
<li>گزینه‌های اشتراک‌گذاری (sharing)، بافرینگ و امنیت</li>
</ul>
<p>را فراهم می‌کنند. برای مثال:</p>
<pre><code class="language-csharp">using var fs = new FileStream(&quot;readwrite.tmp&quot;, FileMode.Open);
</code></pre>
<p>(کلیدواژه‌ی <code>using</code> تضمین می‌کند که استریم پس از خروج از محدوده dispose شود).</p>
<p>🔎 در ادامه به جزئیات <code>FileMode</code> می‌پردازیم.</p>
<hr>
<h3>⚡ متدهای میان‌بُر کلاس File</h3>
<p>این متدها کل محتوای فایل را در یک مرحله می‌خوانند:</p>
<ul>
<li><code>File.ReadAllText</code> → بازگرداندن یک <strong>string</strong></li>
<li><code>File.ReadAllLines</code> → بازگرداندن یک <strong>آرایه از string</strong></li>
<li><code>File.ReadAllBytes</code> → بازگرداندن یک <strong>آرایه‌ی بایت</strong></li>
</ul>
<p>این متدها کل فایل را در یک مرحله می‌نویسند:</p>
<ul>
<li><code>File.WriteAllText</code></li>
<li><code>File.WriteAllLines</code></li>
<li><code>File.WriteAllBytes</code></li>
<li><code>File.AppendAllText</code> (مناسب برای اضافه‌کردن به فایل‌های لاگ)</li>
</ul>
<p>همچنین متدی به نام <code>File.ReadLines</code> وجود دارد که مانند <code>ReadAllLines</code> است، با این تفاوت که یک <code>IEnumerable&lt;string&gt;</code> <strong>Lazy</strong> بازمی‌گرداند (به‌صورت تدریجی خوانده می‌شود، نه یک‌جا). این کارایی بهتری دارد چون کل فایل یک‌جا در حافظه بارگذاری نمی‌شود.</p>
<p>مثال با LINQ برای شمردن تعداد خطوطی که طول آن‌ها بیشتر از ۸۰ کاراکتر است:</p>
<pre><code class="language-csharp">int longLines = File.ReadLines(&quot;filePath&quot;)
                   .Count(l =&gt; l.Length &gt; 80);
</code></pre>
<hr>
<h3>📁 مشخص‌کردن نام فایل</h3>
<p>نام فایل می‌تواند:</p>
<ul>
<li>
<p><strong>مطلق (Absolute)</strong> باشد → مثل:</p>
<ul>
<li>ویندوز: <code>c:\temp\test.txt</code></li>
<li>یونیکس: <code>/tmp/test.txt</code></li>
</ul>
</li>
<li>
<p><strong>نسبی (Relative)</strong> به دایرکتوری فعلی → مثل:</p>
<ul>
<li><code>test.txt</code></li>
<li><code>temp\test.txt</code></li>
</ul>
</li>
</ul>
<p>🔹 دایرکتوری فعلی برنامه از طریق ویژگی استاتیک:</p>
<pre><code class="language-csharp">Environment.CurrentDirectory
</code></pre>
<p>قابل دسترسی و تغییر است.</p>
<p>⚠️ اما دایرکتوری فعلی <strong>ممکن است با مسیر اجرایی برنامه یکی نباشد</strong>. بنابراین <strong>هیچ‌وقت</strong> برای یافتن فایل‌های همراه executable روی آن حساب نکنید.</p>
<p>دایرکتوری پایه‌ی اپلیکیشن از طریق:</p>
<pre><code class="language-csharp">AppDomain.CurrentDomain.BaseDirectory
</code></pre>
<p>دریافت می‌شود (معمولاً همان پوشه‌ی فایل اجرایی است).</p>
<p>برای مشخص کردن نام فایل به‌صورت نسبی نسبت به این دایرکتوری:</p>
<pre><code class="language-csharp">string baseFolder = AppDomain.CurrentDomain.BaseDirectory;
string logoPath = Path.Combine(baseFolder, &quot;logo.jpg&quot;);
Console.WriteLine(File.Exists(logoPath));
</code></pre>
<hr>
<h3>🌐 مسیرهای شبکه‌ای (UNC Path)</h3>
<p>در ویندوز می‌توانید فایل‌ها را از طریق مسیر <strong>UNC</strong> بخوانید/بنویسید:</p>
<ul>
<li><code>\\JoesPC\PicShare\pic.jpg</code></li>
<li><code>\\10.1.1.2\PicShare\pic.jpg</code></li>
</ul>
<p>🔹 در macOS یا Unix برای دسترسی به یک Windows File Share باید ابتدا آن را به filesystem خود mount کنید، سپس مانند مسیر معمولی در C# باز کنید.</p>
<hr>
<h3>⚙️ مشخص کردن FileMode</h3>
<p>تمام سازنده‌های <code>FileStream</code> که یک نام فایل می‌پذیرند، نیاز به یک آرگومان از نوع <strong>FileMode enum</strong> دارند.</p>
<p>📊 شکل 15-3 نشان می‌دهد چگونه باید یک FileMode انتخاب کنید. نتایج مشابه فراخوانی متدهای استاتیک کلاس <strong>File</strong> خواهد بود.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>📂 FileStream</h2>
<p>🔹 اگر روی فایل‌های <strong>Hidden</strong> از <code>File.Create</code> یا <code>FileMode.Create</code> استفاده کنید، یک <strong>استثنا (Exception)</strong> پرتاب می‌شود. برای بازنویسی یک فایل مخفی، باید ابتدا آن را <strong>حذف</strong> و سپس دوباره ایجاد کنید:</p>
<pre><code class="language-csharp">File.Delete(&quot;hidden.txt&quot;);
using var file = File.Create(&quot;hidden.txt&quot;);
</code></pre>
<hr>
<h3>📖 FileAccess</h3>
<p>اگر فقط نام فایل و یک <code>FileMode</code> را به سازنده‌ی <code>FileStream</code> بدهید، نتیجه (با یک استثنا) یک استریم <strong>قابل خواندن/نوشتن</strong> خواهد بود.
اما می‌توانید با مشخص‌کردن آرگومان <strong>FileAccess</strong> دسترسی را محدود کنید:</p>
<pre><code class="language-csharp">[Flags]
public enum FileAccess { Read = 1, Write = 2, ReadWrite = 3 }
</code></pre>
<p>مثال: ساختن یک استریم فقط-خواندنی (معادل <code>File.OpenRead</code>):</p>
<pre><code class="language-csharp">using var fs = new FileStream(&quot;x.bin&quot;, FileMode.Open, FileAccess.Read);
</code></pre>
<p>⚠️ حالت خاص: <code>FileMode.Append</code> → فقط <strong>Write-only</strong> است.
اگر می‌خواهید داده‌ها را <strong>اضافه (Append)</strong> کنید و همزمان امکان خواندن داشته باشید، باید از <code>FileMode.Open</code> یا <code>FileMode.OpenOrCreate</code> استفاده کنید و سپس مکان استریم را به انتهای فایل ببرید:</p>
<pre><code class="language-csharp">using var fs = new FileStream(&quot;myFile.bin&quot;, FileMode.Open);
fs.Seek(0, SeekOrigin.End);
</code></pre>
<hr>
<h3>⚙️ ویژگی‌های پیشرفته‌ی FileStream</h3>
<p>می‌توانید هنگام ساخت یک FileStream آرگومان‌های اضافی بدهید:</p>
<ul>
<li>
<p><strong>FileShare enum</strong> → میزان دسترسی سایر پردازش‌ها (None، Read، ReadWrite، Write).</p>
</li>
<li>
<p><strong>Buffer size</strong> → اندازه بافر داخلی (به‌صورت پیش‌فرض ۴KB).</p>
</li>
<li>
<p><strong>Async flag</strong> → واگذاری عملیات ناهمگام به سیستم‌عامل.</p>
</li>
<li>
<p><strong>FileOptions flags</strong> → شامل:</p>
<ul>
<li><code>Encrypted</code> → رمزنگاری توسط سیستم‌عامل</li>
<li><code>DeleteOnClose</code> → حذف خودکار فایل هنگام بسته‌شدن</li>
<li><code>RandomAccess</code> → بهینه‌سازی برای دسترسی تصادفی</li>
<li><code>SequentialScan</code> → بهینه‌سازی برای اسکن ترتیبی</li>
<li><code>WriteThrough</code> → غیرفعال کردن کش سیستم‌عامل (برای فایل‌های تراکنشی یا لاگ‌ها)</li>
</ul>
</li>
</ul>
<p>⚠️ فلگ‌هایی که سیستم‌عامل پشتیبانی نکند، بی‌صدا (silently) نادیده گرفته می‌شوند.</p>
<p>اگر با <code>FileShare.ReadWrite</code> فایل را باز کنید، چند پردازش یا کاربر می‌توانند همزمان بخوانند/بنویسند. برای جلوگیری از تداخل، می‌توان بخش‌هایی از فایل را قفل کرد:</p>
<pre><code class="language-csharp">public virtual void Lock(long position, long length);
public virtual void Unlock(long position, long length);
</code></pre>
<p>متد <code>Lock</code> اگر ناحیه‌ای از فایل قبلاً قفل باشد، استثنا پرتاب می‌کند.</p>
<hr>
<h2>🧠 MemoryStream</h2>
<p><strong>MemoryStream</strong> از یک آرایه در حافظه به‌عنوان <strong>backing store</strong> استفاده می‌کند.
این یعنی تمام داده‌ها باید یک‌جا در حافظه باشند (برخلاف مزیت اصلی Stream).</p>
<p>اما همچنان مفید است، به‌خصوص وقتی:</p>
<ul>
<li>نیاز به دسترسی تصادفی (Random Access) به یک استریم غیرقابل Seek دارید.</li>
<li>داده‌ی اصلی کوچک و قابل مدیریت است.</li>
</ul>
<p>📌 مثال: کپی کردن داده‌ی یک استریم درون MemoryStream:</p>
<pre><code class="language-csharp">var ms = new MemoryStream();
sourceStream.CopyTo(ms);
</code></pre>
<ul>
<li>
<p>برای گرفتن داده‌ها:</p>
<ul>
<li><code>ToArray()</code> → یک کپی از داده‌ها بازمی‌گرداند.</li>
<li><code>GetBuffer()</code> → مرجع مستقیم به آرایه‌ی ذخیره‌سازی می‌دهد (کارآمدتر است، اما طول آن معمولاً از داده‌ی واقعی بیشتر است).</li>
</ul>
</li>
</ul>
<p>📍 بستن یا Flush کردن MemoryStream اختیاری است:</p>
<ul>
<li>بعد از <code>Close</code> دیگر نمی‌توانید بخوانید/بنویسید، ولی همچنان <code>ToArray()</code> کار می‌کند.</li>
<li><code>Flush</code> هیچ تأثیری ندارد.</li>
</ul>
<hr>
<h2>🔗 PipeStream</h2>
<p><strong>PipeStream</strong> راهی ساده برای ارتباط بین پردازش‌ها (IPC) از طریق پروتکل <strong>Pipe</strong> سیستم‌عامل است.</p>
<h3>انواع Pipe</h3>
<ol>
<li><strong>Anonymous Pipe (سریع‌تر)</strong> → ارتباط یک‌طرفه بین یک پردازش والد و فرزند (روی همان سیستم).</li>
<li><strong>Named Pipe (انعطاف‌پذیرتر)</strong> → ارتباط دوطرفه بین پردازش‌های مختلف (روی یک سیستم یا بین سیستم‌ها در شبکه).</li>
</ol>
<p>📌 Pipes برای IPC روی یک کامپیوتر عالی هستند:</p>
<ul>
<li>نیازی به پروتکل شبکه ندارند (بدون سربار شبکه).</li>
<li>مشکلی با فایروال‌ها ندارند.</li>
</ul>
<hr>
<h3>کلاس‌ها</h3>
<p>PipeStream یک کلاس انتزاعی است. چهار زیرکلاس اصلی دارد:</p>
<ul>
<li><strong>AnonymousPipeServerStream</strong></li>
<li><strong>AnonymousPipeClientStream</strong></li>
<li><strong>NamedPipeServerStream</strong></li>
<li><strong>NamedPipeClientStream</strong></li>
</ul>
<p>🔹 Named Pipes ساده‌ترند، پس اول آن‌ها را بررسی می‌کنیم.</p>
<hr>
<h3>📡 Named Pipes</h3>
<p>ارتباط از طریق یک نام مشترک برقرار می‌شود. دو نقش اصلی وجود دارد:</p>
<ul>
<li><strong>Server</strong> → نمونه‌ای از <code>NamedPipeServerStream</code> ساخته و <code>WaitForConnection()</code> را صدا می‌زند.</li>
<li><strong>Client</strong> → نمونه‌ای از <code>NamedPipeClientStream</code> ساخته و <code>Connect()</code> را صدا می‌زند.</li>
</ul>
<p>سپس دو طرف از استریم برای خواندن/نوشتن استفاده می‌کنند.</p>
<p>📍 مثال ساده:</p>
<p><strong>Server</strong> → ارسال یک بایت (۱۰۰) و دریافت یک بایت:</p>
<pre><code class="language-csharp">using var s = new NamedPipeServerStream(&quot;pipedream&quot;);
s.WaitForConnection();
s.WriteByte(100);
Console.WriteLine(s.ReadByte());
</code></pre>
<p><strong>Client</strong> → دریافت بایت و ارسال یک بایت (۲۰۰):</p>
<pre><code class="language-csharp">using var s = new NamedPipeClientStream(&quot;pipedream&quot;);
s.Connect();
Console.WriteLine(s.ReadByte());
s.WriteByte(200);
</code></pre>
<p>🔹 Pipeها به‌طور پیش‌فرض <strong>دوطرفه</strong> هستند. پس باید یک <strong>پروتکل توافقی</strong> بین Client و Server وجود داشته باشد تا هر دو همزمان ننویسند یا نخوانند.</p>
<hr>
<h3>📑 Message Transmission Mode (فقط ویندوز)</h3>
<p>برای پیام‌های طولانی‌تر، Pipeها یک حالت خاص به نام <strong>Message Mode</strong> دارند.
در این حالت می‌توان با ویژگی <code>IsMessageComplete</code> فهمید یک پیام کامل دریافت شده است.</p>
<p>📌 مثال: خواندن کل پیام:</p>
<pre><code class="language-csharp">static byte[] ReadMessage(PipeStream s)
{
    MemoryStream ms = new MemoryStream();
    byte[] buffer = new byte[0x1000]; // 4KB
    do { ms.Write(buffer, 0, s.Read(buffer, 0, buffer.Length)); }
    while (!s.IsMessageComplete);
    return ms.ToArray();
}
</code></pre>
<hr>
<h3>✨ فعال‌سازی Message Mode</h3>
<p><strong>Server</strong>:</p>
<pre><code class="language-csharp">using var s = new NamedPipeServerStream(
    &quot;pipedream&quot;, PipeDirection.InOut, 1, PipeTransmissionMode.Message);

s.WaitForConnection();
byte[] msg = Encoding.UTF8.GetBytes(&quot;Hello&quot;);
s.Write(msg, 0, msg.Length);
Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(s)));
</code></pre>
<p><strong>Client</strong>:</p>
<pre><code class="language-csharp">using var s = new NamedPipeClientStream(&quot;pipedream&quot;);
s.Connect();
s.ReadMode = PipeTransmissionMode.Message;

Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(s)));
byte[] msg = Encoding.UTF8.GetBytes(&quot;Hello right back!&quot;);
s.Write(msg, 0, msg.Length);
</code></pre>
<p>⚠️ <strong>Message Mode فقط روی ویندوز پشتیبانی می‌شود.</strong>
در سایر سیستم‌عامل‌ها → <code>PlatformNotSupportedException</code> پرتاب می‌شود.</p>
<hr>
<h3><strong>پایپ‌های ناشناس (Anonymous pipes)</strong></h3>
<p>یک <strong>پایپ ناشناس</strong> یک جریان ارتباطی یک‌طرفه بین یک <strong>پردازش والد (parent process)</strong> و یک <strong>پردازش فرزند (child process)</strong> فراهم می‌کند. به‌جای استفاده از یک نام سراسری در سیستم، پایپ‌های ناشناس از طریق یک <strong>هندل خصوصی (private handle)</strong> با هم ارتباط برقرار می‌کنند.</p>
<p>همانند پایپ‌های نام‌دار، در اینجا هم نقش‌های مشخصی برای <strong>کلاینت</strong> و <strong>سرور</strong> وجود دارد. با این حال، شیوه‌ی ارتباط کمی متفاوت است و به‌صورت زیر انجام می‌شود:</p>
<ol>
<li>سرور یک <strong>AnonymousPipeServerStream</strong> می‌سازد و به یک <strong>PipeDirection</strong> (جهت In یا Out) متعهد می‌شود.</li>
<li>سرور متد <strong>GetClientHandleAsString</strong> را صدا می‌زند تا یک شناسه برای پایپ بگیرد، سپس آن را به کلاینت می‌فرستد (معمولاً به‌عنوان آرگومان هنگام راه‌اندازی پردازش فرزند).</li>
<li>پردازش فرزند یک <strong>AnonymousPipeClientStream</strong> می‌سازد و جهت مخالف را مشخص می‌کند.</li>
<li>سرور هندل محلی‌ای که در مرحله‌ی ۲ ساخته شده بود را با متد <strong>DisposeLocalCopyOfClientHandle</strong> آزاد می‌کند.</li>
<li>حالا پردازش والد و فرزند می‌توانند از طریق خواندن/نوشتن استریم با هم ارتباط برقرار کنند.</li>
</ol>
<p>از آنجا که پایپ‌های ناشناس یک‌طرفه هستند، یک سرور برای ارتباط دوطرفه باید <strong>دو پایپ</strong> بسازد.</p>
<p>کد زیر نشان می‌دهد که چطور دو پایپ (ورودی و خروجی) ساخته می‌شوند و سپس یک پردازش فرزند راه‌اندازی می‌شود. در ادامه، یک بایت از سرور به فرزند ارسال شده و یک بایت در پاسخ دریافت می‌شود:</p>
<pre><code class="language-csharp">class Program
{
  static void Main (string[] args)
  {
    if (args.Length == 0)
      // بدون آرگومان = حالت سرور
      AnonymousPipeServer();
    else
      // آرگومان‌ها = شناسه‌های پایپ برای حالت کلاینت
      AnonymousPipeClient (args [0], args [1]);
  }

  static void AnonymousPipeClient (string rxID, string txID)
  {
    using var rx = new AnonymousPipeClientStream (PipeDirection.In, rxID);
    using var tx = new AnonymousPipeClientStream (PipeDirection.Out, txID);
    Console.WriteLine (&quot;Client received: &quot; + rx.ReadByte ());
    tx.WriteByte (200);
  }

  static void AnonymousPipeServer ()
  {
    using var tx = new AnonymousPipeServerStream (
                     PipeDirection.Out, HandleInheritability.Inheritable);
    using var rx = new AnonymousPipeServerStream (
                     PipeDirection.In, HandleInheritability.Inheritable);

    string txID = tx.GetClientHandleAsString ();
    string rxID = rx.GetClientHandleAsString ();

    // ایجاد و راه‌اندازی پردازش فرزند
    string thisAssembly = Assembly.GetEntryAssembly().Location;
    string thisExe = Path.ChangeExtension (thisAssembly, &quot;.exe&quot;);
    var args = $&quot;{txID} {rxID}&quot;;
    var startInfo = new ProcessStartInfo (thisExe, args);
    startInfo.UseShellExecute = false;   // الزامی برای پردازش فرزند
    Process p = Process.Start (startInfo);

    tx.DisposeLocalCopyOfClientHandle ();  // آزادسازی منابع
    rx.DisposeLocalCopyOfClientHandle ();

    tx.WriteByte (100);    // ارسال یک بایت به پردازش فرزند
    Console.WriteLine (&quot;Server received: &quot; + rx.ReadByte ());
    p.WaitForExit ();
  }
}
</code></pre>
<p>📌 همانند پایپ‌های نام‌دار، <strong>کلاینت و سرور باید ارسال و دریافت خود را هماهنگ کنند</strong> و روی طول هر انتقال توافق داشته باشند. متأسفانه پایپ‌های ناشناس از <strong>حالت پیام (message mode)</strong> پشتیبانی نمی‌کنند، بنابراین باید خودتان پروتکل مدیریت طول پیام را پیاده‌سازی کنید.</p>
<p>یکی از راه‌حل‌ها این است که در چهار بایت اول هر انتقال، یک <strong>عدد صحیح (integer)</strong> ارسال شود که طول پیام بعدی را مشخص کند. کلاس <strong>BitConverter</strong> متدهایی برای تبدیل بین یک عدد صحیح و یک آرایه‌ی ۴ بایتی فراهم می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<hr>
<h3><strong>BufferedStream (استریم بافر شده)</strong></h3>
<p>بافرینگ باعث بهبود کارایی می‌شود چون تعداد دفعات رفت‌وبرگشت به <strong>backing store</strong> (مثل فایل یا شبکه) را کاهش می‌دهد.</p>
<p>در مثال زیر ما یک <strong>FileStream</strong> را داخل یک <strong>BufferedStream</strong> با اندازه‌ی بافر ۲۰ کیلوبایت می‌پیچیم:</p>
<pre><code class="language-csharp">// نوشتن 100K در یک فایل:
File.WriteAllBytes (&quot;myFile.bin&quot;, new byte [100000]);
using FileStream fs = File.OpenRead (&quot;myFile.bin&quot;);
using BufferedStream bs = new BufferedStream (fs, 20000);  // بافر 20K
bs.ReadByte();
Console.WriteLine (fs.Position);   // 20000
</code></pre>
<p>🔍 در این مثال، استریم زیرین (<strong>FileStream</strong>) بعد از خواندن فقط <strong>یک بایت</strong>، به اندازه‌ی ۲۰,۰۰۰ بایت جلو می‌رود؛ این به خاطر <strong>read-ahead buffering</strong> است. ما می‌توانیم متد <code>ReadByte</code> را <strong>۱۹,۹۹۹ بار دیگر</strong> صدا بزنیم، بدون اینکه دوباره <code>FileStream</code> درگیر شود.</p>
<p>✅ در عمل، بستن یک <strong>BufferedStream</strong> به طور خودکار استریم backing store زیرین را هم می‌بندد.</p>
<p>⚠️ ترکیب <strong>BufferedStream</strong> با <strong>FileStream</strong> (مثل این مثال) ارزش محدودی دارد، چون <strong>FileStream خودش بافر داخلی دارد</strong>. تنها کاربرد آن می‌تواند زمانی باشد که بخواهیم بافر یک <strong>FileStream</strong> ساخته‌شده را <strong>بزرگ‌تر کنیم</strong>.</p>
<hr>
<h3><strong>Stream Adapters (آداپتورهای استریم)</strong></h3>
<p>از آنجا که <strong>Stream فقط با بایت‌ها سروکار دارد</strong>، برای خواندن یا نوشتن داده‌هایی مثل <strong>رشته‌ها (string)</strong>، <strong>اعداد صحیح (int)</strong> یا <strong>عناصر XML</strong> باید از <strong>adapter</strong> استفاده کنید.</p>
<p>📌 .NET آداپتورهای زیر را فراهم کرده است:</p>
<ul>
<li>
<p><strong>آداپتورهای متنی (برای داده‌های رشته و کاراکتر):</strong></p>
<ul>
<li><code>TextReader</code>, <code>TextWriter</code></li>
<li><code>StreamReader</code>, <code>StreamWriter</code></li>
<li><code>StringReader</code>, <code>StringWriter</code></li>
</ul>
</li>
<li>
<p><strong>آداپتورهای باینری (برای انواع داده‌های اولیه مثل int, bool, string, float):</strong></p>
<ul>
<li><code>BinaryReader</code>, <code>BinaryWriter</code></li>
</ul>
</li>
<li>
<p><strong>آداپتورهای XML (پوشش داده‌شده در فصل 11):</strong></p>
<ul>
<li><code>XmlReader</code>, <code>XmlWriter</code></li>
</ul>
</li>
</ul>
<p>📖 شکل 15-5 روابط بین این نوع‌ها را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3><strong>آداپتورهای متنی (Text Adapters)</strong></h3>
<p><code>TextReader</code> و <code>TextWriter</code> کلاس‌های پایه‌ی انتزاعی هستند که مخصوص کار با <strong>کاراکترها</strong> و <strong>رشته‌ها</strong> طراحی شده‌اند. هر کدام در .NET دو پیاده‌سازی عمومی دارند:</p>
<ul>
<li>
<p><strong><code>StreamReader</code> / <code>StreamWriter</code></strong>
از یک <strong>Stream</strong> به‌عنوان منبع داده‌ی خام استفاده می‌کنند و بایت‌های استریم را به کاراکترها یا رشته‌ها تبدیل می‌کنند.</p>
</li>
<li>
<p><strong><code>StringReader</code> / <code>StringWriter</code></strong>
<code>TextReader</code> / <code>TextWriter</code> را با استفاده از <strong>رشته‌های درون حافظه</strong> پیاده‌سازی می‌کنند.</p>
</li>
</ul>
<p>📌 <strong>جدول 15-2</strong> اعضای <code>TextReader</code> را بر اساس دسته‌بندی نشان می‌دهد.</p>
<ul>
<li>
<p>متد <code>Peek</code> کاراکتر بعدی در استریم را <strong>برمی‌گرداند بدون اینکه موقعیت را جلو ببرد</strong>.</p>
</li>
<li>
<p>هم <code>Peek</code> و هم نسخه‌ی بدون پارامتر <code>Read</code> مقدار <strong>-1</strong> را برمی‌گردانند اگر به انتهای استریم رسیده باشند؛ در غیر این صورت یک <strong>عدد صحیح (int)</strong> برمی‌گردانند که می‌توان آن را مستقیم به <code>char</code> تبدیل کرد.</p>
</li>
<li>
<p>نسخه‌ی overload شده‌ی <code>Read</code> که یک <code>char[] buffer</code> می‌گیرد، دقیقاً مشابه متد <code>ReadBlock</code> عمل می‌کند.</p>
</li>
<li>
<p>متد <code>ReadLine</code> می‌خواند تا زمانی که به یکی از این‌ها برسد:</p>
<ul>
<li><strong>CR</strong> (کد کاراکتری 13)</li>
<li><strong>LF</strong> (کد کاراکتری 10)</li>
<li>یا ترکیب <strong>CR+LF</strong>
سپس یک <strong>رشته (string)</strong> برمی‌گرداند و کاراکترهای CR/LF را حذف می‌کند.</li>
</ul>
</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><code>Environment.NewLine</code> دنباله‌ی <strong>new-line</strong> مناسب برای سیستم‌عامل فعلی را برمی‌گرداند.</p>
<ul>
<li>در <strong>ویندوز</strong>، این مقدار <code>&quot;\r\n&quot;</code> است (به یاد “ReturN” بیفتید) و به صورت تقریبی شبیه یک ماشین تحریر مکانیکی مدل شده: ابتدا <strong>CR</strong> (کاراکتر ۱۳) و سپس <strong>LF</strong> (کاراکتر ۱۰). اگر ترتیب را برعکس کنید، یا دو خط جدید خواهید داشت یا هیچ!</li>
<li>در <strong>Unix</strong> و <strong>macOS</strong>، مقدار تنها <code>&quot;\n&quot;</code> است.</li>
</ul>
<p><code>TextWriter</code> متدهای مشابهی برای نوشتن دارد، همان‌طور که در <strong>جدول 15-3</strong> نشان داده شده است. متدهای <code>Write</code> و <code>WriteLine</code> همچنین <strong>overload</strong> شده‌اند تا همه‌ی نوع‌های اولیه و نوع <strong>object</strong> را قبول کنند. این متدها صرفاً متد <code>ToString</code> را روی مقداری که داده شده صدا می‌زنند (اختیاری از طریق یک <code>IFormatProvider</code> که هنگام صدا زدن متد یا هنگام ساخت <code>TextWriter</code> مشخص شده باشد).</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>متد <code>WriteLine</code> به‌سادگی متن داده‌شده را با <code>Environment.NewLine</code> الحاق می‌کند. می‌توانید این رفتار را از طریق <strong>خاصیت <code>NewLine</code></strong> تغییر دهید (این می‌تواند برای <strong>تطبیق با فرمت‌های فایل Unix</strong> مفید باشد).</p>
<p>همانند <code>Stream</code>، کلاس‌های <code>TextReader</code> و <code>TextWriter</code> نسخه‌های <strong>آسنکرون مبتنی بر Task</strong> از متدهای خواندن و نوشتن خود را ارائه می‌دهند.</p>
<h3>StreamReader و StreamWriter 📄✍️</h3>
<p>در مثال زیر، یک <code>StreamWriter</code> دو خط متن را در یک فایل می‌نویسد و سپس یک <code>StreamReader</code> فایل را دوباره می‌خواند:</p>
<pre><code class="language-csharp">using (FileStream fs = File.Create(&quot;test.txt&quot;))
using (TextWriter writer = new StreamWriter(fs))
{
    writer.WriteLine(&quot;Line1&quot;);
    writer.WriteLine(&quot;Line2&quot;);
}
using (FileStream fs = File.OpenRead(&quot;test.txt&quot;))
using (TextReader reader = new StreamReader(fs))
{
    Console.WriteLine(reader.ReadLine()); // Line1
    Console.WriteLine(reader.ReadLine()); // Line2
}
</code></pre>
<p>چون <strong>Text adapters</strong> اغلب همراه با فایل‌ها استفاده می‌شوند، کلاس <code>File</code> متدهای <strong>استاتیک</strong> <code>CreateText</code>، <code>AppendText</code> و <code>OpenText</code> را برای کوتاه کردن روند فراهم می‌کند:</p>
<pre><code class="language-csharp">using (TextWriter writer = File.CreateText(&quot;test.txt&quot;))
{
    writer.WriteLine(&quot;Line1&quot;);
    writer.WriteLine(&quot;Line2&quot;);
}
using (TextWriter writer = File.AppendText(&quot;test.txt&quot;))
    writer.WriteLine(&quot;Line3&quot;);

using (TextReader reader = File.OpenText(&quot;test.txt&quot;))
    while (reader.Peek() &gt; -1)
        Console.WriteLine(reader.ReadLine()); // Line1, Line2, Line3
</code></pre>
<p>این مثال همچنین نشان می‌دهد که چگونه پایان فایل را بررسی کنیم (<code>reader.Peek()</code>). روش دیگر این است که تا وقتی <code>reader.ReadLine</code> مقدار <code>null</code> برگرداند، ادامه دهیم.</p>
<p>می‌توانید انواع دیگری مانند <strong>اعداد صحیح</strong> را نیز بخوانید و بنویسید، اما چون <code>TextWriter</code> متد <code>ToString</code> را روی نوع شما صدا می‌زند، هنگام خواندن باید رشته را <strong>Parse</strong> کنید:</p>
<pre><code class="language-csharp">using (TextWriter w = File.CreateText(&quot;data.txt&quot;))
{
    w.WriteLine(123);      // می‌نویسد &quot;123&quot;
    w.WriteLine(true);     // می‌نویسد &quot;true&quot;
}
using (TextReader r = File.OpenText(&quot;data.txt&quot;))
{
    int myInt = int.Parse(r.ReadLine());   // myInt == 123
    bool yes = bool.Parse(r.ReadLine());   // yes == true
}
</code></pre>
<h3>رمزگذاری کاراکترها 🔤</h3>
<p><code>TextReader</code> و <code>TextWriter</code> خودشان تنها کلاس‌های <strong>abstract</strong> هستند و ارتباطی با یک <strong>stream</strong> یا <strong>backing store</strong> ندارند. اما <code>StreamReader</code> و <code>StreamWriter</code> به یک <strong>stream بایت‌محور</strong> متصل‌اند و باید بین <strong>کاراکترها و بایت‌ها</strong> تبدیل انجام دهند. این کار از طریق کلاس <code>Encoding</code> در <strong>System.Text</strong> انجام می‌شود که هنگام ساخت <code>StreamReader</code> یا <code>StreamWriter</code> انتخاب می‌کنید. اگر چیزی انتخاب نکنید، <strong>UTF-8</strong> پیش‌فرض استفاده می‌شود.</p>
<p>اگر به‌طور صریح یک <strong>Encoding</strong> مشخص کنید، <code>StreamWriter</code> به‌طور پیش‌فرض یک پیش‌وند (prefix) برای شناسایی رمزگذاری به ابتدای جریان می‌نویسد. این معمولاً ناخواسته است و می‌توانید با ساخت Encoding به شکل زیر از آن جلوگیری کنید:</p>
<pre><code class="language-csharp">var encoding = new UTF8Encoding(
    encoderShouldEmitUTF8Identifier: false,
    throwOnInvalidBytes: true
);
</code></pre>
<p>آرگومان دوم به <code>StreamWriter</code> یا <code>StreamReader</code> می‌گوید اگر با بایت‌هایی مواجه شد که ترجمه معتبر به رشته ندارند، <strong>Exception</strong> پرتاب کند، که با رفتار پیش‌فرض مطابقت دارد.</p>
<h3>مثال رمزگذاری ASCII و UTF-8</h3>
<p>رمزگذاری ساده <code>ASCII</code> است، چون هر کاراکتر با یک بایت نمایش داده می‌شود. کاراکترهای غیرانگلیسی یا نمادهای ویژه قابل نمایش نیستند و به <code>□</code> تبدیل می‌شوند.</p>
<p>رمزگذاری پیش‌فرض <code>UTF-8</code> می‌تواند تمام کاراکترهای یونیکد را نمایش دهد. کاراکترهای ASCII (127 کاراکتر اول) با یک بایت کدگذاری می‌شوند؛ بقیه کاراکترها با تعداد بایت متغیر (معمولاً دو یا سه) کدگذاری می‌شوند. مثال:</p>
<pre><code class="language-csharp">using (TextWriter w = File.CreateText(&quot;but.txt&quot;)) // استفاده از UTF-8 پیش‌فرض
    w.WriteLine(&quot;but-&quot;);

using (Stream s = File.OpenRead(&quot;but.txt&quot;))
    for (int b; (b = s.ReadByte()) &gt; -1;)
        Console.WriteLine(b);
</code></pre>
<p>برای کاراکتر <strong>em dash (—)</strong> که خارج از 127 کاراکتر اول یونیکد است، UTF-8 سه بایت استفاده می‌کند.</p>
<h3>UTF-16</h3>
<p>UTF-16 از دو یا چهار بایت برای هر کاراکتر استفاده می‌کند. نوع <code>char</code> در C# فقط 16 بیت است، پس UTF-16 دقیقاً دو بایت برای هر char استفاده می‌کند. این امکان پرش به ایندکس کاراکتر مشخص در stream را آسان می‌کند.</p>
<p>UTF-16 از یک پیش‌وند دو بایتی برای مشخص کردن <strong>little-endian</strong> یا <strong>big-endian</strong> استفاده می‌کند. ترتیب پیش‌فرض little-endian برای سیستم‌های مبتنی بر ویندوز استاندارد است.</p>
<h3>StringReader و StringWriter</h3>
<p>این‌ها <strong>stream</strong> را wrap نمی‌کنند و از یک <strong>string</strong> یا <strong>StringBuilder</strong> به‌عنوان منبع داده استفاده می‌کنند. بنابراین نیاز به ترجمه بایت نیست و کلاس‌ها تنها بر اساس همان رفتار پایه <code>StreamReader/StreamWriter</code> عمل می‌کنند.</p>
<p>مثال: اگر بخواهید یک رشته حاوی XML را با <code>XmlReader</code> تجزیه کنید:</p>
<pre><code class="language-csharp">XmlReader r = XmlReader.Create(new StringReader(myString));
</code></pre>
<h3>Binary Adapters 💾</h3>
<p><code>BinaryReader</code> و <code>BinaryWriter</code> داده‌های native مانند <code>bool</code>، <code>byte</code>، <code>int</code>، <code>double</code>، <code>string</code> و آرایه‌های نوع‌های اولیه را می‌خوانند و می‌نویسند.
بر خلاف <code>StreamReader/StreamWriter</code>، binary adapters داده‌ها را به‌صورت <strong>موثر در حافظه</strong> ذخیره می‌کنند.</p>
<p>مثال تعریف کلاس ساده و ذخیره/بارگذاری با binary adapters:</p>
<pre><code class="language-csharp">public class Person
{
    public string Name;
    public int Age;
    public double Height;

    public void SaveData(Stream s)
    {
        var w = new BinaryWriter(s);
        w.Write(Name);
        w.Write(Age);
        w.Write(Height);
        w.Flush(); // اطمینان از خالی شدن بافر
    }

    public void LoadData(Stream s)
    {
        var r = new BinaryReader(s);
        Name = r.ReadString();
        Age = r.ReadInt32();
        Height = r.ReadDouble();
    }
}
</code></pre>
<p>همچنین می‌توان با <code>BinaryReader</code> کل محتوای یک <strong>stream seekable</strong> را به آرایه بایت خواند:</p>
<pre><code class="language-csharp">byte[] data = new BinaryReader(s).ReadBytes((int)s.Length);
</code></pre>
<p>این روش راحت‌تر از خواندن مستقیم از stream است، چون نیاز به loop برای اطمینان از خواندن تمام داده‌ها ندارد.</p>
<h3>بستن و آزادسازی Stream Adapters 🔒</h3>
<p>برای <strong>تخریب (tear down)</strong> stream adapters، چهار گزینه دارید:</p>
<ol>
<li>فقط adapter را ببندید.</li>
<li>adapter را ببندید و سپس stream را ببندید.</li>
<li>(برای writers) adapter را Flush کرده و سپس stream را ببندید.</li>
<li>(برای readers) فقط stream را ببندید.</li>
</ol>
<p>در adapters، متدهای <code>Close</code> و <code>Dispose</code> <strong>هم‌معنی</strong> هستند، همانند رفتارشان در streams.</p>
<p>گزینه‌های 1 و 2 از نظر معنایی <strong>یکسان</strong> هستند، زیرا بستن یک adapter به‌طور خودکار <strong>stream زیرین</strong> را نیز می‌بندد. هر زمان که از <strong>nested using statements</strong> استفاده می‌کنید، عملاً گزینه 2 را انتخاب کرده‌اید:</p>
<pre><code class="language-csharp">using (FileStream fs = File.Create(&quot;test.txt&quot;))
using (TextWriter writer = new StreamWriter(fs))
    writer.WriteLine(&quot;Line&quot;);
</code></pre>
<p>چون dispose به ترتیب از داخل به بیرون انجام می‌شود، ابتدا adapter بسته می‌شود و سپس stream. همچنین اگر در <strong>constructor</strong> adapter استثنایی رخ دهد، stream همچنان بسته می‌شود. استفاده از nested using statements تقریباً همیشه ایمن است.</p>
<blockquote>
<p>هرگز یک stream را قبل از بستن یا Flush کردن writer آن نبندید — در غیر این صورت داده‌های بافر شده در adapter از بین می‌روند.</p>
</blockquote>
<p>گزینه‌های 3 و 4 کار می‌کنند چون adapters در دسته <strong>objects با disposal اختیاری</strong> قرار دارند. یک مثال: ممکن است adapter را تمام کرده باشید ولی بخواهید <strong>stream زیرین</strong> برای استفاده‌های بعدی باز بماند:</p>
<pre><code class="language-csharp">using (FileStream fs = new FileStream(&quot;test.txt&quot;, FileMode.Create))
{
    StreamWriter writer = new StreamWriter(fs);
    writer.WriteLine(&quot;Hello&quot;);
    writer.Flush();
    fs.Position = 0;
    Console.WriteLine(fs.ReadByte());
}
</code></pre>
<p>در اینجا، ابتدا به فایل می‌نویسیم، موقعیت stream را تغییر می‌دهیم و سپس اولین بایت را می‌خوانیم. اگر StreamWriter را dispose می‌کردیم، FileStream نیز بسته می‌شد و خواندن بعدی شکست می‌خورد. شرط این است که <strong>Flush</strong> را صدا بزنیم تا بافر StreamWriter به stream نوشته شود.</p>
<p>Stream adapters با semantics <strong>اختیاری در disposal</strong>، الگوی <strong>extended disposal</strong> که finalizer در آن Dispose را صدا می‌زند، پیاده‌سازی نمی‌کنند. این امکان را می‌دهد که adapter رهاشده هنگام رسیدن <strong>garbage collector</strong> به آن، خودکار dispose نشود.</p>
<p>همچنین یک constructor در StreamReader/StreamWriter وجود دارد که دستور می‌دهد stream بعد از disposal باز بماند. بنابراین می‌توان مثال قبل را به شکل زیر بازنویسی کرد:</p>
<pre><code class="language-csharp">using (var fs = new FileStream(&quot;test.txt&quot;, FileMode.Create))
{
    using (var writer = new StreamWriter(fs, new UTF8Encoding(false, true), 0x400, true))
        writer.WriteLine(&quot;Hello&quot;);
    fs.Position = 0;
    Console.WriteLine(fs.ReadByte());
    Console.WriteLine(fs.Length);
}
</code></pre>
<hr>
<h3>Compression Streams 📦</h3>
<p>در فضای نام <code>System.IO.Compression</code> دو <strong>compression stream</strong> عمومی وجود دارد: <code>DeflateStream</code> و <code>GZipStream</code>. هر دو از الگوریتم فشرده‌سازی مشابه ZIP استفاده می‌کنند. تفاوتشان این است که <strong>GZipStream</strong> یک پروتکل اضافی در ابتدا و انتها می‌نویسد که شامل CRC برای تشخیص خطا است و با استانداردهای نرم‌افزاری دیگر سازگار است.</p>
<p>.NET همچنین <code>BrotliStream</code> را ارائه می‌دهد که الگوریتم Brotli را پیاده‌سازی می‌کند. <strong>BrotliStream</strong> بیش از 10 برابر کندتر از DeflateStream و GZipStream است اما نسبت فشرده‌سازی بهتری دارد. (این کاهش سرعت فقط برای فشرده‌سازی است؛ دیکامپرشن بسیار سریع است.)</p>
<p>هر سه stream قابلیت خواندن و نوشتن دارند، با این شرایط:</p>
<ul>
<li>هنگام فشرده‌سازی، همیشه روی stream می‌نویسید.</li>
<li>هنگام دیکامپرشن، همیشه از stream می‌خوانید.</li>
</ul>
<p><code>DeflateStream</code>، <code>GZipStream</code> و <code>BrotliStream</code> <strong>decorator</strong> هستند؛ آن‌ها داده‌ها را از stream دیگری که هنگام ساخت ارائه می‌دهید، فشرده یا دیکامپر می‌کنند.</p>
<p>مثال فشرده‌سازی و دیکامپرشن یک سری بایت با استفاده از FileStream:</p>
<pre><code class="language-csharp">using (Stream s = File.Create(&quot;compressed.bin&quot;))
using (Stream ds = new DeflateStream(s, CompressionMode.Compress))
    for (byte i = 0; i &lt; 100; i++)
        ds.WriteByte(i);

using (Stream s = File.OpenRead(&quot;compressed.bin&quot;))
using (Stream ds = new DeflateStream(s, CompressionMode.Decompress))
    for (byte i = 0; i &lt; 100; i++)
        Console.WriteLine(ds.ReadByte()); // 0 تا 99
</code></pre>
<p>با DeflateStream، فایل فشرده 102 بایت است: کمی بزرگتر از اصلی. BrotliStream آن را به 73 بایت فشرده می‌کند. فشرده‌سازی با داده‌های باینری <strong>متراکم و غیرتکراری</strong> ضعیف عمل می‌کند و با داده‌های رمزنگاری شده بدتر است. اما برای فایل‌های متنی عملکرد خوبی دارد.</p>
<p>مثال بعدی: فشرده و دیکامپرشن یک متن 1000 کلمه با الگوریتم Brotli:</p>
<pre><code class="language-csharp">string[] words = &quot;The quick brown fox jumps over the lazy dog&quot;.Split();
Random rand = new Random(0); // برای ثبات
using (Stream s = File.Create(&quot;compressed.bin&quot;))
using (Stream ds = new BrotliStream(s, CompressionMode.Compress))
using (TextWriter w = new StreamWriter(ds))
    for (int i = 0; i &lt; 1000; i++)
        await w.WriteAsync(words[rand.Next(words.Length)] + &quot; &quot;);

Console.WriteLine(new FileInfo(&quot;compressed.bin&quot;).Length); // 808

using (Stream s = File.OpenRead(&quot;compressed.bin&quot;))
using (Stream ds = new BrotliStream(s, CompressionMode.Decompress))
using (TextReader r = new StreamReader(ds))
    Console.Write(await r.ReadToEndAsync());
</code></pre>
<p>در این حالت، BrotliStream به طور مؤثر فایل را به 808 بایت فشرده می‌کند — کمتر از یک بایت برای هر کلمه. (DeflateStream همان داده‌ها را به 885 بایت فشرده می‌کند.)</p>
<hr>
<h3>فشرده‌سازی در حافظه 🧠💨</h3>
<p>گاهی لازم است فشرده‌سازی کاملاً <strong>در حافظه</strong> انجام شود. نمونه با MemoryStream:</p>
<pre><code class="language-csharp">byte[] data = new byte[1000]; // آرایه خالی برای تست فشرده‌سازی
var ms = new MemoryStream();
using (Stream ds = new DeflateStream(ms, CompressionMode.Compress))
    ds.Write(data, 0, data.Length);

byte[] compressed = ms.ToArray();
Console.WriteLine(compressed.Length); // 11

// دیکامپرشن دوباره به آرایه داده:
ms = new MemoryStream(compressed);
using (Stream ds = new DeflateStream(ms, CompressionMode.Decompress))
    for (int i = 0; i &lt; 1000; i += ds.Read(data, i, 1000 - i));
</code></pre>
<p>استفاده از <code>using</code> روی DeflateStream آن را به‌طور استاندارد می‌بندد و هر بافر نوشته‌نشده را Flush می‌کند. این همچنین MemoryStream را می‌بندد، بنابراین برای استخراج داده‌ها باید <code>ToArray</code> را صدا بزنیم.</p>
<p>نسخه جایگزین که <strong>MemoryStream را باز نگه می‌دارد</strong> و از متدهای <strong>آسنکرون</strong> استفاده می‌کند:</p>
<pre><code class="language-csharp">byte[] data = new byte[1000];
MemoryStream ms = new MemoryStream();
using (Stream ds = new DeflateStream(ms, CompressionMode.Compress, true))
    await ds.WriteAsync(data, 0, data.Length);

Console.WriteLine(ms.Length); // 113
ms.Position = 0;
using (Stream ds = new DeflateStream(ms, CompressionMode.Decompress))
    for (int i = 0; i &lt; 1000; i += await ds.ReadAsync(data, i, 1000 - i));
</code></pre>
<p>فلگ اضافی در constructor به DeflateStream می‌گوید که <strong>stream زیرین را در disposal نبندد</strong>. به این ترتیب MemoryStream باز می‌ماند و می‌توانیم آن را دوباره از موقعیت صفر بخوانیم.</p>
<h3>فشرده‌سازی فایل‌ها در Unix با GZip 🐧📦</h3>
<p>الگوریتم فشرده‌سازی <strong>GZipStream</strong> در سیستم‌های Unix به‌عنوان فرمت فشرده‌سازی فایل محبوب است. هر فایل منبع در یک فایل هدف جداگانه با پسوند <code>.gz</code> فشرده می‌شود.</p>
<p>روش‌های زیر همان کار <strong>gzip</strong> و <strong>gunzip</strong> در خط فرمان Unix را انجام می‌دهند:</p>
<pre><code class="language-csharp">async Task GZip(string sourcefile, bool deleteSource = true)
{
    var gzip = $&quot;{sourcefile}.gz&quot;;
    if (File.Exists(gzip))
        throw new Exception(&quot;Gzip file already exists&quot;);
    
    // فشرده‌سازی
    using (FileStream inStream = File.Open(sourcefile, FileMode.Open))
    using (FileStream outStream = new FileStream(gzip, FileMode.CreateNew))
    using (GZipStream gzipStream = new GZipStream(outStream, CompressionMode.Compress))
        await inStream.CopyToAsync(gzipStream); 

    if (deleteSource) File.Delete(sourcefile);
}

async Task GUnzip(string gzipfile, bool deleteGzip = true)
{
    if (Path.GetExtension(gzipfile) != &quot;.gz&quot;)
        throw new Exception(&quot;Not a gzip file&quot;);

    var uncompressedFile = gzipfile.Substring(0, gzipfile.Length - 3);
    if (File.Exists(uncompressedFile))
        throw new Exception(&quot;Destination file already exists&quot;);
    
    // دیکامپرشن
    using (FileStream uncompressToStream = File.Open(uncompressedFile, FileMode.Create))
    using (FileStream zipfileStream = File.Open(gzipfile, FileMode.Open))
    using (var unzipStream = new GZipStream(zipfileStream, CompressionMode.Decompress))
        await unzipStream.CopyToAsync(uncompressToStream);

    if (deleteGzip) File.Delete(gzipfile);
}
</code></pre>
<p>نمونه استفاده:</p>
<pre><code class="language-csharp">await GZip(&quot;/tmp/myfile.txt&quot;);        // ایجاد /tmp/myfile.txt.gz
await GUnzip(&quot;/tmp/myfile.txt.gz&quot;);   // بازسازی /tmp/myfile.txt
</code></pre>
<hr>
<h3>کار با فایل‌های ZIP 🗜️</h3>
<p>کلاس‌های <strong>ZipArchive</strong> و <strong>ZipFile</strong> در <code>System.IO.Compression</code> از فرمت ZIP پشتیبانی می‌کنند. مزیت ZIP نسبت به <strong>DeflateStream</strong> و <strong>GZipStream</strong> این است که:</p>
<ul>
<li>
<p>می‌تواند چندین فایل را در خود جای دهد.</p>
</li>
<li>
<p>با فایل‌های ZIP ایجاد شده توسط Windows Explorer سازگار است.</p>
</li>
<li>
<p><strong>ZipArchive</strong> با streams کار می‌کند.</p>
</li>
<li>
<p><strong>ZipFile</strong> سناریوی معمول کار با فایل‌ها را پوشش می‌دهد و کلاس کمکی است برای ZipArchive.</p>
</li>
</ul>
<p>نمونه استفاده از <strong>CreateFromDirectory</strong> برای افزودن تمام فایل‌های یک دایرکتوری به ZIP:</p>
<pre><code class="language-csharp">ZipFile.CreateFromDirectory(@&quot;d:\MyFolder&quot;, @&quot;d:\archive.zip&quot;);
</code></pre>
<p>برای استخراج ZIP به دایرکتوری:</p>
<pre><code class="language-csharp">ZipFile.ExtractToDirectory(@&quot;d:\archive.zip&quot;, @&quot;d:\MyFolder&quot;);
</code></pre>
<blockquote>
<p>از .NET 8 به بعد می‌توانید به جای مسیر فایل، یک Stream نیز مشخص کنید.</p>
</blockquote>
<p>هنگام فشرده‌سازی، می‌توانید مشخص کنید که بهینه‌سازی برای <strong>حجم فایل یا سرعت</strong> انجام شود و آیا نام دایرکتوری منبع در آرشیو لحاظ شود یا نه.</p>
<p>برای دسترسی به ورودی‌های منفرد ZIP از <strong>Open</strong> استفاده می‌کنیم، که یک <strong>ZipArchive</strong> برمی‌گرداند. می‌توان فایل‌ها را از طریق <strong>Entries</strong> شمارش یا با <strong>GetEntry</strong> به‌صورت خاص یافت:</p>
<pre><code class="language-csharp">using (ZipArchive zip = ZipFile.Open(@&quot;d:\zz.zip&quot;, ZipArchiveMode.Read))
    foreach (ZipArchiveEntry entry in zip.Entries)
        Console.WriteLine(entry.FullName + &quot; &quot; + entry.Length);
</code></pre>
<p><strong>ZipArchiveEntry</strong> همچنین متدهای <code>Delete</code>، <code>ExtractToFile</code> و <code>Open</code> را دارد. برای ایجاد ورودی جدید از <code>CreateEntry</code> یا متد اکستنشن <code>CreateEntryFromFile</code> استفاده می‌کنیم:</p>
<pre><code class="language-csharp">byte[] data = File.ReadAllBytes(@&quot;d:\foo.dll&quot;); 
using (ZipArchive zip = ZipFile.Open(@&quot;d:\zz.zip&quot;, ZipArchiveMode.Update))
    zip.CreateEntry(@&quot;bin\X64\foo.dll&quot;).Open().Write(data, 0, data.Length);
</code></pre>
<p>می‌توان تمام این کارها را کاملاً در حافظه انجام داد با استفاده از <strong>MemoryStream</strong> به جای مسیر فایل.</p>
<hr>
<h3>کار با فایل‌های Tar 📦🐧</h3>
<p>کلاس‌های <code>System.Formats.Tar</code> (.NET 7 به بعد) از فرمت <strong>.tar</strong> پشتیبانی می‌کنند. این فرمت در Unix برای بسته‌بندی چندین فایل محبوب است.</p>
<p>ایجاد یک فایل tar (tarball):</p>
<pre><code class="language-csharp">TarFile.CreateFromDirectory(&quot;/tmp/testfolder&quot;, &quot;/tmp/test.tar&quot;, false);
</code></pre>
<ul>
<li>آرگومان سوم مشخص می‌کند که آیا نام دایرکتوری پایه در ورودی‌های آرشیو لحاظ شود یا خیر.</li>
</ul>
<p>استخراج tarball:</p>
<pre><code class="language-csharp">TarFile.ExtractToDirectory(&quot;/tmp/test.tar&quot;, &quot;/tmp/testfolder&quot;, true);
</code></pre>
<ul>
<li>آرگومان سوم مشخص می‌کند که آیا فایل‌های موجود بازنویسی شوند یا خیر.</li>
</ul>
<p>هر دو متد امکان استفاده از <strong>Stream</strong> به جای مسیر فایل tar را نیز دارند.</p>
<p>نمونه فشرده‌سازی tar به tar.gz با GZipStream:</p>
<pre><code class="language-csharp">var ms = new MemoryStream();
TarFile.CreateFromDirectory(&quot;/tmp/testfolder&quot;, ms, false);
ms.Position = 0;

using (var fs = File.Create(&quot;/tmp/test.tar.gz&quot;))
using (var gz = new GZipStream(fs, CompressionMode.Compress))
    ms.CopyTo(gz);
</code></pre>
<ul>
<li>این کار مفید است چون فرمت tar خودش فشرده‌سازی ندارد، بر خلاف zip.</li>
</ul>
<p>استخراج tar.gz:</p>
<pre><code class="language-csharp">using (var fs = File.OpenRead(&quot;/tmp/test.tar.gz&quot;))
using (var gz = new GZipStream(fs, CompressionMode.Decompress))
    TarFile.ExtractToDirectory(gz, &quot;/tmp/testfolder&quot;, true);
</code></pre>
<p>همچنین می‌توانید با کلاس‌های <strong>TarReader</strong> و <strong>TarWriter</strong> به سطح API دقیق‌تری دسترسی داشته باشید. نمونه استفاده از <strong>TarReader</strong>:</p>
<pre><code class="language-csharp">using (FileStream archiveStream = File.OpenRead(&quot;/tmp/test.tar&quot;))
using (TarReader reader = new(archiveStream))
{
    while (true)
    {
        TarEntry entry = reader.GetNextEntry();
        if (entry == null) break;
        Console.WriteLine($&quot;Entry {entry.Name} is {entry.DataStream.Length} bytes long&quot;);
        entry.ExtractToFile(Path.Combine(&quot;/tmp/testfolder&quot;, entry.Name), true);
    }
}
</code></pre>
<hr>
<h3>عملیات فایل و دایرکتوری 📁⚙️</h3>
<p>فضای نام <code>System.IO</code> مجموعه‌ای از انواع برای انجام عملیات <strong>utility</strong> روی فایل و دایرکتوری ارائه می‌دهد، مانند:</p>
<ul>
<li>کپی و انتقال فایل‌ها</li>
<li>ایجاد دایرکتوری</li>
<li>تنظیم خصوصیات و دسترسی‌های فایل</li>
</ul>
<p>برای اکثر ویژگی‌ها، می‌توانید بین دو کلاس انتخاب کنید:</p>
<ul>
<li><strong>کلاس‌های ایستا (Static):</strong> <code>File</code> و <code>Directory</code></li>
<li><strong>کلاس‌های با متد نمونه:</strong> <code>FileInfo</code> و <code>DirectoryInfo</code> (ساخته شده با نام فایل یا دایرکتوری)</li>
</ul>
<p>علاوه بر این، کلاس ایستای <strong>Path</strong> وجود دارد که هیچ عملی روی فایل یا دایرکتوری انجام نمی‌دهد؛ بلکه متدهایی برای <strong>دستکاری رشته مسیرها و نام فایل‌ها</strong> ارائه می‌کند و همچنین با فایل‌های موقت کمک می‌کند.</p>
<h3>کلاس File 📁💻</h3>
<p>کلاس <strong>File</strong> یک کلاس ایستا (static) است که تمام متدهای آن یک <strong>نام فایل</strong> می‌گیرند. نام فایل می‌تواند نسبی به دایرکتوری جاری یا کامل با مسیر دایرکتوری باشد. متدهای این کلاس (تمامی <strong>public</strong> و <strong>static</strong>) عبارت‌اند از:</p>
<pre><code class="language-csharp">bool Exists(string path);                 // اگر فایل موجود باشد true برمی‌گرداند
void Delete(string path);                 
void Copy(string sourceFileName, string destFileName);
void Move(string sourceFileName, string destFileName);
void Replace(string sourceFileName, string destinationFileName,
             string destinationBackupFileName);
FileAttributes GetAttributes(string path);
void SetAttributes(string path, FileAttributes fileAttributes);
void Decrypt(string path);
void Encrypt(string path);
DateTime GetCreationTime(string path);      // نسخه UTC نیز وجود دارد
DateTime GetLastAccessTime(string path);    // نسخه UTC نیز وجود دارد
DateTime GetLastWriteTime(string path);
void SetCreationTime(string path, DateTime creationTime);
void SetLastAccessTime(string path, DateTime lastAccessTime);
void SetLastWriteTime(string path, DateTime lastWriteTime);
FileSecurity GetAccessControl(string path);
FileSecurity GetAccessControl(string path, AccessControlSections includeSections);
void SetAccessControl(string path, FileSecurity fileSecurity);
</code></pre>
<ul>
<li>متد <strong>Move</strong> اگر فایل مقصد وجود داشته باشد استثنا می‌اندازد؛ اما <strong>Replace</strong> این کار را نمی‌کند.</li>
<li>هر دو متد امکان تغییر نام فایل یا انتقال آن به دایرکتوری دیگر را فراهم می‌کنند.</li>
<li><strong>Delete</strong> اگر فایل <strong>read-only</strong> باشد یا مجوز حذف توسط سیستم‌عامل به فرآیند شما داده نشده باشد، استثنا <code>UnauthorizedAccessException</code> پرتاب می‌کند.</li>
</ul>
<p>تمام اعضای <strong>FileAttributes</strong> که توسط <code>GetAttributes</code> برگردانده می‌شوند:</p>
<pre><code>Archive, Compressed, Device, Directory, Encrypted,
Hidden, IntegritySystem, Normal, NoScrubData, NotContentIndexed, 
Offline, ReadOnly, ReparsePoint, SparseFile, System, Temporary
</code></pre>
<p>این اعضا قابل ترکیب هستند. برای تغییر یک ویژگی فایل بدون تغییر سایر ویژگی‌ها:</p>
<pre><code class="language-csharp">string filePath = &quot;test.txt&quot;;
FileAttributes fa = File.GetAttributes(filePath);
if ((fa &amp; FileAttributes.ReadOnly) != 0)
{
    // از عملگر XOR (^) برای تغییر پرچم ReadOnly استفاده می‌کنیم
    fa ^= FileAttributes.ReadOnly;
    File.SetAttributes(filePath, fa);
}

// حالا می‌توانیم فایل را حذف کنیم
File.Delete(filePath);
</code></pre>
<p>راه ساده‌تر با <strong>FileInfo</strong>:</p>
<pre><code class="language-csharp">new FileInfo(&quot;test.txt&quot;).IsReadOnly = false;
</code></pre>
<hr>
<h3>ویژگی‌های فشرده‌سازی و رمزگذاری 🔒🗜️</h3>
<p>این قابلیت تنها در <strong>Windows</strong> موجود است و نیازمند پکیج NuGet <code>System.Management</code> است.</p>
<ul>
<li>ویژگی‌های <strong>Compressed</strong> و <strong>Encrypted</strong> متناظر با چک‌باکس‌های فشرده‌سازی و رمزگذاری در پنجره Properties فایل یا دایرکتوری در Windows Explorer هستند.</li>
<li>این نوع فشرده‌سازی و رمزگذاری <strong>شفاف</strong> است؛ به طوری که سیستم‌عامل تمام عملیات را انجام می‌دهد و شما می‌توانید داده‌ها را به صورت plain بخوانید و بنویسید.</li>
<li>نمی‌توان با <code>SetAttributes</code> ویژگی‌های <strong>Compressed</strong> یا <strong>Encrypted</strong> را تغییر داد (اگر تلاش کنید، بدون خطا شکست می‌خورد).</li>
</ul>
<p>راه حل: برای رمزگذاری و رمزگشایی از متدهای <code>Encrypt()</code> و <code>Decrypt()</code> در کلاس <strong>File</strong> استفاده کنید.
برای فشرده‌سازی، استفاده از WMI در <code>System.Management</code> راه حل است:</p>
<pre><code class="language-csharp">static uint CompressFolder(string folder, bool recursive)
{
    string path = &quot;Win32_Directory.Name='&quot; + folder + &quot;'&quot;;
    using (ManagementObject dir = new ManagementObject(path))
    using (ManagementBaseObject p = dir.GetMethodParameters(&quot;CompressEx&quot;))
    {
        p[&quot;Recursive&quot;] = recursive;
        using (ManagementBaseObject result = dir.InvokeMethod(&quot;CompressEx&quot;, p, null))
            return (uint)result.Properties[&quot;ReturnValue&quot;].Value;
    }
}
</code></pre>
<ul>
<li>برای استخراج، <code>CompressEx</code> را با <code>UncompressEx</code> جایگزین کنید.</li>
</ul>
<p><strong>رمزگذاری شفاف</strong> بر پایه کلیدی ساخته شده از رمز عبور کاربر لاگین شده است. تغییر رمز عبور توسط کاربر معتبر مشکلی ایجاد نمی‌کند، اما اگر رمز توسط مدیر ریست شود، داده‌های فایل‌های رمزگذاری‌شده قابل بازیابی نخواهند بود.</p>
<p><strong>NTFS</strong> این قابلیت‌ها را پشتیبانی می‌کند؛ اما <strong>CDFS</strong> (روی CD-ROM) و <strong>FAT</strong> (روی کارت‌های قابل حمل) پشتیبانی نمی‌کنند.</p>
<p>برای تشخیص پشتیبانی یک حجم از فشرده‌سازی و رمزگذاری:</p>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Text;
using System.ComponentModel;
using System.Runtime.InteropServices;

class SupportsCompressionEncryption
{
    const int SupportsCompression = 0x10;
    const int SupportsEncryption = 0x20000;

    [DllImport(&quot;Kernel32.dll&quot;, SetLastError = true)]
    extern static bool GetVolumeInformation(string vol, StringBuilder name,
        int nameSize, out uint serialNum, out uint maxNameLen, out uint flags,
        StringBuilder fileSysName, int fileSysNameSize);

    static void Main()
    {
        uint serialNum, maxNameLen, flags;
        bool ok = GetVolumeInformation(@&quot;C:\&quot;, null, 0, out serialNum,
                                       out maxNameLen, out flags, null, 0);
        if (!ok) throw new Win32Exception();

        bool canCompress = (flags &amp; SupportsCompression) != 0;
        bool canEncrypt = (flags &amp; SupportsEncryption) != 0;
    }
}
</code></pre>
<hr>
<h3>امنیت فایل در Windows 🔐</h3>
<p>این ویژگی نیز <strong>ویندوزی</strong> است و نیازمند پکیج NuGet <code>System.IO.FileSystem.AccessControl</code> می‌باشد.</p>
<p>کلاس <strong>FileSecurity</strong> اجازه می‌دهد مجوزهای سیستم‌عامل را برای کاربران و نقش‌ها مشاهده و تغییر دهید:</p>
<pre><code class="language-csharp">using System;
using System.IO;
using System.Security.AccessControl;
using System.Security.Principal;

void ShowSecurity(FileSecurity sec)
{
    AuthorizationRuleCollection rules = sec.GetAccessRules(true, true, typeof(NTAccount));
    foreach (FileSystemAccessRule r in rules.Cast&lt;FileSystemAccessRule&gt;()
        .OrderBy(rule =&gt; rule.IdentityReference.Value))
    {
        Console.WriteLine($&quot;  {r.IdentityReference.Value}&quot;);  // مثال: MyDomain/Joe
        Console.WriteLine($&quot;    {r.FileSystemRights}: {r.AccessControlType}&quot;); // FullControl
    }
}

var file = &quot;sectest.txt&quot;;
File.WriteAllText(file, &quot;File security test.&quot;);

var sid = new SecurityIdentifier(WellKnownSidType.BuiltinUsersSid, null);
string usersAccount = sid.Translate(typeof(NTAccount)).ToString();
Console.WriteLine($&quot;User: {usersAccount}&quot;);

FileSecurity sec = new FileSecurity(file,
    AccessControlSections.Owner |
    AccessControlSections.Group |
    AccessControlSections.Access);

Console.WriteLine(&quot;AFTER CREATE:&quot;);
ShowSecurity(sec); // BUILTIN\Users هنوز دسترسی Write ندارد

sec.ModifyAccessRule(AccessControlModification.Add,
    new FileSystemAccessRule(usersAccount, FileSystemRights.Write, AccessControlType.Allow),
    out bool modified);

Console.WriteLine(&quot;AFTER MODIFY:&quot;);
ShowSecurity(sec); // BUILTIN\Users اکنون دسترسی Write دارد
</code></pre>
<p>مثال‌های بیشتری در بخش <strong>Special Folders</strong> صفحه 730 ارائه شده است.</p>
<hr>
<h3>امنیت فایل در Unix 🐧</h3>
<p>از <strong>.NET 7</strong> به بعد، کلاس <strong>File</strong> شامل متدهای <strong>GetUnixFileMode</strong> و <strong>SetUnixFileMode</strong> برای گرفتن و تعیین مجوز فایل‌ها در Unix است.</p>
<p>همچنین متد <strong>Directory.CreateDirectory</strong> اورلود شده تا بتواند مجوز Unix را بپذیرد، و هنگام ایجاد فایل می‌توان مجوز را مشخص کرد:</p>
<pre><code class="language-csharp">var fs = new FileStream(&quot;test.txt&quot;,
    new FileStreamOptions
    {
        Mode = FileMode.Create,
        UnixCreateMode = UnixFileMode.UserRead | UnixFileMode.UserWrite
    });
</code></pre>
<h3>کلاس Directory 📂💻</h3>
<p>کلاس <strong>Directory</strong> یک کلاس ایستا (static) است که مجموعه‌ای از متدها مشابه کلاس <strong>File</strong> ارائه می‌دهد، از جمله: بررسی وجود دایرکتوری (<code>Exists</code>)، جابجایی (<code>Move</code>)، حذف (<code>Delete</code>)، دریافت/تنظیم زمان ایجاد یا آخرین دسترسی، و دریافت/تنظیم مجوزهای امنیتی.</p>
<p>متدهای مهم آن عبارت‌اند از:</p>
<pre><code class="language-csharp">string GetCurrentDirectory();                 // دایرکتوری جاری
void   SetCurrentDirectory(string path);     // تنظیم دایرکتوری جاری
DirectoryInfo CreateDirectory(string path);  // ایجاد دایرکتوری
DirectoryInfo GetParent(string path);        // دایرکتوری والد
string GetDirectoryRoot(string path);        // ریشه دایرکتوری
string[] GetLogicalDrives();                 // درایوها یا mount points در Unix

// بازگرداندن مسیرهای کامل
string[] GetFiles(string path);
string[] GetDirectories(string path);
string[] GetFileSystemEntries(string path);
IEnumerable&lt;string&gt; EnumerateFiles(string path);
IEnumerable&lt;string&gt; EnumerateDirectories(string path);
IEnumerable&lt;string&gt; EnumerateFileSystemEntries(string path);
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>متدهای <code>Enumerate*</code> به صورت <strong>lazy</strong> عمل می‌کنند و داده‌ها را هنگام پیمایش از سیستم فایل دریافت می‌کنند، بنابراین برای <strong>LINQ</strong> بسیار مناسب هستند.</li>
<li>این متدها می‌توانند آرگومان‌های <code>searchPattern</code> و <code>searchOption</code> بگیرند و با <code>SearchOption.SearchAllSubDirectories</code> جستجوی بازگشتی انجام دهند.</li>
<li>متدهای <code>*FileSystemEntries</code> ترکیبی از فایل‌ها و دایرکتوری‌ها هستند.</li>
</ul>
<p>ایجاد یک دایرکتوری تنها در صورت عدم وجود:</p>
<pre><code class="language-csharp">if (!Directory.Exists(@&quot;d:\test&quot;))
    Directory.CreateDirectory(@&quot;d:\test&quot;);
</code></pre>
<hr>
<h3>FileInfo و DirectoryInfo 📝</h3>
<p>متدهای ایستا برای عملیات یکباره مناسب هستند، اما اگر نیاز به مجموعه‌ای از عملیات پشت سر هم دارید، استفاده از کلاس‌های <strong>FileInfo</strong> و <strong>DirectoryInfo</strong> راحت‌تر است.</p>
<ul>
<li><strong>FileInfo</strong> اکثر متدهای کلاس <strong>File</strong> را به صورت instance ارائه می‌دهد و ویژگی‌های اضافی مثل <code>Extension</code>، <code>Length</code>، <code>IsReadOnly</code> و <code>Directory</code> دارد:</li>
</ul>
<pre><code class="language-csharp">static string TestDirectory =&gt;
    RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
        ? @&quot;C:\Temp&quot; 
        : &quot;/tmp&quot;;

Directory.CreateDirectory(TestDirectory);
FileInfo fi = new FileInfo(Path.Combine(TestDirectory, &quot;FileInfo.txt&quot;));

Console.WriteLine(fi.Exists);          // false
using (TextWriter w = fi.CreateText())
    w.Write(&quot;Some text&quot;);

fi.Refresh();
Console.WriteLine(fi.Exists);          // true
Console.WriteLine(fi.Name);            // FileInfo.txt
Console.WriteLine(fi.FullName);        // c:\temp\FileInfo.txt (Windows) یا /tmp/FileInfo.txt (Unix)
Console.WriteLine(fi.DirectoryName);   // c:\temp یا /tmp
Console.WriteLine(fi.Directory.Name);  // temp
Console.WriteLine(fi.Extension);       // .txt
Console.WriteLine(fi.Length);          // 9
fi.Encrypt();
fi.Attributes ^= FileAttributes.Hidden; // تغییر پرچم Hidden
fi.IsReadOnly = true;
Console.WriteLine(fi.Attributes);      // ReadOnly, Archive, Hidden, Encrypted
Console.WriteLine(fi.CreationTime);   // زمان ایجاد
fi.MoveTo(Path.Combine(TestDirectory, &quot;FileInfoX.txt&quot;)); 
</code></pre>
<ul>
<li><strong>DirectoryInfo</strong> برای پیمایش دایرکتوری‌ها و فایل‌ها مناسب است:</li>
</ul>
<pre><code class="language-csharp">DirectoryInfo di = new DirectoryInfo(@&quot;e:\photos&quot;);

foreach (FileInfo fi in di.GetFiles(&quot;*.jpg&quot;))
    Console.WriteLine(fi.Name);

foreach (DirectoryInfo subDir in di.GetDirectories())
    Console.WriteLine(subDir.FullName);
</code></pre>
<hr>
<h3>کلاس Path 🛤️</h3>
<p>کلاس <strong>Path</strong> به صورت ایستا متدها و فیلدهایی برای کار با مسیرها و نام فایل‌ها ارائه می‌دهد.</p>
<p>مثال:</p>
<pre><code class="language-csharp">string dir  = @&quot;c:\mydir&quot;;    // یا /mydir
string file = &quot;myfile.txt&quot;;
string path = @&quot;c:\mydir\myfile.txt&quot;;    // یا /mydir/myfile.txt
Directory.SetCurrentDirectory(@&quot;k:\demo&quot;);  // یا /demo
</code></pre>
<p>با این setup می‌توان از متدهای کلاس <strong>Path</strong> برای دستکاری رشته‌های مسیر و نام فایل استفاده کرد، مانند ترکیب مسیر، استخراج نام فایل، استخراج پسوند، و غیره.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-9.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>متدهای کلاس Path و مدیریت پوشه‌های ویژه 🛤️📁</h3>
<h4>۱. <strong>Path.Combine</strong></h4>
<p>متد <strong>Combine</strong> بسیار مفید است؛ زیرا به شما امکان می‌دهد یک دایرکتوری و نام فایل یا دو دایرکتوری را بدون بررسی وجود یا نبودن جداکننده مسیر ترکیب کنید.</p>
<ul>
<li>به‌طور خودکار جداکننده مناسب سیستم عامل را استفاده می‌کند.</li>
<li>اورلودهایی دارد که تا چهار مسیر یا نام فایل را می‌پذیرد.</li>
</ul>
<h4>۲. <strong>GetFullPath</strong></h4>
<p>تبدیل مسیر نسبی به مسیر کامل (Absolute).</p>
<pre><code class="language-csharp">string fullPath = Path.GetFullPath(@&quot;..\..\file.txt&quot;);
</code></pre>
<h4>۳. <strong>GetRandomFileName و GetTempFileName</strong></h4>
<ul>
<li><code>GetRandomFileName</code> نام فایل ۸.۳ منحصر به‌فرد تولید می‌کند بدون ایجاد فایل واقعی.</li>
<li><code>GetTempFileName</code> نام فایل موقت ایجاد می‌کند و فایل صفر بایتی در دایرکتوری temp می‌سازد.
⚠️ پس از استفاده باید آن را حذف کنید، در غیر این صورت پس از ۶۵۰۰۰ بار فراخوانی استثنا ایجاد می‌شود.</li>
</ul>
<p>اگر مشکل ایجاد شد، می‌توان از ترکیب <code>GetTempPath</code> با <code>GetRandomFileName</code> استفاده کرد، اما مراقب پر شدن هارد باشید.</p>
<hr>
<h3>پوشه‌های ویژه (Special Folders) 🌟</h3>
<p>کلاس <strong>Path</strong> و <strong>Directory</strong> پوشه‌های ویژه مثل <strong>My Documents</strong> یا <strong>Program Files</strong> را پوشش نمی‌دهند. برای این کار از:</p>
<pre><code class="language-csharp">string myDocPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
</code></pre>
<ul>
<li><code>Environment.SpecialFolder</code> یک enum است که تمام پوشه‌های ویژه ویندوز را شامل می‌شود: AdminTools, ApplicationData, Fonts, StartMenu و غیره.</li>
<li>مسیر runtime دات‌نت با:</li>
</ul>
<pre><code class="language-csharp">System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()
</code></pre>
<h4>نکات مهم در ویندوز</h4>
<ul>
<li><strong>ApplicationData:</strong> داده‌های کاربر که در شبکه منتقل می‌شوند (روامینگ).</li>
<li><strong>LocalApplicationData:</strong> داده‌های محلی کاربر، بدون رامینگ.</li>
<li><strong>CommonApplicationData:</strong> داده‌های مشترک بین کاربران.</li>
</ul>
<p>رعایت استاندارد: ایجاد یک زیرپوشه با نام برنامه شما برای ذخیره‌سازی داده‌ها.</p>
<pre><code class="language-csharp">string localAppDataPath = Path.Combine(
    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
    &quot;MyCoolApplication&quot;
);
if (!Directory.Exists(localAppDataPath))
    Directory.CreateDirectory(localAppDataPath);
</code></pre>
<p>⚠️ نکته: اگر برنامه با سطح دسترسی مدیر اجرا شود و پوشه‌ها در <code>CommonApplicationData</code> ایجاد شوند، کاربران با دسترسی محدود ممکن است نتوانند فایل‌ها را بعداً تغییر دهند. راه‌حل: ایجاد پوشه‌ها با مجوز مناسب در فرآیند نصب.</p>
<hr>
<h3>Querying Volume Information 💽</h3>
<p>برای دریافت اطلاعات درایوها از <strong>DriveInfo</strong> استفاده می‌کنیم:</p>
<pre><code class="language-csharp">DriveInfo c = new DriveInfo(&quot;C&quot;); // یا &quot;/&quot; در Unix
long totalSize = c.TotalSize;
long freeBytes = c.TotalFreeSpace;
long freeToMe  = c.AvailableFreeSpace;

foreach (DriveInfo d in DriveInfo.GetDrives())
{
    Console.WriteLine(d.Name);          // C:\
    Console.WriteLine(d.DriveType);     // Fixed
    Console.WriteLine(d.RootDirectory); // C:\
    if (d.IsReady)
    {
        Console.WriteLine(d.VolumeLabel); // برچسب درایو
        Console.WriteLine(d.DriveFormat); // NTFS, FAT و غیره
    }
}
</code></pre>
<ul>
<li><code>GetDrives</code> همه درایوهای تعریف‌شده، شامل CD-ROM، کارت حافظه و شبکه را بازمی‌گرداند.</li>
<li><code>DriveType</code> enum: <code>Unknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram</code>.</li>
</ul>
<hr>
<h3>مانیتور کردن تغییرات فایل و دایرکتوری با FileSystemWatcher 🔔</h3>
<ul>
<li><strong>FileSystemWatcher</strong> امکان مانیتور کردن یک دایرکتوری و زیرشاخه‌های آن برای فعالیت‌ها را فراهم می‌کند.</li>
<li>رویدادهایی دارد که هنگام ایجاد، تغییر، حذف، تغییر نام یا تغییر ویژگی فایل/دایرکتوری فعال می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">Watch(GetTestDirectory(), &quot;*.txt&quot;, true);

void Watch(string path, string filter, bool includeSubDirs)
{
    using var watcher = new FileSystemWatcher(path, filter);
    watcher.Created += FileCreatedChangedDeleted;
    watcher.Changed += FileCreatedChangedDeleted;
    watcher.Deleted += FileCreatedChangedDeleted;
    watcher.Renamed += FileRenamed;
    watcher.Error   += FileError;
    watcher.IncludeSubdirectories = includeSubDirs;
    watcher.EnableRaisingEvents = true;

    Console.WriteLine(&quot;Listening for events - press &lt;enter&gt; to end&quot;);
    Console.ReadLine();
}

void FileCreatedChangedDeleted(object o, FileSystemEventArgs e)
    =&gt; Console.WriteLine(&quot;File {0} has been {1}&quot;, e.FullPath, e.ChangeType);

void FileRenamed(object o, RenamedEventArgs e)
    =&gt; Console.WriteLine(&quot;Renamed: {0}-&gt;{1}&quot;, e.OldFullPath, e.FullPath);

void FileError(object o, ErrorEventArgs e)
    =&gt; Console.WriteLine(&quot;Error: &quot; + e.GetException().Message);

string GetTestDirectory() =&gt;
    RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? @&quot;C:\Temp&quot; : &quot;/tmp&quot;;
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>رویدادها در یک <strong>Thread جداگانه</strong> اجرا می‌شوند، بنابراین باید مدیریت استثنا داشته باشید.</li>
<li>رویداد <code>Error</code> نشان‌دهنده overflow بافر داخلی است. با <code>InternalBufferSize</code> می‌توان بافر را تغییر داد.</li>
<li><code>IncludeSubdirectories</code> به صورت بازگشتی اعمال می‌شود.</li>
<li>مراقب باشید فایل‌ها را قبل از اینکه کاملاً نوشته شوند، باز نکنید؛ ممکن است نیاز به استراتژی‌هایی مثل نوشتن با پسوند موقت و تغییر نام بعد از تکمیل داشته باشید.</li>
</ul>
<h3>امنیت سیستم‌عامل (OS Security) 🛡️</h3>
<p>همه برنامه‌ها تحت محدودیت‌های سیستم‌عامل اجرا می‌شوند و این محدودیت‌ها بر اساس سطح دسترسی کاربر اعمال می‌شوند. این محدودیت‌ها علاوه بر I/O فایل، بر دسترسی به منابع دیگر مثل <strong>Windows Registry</strong> هم تأثیر دارند.</p>
<hr>
<h4>۱. <strong>انواع حساب کاربری</strong></h4>
<ul>
<li><strong>حساب کاربری ادمین / سوپر یوزر:</strong> بدون محدودیت در دسترسی به کامپیوتر محلی.</li>
<li><strong>حساب با دسترسی محدود:</strong> عملکردهای مدیریتی محدود و دسترسی به داده‌های دیگر کاربران محدود است.</li>
</ul>
<p>در ویندوز، ویژگی <strong>User Account Control (UAC)</strong> باعث می‌شود هنگام ورود، مدیر سیستم دو توکن یا “کلاه” داشته باشد:</p>
<ol>
<li>کلاه مدیر (Administrative)</li>
<li>کلاه کاربر عادی (Ordinary User)</li>
</ol>
<p>به‌طور پیش‌فرض برنامه‌ها با کلاه کاربر عادی اجرا می‌شوند مگر اینکه درخواست دسترسی مدیریتی کنند و کاربر آن را تأیید کند.</p>
<p>در Unix، کاربران معمولاً با حساب محدود وارد می‌شوند و برای اجرای دستورات با دسترسی بالا از <code>sudo</code> استفاده می‌کنند.</p>
<hr>
<h4>۲. <strong>اجرای برنامه با دسترسی محدود</strong></h4>
<ul>
<li>
<p>به‌طور پیش‌فرض، برنامه‌ها با محدودیت کاربر اجرا می‌شوند. بنابراین باید:</p>
<ol>
<li>برنامه را طوری طراحی کنید که بدون دسترسی مدیر کار کند (<strong>گزینه ایمن‌تر و راحت‌تر</strong>)</li>
<li>یا دسترسی مدیریتی را از طریق <strong>Application Manifest</strong> درخواست کنید (ویندوز)</li>
</ol>
</li>
</ul>
<p>برای تشخیص اینکه برنامه با دسترسی مدیر اجرا می‌شود:</p>
<pre><code class="language-csharp">[DllImport(&quot;libc&quot;)]
public static extern uint getuid();

static bool IsRunningAsAdmin()
{
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        using var identity = WindowsIdentity.GetCurrent();
        var principal = new WindowsPrincipal(identity);
        return principal.IsInRole(WindowsBuiltInRole.Administrator);
    }
    return getuid() == 0;
}
</code></pre>
<ul>
<li>در ویندوز، فقط در صورت فعال بودن UAC و Elevation، مقدار true برمی‌گردد.</li>
<li>در لینوکس، true فقط وقتی فرآیند با sudo اجرا شود.</li>
</ul>
<hr>
<h4>۳. <strong>محدودیت‌های حساب کاربر عادی</strong></h4>
<p>کارهایی که نمی‌توان با حساب عادی انجام داد:</p>
<ul>
<li>نوشتن در پوشه‌های سیستم (مثلاً <code>\Windows</code> یا <code>/bin, /sbin</code>) و زیرشاخه‌ها</li>
<li>نوشتن در پوشه Program Files یا <code>/usr/bin, /opt</code></li>
<li>نوشتن در ریشه درایو سیستم (<code>C:\</code> یا <code>/</code>)</li>
<li>نوشتن در شاخه <code>HKEY_LOCAL_MACHINE</code> در Registry ویندوز</li>
<li>خواندن داده‌های Performance Monitoring (WMI در ویندوز)</li>
</ul>
<p>همچنین ممکن است دسترسی به فایل‌ها یا منابع دیگر کاربران محدود باشد. ویندوز از <strong>Access Control List (ACL)</strong> برای محافظت استفاده می‌کند و اگر دسترسی رد شود، CLR استثنای <strong>UnauthorizedAccessException</strong> پرتاب می‌کند.</p>
<p><strong>راهکار مقابله با محدودیت‌ها:</strong></p>
<ul>
<li>فایل‌ها را در مکان‌های توصیه‌شده کاربر ذخیره کنید.</li>
<li>از Registry فقط برای HKEY_CURRENT_USER استفاده کنید.</li>
<li>کامپوننت‌های ActiveX یا COM را در فرآیند نصب ثبت کنید.</li>
</ul>
<hr>
<h4>۴. <strong>مکان‌های پیشنهادی ذخیره‌سازی فایل‌ها</strong></h4>
<pre><code class="language-csharp">string docsFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
string path = Path.Combine(docsFolder, &quot;test.txt&quot;);

string configFolder = Path.Combine(
    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), // برای کاربر فعلی
    &quot;MyApp&quot;
);
if (!Directory.Exists(configFolder))
    Directory.CreateDirectory(configFolder);
</code></pre>
<p>⚠️ توجه: استفاده از <code>CommonApplicationData</code> برای دسترسی همه کاربران، باید با تنظیم مجوزها همراه باشد.</p>
<hr>
<h4>۵. <strong>Elevation مدیریتی و Virtualization ویندوز</strong></h4>
<p>با <strong>Application Manifest</strong> می‌توانید درخواست دسترسی مدیر کنید:</p>
<pre><code class="language-xml">&lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; /&gt;
</code></pre>
<ul>
<li><code>asInvoker</code>: برنامه بدون دسترسی مدیر اجرا شود و Virtualization غیرفعال است.</li>
</ul>
<p><strong>Virtualization:</strong> تغییرات در پوشه Program Files یا Windows و HKEY_LOCAL_MACHINE به مکان جداگانه هدایت می‌شود تا از آسیب به سیستم جلوگیری شود.</p>
<hr>
<h4>۶. <strong>Memory-Mapped Files</strong> 🗄️</h4>
<p>مزایا:</p>
<ol>
<li>دسترسی سریع و تصادفی به داده‌های فایل</li>
<li>اشتراک حافظه بین فرآیندهای مختلف</li>
</ol>
<p>در دات‌نت از <strong>System.IO.MemoryMappedFiles</strong> استفاده می‌کنیم که در واقع API سیستم‌عامل برای Memory-Mapped Files را پوشش می‌دهد.</p>
<h3>فایل‌های Memory-Mapped و دسترسی تصادفی به فایل 🗂️💨</h3>
<p>Memory-mapped files برای دسترسی <strong>تصادفی و سریع</strong> به داده‌های فایل و همچنین اشتراک حافظه بین فرآیندها استفاده می‌شوند. در مقایسه با FileStream:</p>
<table>
<thead>
<tr>
<th>نوع دسترسی</th>
<th>FileStream</th>
<th>Memory-Mapped File</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sequential (متوالی)</td>
<td>سریع‌تر (~10×)</td>
<td>کندتر</td>
</tr>
<tr>
<td>Random (تصادفی)</td>
<td>کندتر</td>
<td>سریع‌تر (~10×)</td>
</tr>
</tbody>
</table>
<hr>
<h4>۱. ایجاد یک Memory-Mapped File</h4>
<ol>
<li>یک <code>FileStream</code> معمولی بسازید.</li>
<li>یک <code>MemoryMappedFile</code> بسازید و فایل را به آن بدهید.</li>
<li>از <code>CreateViewAccessor</code> برای ایجاد <strong>View Accessor</strong> استفاده کنید.</li>
</ol>
<pre><code class="language-csharp">File.WriteAllBytes(&quot;long.bin&quot;, new byte[1_000_000]);
using MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(&quot;long.bin&quot;);
using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();

accessor.Write(500_000, (byte)77);
Console.WriteLine(accessor.ReadByte(500_000));  // 77
</code></pre>
<ul>
<li>می‌توان نام Map و ظرفیت مشخص کرد تا حافظه به اشتراک گذاشته شود یا اندازه فایل بزرگ‌تر شود.</li>
</ul>
<hr>
<h4>۲. اشتراک حافظه بین فرآیندها (Windows)</h4>
<ul>
<li>یک فرآیند <code>MemoryMappedFile.CreateNew</code> ایجاد می‌کند.</li>
<li>فرآیندهای دیگر با <code>OpenExisting</code> به همان حافظه دسترسی دارند.</li>
</ul>
<pre><code class="language-csharp">// Writer
using var mmFile = MemoryMappedFile.CreateNew(&quot;Demo&quot;, 500);
using var accessor = mmFile.CreateViewAccessor();
accessor.Write(0, 12345);
Console.ReadLine(); // حافظه را زنده نگه می‌دارد

// Reader (فرآیند دیگر)
using var mmFile = MemoryMappedFile.OpenExisting(&quot;Demo&quot;);
using var accessor = mmFile.CreateViewAccessor();
Console.WriteLine(accessor.ReadInt32(0)); // 12345
</code></pre>
<hr>
<h4>۳. اشتراک حافظه بین فرآیندها در Windows و Unix</h4>
<ul>
<li>فایل را با <code>FileStream</code> باز کنید و اجازه خواندن/نوشتن مشترک بدهید (<code>FileShare.ReadWrite</code>).</li>
<li>سپس <code>MemoryMappedFile.CreateFromFile</code> بسازید.</li>
</ul>
<pre><code class="language-csharp">var file = Path.Combine(TestDirectory, &quot;interprocess.bin&quot;);
File.WriteAllBytes(file, new byte[100]);

using FileStream fs = new FileStream(file, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);
using MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(fs, null, fs.Length, MemoryMappedFileAccess.ReadWrite, HandleInheritability.None, true);
using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();
accessor.Write(0, 12345);
Console.ReadLine();
File.Delete(file);
</code></pre>
<hr>
<h4>۴. کار با View Accessor</h4>
<ul>
<li><code>Read*</code> و <code>Write*</code> برای <strong>نوع‌های عددی، bool، char</strong> و آرایه‌ها/structهای Value Type استفاده می‌شوند.</li>
<li>برای رشته‌ها، باید ابتدا آن‌ها را به آرایه بایت تبدیل کنید.</li>
</ul>
<pre><code class="language-csharp">byte[] data = Encoding.UTF8.GetBytes(&quot;This is a test&quot;);
accessor.Write(0, data.Length);
accessor.WriteArray(4, data, 0, data.Length);

// خواندن مجدد
byte[] readData = new byte[accessor.ReadInt32(0)];
accessor.ReadArray(4, readData, 0, readData.Length);
Console.WriteLine(Encoding.UTF8.GetString(readData)); // This is a test
</code></pre>
<ul>
<li>کار با struct:</li>
</ul>
<pre><code class="language-csharp">struct Data { public int X, Y; }
var data = new Data { X = 123, Y = 456 };
accessor.Write(0, ref data);
accessor.Read(0, out data);
Console.WriteLine(data.X + &quot; &quot; + data.Y); // 123 456
</code></pre>
<hr>
<h4>۵. بهینه‌سازی عملکرد با اشاره‌گرها (Unsafe)</h4>
<ul>
<li>استفاده از <code>SafeMemoryMappedViewHandle.AcquirePointer</code> بسیار سریع‌تر از <code>Read/Write</code> است، مخصوصاً برای داده‌های بزرگ:</li>
</ul>
<pre><code class="language-csharp">unsafe
{
    byte* pointer = null;
    try
    {
        accessor.SafeMemoryMappedViewHandle.AcquirePointer(ref pointer);
        int* intPointer = (int*)pointer;
        Console.WriteLine(*intPointer); // 123
    }
    finally
    {
        if (pointer != null)
            accessor.SafeMemoryMappedViewHandle.ReleasePointer();
    }
}
</code></pre>
<ul>
<li>نیاز به فعال کردن unsafe code در فایل <code>.csproj</code>:</li>
</ul>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
  &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>دلیل اصلی برتری عملکرد استفاده از <strong>اشاره‌گرها (pointers)</strong> وقتی با ساختارهای بزرگ کار می‌کنیم این است که اشاره‌گرها اجازه می‌دهند مستقیماً با داده‌های خام (raw data) کار کنیم، بدون اینکه مجبور باشیم از متدهای <code>Read</code> و <code>Write</code> برای کپی کردن داده‌ها بین حافظه <strong>مدیریت‌شده (managed)</strong> و <strong>مدیریت‌نشده (unmanaged)</strong> استفاده کنیم.</p>
<p>این کار باعث صرفه‌جویی قابل‌توجهی در زمان و منابع می‌شود، به‌ویژه وقتی حجم داده‌ها زیاد باشد. این موضوع در <strong>فصل ۲۴</strong> کتاب به‌طور کامل بررسی شده است.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
