<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل چهاردهم: هم‌زمانی و ناهم‌زمانی</h1>
<p>بیشتر برنامه‌ها نیاز دارند با بیش از یک رویداد که به‌طور هم‌زمان رخ می‌دهد سروکار داشته باشند (هم‌زمانی یا <strong>Concurrency</strong>).
در این فصل، ما با پیش‌نیازهای ضروری شروع می‌کنیم، یعنی مبانی <strong>Threading</strong> (ایجاد و مدیریت رشته‌ها) و <strong>Tasks</strong> (وظایف)، و سپس اصول <strong>Asynchrony</strong> (ناهم‌زمانی) و توابع ناهم‌زمان در #C را با جزئیات توضیح می‌دهیم.</p>
<p>در <strong>فصل ۲۱</strong> دوباره به موضوع <strong>Multithreading</strong> (چند‌رشته‌ای) با جزئیات بیشتر برمی‌گردیم و در <strong>فصل ۲۲</strong> موضوع مرتبط یعنی <strong>Parallel Programming</strong> (برنامه‌نویسی موازی) را پوشش می‌دهیم.</p>
<hr>
<h2>🔹 مقدمه</h2>
<p>در ادامه رایج‌ترین سناریوهای هم‌زمانی آورده شده است:</p>
<h3>🖥️ نوشتن یک رابط کاربری پاسخ‌گو</h3>
<p>در برنامه‌های <strong>WPF</strong>، موبایل و <strong>Windows Forms</strong> باید کارهای زمان‌بر را به‌صورت هم‌زمان با کدی که رابط کاربری شما را اجرا می‌کند انجام دهید تا رابط کاربری همچنان پاسخ‌گو باقی بماند.</p>
<h3>🌐 پردازش هم‌زمان درخواست‌ها</h3>
<p>روی یک سرور، درخواست‌های کلاینت می‌توانند به‌طور هم‌زمان برسند و بنابراین باید به‌صورت موازی پردازش شوند تا <strong>Scalability</strong> (مقیاس‌پذیری) حفظ شود. اگر از <strong>ASP.NET Core</strong> یا <strong>Web API</strong> استفاده کنید، زمان‌اجرا (Runtime) این کار را به‌طور خودکار برای شما انجام می‌دهد.
بااین‌حال، همچنان باید نسبت به <strong>Shared State</strong> (وضعیت مشترک) آگاه باشید (برای نمونه، اثر استفاده از <strong>Static Variables</strong> برای کش‌کردن).</p>
<h3>⚡ برنامه‌نویسی موازی</h3>
<p>کدی که محاسبات سنگینی انجام می‌دهد می‌تواند روی رایانه‌های چند‌هسته‌ای یا چند‌پردازنده‌ای سریع‌تر اجرا شود، اگر حجم کار میان هسته‌ها تقسیم شود. (فصل ۲۲ به‌طور کامل به این موضوع اختصاص دارد.)</p>
<h3>🔮 اجرای حدسی (Speculative Execution)</h3>
<p>روی ماشین‌های چند‌هسته‌ای، گاهی می‌توان با پیش‌بینی کاری که ممکن است نیاز به انجام آن باشد و انجام دادن آن از قبل، عملکرد را بهبود داد.
برنامه <strong>LINQPad</strong> از این تکنیک برای سرعت‌بخشیدن به ایجاد کوئری‌های جدید استفاده می‌کند.
نوع دیگری از این روش این است که چند الگوریتم مختلف را به‌طور موازی اجرا کنید که همگی یک وظیفه مشابه را حل می‌کنند. هرکدام زودتر تمام شود «برنده» خواهد بود. این روش زمانی مؤثر است که از قبل ندانید کدام الگوریتم سریع‌تر عمل خواهد کرد.</p>
<hr>
<h2>🧵 مکانیزم عمومی هم‌زمانی: Multithreading</h2>
<p>مکانیزم عمومی‌ای که به یک برنامه اجازه می‌دهد به‌طور هم‌زمان کد را اجرا کند، <strong>Multithreading</strong> نام دارد.
Multithreading هم توسط <strong>CLR</strong> و هم توسط <strong>سیستم‌عامل</strong> پشتیبانی می‌شود و یک مفهوم بنیادین در هم‌زمانی است.
بنابراین درک مبانی <strong>Threading</strong>، و به‌ویژه تأثیر رشته‌ها بر <strong>Shared State</strong> (وضعیت مشترک)، ضروری است.</p>
<hr>
<h2>🧩 Threading</h2>
<p>یک <strong>Thread</strong> یا «رشته»، یک مسیر اجرای مستقل است که می‌تواند جدا از سایر مسیرها پیش برود.</p>
<p>هر رشته درون یک <strong>Process</strong> (فرایند) سیستم‌عامل اجرا می‌شود که محیطی ایزوله را برای اجرای یک برنامه فراهم می‌کند.</p>
<ul>
<li>در یک برنامه <strong>تک‌رشته‌ای</strong> (Single-Threaded)، تنها یک رشته در محیط ایزوله پردازش اجرا می‌شود و بنابراین آن رشته دسترسی انحصاری به آن دارد.</li>
<li>در یک برنامه <strong>چند‌رشته‌ای</strong> (Multi-Threaded)، چند رشته در یک فرایند واحد اجرا می‌شوند و یک محیط اجرایی مشترک (به‌ویژه حافظه) را با هم به اشتراک می‌گذارند.</li>
</ul>
<p>این موضوع دلیل اصلی مفید بودن Multithreading است:
برای نمونه، یک رشته می‌تواند در پس‌زمینه داده‌ها را واکشی کند، درحالی‌که رشته دیگر همان داده‌ها را به‌محض رسیدن نمایش دهد. این داده‌ها به‌عنوان <strong>Shared State</strong> شناخته می‌شوند.</p>
<hr>
<h2>🛠️ ایجاد یک Thread</h2>
<p>یک برنامه کلاینت (<strong>Console</strong>، <strong>WPF</strong>، <strong>UWP</strong> یا <strong>Windows Forms</strong>) در یک رشته منفرد که به‌طور خودکار توسط سیستم‌عامل ساخته می‌شود (رشته‌ی اصلی یا <strong>Main Thread</strong>) شروع به کار می‌کند.
این برنامه تا زمانی که شما کاری خلاف آن انجام ندهید (یعنی رشته‌های بیشتری بسازید، چه به‌طور مستقیم و چه غیرمستقیم) به‌صورت تک‌رشته‌ای باقی می‌ماند.¹</p>
<p>برای ایجاد و شروع یک رشته جدید، باید یک شیء از نوع <strong>Thread</strong> بسازید و متد <strong>Start</strong> آن را فراخوانی کنید.
ساده‌ترین سازنده (Constructor) برای Thread، یک <strong>ThreadStart Delegate</strong> می‌گیرد: متدی بدون پارامتر که نشان می‌دهد اجرای رشته از کجا آغاز شود.</p>
<h3>📌 مثال</h3>
<pre><code class="language-csharp">// توجه: همه نمونه‌های این فصل فرض می‌کنند که Namespaceهای زیر Import شده‌اند:
using System;
using System.Threading;

Thread t = new Thread (WriteY);     // ایجاد و راه‌اندازی یک رشته جدید
t.Start();                          // اجرای متد WriteY روی رشته جدید

// هم‌زمان، روی رشته اصلی هم کاری انجام می‌دهیم.
for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;x&quot;);

void WriteY()
{
    for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;y&quot;);
}
</code></pre>
<hr>
<h3>📤 خروجی نمونه</h3>
<pre><code>xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
...
</code></pre>
<hr>
<p>رشته اصلی یک رشته جدید به نام <code>t</code> می‌سازد و روی آن متدی را اجرا می‌کند که کاراکتر <code>y</code> را به‌طور تکراری چاپ می‌کند.
به‌طور هم‌زمان، رشته اصلی نیز کاراکتر <code>x</code> را به‌طور تکراری چاپ می‌کند، همان‌طور که در شکل <strong>۱۴-۱</strong> نشان داده شده است.</p>
<ul>
<li>روی یک رایانه تک‌هسته‌ای، سیستم‌عامل باید «بُرش‌هایی» از زمان (معمولاً حدود <strong>۲۰ میلی‌ثانیه</strong> در ویندوز) را به هر رشته اختصاص دهد تا هم‌زمانی شبیه‌سازی شود. نتیجه این کار، بلاک‌های تکراری از <code>x</code> و <code>y</code> است.</li>
<li>روی یک ماشین چند‌هسته‌ای یا چند‌پردازنده‌ای، دو رشته می‌توانند واقعاً به‌طور موازی اجرا شوند (با این شرط که دیگر پردازه‌های فعال روی رایانه هم در رقابت باشند).
بااین‌حال در این مثال همچنان بلاک‌های تکراری از <code>x</code> و <code>y</code> مشاهده می‌کنید، زیرا جزئیات ظریفی در مکانیزمی وجود دارد که <strong>Console</strong> درخواست‌های هم‌زمان را مدیریت می‌کند.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/14/Table-14-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>🔄 پیش‌امتیازدهی (Preemption)</h2>
<p>وقتی اجرای یک <strong>Thread</strong> با اجرای کدی روی یک <strong>Thread</strong> دیگر در هم آمیخته می‌شود، گفته می‌شود که آن Thread <strong>Preempted</strong> (پیش‌امتیاز داده شده) است. این اصطلاح اغلب زمانی ظاهر می‌شود که بخواهیم توضیح دهیم چرا چیزی به‌درستی کار نکرده است!</p>
<hr>
<h2>🟢 وضعیت زنده بودن (IsAlive)</h2>
<p>پس از شروع شدن، ویژگی (<strong>Property</strong>) <code>IsAlive</code> در یک Thread مقدار <strong>true</strong> را برمی‌گرداند تا زمانی که آن Thread پایان یابد.
یک Thread زمانی پایان می‌یابد که <strong>Delegate</strong>ای که به سازنده‌ی (Constructor) آن داده شده، اجرای خود را تمام کند. پس از پایان یافتن، یک Thread را نمی‌توان دوباره راه‌اندازی کرد.</p>
<hr>
<h2>📝 نام‌گذاری Threadها</h2>
<p>هر Thread یک ویژگی به نام <strong>Name</strong> دارد که می‌توانید آن را برای اهداف <strong>Debugging</strong> تنظیم کنید.
این ویژگی در <strong>Visual Studio</strong> بسیار مفید است، زیرا نام Thread در <strong>Threads Window</strong> و نوار ابزار <strong>Debug Location</strong> نمایش داده می‌شود.
شما تنها یک‌بار می‌توانید نام یک Thread را تنظیم کنید؛ هر تلاش دیگری برای تغییر نام، یک <strong>Exception</strong> ایجاد خواهد کرد.</p>
<hr>
<h2>🔍 دسترسی به Thread فعلی</h2>
<p>ویژگی استاتیک <code>Thread.CurrentThread</code> رشته‌ای را که در حال حاضر در حال اجراست برمی‌گرداند:</p>
<pre><code class="language-csharp">Console.WriteLine (Thread.CurrentThread.Name);
</code></pre>
<hr>
<h2>⏳ Join و Sleep</h2>
<h3>📌 Join</h3>
<p>می‌توانید با فراخوانی متد <strong>Join</strong> منتظر بمانید تا یک Thread دیگر پایان یابد:</p>
<pre><code class="language-csharp">Thread t = new Thread (Go);
t.Start();
t.Join();
Console.WriteLine (&quot;Thread t has ended!&quot;);

void Go() 
{ 
    for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;y&quot;); 
}
</code></pre>
<p>این کد ابتدا ۱۰۰۰ بار <code>y</code> چاپ می‌کند و بلافاصله پس از آن متن <code>&quot;Thread t has ended!&quot;</code> نمایش داده می‌شود.</p>
<p>همچنین می‌توانید هنگام فراخوانی <strong>Join</strong> یک <strong>Timeout</strong> مشخص کنید (برحسب میلی‌ثانیه یا یک <strong>TimeSpan</strong>). در این صورت متد مقدار <strong>true</strong> برمی‌گرداند اگر Thread پایان یافته باشد، یا <strong>false</strong> اگر زمان تمام شده باشد.</p>
<hr>
<h3>📌 Sleep</h3>
<p>متد <strong>Thread.Sleep</strong> اجرای Thread فعلی را برای مدتی مشخص متوقف می‌کند:</p>
<pre><code class="language-csharp">Thread.Sleep (TimeSpan.FromHours (1));  // توقف برای ۱ ساعت
Thread.Sleep (500);                     // توقف برای ۵۰۰ میلی‌ثانیه
</code></pre>
<p>فراخوانی <code>Thread.Sleep(0)</code> بلافاصله <strong>بُرش زمانی</strong> (Time Slice) فعلی را آزاد کرده و داوطلبانه CPU را در اختیار سایر Threadها قرار می‌دهد.
متد <code>Thread.Yield()</code> نیز همین کار را انجام می‌دهد، با این تفاوت که CPU را تنها به Threadهایی واگذار می‌کند که روی همان پردازنده در حال اجرا هستند.</p>
<ul>
<li>استفاده از <code>Sleep(0)</code> یا <code>Yield</code> گاهی در کدهای <strong>Production</strong> برای بهینه‌سازی‌های پیشرفته‌ی عملکرد مفید است.</li>
<li>این‌ها همچنین ابزارهای عالی <strong>Diagnostic</strong> (عیب‌یابی) هستند: اگر اضافه کردن <code>Thread.Yield()</code> در هرجای کد شما باعث خراب شدن برنامه شود، تقریباً مطمئن باشید که یک <strong>Bug</strong> در کدتان وجود دارد.</li>
</ul>
<hr>
<h2>🚫 Block شدن یک Thread</h2>
<p>وقتی اجرای یک Thread به دلایلی متوقف شود، گفته می‌شود که آن Thread <strong>Blocked</strong> است؛ مثلاً هنگام اجرای <strong>Sleep</strong> یا منتظر ماندن برای پایان یافتن یک Thread دیگر با <strong>Join</strong>.</p>
<ul>
<li>یک Thread <strong>Blocked</strong> بلافاصله بُرش زمانی پردازنده‌ی خود را آزاد می‌کند.</li>
<li>از آن لحظه به بعد، هیچ زمانی از CPU مصرف نمی‌کند تا زمانی که شرط Block شدن برطرف شود.</li>
</ul>
<p>برای بررسی اینکه آیا یک Thread در حالت Block است می‌توانید از ویژگی <strong>ThreadState</strong> استفاده کنید:</p>
<pre><code class="language-csharp">bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0;
</code></pre>
<hr>
<h2>⚙️ ThreadState</h2>
<p>ویژگی <strong>ThreadState</strong> یک <strong>Flags Enum</strong> است که سه «لایه» داده را به‌صورت <strong>Bitwise</strong> ترکیب می‌کند.
بااین‌حال بیشتر مقادیر آن زائد، بلااستفاده یا منسوخ شده‌اند.</p>
<p>روش توسعه‌یافته‌ی زیر یک مقدار ThreadState را به یکی از چهار مقدار مفید ساده‌سازی می‌کند:</p>
<ul>
<li><strong>Unstarted</strong></li>
<li><strong>Running</strong></li>
<li><strong>WaitSleepJoin</strong></li>
<li><strong>Stopped</strong></li>
</ul>
<pre><code class="language-csharp">public static ThreadState Simplify (this ThreadState ts)
{
    return ts &amp; (ThreadState.Unstarted |
                 ThreadState.WaitSleepJoin |
                 ThreadState.Stopped);
}
</code></pre>
<p>🔎 ویژگی ThreadState برای مقاصد <strong>Diagnostic</strong> مفید است، اما برای <strong>Synchronization</strong> مناسب نیست، زیرا وضعیت یک Thread می‌تواند بین بررسی مقدار ThreadState و عمل‌کردن بر اساس آن تغییر کند.</p>
<p>هنگامی‌که یک Thread <strong>Block</strong> یا <strong>Unblock</strong> می‌شود، سیستم‌عامل یک <strong>Context Switch</strong> انجام می‌دهد. این عمل هزینه‌ی اندکی دارد (معمولاً یک یا دو میکروثانیه).</p>
<hr>
<h2>⚖️ I/O-bound در مقابل Compute-bound</h2>
<ul>
<li>
<p>عملیاتی که بیشتر زمان خود را در انتظار رخ‌دادن چیزی می‌گذراند، <strong>I/O-bound</strong> نامیده می‌شود.
نمونه: <strong>دانلود یک صفحه وب</strong> یا فراخوانی <code>Console.ReadLine</code>.
(عملیات I/O-bound معمولاً شامل ورودی یا خروجی هستند، اما این یک الزام قطعی نیست: <code>Thread.Sleep</code> هم I/O-bound محسوب می‌شود.)</p>
</li>
<li>
<p>در مقابل، عملیاتی که بیشتر زمان خود را صرف انجام کارهای سنگین CPU می‌کند، <strong>Compute-bound</strong> نام دارد.</p>
</li>
</ul>
<hr>
<h2>🔄 Blocking در مقابل Spinning</h2>
<p>یک عملیات I/O-bound می‌تواند به دو صورت عمل کند:</p>
<ol>
<li><strong>انتظار همگام (Synchronous)</strong> روی Thread فعلی تا پایان عملیات (مثال: <code>Console.ReadLine</code>، <code>Thread.Sleep</code> یا <code>Thread.Join</code>).</li>
<li><strong>عمل ناهمگام (Asynchronous)</strong> که با پایان عملیات در آینده، یک <strong>Callback</strong> اجرا می‌کند (بیشتر در ادامه این فصل توضیح داده می‌شود).</li>
</ol>
<hr>
<h3>🔁 Blocking با حلقه Sleep</h3>
<p>عملیات‌های I/O-bound که به‌صورت همگام منتظر می‌مانند بیشتر زمان خود را در حالت Block سپری می‌کنند.
گاهی این انتظار به شکل یک حلقه‌ی Sleep پیاده‌سازی می‌شود:</p>
<pre><code class="language-csharp">while (DateTime.Now &lt; nextStartTime)
    Thread.Sleep (100);
</code></pre>
<hr>
<h3>🔁 Spinning (چرخش مداوم)</h3>
<p>گزینه‌ی دیگر این است که یک Thread به‌طور مداوم بچرخد:</p>
<pre><code class="language-csharp">while (DateTime.Now &lt; nextStartTime);
</code></pre>
<p>این کار به‌شدت وقت CPU را تلف می‌کند. از دید <strong>CLR</strong> و سیستم‌عامل، Thread در حال انجام یک محاسبه مهم است، بنابراین منابع به آن اختصاص داده می‌شود. در عمل، ما یک عملیات I/O-bound را به یک عملیات <strong>Compute-bound</strong> تبدیل کرده‌ایم.</p>
<hr>
<h2>✨ نکات ظریف درباره Spinning در برابر Blocking</h2>
<p>۱. <strong>Spinning کوتاه‌مدت</strong> گاهی می‌تواند مؤثر باشد، زمانی که انتظار دارید شرط به‌زودی (مثلاً در چند میکروثانیه) برقرار شود. این کار از سربار و تأخیر <strong>Context Switch</strong> جلوگیری می‌کند.
📌 برای این منظور، .NET متدها و کلاس‌های خاصی مثل <strong>SpinLock</strong> و <strong>SpinWait</strong> را ارائه می‌دهد.</p>
<p>۲. <strong>Blocking هم بی‌هزینه نیست</strong>. هر Thread حدود <strong>۱ مگابایت حافظه</strong> را برای تمام مدت عمرش اشغال می‌کند و برای <strong>CLR</strong> و سیستم‌عامل بار مدیریتی مداوم ایجاد می‌کند.
به همین دلیل، Blocking در برنامه‌های بسیار I/O-bound که باید صدها یا هزاران عملیات هم‌زمان را مدیریت کنند می‌تواند مشکل‌ساز شود.</p>
<p>🔑 در چنین شرایطی، برنامه‌ها باید از رویکرد <strong>Callback-based</strong> استفاده کنند، یعنی هنگام انتظار، Thread خود را به‌طور کامل آزاد کنند.
این دقیقاً (بخشی از) هدف الگوهای <strong>Asynchronous</strong> است که در ادامه بررسی خواهیم کرد.</p>
<h2>🔀 وضعیت محلی در مقابل وضعیت مشترک</h2>
<p><strong>CLR</strong> به هر Thread پشته‌ی حافظه‌ی مخصوص خودش را اختصاص می‌دهد، بنابراین متغیرهای محلی از هم جدا نگه داشته می‌شوند.</p>
<p>در مثال زیر، متدی با یک متغیر محلی تعریف می‌کنیم و سپس آن متد را به‌طور هم‌زمان روی <strong>Thread اصلی</strong> و یک <strong>Thread جدید</strong> فراخوانی می‌کنیم:</p>
<pre><code class="language-csharp">new Thread (Go).Start();      // فراخوانی Go() روی یک Thread جدید
Go();                         // فراخوانی Go() روی Thread اصلی

void Go()
{
    // تعریف و استفاده از متغیر محلی - 'cycles'
    for (int cycles = 0; cycles &lt; 5; cycles++) 
        Console.Write ('?');
}
</code></pre>
<p>برای هر Thread یک نسخه جداگانه از متغیر <code>cycles</code> روی پشته‌ی حافظه‌اش ساخته می‌شود. بنابراین، خروجی طبق انتظار ۱۰ علامت سؤال خواهد بود.</p>
<hr>
<h2>🤝 اشتراک داده بین Threadها</h2>
<p>Threadها داده‌ها را در صورتی به اشتراک می‌گذارند که مرجع (Reference) مشترکی به یک شیء یا متغیر داشته باشند:</p>
<pre><code class="language-csharp">bool _done = false;
new Thread (Go).Start();
Go();

void Go()
{
    if (!_done) 
    { 
        _done = true; 
        Console.WriteLine (&quot;Done&quot;); 
    }
}
</code></pre>
<p>در این مثال، هر دو Thread متغیر <code>_done</code> را به اشتراک می‌گذارند، پس خروجی <code>&quot;Done&quot;</code> فقط یک‌بار چاپ می‌شود.</p>
<hr>
<h3>📌 اشتراک‌گذاری از طریق Lambda</h3>
<p>متغیرهای محلی که در یک <strong>Lambda Expression</strong> گرفته (Capture) می‌شوند نیز می‌توانند مشترک باشند:</p>
<pre><code class="language-csharp">bool done = false;
ThreadStart action = () =&gt;
{
    if (!done) 
    { 
        done = true; 
        Console.WriteLine (&quot;Done&quot;); 
    }
};

new Thread (action).Start();
action();
</code></pre>
<hr>
<h3>📌 اشتراک‌گذاری از طریق Fieldها</h3>
<p>به‌طور رایج‌تر، <strong>Fieldها</strong> برای اشتراک داده میان Threadها استفاده می‌شوند.</p>
<pre><code class="language-csharp">var tt = new ThreadTest();
new Thread (tt.Go).Start();
tt.Go();

class ThreadTest 
{
    bool _done;
    public void Go()
    {
        if (!_done) 
        { 
            _done = true; 
            Console.WriteLine (&quot;Done&quot;); 
        }
    }
}
</code></pre>
<hr>
<h3>📌 اشتراک‌گذاری از طریق Static Field</h3>
<p>راه دیگر برای اشتراک داده‌ها میان Threadها استفاده از <strong>Static Field</strong>هاست:</p>
<pre><code class="language-csharp">class ThreadTest 
{
    static bool _done;    // Static Fieldها میان همه Threadها در یک Process مشترک هستند

    static void Main()
    {
        new Thread (Go).Start();
        Go();
    }

    static void Go()
    {
        if (!_done) 
        { 
            _done = true; 
            Console.WriteLine (&quot;Done&quot;); 
        }
    }
}
</code></pre>
<hr>
<h2>⚠️ مشکل Thread Safety</h2>
<p>هر چهار مثال بالا مفهوم کلیدی دیگری را نشان می‌دهند: <strong>ایمنی Threadها</strong> (یا بهتر بگوییم، نبود آن!).
در حقیقت خروجی <strong>نامعین</strong> است: این امکان (هرچند نادر) وجود دارد که <code>&quot;Done&quot;</code> دوبار چاپ شود.</p>
<p>اگر ترتیب دستورات در متد <code>Go</code> را عوض کنیم، احتمال چاپ دوباره <code>&quot;Done&quot;</code> به‌شدت افزایش می‌یابد:</p>
<pre><code class="language-csharp">static void Go()
{
    if (!_done) 
    { 
        Console.WriteLine (&quot;Done&quot;); 
        _done = true; 
    }
}
</code></pre>
<p>مشکل اینجاست که یک Thread ممکن است در حال بررسی شرط <code>if</code> باشد در همان لحظه‌ای که Thread دیگر دارد <code>WriteLine</code> را اجرا می‌کند—قبل از آنکه فرصت کند مقدار <code>_done</code> را برابر <strong>true</strong> کند.</p>
<p>این مثال یکی از راه‌های متعدد را نشان می‌دهد که در آن <strong>Shared Writable State</strong> (وضعیت مشترک قابل‌نوشتن) می‌تواند خطاهای متناوبی ایجاد کند؛ همان خطاهایی که <strong>Multithreading</strong> به‌بدنامی برای آن‌ها مشهور است.</p>
<hr>
<h2>🔒 قفل‌گذاری و ایمنی Threadها</h2>
<p>برای حل مثال قبلی می‌توانیم هنگام خواندن و نوشتن روی Field مشترک، یک <strong>Exclusive Lock</strong> بگیریم.
#C برای این منظور دستور <code>lock</code> را فراهم کرده است:</p>
<pre><code class="language-csharp">class ThreadSafe 
{
    static bool _done;
    static readonly object _locker = new object();

    static void Main()
    {
        new Thread (Go).Start();
        Go();
    }

    static void Go()
    {
        lock (_locker)
        {
            if (!_done) 
            { 
                Console.WriteLine (&quot;Done&quot;); 
                _done = true; 
            }
        }
    }
}
</code></pre>
<p>وقتی دو Thread هم‌زمان برای گرفتن یک Lock (که می‌تواند روی هر شیء از نوع Reference باشد؛ در اینجا <code>_locker</code>) رقابت کنند، یکی از آن‌ها منتظر می‌ماند (Blocked) تا Lock آزاد شود.
این کار تضمین می‌کند که فقط یک Thread می‌تواند هم‌زمان وارد بلوک کد شود، و <code>&quot;Done&quot;</code> فقط یک‌بار چاپ خواهد شد.</p>
<p>کدی که به این شکل محافظت شده باشد—در برابر عدم قطعیت در یک محیط چند‌رشته‌ای—به آن <strong>Thread Safe</strong> می‌گویند.</p>
<hr>
<h2>⚡ عملیات ناامن حتی در ساده‌ترین حالات</h2>
<p>حتی عمل ساده‌ی <strong>Auto-increment</strong> یک متغیر هم Thread Safe نیست:</p>
<p>عبارت <code>x++</code> روی پردازنده به‌صورت چند عمل جداگانه (خواندن، افزایش و نوشتن) اجرا می‌شود.
بنابراین اگر دو Thread هم‌زمان <code>x++</code> را خارج از یک Lock اجرا کنند، متغیر ممکن است فقط یک‌بار افزایش یابد به‌جای دوبار (یا بدتر، مقدار <code>x</code> ممکن است در شرایط خاص به‌شکل تکه‌تکه و نادرست ذخیره شود).</p>
<hr>
<h2>🚫 محدودیت‌های قفل‌گذاری</h2>
<p>قفل‌گذاری <strong>گلوله نقره‌ای</strong> برای حل همه مشکلات Thread Safety نیست:</p>
<ul>
<li>ممکن است فراموش کنید که در حین دسترسی به یک Field از Lock استفاده کنید.</li>
<li>قفل‌گذاری خودش می‌تواند مشکلاتی مانند <strong>Deadlock</strong> ایجاد کند.</li>
</ul>
<p>یک نمونه خوب برای استفاده از قفل‌گذاری، دسترسی به یک <strong>Cache در حافظه</strong> است که برای نگهداری اشیای پایگاه داده در یک برنامه‌ی <strong>ASP.NET</strong> استفاده می‌شود.
این نوع برنامه ساده است و به‌درستی کار می‌کند و هیچ خطری برای Deadlock وجود ندارد.
نمونه‌ای از این موضوع را در بخش <strong>&quot;Thread Safety in Application Servers&quot;</strong> (صفحه ۹۰۱) خواهیم دید.</p>
<h2>📤 ارسال داده به یک Thread</h2>
<p>گاهی لازم است هنگام شروع یک <strong>Thread</strong>، آرگومان‌هایی به متد ورودی آن ارسال کنید.
ساده‌ترین راه برای این کار استفاده از <strong>Lambda Expression</strong> است که متد را با آرگومان‌های مورد نظر فراخوانی می‌کند:</p>
<pre><code class="language-csharp">Thread t = new Thread ( () =&gt; Print (&quot;Hello from t!&quot;) );
t.Start();

void Print (string message) =&gt; Console.WriteLine (message);
</code></pre>
<p>با این روش، می‌توانید هر تعداد آرگومان را به متد ارسال کنید.
حتی می‌توانید کل پیاده‌سازی را در یک <strong>Lambda چند‌دستوره‌ای</strong> قرار دهید:</p>
<pre><code class="language-csharp">new Thread (() =&gt;
{
    Console.WriteLine (&quot;I'm running on another thread!&quot;);
    Console.WriteLine (&quot;This is so easy!&quot;);
}).Start();
</code></pre>
<hr>
<h3>🔄 روش دیگر: استفاده از <code>Thread.Start</code></h3>
<p>روش جایگزین (اما کمتر انعطاف‌پذیر) این است که آرگومان را به متد <code>Start</code> ارسال کنیم:</p>
<pre><code class="language-csharp">Thread t = new Thread (Print);
t.Start (&quot;Hello from t!&quot;);

void Print (object messageObj)
{
    string message = (string) messageObj;   // نیاز به Cast داریم
    Console.WriteLine (message);
}
</code></pre>
<p>این روش کار می‌کند چون سازنده‌ی <strong>Thread</strong> برای دو نوع Delegate <strong>Overload</strong> شده است:</p>
<pre><code class="language-csharp">public delegate void ThreadStart();
public delegate void ParameterizedThreadStart (object obj);
</code></pre>
<hr>
<h2>🧩 Lambda Expressions و متغیرهای Captured</h2>
<p>همان‌طور که دیدیم، <strong>Lambda Expression</strong> راحت‌ترین و قدرتمندترین روش برای ارسال داده به یک Thread است.
اما باید مراقب باشید که بعد از شروع Thread، به‌طور ناخواسته متغیرهای Captured را تغییر ندهید.</p>
<p>برای نمونه:</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
    new Thread (() =&gt; Console.Write (i)).Start();
</code></pre>
<p>خروجی <strong>نامعین</strong> است! مثالی از خروجی:</p>
<pre><code>0223557799
</code></pre>
<p>مشکل این است که متغیر <code>i</code> در طول اجرای حلقه به یک محل حافظه‌ی مشترک اشاره دارد.
بنابراین هر Thread، متدی را روی متغیری فراخوانی می‌کند که ممکن است هم‌زمان در حال تغییر باشد!</p>
<p>✅ راه‌حل: استفاده از یک متغیر موقت:</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
    int temp = i;
    new Thread (() =&gt; Console.Write (temp)).Start();
}
</code></pre>
<p>حالا هر عدد از <strong>۰ تا ۹</strong> دقیقاً یک‌بار چاپ می‌شود.
(البته ترتیب هنوز مشخص نیست، چون Threadها می‌توانند در زمان‌های نامعین شروع شوند.)</p>
<p>این مشکل مشابه موضوع <strong>&quot;Captured Variables&quot;</strong> (صفحه ۴۳۴) است؛
مشکل هم به قوانین C# در Capture متغیرهای حلقه مربوط می‌شود و هم به Multithreading.</p>
<p>در این روش، متغیر <code>temp</code> محلی به هر Iteration حلقه است، پس هر Thread حافظه‌ای متفاوت Capture می‌کند و مشکلی پیش نمی‌آید.</p>
<p>یک مثال ساده‌تر برای نمایش مشکل:</p>
<pre><code class="language-csharp">string text = &quot;t1&quot;;
Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );
text = &quot;t2&quot;;
Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );
t1.Start(); t2.Start();
</code></pre>
<p>چون هر دو Lambda متغیر <code>text</code> را Capture کرده‌اند، خروجی دوبار <code>&quot;t2&quot;</code> خواهد بود.</p>
<hr>
<h2>⚠️ مدیریت استثناها در Threadها</h2>
<p>بلوک‌های <strong>try/catch/finally</strong> که هنگام ایجاد یک Thread در جریان هستند، هیچ تأثیری روی آن Thread هنگام اجرا ندارند.</p>
<p>مثال:</p>
<pre><code class="language-csharp">try
{
    new Thread (Go).Start();
}
catch (Exception ex)
{
    // اینجا هیچ‌وقت اجرا نمی‌شود!
    Console.WriteLine (&quot;Exception!&quot;);
}

void Go() { throw null; }   // پرتاب NullReferenceException
</code></pre>
<p>در اینجا، Thread جدید با یک <strong>Unhandled NullReferenceException</strong> مواجه می‌شود.
این رفتار منطقی است، چون هر Thread مسیر اجرای مستقل خود را دارد.</p>
<p>✅ راه‌حل این است که <strong>Exception Handler</strong> را داخل متد <code>Go</code> قرار دهیم:</p>
<pre><code class="language-csharp">new Thread (Go).Start();

void Go()
{
    try
    {
        ...
        throw null;    // اینجا خطا پرتاب می‌شود
        ...
    }
    catch (Exception ex)
    {
        // معمولاً Exception را Log می‌کنیم یا به یک Thread دیگر سیگنال می‌دهیم
        ...
    }
}
</code></pre>
<p>در برنامه‌های واقعی، باید در تمام متدهای ورودی Thread <strong>Exception Handler</strong> داشته باشید—همان‌طور که در Thread اصلی برنامه هم نیاز دارید.
چون یک Exception مدیریت‌نشده باعث بسته‌شدن کل برنامه و نمایش یک پنجره‌ی ناخوشایند می‌شود.</p>
<hr>
<h2>🗂️ مدیریت متمرکز استثناها</h2>
<p>در برنامه‌های <strong>WPF، UWP و Windows Forms</strong> می‌توانید برای مدیریت سراسری Exceptionها مشترک شوید:</p>
<ul>
<li><code>Application.DispatcherUnhandledException</code></li>
<li><code>Application.ThreadException</code></li>
</ul>
<p>این رویدادها پس از وقوع یک Exception مدیریت‌نشده در هر بخش برنامه که از طریق Message Loop فراخوانی شده است (یعنی تمام کدی که روی Thread اصلی در حال اجراست) فعال می‌شوند.</p>
<p>این روش به‌عنوان یک پشتوانه برای <strong>Log کردن و گزارش باگ‌ها</strong> مفید است (هرچند برای Exceptionهای مدیریت‌نشده روی Worker Threadها فعال نمی‌شود).</p>
<p>مدیریت این رویدادها از بسته‌شدن برنامه جلوگیری می‌کند؛ البته ممکن است تصمیم بگیرید برنامه را مجدداً راه‌اندازی کنید تا از حالت ناپایدار احتمالی جلوگیری شود.</p>
<h2>🌗 Foreground در مقابل Background Threads</h2>
<p>به‌طور پیش‌فرض، Threadهایی که شما به‌طور صریح ایجاد می‌کنید، <strong>Foreground</strong> هستند.</p>
<p>🔹 <strong>Foreground Thread</strong> باعث می‌شود برنامه تا زمانی که حتی یکی از آن‌ها در حال اجراست، زنده بماند.
🔹 <strong>Background Thread</strong> چنین اثری ندارد؛ به‌محض اینکه همه‌ی Foreground Threadها تمام شوند، برنامه پایان می‌یابد و هر Background Threadی که هنوز در حال اجراست، ناگهانی قطع می‌شود.</p>
<p>⚠️ وضعیت Foreground یا Background هیچ ارتباطی با <strong>Priority</strong> (اولویت تخصیص زمان پردازش) ندارد.</p>
<p>می‌توانید وضعیت یک Thread را از طریق ویژگی <code>IsBackground</code> پرس‌وجو یا تغییر دهید:</p>
<pre><code class="language-csharp">static void Main (string[] args)
{
    Thread worker = new Thread ( () =&gt; Console.ReadLine() );
    if (args.Length &gt; 0) worker.IsBackground = true;
    worker.Start();
}
</code></pre>
<ul>
<li>اگر برنامه بدون آرگومان اجرا شود، Thread به‌صورت <strong>Foreground</strong> خواهد بود و منتظر می‌ماند تا کاربر Enter بزند.</li>
<li>اگر برنامه با آرگومان اجرا شود، Thread به‌صورت <strong>Background</strong> است و برنامه تقریباً بلافاصله تمام می‌شود (و <code>ReadLine</code> قطع می‌گردد).</li>
</ul>
<p>❌ توجه: وقتی برنامه این‌گونه پایان یابد، بلاک‌های <code>finally</code> در پشته‌ی اجرای Background Thread اجرا نمی‌شوند.
بنابراین اگر برای پاک‌سازی (مثل حذف فایل‌های موقت) از <code>finally</code> یا <code>using</code> استفاده می‌کنید، باید مطمئن شوید هنگام خروج از برنامه، این Threadها به‌طور صحیح به پایان برسند (مثلاً با <code>Join</code> یا <strong>Signaling</strong>). همیشه هم باید <strong>Timeout</strong> تعیین کنید تا در صورت لجبازی یک Thread، برنامه بسته نشود.</p>
<hr>
<h2>🎚️ اولویت Threads</h2>
<p>ویژگی <code>Priority</code> تعیین می‌کند یک Thread چه میزان زمان پردازش نسبت به سایر Threadها دریافت کند:</p>
<pre><code class="language-csharp">enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest }
</code></pre>
<p>این موضوع زمانی اهمیت دارد که چندین Thread هم‌زمان فعال باشند.</p>
<ul>
<li>بالا بردن اولویت می‌تواند باعث شود Threadهای دیگر <strong>گرسنه</strong> بمانند.</li>
<li>اگر می‌خواهید Thread شما اولویتی بالاتر از سایر Processها داشته باشد، باید اولویت Process را هم بالا ببرید:</li>
</ul>
<pre><code class="language-csharp">using Process p = Process.GetCurrentProcess();
p.PriorityClass = ProcessPriorityClass.High;
</code></pre>
<p>این کار برای <strong>پردازش‌های غیر-UI کوچک با نیاز به واکنش سریع</strong> مناسب است. اما در برنامه‌های پرمصرف (مخصوصاً با UI)، افزایش اولویت Process می‌تواند کل سیستم را کند کند.</p>
<hr>
<h2>📡 Signaling</h2>
<p>گاهی لازم است یک Thread منتظر بماند تا از Threadهای دیگر سیگنال دریافت کند.
ساده‌ترین سازه برای این کار <strong>ManualResetEvent</strong> است:</p>
<ul>
<li><code>WaitOne</code> → Thread فعلی را مسدود می‌کند.</li>
<li><code>Set</code> → سیگنال را باز می‌کند و منتظرها آزاد می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var signal = new ManualResetEvent (false);

new Thread (() =&gt;
{
    Console.WriteLine (&quot;Waiting for signal...&quot;);
    signal.WaitOne();
    signal.Dispose();
    Console.WriteLine (&quot;Got signal!&quot;);
}).Start();

Thread.Sleep(2000);
signal.Set();  // سیگنال باز شد
</code></pre>
<p>بعد از فراخوانی <code>Set</code>، سیگنال باز می‌ماند تا زمانی که دوباره <code>Reset</code> شود.
CLR سازه‌های Signaling متنوعی دارد که در فصل ۲۱ بررسی می‌شوند.</p>
<hr>
<h2>🖥️ Threading در برنامه‌های Rich Client</h2>
<p>در برنامه‌های <strong>WPF، UWP و Windows Forms</strong>، اجرای عملیات طولانی روی Thread اصلی باعث <strong>هنگ کردن UI</strong> می‌شود، چون همان Thread مسئول پردازش ورودی‌ها (کیبورد/ماوس) و رندر رابط کاربری است.</p>
<p>راه‌حل:</p>
<ul>
<li>ایجاد <strong>Worker Thread</strong> برای کارهای زمان‌بر.</li>
<li>سپس انتقال نتیجه به Thread اصلی برای به‌روزرسانی UI.</li>
</ul>
<p>⚠️ همه‌ی این فریم‌ورک‌ها مدل Threading دارند که فقط اجازه می‌دهد UI توسط همان Threadی دسترسی یابد که آن را ساخته است (معمولاً Thread اصلی). در غیر این صورت، رفتار نامشخص یا Exception رخ می‌دهد.</p>
<p>برای به‌روزرسانی UI از Worker Thread باید درخواست را به UI Thread <strong>Marshal</strong> کنید:</p>
<ul>
<li><strong>WPF</strong> → با <code>Dispatcher.BeginInvoke</code> یا <code>Dispatcher.Invoke</code></li>
<li><strong>UWP</strong> → با <code>Dispatcher.RunAsync</code> یا <code>Dispatcher.Invoke</code></li>
<li><strong>Windows Forms</strong> → با <code>Control.BeginInvoke</code> یا <code>Control.Invoke</code></li>
</ul>
<p><code>BeginInvoke</code>/<code>RunAsync</code> Delegate را در صف پیام UI می‌گذارند (غیرمسدودکننده).
<code>Invoke</code> همان کار را می‌کند، اما تا پردازش Delegate توسط UI Thread صبر می‌کند (مسدودکننده و با امکان بازگشت مقدار).</p>
<hr>
<h2>📝 مثال در WPF</h2>
<p>فرض کنید یک پنجره WPF داریم که شامل TextBoxی به نام <code>txtMessage</code> است. می‌خواهیم پس از یک کار زمان‌بر، متن آن را تغییر دهیم:</p>
<pre><code class="language-csharp">partial class MyWindow : Window
{
    public MyWindow()
    {
        InitializeComponent();
        new Thread (Work).Start();
    }

    void Work()
    {
        Thread.Sleep (5000);           // شبیه‌سازی کار زمان‌بر
        UpdateMessage (&quot;The answer&quot;);
    }

    void UpdateMessage (string message)
    {
        Action action = () =&gt; txtMessage.Text = message;
        Dispatcher.BeginInvoke (action);
    }
}
</code></pre>
<p>🔹 پنجره فوراً پاسخ‌گو خواهد بود.
🔹 بعد از ۵ ثانیه، TextBox به‌روزرسانی می‌شود.</p>
<p>در Windows Forms هم مشابه است، با این تفاوت که باید از متد <code>BeginInvoke</code> فرم استفاده کنید:</p>
<pre><code class="language-csharp">void UpdateMessage (string message)
{
    Action action = () =&gt; txtMessage.Text = message;
    this.BeginInvoke (action);
}
</code></pre>
<hr>
<h2>🪟 چندین UI Thread</h2>
<p>در یک برنامه می‌توان چندین UI Thread داشت، هرکدام مالک یک <strong>پنجره‌ی مستقل</strong>.
این معمولاً در <strong>SDI Applications</strong> (مثل Microsoft Word) استفاده می‌شود. هر پنجره‌ی مستقل می‌تواند UI Thread خودش را داشته باشد تا پاسخ‌گویی بیشتری به کاربر ارائه دهد.</p>
<h3>کانتکست‌های همگام‌سازی (Synchronization Contexts) 🔄</h3>
<p>در فضای نام <strong>System.ComponentModel</strong> کلاسی به نام <strong>SynchronizationContext</strong> وجود دارد که امکان <strong>عمومیت دادن به Thread Marshaling</strong> را فراهم می‌کند.</p>
<p>📱💻 در APIهای مربوط به rich-client برای موبایل و دسکتاپ (یعنی <strong>UWP، WPF و Windows Forms</strong>) هرکدام زیرکلاسی از <strong>SynchronizationContext</strong> تعریف و ایجاد می‌کنند. شما می‌توانید این نمونه را از طریق ویژگی (Property) ایستا به نام <strong>SynchronizationContext.Current</strong> (وقتی روی یک UI thread در حال اجرا هستید) به‌دست آورید.</p>
<p>گرفتن این property به شما اجازه می‌دهد بعداً از داخل یک worker thread به کنترل‌های UI “post” کنید:</p>
<pre><code class="language-csharp">partial class MyWindow : Window
{
    SynchronizationContext _uiSyncContext;

    public MyWindow()
    {
        InitializeComponent();
        // گرفتن کانتکست همگام‌سازی برای UI thread جاری:
        _uiSyncContext = SynchronizationContext.Current;
        new Thread(Work).Start();
    }

    void Work()
    {
        Thread.Sleep(5000);   // شبیه‌سازی یک کار زمان‌بر
        UpdateMessage(&quot;The answer&quot;);
    }

    void UpdateMessage(string message)
    {
        // Marshal کردن delegate به UI thread:
        _uiSyncContext.Post(_ =&gt; txtMessage.Text = message, null);
    }
}
</code></pre>
<p>🔑 این روش مفید است چون در همه‌ی APIهای رابط کاربری rich-client به یک شکل کار می‌کند.</p>
<p>فراخوانی <strong>Post</strong> معادل فراخوانی <strong>BeginInvoke</strong> روی یک Dispatcher یا Control است. همچنین متدی به نام <strong>Send</strong> وجود دارد که معادل <strong>Invoke</strong> است.</p>
<hr>
<h3>Thread Pool 🏊‍♂️</h3>
<p>وقتی یک thread جدید ایجاد می‌کنید، چند صد میکروثانیه صرف آماده‌سازی چیزهایی مثل stack متغیرهای محلی می‌شود. <strong>Thread Pool</strong> این overhead را کاهش می‌دهد چون شامل مجموعه‌ای از threadهای از پیش ساخته‌شده و قابل بازیافت است.</p>
<p>🔹 استفاده از Thread Pool برای برنامه‌نویسی موازی کارآمد و <strong>Concurrency</strong> ریزدانه‌ای ضروری است. این کار اجازه می‌دهد عملیات‌های کوتاه اجرا شوند بدون اینکه overhead ایجاد Thread زیاد شود.</p>
<p>اما هنگام استفاده از pooled threadها باید چند نکته را در نظر بگیرید:</p>
<ul>
<li>🚫 نمی‌توانید خاصیت <strong>Name</strong> را برای pooled threadها تنظیم کنید (اشکال‌زدایی سخت‌تر می‌شود، گرچه در Visual Studio می‌توانید یک description به آن‌ها اضافه کنید).</li>
<li>🕑 pooled threadها همیشه <strong>background thread</strong> هستند.</li>
<li>❌ بلاک کردن pooled threadها می‌تواند عملکرد را کاهش دهد (نگاه کنید به «Hygiene in the thread pool»).</li>
</ul>
<p>می‌توانید <strong>Priority</strong> یک pooled thread را تغییر دهید؛ وقتی thread آزاد شود و به Pool برگردد، مقدارش دوباره روی Normal تنظیم می‌شود.</p>
<p>برای بررسی اینکه آیا در حال حاضر روی یک pooled thread در حال اجرا هستید یا نه، می‌توانید از خاصیت <strong>Thread.CurrentThread.IsThreadPoolThread</strong> استفاده کنید.</p>
<hr>
<h3>ورود به Thread Pool 🚀</h3>
<p>ساده‌ترین راه اجرای صریح یک کار در thread pool استفاده از <strong>Task.Run</strong> است (این موضوع را در بخش بعدی کامل‌تر توضیح می‌دهیم):</p>
<pre><code class="language-csharp">// Task در فضای نام System.Threading.Tasks است
Task.Run(() =&gt; Console.WriteLine(&quot;Hello from the thread pool&quot;));
</code></pre>
<p>قبل از نسخه‌ی <strong>.NET Framework 4.0</strong> که Task وجود نداشت، روش رایج استفاده از <strong>ThreadPool.QueueUserWorkItem</strong> بود:</p>
<pre><code class="language-csharp">ThreadPool.QueueUserWorkItem(notUsed =&gt; Console.WriteLine(&quot;Hello&quot;));
</code></pre>
<p>همچنین استفاده‌های زیر به‌طور ضمنی از thread pool بهره می‌برند:</p>
<ul>
<li>🌐 سرورهای اپلیکیشن <strong>ASP.NET Core</strong> و <strong>Web API</strong></li>
<li>⏱️ کلاس‌های <strong>System.Timers.Timer</strong> و <strong>System.Threading.Timer</strong></li>
<li>📊 ساختارهای برنامه‌نویسی موازی (توضیح در فصل 22)</li>
<li>⚙️ کلاس قدیمی <strong>BackgroundWorker</strong></li>
</ul>
<hr>
<h3>رعایت بهداشت در Thread Pool 🧹</h3>
<p>Thread Pool وظیفه دیگری هم دارد: جلوگیری از ایجاد <strong>oversubscription</strong>.</p>
<p>❗ Oversubscription یعنی تعداد threadهای فعال بیشتر از تعداد هسته‌های CPU باشد و سیستم‌عامل مجبور شود بین آن‌ها time-slice انجام دهد. این کار کارایی را کاهش می‌دهد چون context switch پرهزینه است و cacheهای CPU را هم بی‌اعتبار می‌کند.</p>
<p>✅ CLR از oversubscription جلوگیری می‌کند با:</p>
<ul>
<li>صف‌بندی (queue) کردن تسک‌ها</li>
<li>و کنترل شروع آن‌ها</li>
</ul>
<p>اول به اندازه تعداد هسته‌های سخت‌افزاری تسک‌ها را به‌طور همزمان اجرا می‌کند، سپس با استفاده از یک الگوریتم hill-climbing سطح Concurrency را تنظیم می‌کند. اگر throughput بهتر شود، در همان جهت ادامه می‌دهد وگرنه مسیرش را عوض می‌کند.</p>
<p>این استراتژی در صورتی بهترین عملکرد را دارد که:</p>
<ol>
<li>🕒 کارها کوتاه‌مدت باشند (کمتر از ۲۵۰ میلی‌ثانیه، و ترجیحاً زیر ۱۰۰ میلی‌ثانیه).</li>
<li>🚫 کارهایی که بیشتر وقتشان را در حالت <strong>Blocked</strong> هستند، غالب نباشند.</li>
</ol>
<p>بلاک شدن مشکل‌ساز است چون CLR تصور می‌کند CPU درگیر است. CLR هوشمند است و برای جبران threadهای بیشتری وارد Pool می‌کند؛ اما این کار می‌تواند دوباره به oversubscription منجر شود و همچنین باعث تأخیر (latency) شود، مخصوصاً در ابتدای اجرای اپلیکیشن (بیشتر در سیستم‌عامل‌های client که مصرف منابع پایین‌تری ترجیح داده می‌شود).</p>
<p>👌 رعایت بهداشت در Thread Pool وقتی اهمیت بیشتری دارد که بخواهید CPU را به‌طور کامل استفاده کنید (مثلاً با استفاده از APIهای برنامه‌نویسی موازی در فصل 22).</p>
<h3>تسک‌ها (Tasks) ⚡</h3>
<p>🔹 یک <strong>Thread</strong> ابزاری سطح پایین برای ایجاد <strong>Concurrency</strong> است و محدودیت‌هایی دارد، از جمله:</p>
<ul>
<li>📥 اگرچه فرستادن داده به داخل یک Thread که ایجاد کرده‌اید ساده است، گرفتن یک <strong>مقدار بازگشتی (return value)</strong> از Threadی که Join کرده‌اید آسان نیست. باید یک <strong>فیلد مشترک</strong> تنظیم کنید. همچنین اگر عملیات یک <strong>Exception</strong> پرتاب کند، گرفتن و منتقل کردن آن هم دردسر دارد.</li>
<li>🔄 نمی‌توانید به Thread بگویید وقتی تمام شد چیزی دیگری را شروع کند؛ بلکه باید آن را Join کنید (که باعث بلاک شدن Thread خودتان می‌شود).</li>
</ul>
<p>این محدودیت‌ها باعث می‌شوند <strong>Concurrency ریزدانه‌ای (fine-grained)</strong> سخت شود؛ یعنی ترکیب عملیات‌های کوچک‌تر برای ساخت عملیات‌های همزمان بزرگ‌تر مشکل است (که برای <strong>برنامه‌نویسی Asynchronous</strong> حیاتی است). در نتیجه نیاز به <strong>synchronization دستی</strong> (مثل Locking، Signaling و غیره) بیشتر می‌شود که خودش مشکلات دیگری دارد.</p>
<p>همچنین استفاده مستقیم از Threadها اثرات منفی روی <strong>کارایی</strong> دارد (توضیح در بخش «Thread Pool»). اگر نیاز به اجرای صدها یا هزاران عملیات I/O همزمان داشته باشید، رویکرد Thread‌محور باعث مصرف صدها یا هزاران مگابایت حافظه صرفاً برای overhead مربوط به Threadها می‌شود.</p>
<p>✅ کلاس <strong>Task</strong> به همه این مشکلات کمک می‌کند. <strong>Task</strong> نسبت به Thread یک <strong>انتزاع سطح بالاتر</strong> است؛ یعنی نشان‌دهنده یک عملیات همزمان است که ممکن است پشتیبانی‌شده توسط Thread باشد یا نباشد.</p>
<p>ویژگی‌ها:</p>
<ul>
<li>🔗 <strong>Taskها ترکیب‌پذیر (compositional)</strong> هستند (می‌توانید آن‌ها را با استفاده از Continuationها به هم زنجیر کنید).</li>
<li>🏊 می‌توانند از Thread Pool استفاده کنند تا زمان شروع را کم کنند.</li>
<li>📞 با استفاده از <strong>TaskCompletionSource</strong> می‌توانند رویکرد Callback را پیاده‌سازی کنند که اصلاً نیازی به Threadها ندارد (مناسب برای عملیات I/O-bound).</li>
</ul>
<p>کلاس‌های Task در <strong>.NET Framework 4.0</strong> به‌عنوان بخشی از کتابخانه برنامه‌نویسی موازی معرفی شدند، و بعداً با <strong>awaiters</strong> بهبود پیدا کردند تا در سناریوهای عمومی Concurrency هم خوب کار کنند. آن‌ها همچنین پایه‌ی <strong>توابع Asynchronous در C#</strong> هستند.</p>
<p>(در این بخش، ویژگی‌های Task مرتبط با <strong>برنامه‌نویسی موازی</strong> را کنار می‌گذاریم و در فصل 22 به آن‌ها می‌پردازیم.)</p>
<hr>
<h3>شروع یک Task ▶️</h3>
<p>ساده‌ترین راه برای شروع یک Task پشتیبانی‌شده توسط Thread استفاده از متد ایستای <strong>Task.Run</strong> است (کلاس Task در فضای نام <strong>System.Threading.Tasks</strong> است):</p>
<pre><code class="language-csharp">Task.Run(() =&gt; Console.WriteLine(&quot;Foo&quot;));
</code></pre>
<p>به‌طور پیش‌فرض، Taskها روی <strong>Thread Pool</strong> اجرا می‌شوند که <strong>background thread</strong> هستند.
یعنی وقتی <strong>main thread</strong> تمام شود، همه Taskهایی که ساخته‌اید هم متوقف می‌شوند.</p>
<p>پس در یک <strong>Console Application</strong>، باید main thread را بعد از شروع Task بلاک کنید (مثلاً با <strong>Wait</strong> روی Task یا با <strong>Console.ReadLine</strong>):</p>
<pre><code class="language-csharp">Task.Run(() =&gt; Console.WriteLine(&quot;Foo&quot;));
Console.ReadLine();
</code></pre>
<p>در <strong>LINQPad</strong> نیازی به <code>Console.ReadLine</code> نیست، چون پروسه‌ی LINQPad به‌طور خودکار background threadها را زنده نگه می‌دارد.</p>
<p>فراخوانی <strong>Task.Run</strong> تقریباً شبیه به ایجاد یک Thread است:</p>
<pre><code class="language-csharp">new Thread(() =&gt; Console.WriteLine(&quot;Foo&quot;)).Start();
</code></pre>
<p>اما <code>Task.Run</code> یک <strong>Task object</strong> برمی‌گرداند که می‌توانیم وضعیت پیشرفت آن را مانیتور کنیم (مشابه Thread object).
توجه کنید که بعد از <code>Task.Run</code> دیگر <strong>Start</strong> نمی‌زنیم چون این متد <strong>Hot Task</strong> ایجاد می‌کند. (می‌توانید با سازنده‌ی Task یک <strong>Cold Task</strong> بسازید، اما در عمل کم‌استفاده است.)</p>
<p>می‌توانید وضعیت اجرای Task را از طریق خاصیت <strong>Status</strong> بررسی کنید.</p>
<hr>
<h3>Wait ⏳</h3>
<p>فراخوانی <strong>Wait</strong> روی یک Task باعث بلاک شدن می‌شود تا Task کامل شود (مشابه فراخوانی <strong>Join</strong> روی یک Thread):</p>
<pre><code class="language-csharp">Task task = Task.Run(() =&gt;
{
    Thread.Sleep(2000);
    Console.WriteLine(&quot;Foo&quot;);
});
Console.WriteLine(task.IsCompleted);  // False
task.Wait();  // تا تکمیل Task بلاک می‌شود
</code></pre>
<p>متد Wait امکان تعیین <strong>Timeout</strong> و <strong>CancellationToken</strong> را هم می‌دهد (توضیح در بخش «Cancellation» صفحه 681).</p>
<hr>
<h3>Long-running Tasks 🐢</h3>
<p>به‌طور پیش‌فرض، CLR تسک‌ها را روی pooled threads اجرا می‌کند که برای کارهای <strong>کوتاه‌مدت و compute-bound</strong> ایده‌آل است.</p>
<p>برای کارهای <strong>بلندمدت یا blocking</strong> می‌توانید مانع استفاده از pooled thread شوید:</p>
<pre><code class="language-csharp">Task task = Task.Factory.StartNew(() =&gt; ...,
    TaskCreationOptions.LongRunning);
</code></pre>
<p>اجرای یک تسک بلندمدت روی یک pooled thread مشکلی ندارد؛ اما اگر چندین تسک بلندمدت موازی اجرا شوند (خصوصاً آن‌هایی که Block می‌شوند)، عملکرد کاهش می‌یابد.</p>
<p>راهکارهای بهتر در این حالت:</p>
<ul>
<li>اگر تسک‌ها <strong>I/O-bound</strong> هستند: از <strong>TaskCompletionSource</strong> و توابع <strong>Asynchronous</strong> برای پیاده‌سازی Concurrency با Callbackها استفاده کنید.</li>
<li>اگر تسک‌ها <strong>Compute-bound</strong> هستند: از یک <strong>Producer/Consumer Queue</strong> استفاده کنید تا Concurrency را کنترل کرده و جلوی گرسنگی سایر Threadها و پروسه‌ها را بگیرید (توضیح در «Producer/Consumer Queue» صفحه 970).</li>
</ul>
<hr>
<h3>بازگرداندن مقادیر 🔢</h3>
<p>کلاس Task یک زیرکلاس جنریک به نام <strong>Task<TResult></strong> دارد که اجازه می‌دهد یک مقدار بازگشتی تولید کند.</p>
<p>می‌توانید با دادن یک <strong>Func<TResult></strong> (یا lambda expression سازگار) به Task.Run یک Task<TResult> بسازید:</p>
<pre><code class="language-csharp">Task&lt;int&gt; task = Task.Run(() =&gt; 
{ 
    Console.WriteLine(&quot;Foo&quot;); 
    return 3; 
});
int result = task.Result;   // بلاک می‌شود تا Task تمام شود
Console.WriteLine(result);  // 3
</code></pre>
<p>نمونه: محاسبه تعداد اعداد اول در سه میلیون عدد اول:</p>
<pre><code class="language-csharp">Task&lt;int&gt; primeNumberTask = Task.Run(() =&gt;
    Enumerable.Range(2, 3000000)
              .Count(n =&gt; Enumerable.Range(2, (int)Math.Sqrt(n)-1)
              .All(i =&gt; n % i &gt; 0)));

Console.WriteLine(&quot;Task running...&quot;);
Console.WriteLine(&quot;The answer is &quot; + primeNumberTask.Result);
</code></pre>
<p>خروجی:</p>
<pre><code>Task running...
The answer is 216816
</code></pre>
<hr>
<h3>مدیریت Exceptionها ⚠️</h3>
<p>🔮 <strong>Task<TResult></strong> شبیه یک <em>Future</em> است، یعنی نتیجه‌ای را در آینده نگه می‌دارد.
برخلاف Threadها، تسک‌ها Exceptionها را راحت منتقل می‌کنند.</p>
<p>اگر کد داخل Task یک Exception مدیریت‌نشده پرتاب کند:</p>
<ul>
<li>اگر Wait کنید یا به Result دسترسی بزنید، Exception دوباره پرتاب می‌شود.</li>
</ul>
<pre><code class="language-csharp">// شروع یک Task که NullReferenceException پرتاب می‌کند:
Task task = Task.Run(() =&gt; { throw null; });

try
{
    task.Wait();
}
catch (AggregateException aex)
{
    if (aex.InnerException is NullReferenceException)
        Console.WriteLine(&quot;Null!&quot;);
    else
        throw;
}
</code></pre>
<p>🧩 CLR Exception را در یک <strong>AggregateException</strong> بسته‌بندی می‌کند تا با سناریوهای برنامه‌نویسی موازی هم‌خوانی داشته باشد (توضیح در فصل 22).</p>
<p>می‌توانید بدون پرتاب Exception بررسی کنید که آیا Task Faulted شده یا نه، با استفاده از ویژگی‌های:</p>
<ul>
<li><strong>IsFaulted</strong></li>
<li><strong>IsCanceled</strong></li>
</ul>
<p>اگر هر دو <code>false</code> باشند، خطایی رخ نداده.</p>
<ul>
<li>اگر <code>IsCanceled = true</code> باشد، یعنی یک <strong>OperationCanceledException</strong> پرتاب شده (توضیح در بخش «Cancellation» صفحه 941).</li>
<li>اگر <code>IsFaulted = true</code> باشد، نوع دیگری از Exception رخ داده و خاصیت <strong>Exception</strong> جزئیات خطا را نشان می‌دهد.</li>
</ul>
<h3>استثناها و Taskهای مستقل 🚨</h3>
<p>در مورد Taskهای مستقل یا همان <strong>set-and-forget</strong> (یعنی آن‌هایی که شما دیگر با <code>Wait()</code> یا <code>Result</code> یا continuation به سراغشان نمی‌روید)، یک <strong>روش درست</strong> این است که حتماً کد Task را به‌صورت صریح مدیریت استثنا بنویسید تا از شکست‌های خاموش جلوگیری کنید؛ دقیقاً همان‌طور که در یک Thread عادی عمل می‌کنید.</p>
<p>نادیده گرفتن استثناها زمانی مشکلی ندارد که آن استثنا فقط به معنی شکست در گرفتن نتیجه‌ای باشد که دیگر به آن علاقه‌ای ندارید.
📌 برای مثال، اگر کاربر درخواست دانلود یک صفحه وب را لغو کند، برایمان مهم نیست که در ادامه مشخص شود آن صفحه اصلاً وجود نداشته است.</p>
<p>اما نادیده گرفتن استثنا زمانی مشکل‌ساز می‌شود که آن استثنا نشان‌دهنده‌ی یک <strong>باگ در برنامه</strong> باشد؛ به دو دلیل:</p>
<ul>
<li>🛑 ممکن است باگ باعث شود برنامه در یک وضعیت نامعتبر باقی بماند.</li>
<li>🧩 احتمال دارد استثناهای بیشتری در آینده رخ دهند و اگر خطای اولیه ثبت (log) نشود، تشخیص مشکل سخت خواهد شد.</li>
</ul>
<p>شما می‌توانید استثناهای مشاهده‌نشده را در سطح سراسری مدیریت کنید، از طریق رویداد استاتیک <code>TaskScheduler.UnobservedTaskException</code>. مدیریت این رویداد و ثبت خطا می‌تواند بسیار منطقی باشد.</p>
<hr>
<h3>نکات ظریف درباره‌ی استثناهای مشاهده‌نشده 🕵️‍♂️</h3>
<p>چند نکته جالب در مورد اینکه چه چیزی <strong>unobserved</strong> محسوب می‌شود وجود دارد:</p>
<ul>
<li>اگر روی یک Task با زمان‌بندی (timeout) منتظر بمانید و خطا بعد از پایان زمان رخ دهد، آن خطا به‌عنوان استثنای مشاهده‌نشده در نظر گرفته می‌شود.</li>
<li>همین که ویژگی <code>Exception</code> یک Task را بعد از fault شدن بررسی کنید، آن استثنا «observed» محسوب می‌شود.</li>
</ul>
<hr>
<h3>Continuations 🔗</h3>
<p>یک Continuation به یک Task می‌گوید: «وقتی کارت تمام شد، ادامه بده و یک کار دیگر انجام بده.»
معمولاً Continuation به‌صورت یک <strong>callback</strong> پیاده‌سازی می‌شود که درست پس از اتمام عملیات اجرا می‌گردد.</p>
<p>دو روش برای اتصال Continuation به یک Task وجود دارد. روش اول اهمیت ویژه‌ای دارد، چون توسط توابع <strong>asynchronous در C#</strong> استفاده می‌شود. مثال زیر را در نظر بگیرید (همان مثال شمارش اعداد اول):</p>
<pre><code class="language-csharp">Task&lt;int&gt; primeNumberTask = Task.Run(() =&gt;
  Enumerable.Range(2, 3000000).Count(n =&gt; 
    Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =&gt; n % i &gt; 0)));

var awaiter = primeNumberTask.GetAwaiter();
awaiter.OnCompleted(() =&gt;
{
  int result = awaiter.GetResult();
  Console.WriteLine(result); // نمایش نتیجه
});
</code></pre>
<p>فراخوانی <code>GetAwaiter</code> روی یک Task، یک <strong>awaiter object</strong> برمی‌گرداند که متد <code>OnCompleted</code> آن، به Task می‌گوید پس از پایان (یا خطا)، کدام delegate اجرا شود.
حتی می‌توانید یک Continuation را روی Taskی که قبلاً کامل شده وصل کنید؛ در این صورت، Continuation بلافاصله زمان‌بندی و اجرا می‌شود.</p>
<p>یک <strong>awaiter</strong> هر شیئی است که دو متد (<code>OnCompleted</code> و <code>GetResult</code>) و یک ویژگی بولی (<code>IsCompleted</code>) داشته باشد. هیچ interface یا کلاس پایه‌ی مشترکی برای همه این موارد وجود ندارد (البته <code>OnCompleted</code> بخشی از اینترفیس <code>INotifyCompletion</code> است).</p>
<p>📌 اگر Task مادر fault شود، استثنا زمانی که continuation فراخوانی <code>GetResult()</code> را انجام می‌دهد دوباره پرتاب می‌شود.
برتری <code>GetResult</code> نسبت به دسترسی مستقیم به <code>Result</code> این است که استثناها را بدون بسته‌بندی در <code>AggregateException</code> پرتاب می‌کند، که باعث کدهای <code>catch</code> تمیزتر می‌شود.</p>
<hr>
<h3>نکته درباره‌ی Synchronization Context 🎛️</h3>
<p>اگر یک <strong>SynchronizationContext</strong> وجود داشته باشد، <code>OnCompleted</code> آن را به‌طور خودکار capture می‌کند و continuation را در همان context اجرا می‌کند. این برای اپلیکیشن‌های رابط کاربری (UI) بسیار مفید است، چون Continuation به نخ UI بازگردانده می‌شود.</p>
<p>اما در کتابخانه‌ها معمولاً مطلوب نیست، چون این پرش به نخ UI هزینه‌بر است.
برای جلوگیری از آن می‌توان از متد <code>ConfigureAwait(false)</code> استفاده کرد:</p>
<pre><code class="language-csharp">var awaiter = primeNumberTask.ConfigureAwait(false).GetAwaiter();
</code></pre>
<p>اگر هیچ SynchronizationContextای وجود نداشته باشد—یا شما <code>ConfigureAwait(false)</code> استفاده کنید—Continuation به‌طور کلی روی یک <strong>pooled thread</strong> اجرا می‌شود.</p>
<hr>
<h3>روش دوم: ContinueWith 🧩</h3>
<p>روش دیگر اتصال Continuation، فراخوانی متد <code>ContinueWith</code> روی Task است:</p>
<pre><code class="language-csharp">primeNumberTask.ContinueWith(antecedent =&gt;
{
  int result = antecedent.Result;
  Console.WriteLine(result); // نمایش 123
});
</code></pre>
<p>🔹 <code>ContinueWith</code> خودش یک Task برمی‌گرداند، بنابراین می‌توانید چندین Continuation زنجیره‌ای بسازید.
اما در این حالت باید به‌صورت مستقیم با <code>AggregateException</code> سروکار داشته باشید و برای اپلیکیشن‌های UI کد اضافی برای <strong>marshal کردن</strong> Continuation بنویسید.
همچنین در محیط‌های غیر UI، اگر بخواهید Continuation روی همان نخ اجرا شود، باید گزینه‌ی <code>TaskContinuationOptions.ExecuteSynchronously</code> را مشخص کنید؛ در غیر این صورت به thread pool پرش خواهد کرد.</p>
<p>📌 <code>ContinueWith</code> به‌ویژه در سناریوهای <strong>parallel programming</strong> مفید است (در فصل 22 به‌طور کامل بررسی خواهد شد).</p>
<hr>
<h3>TaskCompletionSource ⚡</h3>
<p>تا اینجا دیدیم که <code>Task.Run</code> یک Task می‌سازد که delegate را روی یک نخ (pooled یا غیر pooled) اجرا می‌کند. اما روش دیگر استفاده از <code>TaskCompletionSource</code> است.</p>
<p><code>TaskCompletionSource</code> به شما اجازه می‌دهد یک Task بسازید که حاصل هر عملیاتی باشد که در آینده کامل خواهد شد. این کار از طریق ساخت یک Task «وابسته» انجام می‌شود که شما به‌طور دستی کنترلش می‌کنید (با مشخص کردن زمان پایان یا fault شدن عملیات).</p>
<p>این روش برای عملیات‌های I/O-bound عالی است: شما همه مزایای Taskها (انتقال مقادیر بازگشتی، استثناها و Continuationها) را دارید، بدون اینکه یک نخ برای کل مدت اشغال شود.</p>
<p>برای استفاده، کافیست یک نمونه از کلاس بسازید. این کلاس یک ویژگی به نام <code>Task</code> دارد که همان Taskی است که می‌توانید روی آن منتظر بمانید یا Continuation وصل کنید. کنترل کامل Task هم با خود <code>TaskCompletionSource</code> است از طریق متدهای زیر:</p>
<pre><code class="language-csharp">public class TaskCompletionSource&lt;TResult&gt;
{
  public void SetResult (TResult result);
  public void SetException (Exception exception);
  public void SetCanceled();
  public bool TrySetResult (TResult result);
  public bool TrySetException (Exception exception);
  public bool TrySetCanceled();
  public bool TrySetCanceled (CancellationToken cancellationToken);
  ...
}
</code></pre>
<p>فراخوانی هرکدام از این متدها Task را سیگنال می‌دهد و آن را در وضعیت <strong>completed</strong>، <strong>faulted</strong> یا <strong>canceled</strong> قرار می‌دهد.</p>
<p>📌 انتظار این است که دقیقاً یکی از این متدها یک‌بار فراخوانی شود. اگر دوباره <code>SetResult</code>, <code>SetException</code> یا <code>SetCanceled</code> صدا زده شوند، استثنا پرتاب می‌کنند. درحالی‌که متدهای <code>Try*</code> فقط مقدار <code>false</code> برمی‌گردانند.</p>
<hr>
<h3>نمونه کد: چاپ عدد ۴۲ بعد از ۵ ثانیه 🕒</h3>
<pre><code class="language-csharp">var tcs = new TaskCompletionSource&lt;int&gt;();
new Thread(() =&gt; { Thread.Sleep(5000); tcs.SetResult(42); })
{ IsBackground = true }
.Start();
Task&lt;int&gt; task = tcs.Task;         
Console.WriteLine(task.Result);   // 42
</code></pre>
<hr>
<h3>نوشتن متد Run اختصاصی 🚀</h3>
<pre><code class="language-csharp">Task&lt;TResult&gt; Run&lt;TResult&gt;(Func&lt;TResult&gt; function)
{
  var tcs = new TaskCompletionSource&lt;TResult&gt;();
  new Thread(() =&gt;
  {
    try { tcs.SetResult(function()); }
    catch (Exception ex) { tcs.SetException(ex); }
  }).Start();
  return tcs.Task;
}
...
Task&lt;int&gt; task = Run(() =&gt; { Thread.Sleep(5000); return 42; });
</code></pre>
<p>این کار معادل فراخوانی <code>Task.Factory.StartNew</code> با گزینه‌ی <code>TaskCreationOptions.LongRunning</code> است.</p>
<hr>
<h3>قدرت اصلی TaskCompletionSource ⚡</h3>
<p>قدرت واقعی این روش در ساخت Taskهایی است که <strong>نخ را اشغال نمی‌کنند</strong>. برای مثال:
می‌خواهیم Taskی بسازیم که بعد از ۵ ثانیه مقدار ۴۲ را برگرداند. می‌توانیم بدون استفاده از Thread و فقط با استفاده از <code>Timer</code> این کار را انجام دهیم:</p>
<pre><code class="language-csharp">Task&lt;int&gt; GetAnswerToLife()
{
  var tcs = new TaskCompletionSource&lt;int&gt;();
  var timer = new System.Timers.Timer(5000) { AutoReset = false };
  timer.Elapsed += delegate { timer.Dispose(); tcs.SetResult(42); };
  timer.Start();
  return tcs.Task;
}
</code></pre>
<p>با وصل کردن یک Continuation به این Task:</p>
<pre><code class="language-csharp">var awaiter = GetAnswerToLife().GetAwaiter();
awaiter.OnCompleted(() =&gt; Console.WriteLine(awaiter.GetResult()));
</code></pre>
<hr>
<h3>ساخت متد Delay عمومی ⏱️</h3>
<p>می‌توانیم کدی بنویسیم که فقط صبر کند (بدون مقدار بازگشتی):</p>
<pre><code class="language-csharp">Task Delay(int milliseconds)
{
  var tcs = new TaskCompletionSource&lt;object&gt;();
  var timer = new System.Timers.Timer(milliseconds) { AutoReset = false };
  timer.Elapsed += delegate { timer.Dispose(); tcs.SetResult(null); };
  timer.Start();
  return tcs.Task;
}
</code></pre>
<p>📌 در .NET 5 به بعد، نسخه‌ی غیر generic از TaskCompletionSource معرفی شده است، بنابراین می‌توانید به‌جای <code>TaskCompletionSource&lt;object&gt;</code> از آن استفاده کنید.</p>
<hr>
<h3>اجرای ۱۰,۰۰۰ عملیات همزمان 🚀</h3>
<p>از آنجایی که این روش نخ‌ها را اشغال نمی‌کند، می‌توانیم هزاران عملیات را همزمان اجرا کنیم:</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10000; i++)
  Delay(5000).GetAwaiter().OnCompleted(() =&gt; Console.WriteLine(42));
</code></pre>
<p>تایمرها callbackهای خود را روی <strong>pooled threads</strong> اجرا می‌کنند. بنابراین بعد از ۵ ثانیه، thread pool درخواست‌های زیادی برای <code>SetResult(null)</code> دریافت می‌کند. اگر درخواست‌ها سریع‌تر از توان پردازش برسند، thread pool آن‌ها را در صف قرار می‌دهد و در سطح بهینه‌ی موازی‌سازی پردازش می‌کند.</p>
<p>از آنجایی که کار نخ‌ها کوتاه است (فقط فراخوانی <code>SetResult</code> و اجرای continuation)، این روش بسیار بهینه عمل می‌کند.</p>
<h3>⏳ <strong>Task.Delay</strong></h3>
<p>متدی که پیش‌تر نوشتیم به اندازه‌ای کاربردی است که به‌صورت یک متد استاتیک در کلاس <strong>Task</strong> در دسترس قرار گرفته است:</p>
<pre><code class="language-csharp">Task.Delay(5000).GetAwaiter().OnCompleted(() =&gt; Console.WriteLine(42));
</code></pre>
<p>یا:</p>
<pre><code class="language-csharp">Task.Delay(5000).ContinueWith(ant =&gt; Console.WriteLine(42));
</code></pre>
<p><strong>Task.Delay</strong> معادل asynchronous برای <strong>Thread.Sleep</strong> است.</p>
<hr>
<h3>📌 <strong>اصول Asynchrony (غیرهمزمانی)</strong></h3>
<p>در هنگام نمایش <strong>TaskCompletionSource</strong>، عملاً متدهای asynchronous نوشتیم. در این بخش دقیقاً تعریف می‌کنیم که عملیات asynchronous چیست و توضیح می‌دهیم چگونه این موضوع به برنامه‌نویسی asynchronous منجر می‌شود.</p>
<hr>
<h4>🔄 <strong>عملیات Synchronous در برابر Asynchronous</strong></h4>
<ul>
<li>یک عملیات <strong>synchronous</strong> کار خود را <strong>قبل از بازگشت به فراخواننده</strong> انجام می‌دهد.</li>
<li>یک عملیات <strong>asynchronous</strong> می‌تواند (بیشتر یا تمام) کار خود را <strong>بعد از بازگشت به فراخواننده</strong> انجام دهد.</li>
</ul>
<p>بیشتر متدهایی که می‌نویسید و صدا می‌زنید synchronous هستند. برای نمونه:</p>
<ul>
<li><code>List&lt;T&gt;.Add</code></li>
<li><code>Console.WriteLine</code></li>
<li><code>Thread.Sleep</code></li>
</ul>
<p>اما متدهای asynchronous کمتر رایج هستند و باعث <strong>ایجاد concurrency (هم‌زمانی)</strong> می‌شوند، زیرا کار به موازات فراخواننده ادامه پیدا می‌کند. این متدها معمولاً سریع (یا بلافاصله) به فراخواننده بازمی‌گردند؛ بنابراین به آن‌ها <strong>nonblocking methods</strong> نیز گفته می‌شود.</p>
<p>بیشتر متدهای asynchronous که تاکنون دیده‌ایم، متدهای <strong>general-purpose</strong> هستند، مثل:</p>
<ul>
<li><code>Thread.Start</code></li>
<li><code>Task.Run</code></li>
<li>متدهایی که continuation به taskها متصل می‌کنند</li>
</ul>
<p>علاوه بر این‌ها، برخی متدهای بخش <strong>Synchronization Contexts</strong> (مثل <code>Dispatcher.BeginInvoke</code>، ‏<code>Control.BeginInvoke</code> و ‏<code>SynchronizationContext.Post</code>) نیز asynchronous هستند. همچنین متدهایی که در بخش <strong>TaskCompletionSource</strong> نوشتیم (مثل <strong>Delay</strong>) هم asynchronous می‌باشند.</p>
<hr>
<h3>❓ <strong>برنامه‌نویسی Asynchronous چیست؟</strong></h3>
<p>اصل برنامه‌نویسی asynchronous این است که توابع <strong>طولانی یا بالقوه طولانی</strong> را به‌صورت asynchronous بنویسید.</p>
<p>این موضوع در تضاد با رویکرد سنتی است که توابع طولانی را به‌صورت synchronous نوشته و سپس آن‌ها را از یک thread یا task جدید فراخوانی می‌کند تا concurrency فراهم شود.</p>
<p>تفاوت در اینجاست که در رویکرد asynchronous، <strong>concurrency درون همان تابع طولانی</strong> آغاز می‌شود، نه از بیرون آن.</p>
<p>✅ این دو مزیت بزرگ دارد:</p>
<ol>
<li><strong>I/O-bound concurrency</strong> بدون اشغال thread قابل پیاده‌سازی است (همان‌طور که در بخش TaskCompletionSource دیدیم)، که باعث بهبود <strong>scalability</strong> و <strong>efficiency</strong> می‌شود.</li>
<li>در اپلیکیشن‌های <strong>rich-client</strong>، کد کمتری روی worker thread اجرا می‌شود، که <strong>thread-safety</strong> را ساده‌تر می‌کند.</li>
</ol>
<hr>
<h3>🎯 <strong>کاربردهای Asynchronous Programming</strong></h3>
<p>این منجر به دو کاربرد مشخص برای برنامه‌نویسی asynchronous می‌شود:</p>
<ol>
<li>
<p><strong>برنامه‌های سمت سرور (server-side)</strong> که نیاز به مدیریت کارآمد حجم بالایی از <strong>I/O همزمان</strong> دارند.</p>
<ul>
<li>چالش اینجا <strong>thread-safety</strong> نیست (چون معمولاً shared state کمی وجود دارد).</li>
<li>بلکه چالش <strong>بهره‌وری از thread</strong> است؛ مثلاً مصرف نکردن یک thread برای هر درخواست شبکه.</li>
</ul>
</li>
<li>
<p><strong>ساده‌سازی thread-safety در اپلیکیشن‌های rich-client.</strong></p>
<ul>
<li>وقتی برنامه بزرگ می‌شود، معمولاً متدهای بزرگ را به متدهای کوچک‌تر refactor می‌کنیم.</li>
<li>این موضوع باعث ایجاد زنجیره‌ای از متدها (call graph) می‌شود که همدیگر را صدا می‌زنند.</li>
<li>در حالت synchronous، اگر یکی از متدها طولانی باشد، کل زنجیره باید روی worker thread اجرا شود.</li>
<li>در حالت asynchronous، فقط وقتی thread لازم باشد شروع می‌کنیم (یا حتی اصلاً برای عملیات I/O نیازی به thread نیست).</li>
</ul>
</li>
</ol>
<p>این باعث ایجاد <strong>concurrency دقیق‌تر (fine-grained)</strong> می‌شود، یعنی مجموعه‌ای از عملیات‌های کوچک همزمان که بین آن‌ها اجرای برنامه به UI thread بازمی‌گردد.</p>
<hr>
<h3>⚖️ <strong>یک قانون سرانگشتی مهم</strong></h3>
<p>برای بهره‌مندی از مزایای asynchrony، هم عملیات‌های <strong>I/O-bound</strong> و هم عملیات‌های <strong>compute-bound</strong> باید asynchronous نوشته شوند.</p>
<ul>
<li>هر چیزی که بیشتر از <strong>۵۰ میلی‌ثانیه</strong> طول بکشد، کاندید مناسبی برای asynchronous است.</li>
<li>البته اگر بیش از حد عملیات کوچک را asynchronous کنید، کارایی کاهش می‌یابد (به دلیل overhead عملیات asynchronous).</li>
</ul>
<hr>
<h3>📱 <strong>UWP و تشویق به Asynchronous</strong></h3>
<p>فریم‌ورک <strong>UWP</strong> آن‌قدر برنامه‌نویسی asynchronous را تشویق می‌کند که نسخه‌های synchronous برخی متدهای طولانی اصلاً ارائه نشده‌اند یا حتی exception پرتاب می‌کنند.
بنابراین شما <strong>باید</strong> متدهای asynchronous را صدا بزنید که <strong>task</strong> بازمی‌گردانند (یا شئ‌هایی که با متد <strong>AsTask</strong> قابل تبدیل به task هستند).</p>
<hr>
<h3>🔗 <strong>Asynchronous Programming و Continuations</strong></h3>
<p>Taskها به‌خوبی با برنامه‌نویسی asynchronous سازگارند، زیرا از <strong>continuation</strong> پشتیبانی می‌کنند.</p>
<ul>
<li>برای عملیات <strong>I/O-bound</strong> از <strong>TaskCompletionSource</strong> استفاده می‌کنیم (مثل متد Delay).</li>
<li>برای عملیات <strong>compute-bound</strong> از <strong>Task.Run</strong> استفاده می‌کنیم.</li>
</ul>
<p>ویژگی مهم این است که سعی می‌کنیم <strong>در سطح پایین call graph</strong> این کار را انجام دهیم، تا در اپلیکیشن‌های rich-client متدهای سطح بالا روی UI thread باقی بمانند و بدون نگرانی از thread-safety به کنترل‌ها و shared state دسترسی داشته باشند.</p>
<hr>
<h3>🔢 <strong>نمونه کد: شمارش اعداد اول</strong></h3>
<pre><code class="language-csharp">int GetPrimesCount (int start, int count)
{
  return
    ParallelEnumerable.Range (start, count).Count (n =&gt; 
      Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i =&gt; n % i &gt; 0));
}
</code></pre>
<p>این تابع اعداد اول را می‌شمارد و از همه هسته‌های CPU استفاده می‌کند. اجرای آن طولانی است.</p>
<p>یک متد برای فراخوانی آن:</p>
<pre><code class="language-csharp">void DisplayPrimeCounts()
{
  for (int i = 0; i &lt; 10; i++)
    Console.WriteLine (GetPrimesCount (i*1000000 + 2, 1000000) +
      &quot; primes between &quot; + (i*1000000) + &quot; and &quot; + ((i+1)*1000000-1));
  Console.WriteLine (&quot;Done!&quot;);
}
</code></pre>
<p>خروجی:</p>
<pre><code>78498 primes between 0 and 999999
70435 primes between 1000000 and 1999999
67883 primes between 2000000 and 2999999
...
62090 primes between 9000000 and 9999999
</code></pre>
<p>در اینجا یک <strong>call graph</strong> داریم:</p>
<ul>
<li>‎<code>DisplayPrimeCounts</code> فراخوانی می‌کند ‎<code>GetPrimesCount</code> را.</li>
<li>در عمل، در اپلیکیشن‌های rich-client، این متد احتمالاً UI را به‌روزرسانی می‌کرد.</li>
</ul>
<hr>
<h3>⚡ <strong>اجرای coarse-grained concurrency</strong></h3>
<pre><code class="language-csharp">Task.Run(() =&gt; DisplayPrimeCounts());
</code></pre>
<hr>
<h3>✅ <strong>اجرای fine-grained concurrency (نسخه asynchronous)</strong></h3>
<pre><code class="language-csharp">Task&lt;int&gt; GetPrimesCountAsync (int start, int count)
{
  return Task.Run(() =&gt;
    ParallelEnumerable.Range (start, count).Count (n =&gt; 
      Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i =&gt; n % i &gt; 0)));
}
</code></pre>
<h3>🌟 <strong>چرا پشتیبانی زبان مهم است</strong></h3>
<p>اکنون باید <strong>DisplayPrimeCounts</strong> را تغییر دهیم تا <strong>GetPrimesCountAsync</strong> را فراخوانی کند.
اینجاست که کلیدواژه‌های <strong>async</strong> و <strong>await</strong> در C# وارد می‌شوند، زیرا بدون آن‌ها کار ساده نیست.</p>
<p>اگر فقط حلقه را به این شکل تغییر دهیم:</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
  var awaiter = GetPrimesCountAsync(i*1000000 + 2, 1000000).GetAwaiter();
  awaiter.OnCompleted(() =&gt;
    Console.WriteLine(awaiter.GetResult() + &quot; primes between... &quot;));
}
Console.WriteLine(&quot;Done&quot;);
</code></pre>
<ul>
<li>حلقه سریعاً ۱۰ بار تکرار می‌شود (زیرا متدها nonblocking هستند).</li>
<li>همه ۱۰ عملیات <strong>همزمان</strong> اجرا می‌شوند و پیام <strong>Done</strong> قبل از تمام شدن کارها چاپ می‌شود.</li>
</ul>
<hr>
<h3>⚠️ مشکل اجرای همزمان</h3>
<ul>
<li>در این مثال، اجرای موازی عملیات مطلوب نیست، زیرا خود متدها داخلی parallel شده‌اند و فقط باعث طولانی‌تر شدن زمان مشاهده اولین نتیجه می‌شود.</li>
<li>همچنین، ممکن است <strong>Task B به نتیجه Task A وابسته باشد</strong> (مثلاً در گرفتن صفحه وب، ابتدا DNS lookup و سپس HTTP request انجام می‌شود).</li>
</ul>
<p>برای اجرای <strong>توالی‌ای</strong>، باید iteration بعدی حلقه از continuation خود متد اجرا شود:</p>
<pre><code class="language-csharp">void DisplayPrimeCounts()
{
  DisplayPrimeCountsFrom(0);
}

void DisplayPrimeCountsFrom(int i)
{
  var awaiter = GetPrimesCountAsync(i*1000000 + 2, 1000000).GetAwaiter();
  awaiter.OnCompleted(() =&gt; 
  {
    Console.WriteLine(awaiter.GetResult() + &quot; primes between...&quot;);
    if (++i &lt; 10) DisplayPrimeCountsFrom(i);
    else Console.WriteLine(&quot;Done&quot;);
  });
}
</code></pre>
<ul>
<li>اگر بخواهیم <strong>DisplayPrimeCounts</strong> خودش asynchronous باشد و یک Task بازگرداند، باید از <strong>TaskCompletionSource</strong> استفاده کنیم.</li>
</ul>
<hr>
<h3>✅ <strong>راه حل ساده با async/await</strong></h3>
<p>C# این کار را برای ما ساده کرده است:</p>
<pre><code class="language-csharp">async Task DisplayPrimeCountsAsync()
{
  for (int i = 0; i &lt; 10; i++)
    Console.WriteLine(await GetPrimesCountAsync(i*1000000 + 2, 1000000) +
      &quot; primes between &quot; + (i*1000000) + &quot; and &quot; + ((i+1)*1000000-1));
  Console.WriteLine(&quot;Done!&quot;);
}
</code></pre>
<ul>
<li>کلیدواژه‌های <strong>async</strong> و <strong>await</strong> امکان پیاده‌سازی asynchronous را بدون پیچیدگی زیاد فراهم می‌کنند.</li>
</ul>
<hr>
<h3>🔄 <strong>چرا حلقه‌های imperative مشکل دارند؟</strong></h3>
<p>حلقه‌های <code>for</code> و <code>foreach</code> با continuations خوب ترکیب نمی‌شوند، زیرا روی <strong>state محلی فعلی متد</strong> تکیه دارند (مثلاً “چند بار دیگر حلقه اجرا می‌شود؟”).</p>
<ul>
<li>استفاده از <strong>async/await</strong> یک راه حل است.</li>
<li>راه دیگر، جایگزین کردن حلقه‌های imperative با معادل functional آن‌ها (مثل <strong>LINQ</strong>) است، که اساس <strong>Reactive Extensions (Rx)</strong> می‌باشد.</li>
<li>Rx برای جلوگیری از blocking روی <strong>push-based sequences</strong> کار می‌کند که مفهومی پیچیده دارد.</li>
</ul>
<hr>
<h3>🛠️ <strong>توابع Asynchronous در C#</strong></h3>
<p>کلیدواژه‌های <strong>async</strong> و <strong>await</strong> اجازه می‌دهند کد asynchronous با <strong>ساختار مشابه synchronous</strong> بنویسیم، بدون نیاز به نوشتن تمام plumbing داخلی asynchronous.</p>
<h4>Awaiting</h4>
<pre><code class="language-csharp">var result = await expression;
statement(s);
</code></pre>
<ul>
<li>توسط کامپایلر به چیزی مشابه این گسترش می‌یابد:</li>
</ul>
<pre><code class="language-csharp">var awaiter = expression.GetAwaiter();
awaiter.OnCompleted(() =&gt;
{
  var result = awaiter.GetResult();
  statement(s);
});
</code></pre>
<ul>
<li>کامپایلر همچنین برای <strong>سرویس‌دهی سریع در صورت تکمیل همزمان</strong> و مدیریت جزئیات دیگر، کد اضافه می‌کند.</li>
</ul>
<hr>
<h3>🔢 <strong>نمونه کد شمارش اعداد اول با await</strong></h3>
<pre><code class="language-csharp">Task&lt;int&gt; GetPrimesCountAsync(int start, int count)
{
  return Task.Run(() =&gt;
    ParallelEnumerable.Range(start, count).Count(n =&gt;
      Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i =&gt; n % i &gt; 0)));
}

async void DisplayPrimesCount()
{
  int result = await GetPrimesCountAsync(2, 1000000);
  Console.WriteLine(result);
}
</code></pre>
<ul>
<li>کلیدواژه <strong>async</strong> به کامپایلر می‌گوید که <code>await</code> در این متد، یک keyword است نه یک identifier.</li>
<li>async فقط روی <strong>آنچه داخل متد رخ می‌دهد</strong> تأثیر دارد و مشابه <code>unsafe</code>، تاثیری روی signature متد ندارد.</li>
<li>می‌تواند روی متدهای <code>void</code> یا <code>Task</code> و <code>Task&lt;TResult&gt;</code> اعمال شود.</li>
</ul>
<hr>
<h3>🔁 <strong>چگونگی کار await</strong></h3>
<ul>
<li>با رسیدن به یک <strong>await expression</strong>، اجرا معمولاً به فراخواننده بازمی‌گردد، مشابه <code>yield return</code> در iteratorها.</li>
<li>قبل از بازگشت، runtime یک <strong>continuation</strong> به task ضمیمه می‌کند.</li>
<li>وقتی task تکمیل شد، اجرا از همان نقطه ادامه می‌یابد.</li>
<li>در صورت خطا، exception بازتاب داده می‌شود و در غیر این صورت، مقدار بازگشتی به <strong>await expression</strong> اختصاص می‌یابد.</li>
</ul>
<h4>معادل منطقی</h4>
<pre><code class="language-csharp">void DisplayPrimesCount()
{
  var awaiter = GetPrimesCountAsync(2, 1000000).GetAwaiter();
  awaiter.OnCompleted(() =&gt;
  {
    int result = awaiter.GetResult();
    Console.WriteLine(result);
  });
}
</code></pre>
<ul>
<li>Await می‌تواند روی taskهای generic (<code>Task&lt;TResult&gt;</code>) یا nongeneric (<code>Task</code>) استفاده شود.</li>
<li>نمونه nongeneric:</li>
</ul>
<pre><code class="language-csharp">await Task.Delay(5000);
Console.WriteLine(&quot;Five seconds passed!&quot;);
</code></pre>
<h3>🔹 <strong>حفظ state محلی با await</strong></h3>
<p>یکی از قدرت‌های واقعی <strong>await</strong> این است که می‌تواند تقریباً در هر جایی از کد ظاهر شود (داخل یک تابع asynchronous)، به جز درون <code>lock</code> یا <code>unsafe context</code>.</p>
<p>مثال ساده داخل یک حلقه:</p>
<pre><code class="language-csharp">async void DisplayPrimeCounts()
{
  for (int i = 0; i &lt; 10; i++)
    Console.WriteLine(await GetPrimesCountAsync(i*1000000 + 2, 1000000));
}
</code></pre>
<ul>
<li>
<p>با اولین اجرای <code>GetPrimesCountAsync</code>، کنترل به فراخواننده بازمی‌گردد.</p>
</li>
<li>
<p>پس از تکمیل (یا خطا) متد، اجرای کد از همان نقطه ادامه می‌یابد.</p>
</li>
<li>
<p><strong>مقادیر متغیرهای محلی و شمارنده‌های حلقه حفظ می‌شوند</strong>.</p>
</li>
<li>
<p>کامپایلر این متدها را به یک <strong>state machine</strong> تبدیل می‌کند (مشابه iteratorها).</p>
</li>
<li>
<p>continuationها تضمین می‌کنند که بعد از <code>await</code>، اجرا دوباره از همان نقطه ادامه یابد.</p>
</li>
</ul>
<hr>
<h3>🔹 <strong>Await در رابط کاربری (UI)</strong></h3>
<p>فرض کنید می‌خواهیم یک UI ساده داشته باشیم که همزمان <strong>محاسبات سنگین</strong> انجام می‌دهد اما پاسخگو بماند.</p>
<h4>نسخه synchronous (غیرواکنش‌گرا)</h4>
<pre><code class="language-csharp">void Go()
{
  for (int i = 1; i &lt; 5; i++)
    _results.Text += GetPrimesCount(i*1000000, 1000000) + &quot; primes between ...&quot; + Environment.NewLine;
}
</code></pre>
<ul>
<li>در این حالت، برنامه <strong>برای مدتی قفل می‌شود</strong> و UI پاسخگو نیست.</li>
</ul>
<h4>نسخه asynchronous با Task.Run و await</h4>
<pre><code class="language-csharp">async void Go()
{
  _button.IsEnabled = false;
  for (int i = 1; i &lt; 5; i++)
    _results.Text += await GetPrimesCountAsync(i*1000000, 1000000) +
                     &quot; primes between ...&quot; + Environment.NewLine;
  _button.IsEnabled = true;
}
</code></pre>
<ul>
<li>کد داخل <code>Go</code> بر روی <strong>UI thread</strong> اجرا می‌شود و تنها <strong>GetPrimesCountAsync</strong> روی worker thread.</li>
<li>اجرای <code>Go</code> به صورت <strong>pseudo-concurrent</strong> با message loop رخ می‌دهد.</li>
<li><strong>نقاط preemption تنها هنگام await</strong> رخ می‌دهند، بنابراین thread safety ساده‌تر است.</li>
<li>با Task.Run، <strong>concurrency واقعی</strong> پایین‌تر در call stack رخ می‌دهد.</li>
</ul>
<hr>
<h3>🔹 مثال I/O-bound: دانلود صفحات وب</h3>
<pre><code class="language-csharp">async void Go()
{
  _button.IsEnabled = false;
  string[] urls = &quot;www.albahari.com www.oreilly.com www.linqpad.net&quot;.Split();
  int totalLength = 0;
  try
  {
    foreach (string url in urls)
    {
      var uri = new Uri(&quot;http://&quot; + url);
      byte[] data = await new WebClient().DownloadDataTaskAsync(uri);
      _results.Text += &quot;Length of &quot; + url + &quot; is &quot; + data.Length + Environment.NewLine;
      totalLength += data.Length;
    }
    _results.Text += &quot;Total length: &quot; + totalLength;
  }
  catch (WebException ex)
  {
    _results.Text += &quot;Error: &quot; + ex.Message;
  }
  finally
  {
    _button.IsEnabled = true;
  }
}
</code></pre>
<ul>
<li>کد <strong>شبیه نسخه synchronous</strong> نوشته شده است.</li>
<li>پس از اولین await، کنترل به caller بازمی‌گردد، اما continuation تضمین می‌کند که تمام بلاک <code>finally</code> بعد از تکمیل method اجرا شود.</li>
</ul>
<hr>
<h3>🔹 <strong>نحوه عملکرد زیر کاپوت</strong></h3>
<ul>
<li>UI thread یک <strong>message loop</strong> دارد که event handlerها را اجرا می‌کند.</li>
<li>اجرای <code>Go</code> تا رسیدن به await ادامه پیدا می‌کند، سپس کنترل به message loop بازمی‌گردد.</li>
<li>کامپایلر یک continuation ضمیمه می‌کند تا پس از تکمیل task، اجرای متد از همان نقطه ادامه یابد.</li>
<li>چون await روی <strong>UI thread</strong> انجام شده است، continuation به <strong>synchronization context</strong> ارسال می‌شود و دوباره توسط message loop اجرا می‌شود.</li>
<li>این مدل <strong>pseudo-concurrency</strong> را روی UI فراهم می‌کند و <strong>concurrency واقعی</strong> در Task.Run یا I/O-bound method رخ می‌دهد.</li>
</ul>
<h3>🔹 <strong>Coarse-Grained Concurrency vs Async/Await</strong></h3>
<p>قبل از C# 5، برنامه‌نویسی <strong>asynchronous</strong> دشوار بود:</p>
<ul>
<li>زبان هیچ پشتیبانی مستقیم نداشت.</li>
<li>فریمورک .NET متدهای asynchronous را با الگوهای پیچیده‌ای مانند <strong>EAP</strong> و <strong>APM</strong> ارائه می‌کرد.</li>
<li>راه‌حل رایج: <strong>coarse-grained concurrency</strong> با BackgroundWorker یا Task.Run.</li>
</ul>
<h4>مثال coarse-grained</h4>
<pre><code class="language-csharp">_button.Click += (sender, args) =&gt;
{
    _button.IsEnabled = false;
    Task.Run(() =&gt; Go());
};

void Go()
{
    for (int i = 1; i &lt; 5; i++)
    {
        int result = GetPrimesCount(i * 1000000, 1000000);
        Dispatcher.BeginInvoke(new Action(() =&gt;
            _results.Text += result + &quot; primes between ...&quot; + Environment.NewLine));
    }
    Dispatcher.BeginInvoke(new Action(() =&gt; _button.IsEnabled = true));
}
</code></pre>
<p>⚠️ مشکلات این روش:</p>
<ul>
<li>کل call graph (Go + GetPrimesCount) روی worker thread اجرا می‌شود.</li>
<li>برای دسترسی به UI باید از <code>Dispatcher.BeginInvoke</code> استفاده کرد.</li>
<li><strong>race conditions</strong> و خطاهای thread-safety به راحتی رخ می‌دهند، خصوصاً اگر داده‌ها یا تنظیمات از منابع غیر thread-safe خوانده شوند.</li>
</ul>
<hr>
<h3>🔹 <strong>نوشتن توابع Asynchronous با async/await</strong></h3>
<p>می‌توان <code>void</code> را با <code>Task</code> جایگزین کرد تا متد خود به صورت <strong>awaitable</strong> شود:</p>
<pre><code class="language-csharp">async Task PrintAnswerToLife()
{
    await Task.Delay(5000);
    int answer = 21 * 2;
    Console.WriteLine(answer);
}
</code></pre>
<ul>
<li>نیازی به return صریح Task نیست؛ کامپایلر <strong>Task</strong> را تولید می‌کند.</li>
<li>این امکان ایجاد <strong>chained async calls</strong> را فراهم می‌کند:</li>
</ul>
<pre><code class="language-csharp">async Task Go()
{
    await PrintAnswerToLife();
    Console.WriteLine(&quot;Done&quot;);
}
</code></pre>
<hr>
<h3>🔹 <strong>توسعه متد با TaskCompletionSource</strong></h3>
<p>معادل داخلی async/await:</p>
<pre><code class="language-csharp">Task PrintAnswerToLife()
{
    var tcs = new TaskCompletionSource&lt;object&gt;();
    var awaiter = Task.Delay(5000).GetAwaiter();
    awaiter.OnCompleted(() =&gt;
    {
        try
        {
            awaiter.GetResult(); // پرتاب استثنا در صورت وقوع
            int answer = 21 * 2;
            Console.WriteLine(answer);
            tcs.SetResult(null);
        }
        catch (Exception ex) { tcs.SetException(ex); }
    });
    return tcs.Task;
}
</code></pre>
<ul>
<li>وقتی متد asynchronous تمام می‌شود، اجرای کد به <strong>continuation</strong> منتقل می‌شود.</li>
<li>در rich-client scenario، ادامه اجرا به <strong>UI thread</strong> باز می‌گردد.</li>
</ul>
<hr>
<h3>🔹 <strong>Returning Task<TResult></strong></h3>
<pre><code class="language-csharp">async Task&lt;int&gt; GetAnswerToLife()
{
    await Task.Delay(5000);
    int answer = 21 * 2;
    return answer; // متد Task&lt;int&gt; برمی‌گرداند
}

async Task PrintAnswerToLife()
{
    int answer = await GetAnswerToLife();
    Console.WriteLine(answer);
}

async Task Go()
{
    await PrintAnswerToLife();
    Console.WriteLine(&quot;Done&quot;);
}
</code></pre>
<ul>
<li>این الگو مشابه برنامه‌نویسی synchronous است، اما بدون بلاک کردن thread.</li>
</ul>
<hr>
<h3>🔹 <strong>راهنمای طراحی متدهای Asynchronous در C#</strong></h3>
<ol>
<li>ابتدا متدها را به صورت synchronous بنویسید.</li>
<li>متدهای synchronous را با <strong>متدهای asynchronous</strong> جایگزین و <code>await</code> کنید.</li>
<li>به جز متدهای <strong>top-level</strong> (مثلاً event handlerها)، نوع بازگشتی متدهای asynchronous را به <code>Task</code> یا <code>Task&lt;TResult&gt;</code> تغییر دهید تا <strong>awaitable</strong> شوند.</li>
</ol>
<p>💡 نکته: نیازی به استفاده صریح از <code>TaskCompletionSource</code> نیست مگر در <strong>bottom-level methods</strong> که I/O-bound concurrency را مدیریت می‌کنند.</p>
<h3>اجرای نمودار فراخوانی‌های غیرهمزمان ⏱️</h3>
<p>برای اینکه دقیقاً ببینیم این کد چگونه اجرا می‌شود، مفید است که کد خود را به شکل زیر بازچینی کنیم:</p>
<pre><code class="language-csharp">async Task Go()
{
    var task = PrintAnswerToLife();
    await task;
    Console.WriteLine(&quot;Done&quot;);
}

async Task PrintAnswerToLife()
{
    var task = GetAnswerToLife();
    int answer = await task;
    Console.WriteLine(answer);
}

async Task&lt;int&gt; GetAnswerToLife()
{
    var task = Task.Delay(5000);
    await task;
    int answer = 21 * 2;
    return answer;
}
</code></pre>
<p>در اینجا، <code>Go</code> متد <code>PrintAnswerToLife</code> را فراخوانی می‌کند، که آن خود <code>GetAnswerToLife</code> را فراخوانی می‌کند، که در نهایت <code>Delay</code> را صدا می‌زند و منتظر می‌ماند. عبارت <code>await</code> باعث می‌شود اجرای کد به <code>PrintAnswerToLife</code> بازگردد، که آن نیز منتظر است و به <code>Go</code> بازمی‌گردد و در نهایت به فراخواننده بازمی‌گردد. همه این‌ها به صورت همزمان (synchronously) روی همان نخ (thread) که <code>Go</code> را فراخوانی کرده است اجرا می‌شود؛ این فاز کوتاه همزمان اجرای برنامه است.</p>
<p>پس از پنج ثانیه، ادامه‌ی اجرای <code>Delay</code> فراخوانی می‌شود و اجرای کد به <code>GetAnswerToLife</code> برمی‌گردد، روی یک نخ موجود در pool. (اگر از یک نخ UI شروع کرده باشیم، اجرای کد به همان نخ بازمی‌گردد.) سپس بقیه دستورات در <code>GetAnswerToLife</code> اجرا می‌شوند، و پس از آن <code>Task&lt;int&gt;</code> این متد با نتیجه ۴۲ تکمیل می‌شود و ادامه‌ی اجرای <code>PrintAnswerToLife</code> اجرا می‌شود و دستورات باقی‌مانده در آن متد اجرا می‌شوند. این روند تا زمانی که <code>Go</code> تکمیل شود ادامه پیدا می‌کند.</p>
<p>جریان اجرا مطابق نمودار فراخوانی همزمانی است که پیش‌تر نشان دادیم، زیرا الگوی ما این است که بلافاصله پس از فراخوانی هر متد غیرهمزمان، آن را <code>await</code> می‌کنیم. این باعث ایجاد جریان ترتیبی بدون موازی‌سازی یا اجرای همزمان درون نمودار فراخوانی می‌شود. هر عبارت <code>await</code> یک «وقفه» در اجرا ایجاد می‌کند و پس از آن برنامه از همان نقطه ادامه می‌یابد.</p>
<hr>
<h3>موازی‌سازی ⚡</h3>
<p>فراخوانی یک متد غیرهمزمان بدون <code>await</code> کردن آن، اجازه می‌دهد کد بعدی به صورت موازی اجرا شود. ممکن است در مثال‌های قبلی دیده باشید که یک دکمه داشتیم که handler آن <code>Go</code> را فراخوانی می‌کرد:</p>
<pre><code class="language-csharp">_button.Click += (sender, args) =&gt; Go();
</code></pre>
<p>با وجود اینکه <code>Go</code> یک متد غیرهمزمان است، ما آن را <code>await</code> نکردیم و این همان چیزی است که همزمانی لازم برای حفظ پاسخگویی UI را فراهم می‌کند.</p>
<p>می‌توانیم از همین اصل برای اجرای دو عملیات غیرهمزمان به صورت موازی استفاده کنیم:</p>
<pre><code class="language-csharp">var task1 = PrintAnswerToLife();
var task2 = PrintAnswerToLife();
await task1;
await task2;
</code></pre>
<p>(با <code>await</code> کردن هر دو عملیات بعداً، در آن نقطه موازی‌سازی «به پایان می‌رسد». بعداً با ترکیب‌کننده <code>WhenAll</code> این الگو را توضیح می‌دهیم.)</p>
<p>همزمانی ایجاد شده به این شکل، چه عملیات روی نخ UI آغاز شده باشد و چه نه، رخ می‌دهد، اگرچه تفاوتی در نحوه وقوع آن وجود دارد. در هر دو حالت، همان همزمانی واقعی در سطح پایین اتفاق می‌افتد (مثل <code>Task.Delay</code> یا کدی که به <code>Task.Run</code> سپرده شده است). متدهای بالاتر در call stack تنها در صورتی همزمانی واقعی خواهند داشت که عملیات بدون حضور <code>SynchronizationContext</code> آغاز شده باشد؛ در غیر این صورت، به همزمانی شبه‌واقعی (pseudo-concurrency) و ایمنی ساده‌شده نخ‌ها محدود می‌شوند، جایی که تنها نقطه‌ای که می‌توانیم متوقف شویم، عبارت <code>await</code> است. این اجازه می‌دهد که برای مثال، یک فیلد مشترک <code>_x</code> تعریف کرده و در <code>GetAnswerToLife</code> بدون قفل کردن آن را افزایش دهیم:</p>
<pre><code class="language-csharp">async Task&lt;int&gt; GetAnswerToLife()
{
    _x++;
    await Task.Delay(5000);
    return 21 * 2;
}
</code></pre>
<p>(با این حال، نمی‌توانیم فرض کنیم که <code>_x</code> قبل و بعد از <code>await</code> مقدار یکسانی دارد.)</p>
<hr>
<h3>عبارت‌های Lambda غیرهمزمان 🔹</h3>
<p>همانطور که متدهای معمولی نام‌دار می‌توانند غیرهمزمان باشند:</p>
<pre><code class="language-csharp">async Task NamedMethod()
{
    await Task.Delay(1000);
    Console.WriteLine(&quot;Foo&quot;);
}
</code></pre>
<p>همین‌طور می‌توان متدهای بدون نام (lambda و anonymous) را با پیشوند <code>async</code> نوشت:</p>
<pre><code class="language-csharp">Func&lt;Task&gt; unnamed = async () =&gt;
{
    await Task.Delay(1000);
    Console.WriteLine(&quot;Foo&quot;);
};
</code></pre>
<p>می‌توانیم آنها را فراخوانی و <code>await</code> کنیم:</p>
<pre><code class="language-csharp">await NamedMethod();
await unnamed();
</code></pre>
<p>همچنین می‌توان از Lambda غیرهمزمان هنگام attach کردن event handler استفاده کرد:</p>
<pre><code class="language-csharp">myButton.Click += async (sender, args) =&gt;
{
    await Task.Delay(1000);
    myButton.Content = &quot;Done&quot;;
};
</code></pre>
<p>این کوتاه‌تر از روش زیر است که همان اثر را دارد:</p>
<pre><code class="language-csharp">myButton.Click += ButtonHandler;
...
async void ButtonHandler(object sender, EventArgs args)
{
    await Task.Delay(1000);
    myButton.Content = &quot;Done&quot;;
};
</code></pre>
<p>Lambda غیرهمزمان می‌تواند <code>Task&lt;TResult&gt;</code> نیز بازگرداند:</p>
<pre><code class="language-csharp">Func&lt;Task&lt;int&gt;&gt; unnamed = async () =&gt;
{
    await Task.Delay(1000);
    return 123;
};
int answer = await unnamed();
</code></pre>
<hr>
<h3>جریان‌های غیرهمزمان 🌊</h3>
<p>با <code>yield return</code> می‌توان یک iterator نوشت؛ با <code>await</code> می‌توان یک متد غیرهمزمان نوشت. <strong>جریان‌های غیرهمزمان</strong> (از C# 8) این دو مفهوم را ترکیب می‌کنند و به شما امکان می‌دهند یک iterator بنویسید که در طول اجرای آن منتظر بماند و عناصر را به صورت غیرهمزمان برگرداند. این ویژگی بر اساس دو اینترفیس زیر ساخته شده است که نسخه‌های غیرهمزمان اینترفیس‌های شمارشی هستند:</p>
<pre><code class="language-csharp">public interface IAsyncEnumerable&lt;out T&gt;
{
    IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(...);
}

public interface IAsyncEnumerator&lt;out T&gt; : IAsyncDisposable
{
    T Current { get; }
    ValueTask&lt;bool&gt; MoveNextAsync();
}
</code></pre>
<p><code>ValueTask&lt;T&gt;</code> یک struct است که <code>Task&lt;T&gt;</code> را بسته‌بندی می‌کند و از نظر رفتار مشابه آن است و در عین حال اجرای کارآمدتری زمانی که تسک به صورت همزمان کامل شود، ارائه می‌دهد. <code>IAsyncDisposable</code> نسخه غیرهمزمان <code>IDisposable</code> است و امکان cleanup غیرهمزمان را فراهم می‌کند:</p>
<pre><code class="language-csharp">public interface IAsyncDisposable
{
    ValueTask DisposeAsync();
}
</code></pre>
<p>اقدام به گرفتن هر عنصر از توالی (<code>MoveNextAsync</code>) یک عملیات غیرهمزمان است، بنابراین جریان‌های غیرهمزمان مناسب زمانی هستند که عناصر به صورت تدریجی (مثلاً از یک ویدیو استریم) می‌رسند.</p>
<p>در مقابل، نوع زیر زمانی مناسب است که کل توالی تأخیر داشته باشد اما عناصر هنگام رسیدن همه با هم ارائه شوند:</p>
<pre><code class="language-csharp">Task&lt;IEnumerable&lt;T&gt;&gt;
</code></pre>
<p>برای ایجاد جریان غیرهمزمان، باید متدی نوشت که اصول iterator و متدهای غیرهمزمان را ترکیب کند. یعنی متد باید هم <code>yield return</code> و هم <code>await</code> داشته باشد و نوع بازگشتی آن <code>IAsyncEnumerable&lt;T&gt;</code> باشد:</p>
<pre><code class="language-csharp">async IAsyncEnumerable&lt;int&gt; RangeAsync(int start, int count, int delay)
{
    for (int i = start; i &lt; start + count; i++)
    {
        await Task.Delay(delay);
        yield return i;
    }
}
</code></pre>
<p>برای مصرف یک جریان غیرهمزمان، از <code>await foreach</code> استفاده کنید:</p>
<pre><code class="language-csharp">await foreach (var number in RangeAsync(0, 10, 500))
    Console.WriteLine(number);
</code></pre>
<p>توجه کنید که داده‌ها به صورت پیوسته هر ۵۰۰ میلی‌ثانیه (یا در واقعیت، به محض آماده شدن) می‌رسند. در مقایسه با همان ساختار با <code>Task&lt;IEnumerable&lt;T&gt;&gt;</code>، هیچ داده‌ای بازگردانده نمی‌شود تا آخرین عنصر آماده شود:</p>
<pre><code class="language-csharp">static async Task&lt;IEnumerable&lt;int&gt;&gt; RangeTaskAsync(int start, int count, int delay)
{
    List&lt;int&gt; data = new List&lt;int&gt;();
    for (int i = start; i &lt; start + count; i++)
    {
        await Task.Delay(delay);
        data.Add(i);
    }
    return data;
}
</code></pre>
<p>برای مصرف آن با <code>foreach</code>:</p>
<pre><code class="language-csharp">foreach (var data in await RangeTaskAsync(0, 10, 500))
    Console.WriteLine(data);
</code></pre>
<h3>پرس‌وجو روی IAsyncEnumerable<T> 🔍</h3>
<p>پکیج <strong>System.Linq.Async</strong>، عملگرهای LINQ را برای <strong>IAsyncEnumerable<T></strong> تعریف می‌کند، که به شما امکان می‌دهد کوئری‌ها را تقریباً همانند <strong>IEnumerable<T></strong> بنویسید.</p>
<p>برای مثال، می‌توانیم یک کوئری LINQ روی متد <strong>RangeAsync</strong> که در بخش قبل تعریف کردیم بنویسیم:</p>
<pre><code class="language-csharp">IAsyncEnumerable&lt;int&gt; query =
    from i in RangeAsync(0, 10, 500)
    where i % 2 == 0      // فقط اعداد زوج
    select i * 10;        // ضرب در ۱۰

await foreach (var number in query)
    Console.WriteLine(number);
</code></pre>
<p>این کد خروجی‌هایی مانند <code>0, 20, 40, ...</code> تولید می‌کند.</p>
<p>اگر با <strong>Rx</strong> آشنا هستید، می‌توانید از عملگرهای قوی‌تر آن نیز بهره ببرید، با فراخوانی متد <strong>ToObservable</strong> که یک <strong>IAsyncEnumerable<T></strong> را به <strong>IObservable<T></strong> تبدیل می‌کند. همچنین متد <strong>ToAsyncEnumerable</strong> برای تبدیل در جهت معکوس نیز وجود دارد.</p>
<hr>
<h3>IAsyncEnumerable<T> در ASP.Net Core 🌐</h3>
<p>اکشن‌های Controller در <strong>ASP.Net Core</strong> اکنون می‌توانند <strong>IAsyncEnumerable<T></strong> بازگردانند. چنین متدهایی باید با کلمه کلیدی <code>async</code> مشخص شوند. مثال:</p>
<pre><code class="language-csharp">[HttpGet]
public async IAsyncEnumerable&lt;string&gt; Get()
{
    using var dbContext = new BookContext();
    await foreach (var title in dbContext.Books
                                         .Select(b =&gt; b.Title)
                                         .AsAsyncEnumerable())
        yield return title;
}
</code></pre>
<hr>
<h3>متدهای غیرهمزمان در WinRT ⚡</h3>
<p>اگر در حال توسعه برنامه‌های <strong>UWP</strong> هستید، باید با انواع <strong>WinRT</strong> که در سیستم‌عامل تعریف شده‌اند کار کنید. معادل <strong>Task</strong> در WinRT، <strong>IAsyncAction</strong> و معادل <strong>Task<TResult></strong>، <strong>IAsyncOperation<TResult></strong> است. برای عملیات‌هایی که پیشرفت (Progress) گزارش می‌دهند، معادل‌ها عبارت‌اند از: <strong>IAsyncActionWithProgress<TProgress></strong> و <strong>IAsyncOperationWithProgress&lt;TResult, TProgress&gt;</strong>. همه این‌ها در namespace <strong>Windows.Foundation</strong> تعریف شده‌اند.</p>
<p>می‌توانید آنها را به <strong>Task</strong> یا <strong>Task<TResult></strong> تبدیل کنید با استفاده از <strong>AsTask</strong>:</p>
<pre><code class="language-csharp">Task&lt;StorageFile&gt; fileTask = KnownFolders.DocumentsLibrary
                                     .CreateFileAsync(&quot;test.txt&quot;)
                                     .AsTask();
</code></pre>
<p>یا مستقیماً <code>await</code> کنید:</p>
<pre><code class="language-csharp">StorageFile file = await KnownFolders.DocumentsLibrary
                                .CreateFileAsync(&quot;test.txt&quot;);
</code></pre>
<p>به دلیل محدودیت‌های سیستم نوع COM، <strong>IAsyncActionWithProgress<TProgress></strong> و <strong>IAsyncOperationWithProgress&lt;TResult, TProgress&gt;</strong> بر اساس <strong>IAsyncAction</strong> نیستند، بلکه هر دو از نوع پایه مشترکی به نام <strong>IAsyncInfo</strong> ارث‌بری می‌کنند.</p>
<p>متد <strong>AsTask</strong> همچنین می‌تواند یک <strong>cancellation token</strong> دریافت کند و می‌تواند با نوع <strong>IProgress<T></strong> هنگام استفاده از نسخه‌های WithProgress ترکیب شود.</p>
<hr>
<h3>غیرهمزمانی و Synchronization Context ⏳</h3>
<p>همان‌طور که قبلاً دیدیم، وجود <strong>SynchronizationContext</strong> در ارسال ادامه‌های اجرا (continuations) مهم است. چند نکته ظریف دیگر نیز وجود دارد که این contexts با متدهای غیرهمزمان با بازگشت <code>void</code> ایجاد می‌کنند. این‌ها نتیجه مستقیم کامپایلر C# نیست، بلکه ناشی از نوع‌های <strong>Async*MethodBuilder</strong> در namespace <strong>System.CompilerServices</strong> است که کامپایلر هنگام گسترش متدهای غیرهمزمان استفاده می‌کند.</p>
<h4>ارسال Exception ⚠️</h4>
<p>در برنامه‌های Rich-Client معمول است که از رویداد مرکزی مدیریت استثنا (<strong>Application.DispatcherUnhandledException</strong> در WPF) برای پردازش استثناهای بدون کنترل روی نخ UI استفاده شود. در برنامه‌های <strong>ASP.NET Core</strong> نیز، یک <strong>ExceptionFilterAttribute</strong> سفارشی در <strong>ConfigureServices</strong> در <strong>Startup.cs</strong> همین کار را انجام می‌دهد. در پشت صحنه، این‌ها با فراخوانی eventها (یا pipeline متدهای پردازش صفحات در ASP.NET Core) در بلوک try/catch خودشان کار می‌کنند.</p>
<p>متدهای غیرهمزمان سطح بالا این موضوع را پیچیده می‌کنند. به مثال زیر توجه کنید:</p>
<pre><code class="language-csharp">async void ButtonClick(object sender, RoutedEventArgs args)
{
    await Task.Delay(1000);
    throw new Exception(&quot;Will this be ignored?&quot;);
}
</code></pre>
<p>وقتی دکمه کلیک می‌شود و handler اجرا می‌شود، پس از <code>await</code> اجرای برنامه به message loop بازمی‌گردد، و استثنایی که یک ثانیه بعد پرتاب می‌شود، توسط catch بلوک در message loop گرفته نمی‌شود.</p>
<p>برای حل این مشکل، <strong>AsyncVoidMethodBuilder</strong> استثناهای بدون کنترل (در متدهای غیرهمزمان با بازگشت <code>void</code>) را می‌گیرد و آنها را در صورت وجود، به <strong>SynchronizationContext</strong> ارسال می‌کند تا رویدادهای مدیریت استثنا جهانی همچنان اجرا شوند.</p>
<p>کامپایلر این منطق را تنها روی متدهای غیرهمزمان با بازگشت <code>void</code> اعمال می‌کند. بنابراین اگر <strong>ButtonClick</strong> را به بازگشت <strong>Task</strong> تغییر دهیم، استثنای بدون کنترل Task را Fault می‌کند و هیچ مسیر دیگری برای رسیدن به آن وجود ندارد (منجر به unobserved exception می‌شود).</p>
<p>یک نکته جالب: فرقی نمی‌کند که استثنا قبل یا بعد از <code>await</code> پرتاب شود. برای مثال:</p>
<pre><code class="language-csharp">async void Foo() { throw null; await Task.Delay(1000); }
</code></pre>
<p>استثنا به SynchronizationContext (اگر موجود باشد) ارسال می‌شود و هرگز به فراخواننده بازنمی‌گردد. اگر SynchronizationContext موجود نباشد، استثنا روی Thread Pool گسترش می‌یابد و برنامه خاتمه می‌یابد.</p>
<p>این رفتار برای اطمینان از پیش‌بینی‌پذیری و سازگاری است. مشابه این، <strong>InvalidOperationException</strong> همیشه باعث Fault شدن Task می‌شود، بدون توجه به شرط‌ها:</p>
<pre><code class="language-csharp">async Task Foo()
{
    if (someCondition) await Task.Delay(100);
    throw new InvalidOperationException();
}
</code></pre>
<p>Iteratorها نیز به همین شکل کار می‌کنند:</p>
<pre><code class="language-csharp">IEnumerable&lt;int&gt; Foo() { throw null; yield return 123; }
</code></pre>
<p>در این مثال، استثنا تا زمان enumerating توالی به فراخواننده بازنمی‌گردد.</p>
<hr>
<h3>OperationStarted و OperationCompleted ⚙️</h3>
<p>اگر SynchronizationContext موجود باشد، متدهای غیرهمزمان با بازگشت <code>void</code> هنگام ورود به متد <strong>OperationStarted</strong> و هنگام پایان <strong>OperationCompleted</strong> آن را فراخوانی می‌کنند.</p>
<p>Override کردن این متدها هنگام نوشتن یک SynchronizationContext سفارشی برای تست واحد متدهای غیرهمزمان با بازگشت <code>void</code> مفید است. این موضوع در <strong>Microsoft Parallel Programming blog</strong> توضیح داده شده است.</p>
<h3>بهینه‌سازی‌ها ⚡</h3>
<h4>تکمیل همزمان (Completing synchronously) ⏱️</h4>
<p>یک متد غیرهمزمان می‌تواند قبل از <code>await</code> بازگردد. به مثال زیر که دانلود صفحات وب را <strong>کش</strong> می‌کند توجه کنید:</p>
<pre><code class="language-csharp">static Dictionary&lt;string,string&gt; _cache = new Dictionary&lt;string,string&gt;();

async Task&lt;string&gt; GetWebPageAsync(string uri)
{
    string html;
    if (_cache.TryGetValue(uri, out html)) return html;
    return _cache[uri] = await new WebClient().DownloadStringTaskAsync(uri);
}
</code></pre>
<p>اگر URI از قبل در کش موجود باشد، اجرای برنامه بدون هیچ <code>await</code> به فراخواننده بازمی‌گردد و متد یک <strong>Task</strong> از پیش تکمیل‌شده برمی‌گرداند. به این حالت <strong>تکمیل همزمان (synchronous completion)</strong> گفته می‌شود.</p>
<p>وقتی یک <strong>Task</strong> که همزمان تکمیل شده را <code>await</code> می‌کنید، اجرا به جای بازگشت به فراخواننده و ادامه از طریق continuation، مستقیم به دستور بعدی می‌رود. کامپایلر این بهینه‌سازی را با بررسی خاصیت <code>IsCompleted</code> روی <strong>awaiter</strong> انجام می‌دهد:</p>
<pre><code class="language-csharp">var awaiter = GetWebPageAsync().GetAwaiter();
if (awaiter.IsCompleted)
    Console.WriteLine(awaiter.GetResult());
else
    awaiter.OnCompleted(() =&gt; Console.WriteLine(awaiter.GetResult()));
</code></pre>
<p><code>await</code> کردن یک متد که همزمان تکمیل شده، تنها بار کوچکی دارد—مثلاً حدود ۲۰ نانوثانیه روی یک کامپیوتر ۲۰۱۹. در مقابل، رفتن به <strong>Thread Pool</strong> هزینه یک <strong>Context Switch</strong> دارد—حدود ۱ تا ۲ میکروثانیه، و رفتن به <strong>UI Message Loop</strong> حداقل ۱۰ برابر بیشتر (بسیار بیشتر اگر نخ UI شلوغ باشد).</p>
<hr>
<h4>متدهای غیرهمزمان بدون <code>await</code> ⚙️</h4>
<p>قانوناً می‌توانید متدهای غیرهمزمان بنویسید که هرگز <code>await</code> نداشته باشند، گرچه کامپایلر هشدار می‌دهد:</p>
<pre><code class="language-csharp">async Task&lt;string&gt; Foo() { return &quot;abc&quot;; }
</code></pre>
<p>این متدها برای <strong>Override کردن متدهای virtual/abstract</strong> مفیدند، حتی اگر نیاز به غیرهمزمانی نداشته باشید. روش دیگر استفاده از <strong>Task.FromResult</strong> است، که یک <strong>Task</strong> از پیش تکمیل‌شده برمی‌گرداند:</p>
<pre><code class="language-csharp">Task&lt;string&gt; Foo() { return Task.FromResult(&quot;abc&quot;); }
</code></pre>
<p>متد <strong>GetWebPageAsync</strong> اگر از نخ UI فراخوانی شود، به طور ضمنی <strong>Thread-Safe</strong> است، زیرا می‌توان چند بار پشت سر هم آن را فراخوانی کرد بدون نیاز به قفل کردن. اما اگر چند فراخوانی برای همان URI انجام شود، چند دانلود تکراری رخ می‌دهد که در نهایت آخرین دانلود کش را بروزرسانی می‌کند.</p>
<p>راه حل بهینه: به جای ذخیره رشته‌ها، <strong>کش “futures”</strong> (یعنی Task<string>) ایجاد کنید:</p>
<pre><code class="language-csharp">static Dictionary&lt;string,Task&lt;string&gt;&gt; _cache = new Dictionary&lt;string,Task&lt;string&gt;&gt;();

Task&lt;string&gt; GetWebPageAsync(string uri)
{
    if (_cache.TryGetValue(uri, out var downloadTask)) return downloadTask;
    return _cache[uri] = new WebClient().DownloadStringTaskAsync(uri);
}
</code></pre>
<p>توجه کنید که متد را <code>async</code> نکردیم، زیرا مستقیماً <strong>Task</strong> بدست آمده از <strong>WebClient</strong> را برمی‌گردانیم.</p>
<p>اگر چند بار همان URI را فراخوانی کنیم، همان <strong>Task<string></strong> برمی‌گردد و حتی اگر Task کامل شده باشد، <code>await</code> کردن آن ارزان است.</p>
<p>برای ایمن‌سازی کامل، می‌توانیم به کل بدنه متد <strong>Lock</strong> اضافه کنیم:</p>
<pre><code class="language-csharp">lock(_cache)
{
    if (_cache.TryGetValue(uri, out var downloadTask))
        return downloadTask;
    else
        return _cache[uri] = new WebClient().DownloadStringTaskAsync(uri);
}
</code></pre>
<p>قفل فقط برای بررسی کش و ایجاد Task جدید است، نه برای طول زمان دانلود، تا همزمانی حفظ شود.</p>
<hr>
<h4>ValueTask<T> 💎</h4>
<p><strong>ValueTask<T></strong> برای <strong>میروبهینه‌سازی</strong> طراحی شده و ممکن است نیازی به استفاده از آن نداشته باشید، اما برخی متدهای .NET و <strong>IAsyncEnumerable<T></strong> از آن استفاده می‌کنند.</p>
<p>همان‌طور که دیدیم، کامپایلر هنگام <code>await</code> روی یک Task تکمیل‌شده همزمان، continuation را کوتاه‌کرده و مستقیم به دستور بعدی می‌رود. اگر تکمیل همزمان به دلیل <strong>کش</strong> باشد، می‌توان کش Task را ذخیره کرد تا بهینه و شیک باشد.</p>
<p>اما در همه حالات عملی نیست و گاهی نیاز به ساخت Task جدید است. چون Task و Task<T> <strong>Reference Type</strong> هستند، ایجاد آن‌ها نیاز به حافظه روی Heap دارد و در نهایت جمع‌آوری زباله رخ می‌دهد.</p>
<p>برای <strong>بهینه‌سازی بدون تخصیص حافظه</strong>، از <strong>ValueTask</strong> و <strong>ValueTask<T></strong> استفاده می‌کنیم:</p>
<pre><code class="language-csharp">async ValueTask&lt;int&gt; Foo() { ... }
int answer = await Foo();   // (احتمالاً) بدون تخصیص
</code></pre>
<p>اگر عملیات همزمان کامل نشود، <strong>ValueTask<T></strong> یک Task<T> معمولی می‌سازد و await را به آن منتقل می‌کند. می‌توان ValueTask<T> را به Task<T> با <strong>AsTask</strong> تبدیل کرد. نسخه غیرجنریک آن نیز وجود دارد، مشابه Task.</p>
<hr>
<h4>نکات احتیاطی هنگام استفاده از ValueTask<T> ⚠️</h4>
<p>ValueTask<T> به دلیل اینکه struct است، رفتار نوع مقدار (Value Type) دارد و ممکن است باعث اشتباه شود. برای جلوگیری از رفتار نادرست، از کارهای زیر پرهیز کنید:</p>
<ul>
<li><code>await</code> کردن همان ValueTask<T> چند بار</li>
<li>فراخوانی <code>.GetAwaiter().GetResult()</code> قبل از تکمیل عملیات</li>
</ul>
<p>اگر نیاز به این کارها دارید، ابتدا با <strong>.AsTask()</strong> به Task تبدیل کرده و روی آن کار کنید:</p>
<pre><code class="language-csharp">await Foo();              // امن
ValueTask&lt;int&gt; valueTask = Foo();  // خطرناک!
Task&lt;int&gt; task = Foo().AsTask();   // امن
</code></pre>
<hr>
<h4>جلوگیری از Bounce زیاد 🔄</h4>
<p>برای متدهایی که در یک حلقه فراخوانی می‌شوند، می‌توانید هزینه رفت و برگشت به UI message loop را با <strong>ConfigureAwait(false)</strong> کاهش دهید. این باعث می‌شود continuation به <strong>SynchronizationContext</strong> بازنگردد و بار کمتر شود:</p>
<pre><code class="language-csharp">async void A() { ... await B(); ... }

async Task B()
{
    for (int i = 0; i &lt; 1000; i++)
        await C().ConfigureAwait(false);
}

async Task C() { ... }
</code></pre>
<p>در این حالت، مدل ساده thread-safety در اپ‌های UI از بین می‌رود، اما متد A اگر روی نخ UI شروع شده باشد، روی همان نخ باقی می‌ماند.</p>
<p>این بهینه‌سازی برای <strong>کتابخانه‌ها</strong> بسیار مفید است، جایی که معمولاً با state مشترک فراخواننده کار نمی‌کنید و به کنترل‌های UI دسترسی ندارید. همچنین متدهایی که سریع اجرا می‌شوند، می‌توانند بدون تخصیص Task کامل شوند.</p>
<h3>الگوهای غیرهمزمان (Asynchronous Patterns) ⚡</h3>
<h4>لغو عملیات (Cancellation) ❌</h4>
<p>گاهی اوقات مهم است که بتوان یک عملیات همزمان را بعد از شروع، <strong>لغو</strong> کرد—مثلاً در پاسخ به درخواست کاربر. یک راه ساده برای این کار استفاده از <strong>فلگ لغو (cancellation flag)</strong> است، که می‌توان با نوشتن کلاس زیر آن را کپسوله کرد:</p>
<pre><code class="language-csharp">class CancellationToken
{
    public bool IsCancellationRequested { get; private set; }
    public void Cancel() { IsCancellationRequested = true; }
    public void ThrowIfCancellationRequested()
    {
        if (IsCancellationRequested)
            throw new OperationCanceledException();
    }
}
</code></pre>
<p>سپس می‌توانیم یک متد غیرهمزمان قابل لغو بنویسیم:</p>
<pre><code class="language-csharp">async Task Foo(CancellationToken cancellationToken)
{
    for (int i = 0; i &lt; 10; i++)
    {
        Console.WriteLine(i);
        await Task.Delay(1000);
        cancellationToken.ThrowIfCancellationRequested();
    }
}
</code></pre>
<p>وقتی فراخواننده بخواهد عملیات را لغو کند، متد <code>Cancel</code> را روی <strong>cancellation token</strong> فراخوانی می‌کند. این باعث می‌شود <code>IsCancellationRequested</code> برابر با true شود و متد Foo با یک <strong>OperationCanceledException</strong> متوقف شود.</p>
<p>CLR یک نوع مشابه به نام <strong>CancellationToken</strong> دارد، ولی <strong>متد Cancel</strong> ندارد؛ این متد روی <strong>CancellationTokenSource</strong> ارائه شده است. این تفکیک باعث امنیت بیشتر می‌شود: متدی که فقط دسترسی به CancellationToken دارد، می‌تواند لغو را چک کند ولی آن را آغاز نکند.</p>
<p>برای گرفتن یک <strong>cancellation token</strong> ابتدا یک <strong>CancellationTokenSource</strong> ایجاد می‌کنیم:</p>
<pre><code class="language-csharp">var cancelSource = new CancellationTokenSource();
Task foo = Foo(cancelSource.Token);
...
cancelSource.Cancel();
</code></pre>
<p>اکثر متدهای غیرهمزمان در CLR از <strong>cancellation token</strong> پشتیبانی می‌کنند، از جمله <strong>Task.Delay</strong>. اگر متد Foo <strong>توکن</strong> خود را به Delay بدهد، Task بلافاصله پس از درخواست لغو متوقف می‌شود:</p>
<pre><code class="language-csharp">async Task Foo(CancellationToken cancellationToken)
{
    for (int i = 0; i &lt; 10; i++)
    {
        Console.WriteLine(i);
        await Task.Delay(1000, cancellationToken);
    }
}
</code></pre>
<p>دیگر نیاز به <code>ThrowIfCancellationRequested</code> نیست، زیرا <strong>Task.Delay</strong> این کار را انجام می‌دهد. <strong>Cancellation tokens</strong> به خوبی در طول call stack منتقل می‌شوند.</p>
<hr>
<h4>گزارش پیشرفت (Progress Reporting) 📊</h4>
<p>گاهی لازم است یک عملیات غیرهمزمان <strong>پیشرفت</strong> خود را گزارش دهد. یک راه ساده استفاده از <strong>Action delegate</strong> است:</p>
<pre><code class="language-csharp">Task Foo(Action&lt;int&gt; onProgressPercentChanged)
{
    return Task.Run(() =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            if (i % 10 == 0) onProgressPercentChanged(i / 10);
            // انجام کاری که زمان‌بر است...
        }
    });
}

Action&lt;int&gt; progress = i =&gt; Console.WriteLine(i + &quot; %&quot;);
await Foo(progress);
</code></pre>
<p>این روش در <strong>Console App</strong> خوب کار می‌کند، ولی در <strong>rich-client</strong> مشکلات <strong>thread-safety</strong> ایجاد می‌کند، چون پیشرفت از یک <strong>worker thread</strong> گزارش می‌شود.</p>
<p>CLR یک راه حل بهتر ارائه می‌دهد: <strong>IProgress<T></strong> و کلاس <strong>Progress<T></strong>. این کلاس‌ها <strong>delegate</strong> را کپسوله می‌کنند تا اپلیکیشن‌های UI بتوانند پیشرفت را به صورت ایمن از طریق <strong>SynchronizationContext</strong> گزارش کنند.</p>
<pre><code class="language-csharp">public interface IProgress&lt;in T&gt;
{
    void Report(T value);
}
</code></pre>
<p>استفاده از IProgress<T> آسان است:</p>
<pre><code class="language-csharp">Task Foo(IProgress&lt;int&gt; onProgressPercentChanged)
{
    return Task.Run(() =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            if (i % 10 == 0) onProgressPercentChanged.Report(i / 10);
            // انجام کاری که زمان‌بر است...
        }
    });
}

var progress = new Progress&lt;int&gt;(i =&gt; Console.WriteLine(i + &quot; %&quot;));
await Foo(progress);
</code></pre>
<p>کلاس <strong>Progress<T></strong> هنگام ایجاد، <strong>SynchronizationContext</strong> را ذخیره می‌کند. وقتی <strong>Report</strong> فراخوانی شود، delegate از طریق همان context اجرا می‌شود.</p>
<hr>
<h4>مقایسه با Rx</h4>
<p>اگر با <strong>Rx</strong> آشنا باشید، متوجه می‌شوید که <strong>IProgress<T></strong> همراه با <strong>Task</strong> خروجی، مجموعه قابلیت مشابه <strong>IObserver<T></strong> را ارائه می‌دهد. تفاوت این است که Task می‌تواند <strong>مقدار نهایی</strong> برگرداند، در حالی که IProgress<T> مقادیر میانی (مثلاً درصد تکمیل یا بایت‌های دانلود شده) را گزارش می‌کند.</p>
<hr>
<h4>WinRT و گزارش پیشرفت</h4>
<p>در WinRT، متدهای غیرهمزمان که پیشرفت را گزارش می‌دهند، به جای IProgress<T>، یکی از این رابط‌ها را برمی‌گردانند:</p>
<ul>
<li><code>IAsyncActionWithProgress&lt;TProgress&gt;</code></li>
<li><code>IAsyncOperationWithProgress&lt;TResult, TProgress&gt;</code></li>
</ul>
<p>هر دو از <code>IAsyncInfo</code> مشتق شده‌اند. با استفاده از <strong>AsTask</strong>، می‌توان آن‌ها را به Task معمولی با <strong>IProgress<T></strong> تبدیل کرد:</p>
<pre><code class="language-csharp">var progress = new Progress&lt;int&gt;(i =&gt; Console.WriteLine(i + &quot; %&quot;));
CancellationToken cancelToken = ...
var task = someWinRTobject.FooAsync().AsTask(cancelToken, progress);
</code></pre>
<p>این روش به شما امکان می‌دهد تا از <strong>رابط‌های COM پیچیده</strong> صرف‌نظر کنید و به سادگی از <strong>.NET API</strong> برای لغو و گزارش پیشرفت استفاده نمایید.</p>
<h3>الگوی غیرهمزمان مبتنی بر Task (Task-Based Asynchronous Pattern – TAP) ⚡</h3>
<p>در .NET صدها متد غیرهمزمان وجود دارد که <strong>Task</strong> یا <strong>Task<TResult></strong> برمی‌گردانند و می‌توانید روی آن‌ها <strong>await</strong> کنید (بیشتر مربوط به عملیات I/O). بیشتر این متدها حداقل تا حدی از الگویی به نام <strong>Task-Based Asynchronous Pattern (TAP)</strong> پیروی می‌کنند که یک <strong>ساختار منطقی و استاندارد</strong> برای کار با Taskها ارائه می‌دهد. یک متد TAP معمولاً ویژگی‌های زیر را دارد:</p>
<ul>
<li>برمی‌گرداند یک <strong>Task یا Task<TResult> فعال (hot)</strong></li>
<li>نام آن با پسوند <strong>Async</strong> ختم می‌شود (به جز موارد خاص مثل task combinatorها)</li>
<li>در صورت پشتیبانی از لغو یا گزارش پیشرفت، <strong>overload</strong>هایی می‌پذیرد که <strong>cancellation token</strong> و/یا <strong>IProgress<T></strong> را دریافت می‌کنند</li>
<li>سریع به فراخواننده بازمی‌گردد (فقط یک فاز همزمان کوتاه دارد)</li>
<li>اگر عملیات I/O محور باشد، یک Thread را درگیر نمی‌کند</li>
</ul>
<p>همان‌طور که دیدیم، نوشتن متدهای TAP با <strong>async/await</strong> در C# بسیار ساده است.</p>
<hr>
<h3>ترکیب‌کننده‌های Task (Task Combinators) 🔗</h3>
<p>یکی از مزایای داشتن یک پروتکل یکنواخت برای متدهای غیرهمزمان این است که می‌توان <strong>task combinator</strong> نوشت و استفاده کرد—یعنی توابعی که چند Task را با هم ترکیب می‌کنند، بدون توجه به اینکه هر Task دقیقاً چه کاری انجام می‌دهد.</p>
<p>CLR دو ترکیب‌کننده Task ارائه می‌دهد: <strong>Task.WhenAny</strong> و <strong>Task.WhenAll</strong>. برای توضیح آن‌ها، فرض می‌کنیم متدهای زیر تعریف شده‌اند:</p>
<pre><code class="language-csharp">async Task&lt;int&gt; Delay1() { await Task.Delay(1000); return 1; }
async Task&lt;int&gt; Delay2() { await Task.Delay(2000); return 2; }
async Task&lt;int&gt; Delay3() { await Task.Delay(3000); return 3; }
</code></pre>
<hr>
<h4>Task.WhenAny 🏁</h4>
<p><strong>Task.WhenAny</strong> یک Task برمی‌گرداند که وقتی <strong>هر یک از Taskها کامل شد</strong>، تمام می‌شود. مثال زیر پس از ۱ ثانیه تکمیل می‌شود:</p>
<pre><code class="language-csharp">Task&lt;int&gt; winningTask = await Task.WhenAny(Delay1(), Delay2(), Delay3());
Console.WriteLine(&quot;Done&quot;);
Console.WriteLine(winningTask.Result);   // 1
</code></pre>
<p>بهتر است <strong>winningTask</strong> را نیز await کنیم تا هرگونه Exception بدون AggregateException بازنشانی شود:</p>
<pre><code class="language-csharp">Console.WriteLine(await winningTask);   // 1
</code></pre>
<p>می‌توان این را در یک خط هم نوشت:</p>
<pre><code class="language-csharp">int answer = await await Task.WhenAny(Delay1(), Delay2(), Delay3());
</code></pre>
<p><strong>کاربرد:</strong> اعمال <strong>Timeout</strong> یا لغو روی عملیاتی که پشتیبانی نمی‌کنند:</p>
<pre><code class="language-csharp">Task&lt;string&gt; task = SomeAsyncFunc();
Task winner = await Task.WhenAny(task, Task.Delay(5000));
if (winner != task) throw new TimeoutException();
string result = await task;   // بازکردن نتیجه و پرتاب مجدد
</code></pre>
<hr>
<h4>Task.WhenAll 📦</h4>
<p><strong>Task.WhenAll</strong> یک Task برمی‌گرداند که وقتی <strong>تمام Taskها تکمیل شدند</strong>، تمام می‌شود. مثال زیر پس از ۳ ثانیه تکمیل می‌شود و الگوی <strong>fork/join</strong> را نشان می‌دهد:</p>
<pre><code class="language-csharp">await Task.WhenAll(Delay1(), Delay2(), Delay3());
</code></pre>
<p>تفاوت با await کردن Taskها یکی‌یکی این است که اگر task1 با خطا مواجه شود، دیگر task2 و task3 اجرا نمی‌شوند و Exceptionهای آن‌ها نادیده گرفته می‌شوند. اما <strong>Task.WhenAll</strong> منتظر می‌ماند تا همه Taskها تکمیل شوند و اگر چند خطا رخ دهد، همه Exceptionها در <strong>AggregateException</strong> ترکیب می‌شوند.</p>
<p>استفاده از Task<TResult> با WhenAll نتیجه‌ای از نوع <strong>Task&lt;TResult[]&gt;</strong> برمی‌گرداند:</p>
<pre><code class="language-csharp">Task&lt;int&gt; task1 = Task.Run(() =&gt; 1);
Task&lt;int&gt; task2 = Task.Run(() =&gt; 2);
int[] results = await Task.WhenAll(task1, task2);   // {1, 2}
</code></pre>
<p><strong>مثال عملی:</strong> دانلود چند URI به صورت موازی و جمع طول کل محتوا:</p>
<pre><code class="language-csharp">async Task&lt;int&gt; GetTotalSize(string[] uris)
{
    IEnumerable&lt;Task&lt;int&gt;&gt; downloadTasks = uris.Select(async uri =&gt;
        (await new WebClient().DownloadDataTaskAsync(uri)).Length);
    int[] contentLengths = await Task.WhenAll(downloadTasks);
    return contentLengths.Sum();
}
</code></pre>
<hr>
<h3>ترکیب‌کننده‌های سفارشی 🛠️</h3>
<p>می‌توان ترکیب‌کننده Task خود را نوشت، مثلاً برای await کردن یک Task با <strong>Timeout</strong>:</p>
<pre><code class="language-csharp">async static Task&lt;TResult&gt; WithTimeout&lt;TResult&gt;(this Task&lt;TResult&gt; task, TimeSpan timeout)
{
    var cancelSource = new CancellationTokenSource();
    var delay = Task.Delay(timeout, cancelSource.Token);
    Task winner = await Task.WhenAny(task, delay).ConfigureAwait(false);
    if (winner == task)
        cancelSource.Cancel();
    else
        throw new TimeoutException();
    return await task.ConfigureAwait(false);   // بازکردن نتیجه و پرتاب مجدد
}
</code></pre>
<p>همچنین می‌توان Task را با <strong>CancellationToken</strong> ترک کرد:</p>
<pre><code class="language-csharp">static Task&lt;TResult&gt; WithCancellation&lt;TResult&gt;(this Task&lt;TResult&gt; task, CancellationToken cancelToken)
{
    var tcs = new TaskCompletionSource&lt;TResult&gt;();
    var reg = cancelToken.Register(() =&gt; tcs.TrySetCanceled());
    task.ContinueWith(ant =&gt; 
    {
        reg.Dispose();
        if (ant.IsCanceled)
            tcs.TrySetCanceled();
        else if (ant.IsFaulted)
            tcs.TrySetException(ant.Exception.InnerExceptions);
        else
            tcs.TrySetResult(ant.Result);
    });
    return tcs.Task;
}
</code></pre>
<p><strong>مزیت:</strong> پیچیدگی مربوط به concurrency از منطق اصلی برنامه جدا می‌شود و در متدهای قابل استفاده مجدد نگهداری می‌شود.</p>
<hr>
<h4>TaskCompletionSource و کنترل خطا</h4>
<p>می‌توان ترکیب‌کننده‌ای نوشت که شبیه <strong>WhenAll</strong> عمل کند، اما اگر هر Task خطا دهد، Task حاصل فوراً خطا کند:</p>
<pre><code class="language-csharp">async Task&lt;TResult[]&gt; WhenAllOrError&lt;TResult&gt;(params Task&lt;TResult&gt;[] tasks)
{
    var killJoy = new TaskCompletionSource&lt;TResult[]&gt;();
    foreach (var task in tasks)
        task.ContinueWith(ant =&gt;
        {
            if (ant.IsCanceled) 
                killJoy.TrySetCanceled();
            else if (ant.IsFaulted)
                killJoy.TrySetException(ant.Exception.InnerExceptions);
        });
    return await await Task.WhenAny(killJoy.Task, Task.WhenAll(tasks))
                           .ConfigureAwait(false);
}
</code></pre>
<hr>
<h3>قفل غیرهمزمان (Asynchronous Locking) 🔒</h3>
<p>در بخش <strong>Asynchronous semaphores and locks</strong> (صفحه 906) توضیح داده‌ایم که چگونه می‌توان با <strong>SemaphoreSlim</strong> قفل یا محدودیت همزمانی را به صورت غیرهمزمان اعمال کرد.</p>
<h3>الگوهای قدیمی غیرهمزمان (Obsolete Patterns) ⏳</h3>
<p>قبل از ظهور <strong>Task</strong> و <strong>async/await</strong>، در .NET روش‌های دیگری برای برنامه‌نویسی غیرهمزمان وجود داشت که امروزه به ندرت مورد نیاز هستند. دو الگوی مهم عبارت‌اند از <strong>APM</strong> و <strong>EAP</strong>.</p>
<hr>
<h2>۱. الگوی برنامه‌نویسی غیرهمزمان (Asynchronous Programming Model – APM) 🏛️</h2>
<p>APM قدیمی‌ترین الگو است و بر اساس <em><em>زوج متدهای Begin</em>/End</em>** و <strong>IAsyncResult</strong> کار می‌کند.</p>
<p>مثال با کلاس <code>Stream</code> در <strong>System.IO</strong>:</p>
<ul>
<li>نسخه همزمان:</li>
</ul>
<pre><code class="language-csharp">public int Read(byte[] buffer, int offset, int size);
</code></pre>
<ul>
<li>نسخه غیرهمزمان مبتنی بر Task:</li>
</ul>
<pre><code class="language-csharp">public Task&lt;int&gt; ReadAsync(byte[] buffer, int offset, int size);
</code></pre>
<ul>
<li>نسخه APM:</li>
</ul>
<pre><code class="language-csharp">public IAsyncResult BeginRead(byte[] buffer, int offset, int size,
                              AsyncCallback callback, object state);
public int EndRead(IAsyncResult asyncResult);
</code></pre>
<p><strong>نحوه کار:</strong></p>
<ol>
<li>فراخوانی <code>BeginRead</code> عملیات را شروع می‌کند و یک <strong>IAsyncResult</strong> برمی‌گرداند که مانند یک <strong>توکن</strong> عمل می‌کند.</li>
<li>وقتی عملیات تکمیل شد یا خطا داد، <strong>AsyncCallback</strong> فراخوانی می‌شود.</li>
<li>در callback، <code>EndRead</code> صدا زده می‌شود تا مقدار بازگشتی و Exception در صورت وجود ارائه شود.</li>
</ol>
<p><strong>پیچیدگی:</strong> استفاده از APM دشوار و پیاده‌سازی آن حتی سخت‌تر است.</p>
<p><strong>راه حل مدرن:</strong> استفاده از <strong>Task.Factory.FromAsync</strong> برای تبدیل زوج متد APM به Task:</p>
<pre><code class="language-csharp">Task&lt;int&gt; readChunk = Task&lt;int&gt;.Factory.FromAsync(
    stream.BeginRead, stream.EndRead, buffer, 0, 1000, null);
</code></pre>
<hr>
<h2>۲. الگوی غیرهمزمان مبتنی بر رویداد (Event-Based Asynchronous Pattern – EAP) 🎉</h2>
<p>EAP در سال ۲۰۰۵ معرفی شد تا جایگزینی ساده‌تر برای APM باشد، به ویژه در سناریوهای UI.</p>
<p><strong>نمونه کلاس WebClient:</strong></p>
<pre><code class="language-csharp">public byte[] DownloadData(Uri address);           // نسخه همزمان
public void DownloadDataAsync(Uri address);        // نسخه غیرهمزمان
public void DownloadDataAsync(Uri address, object userToken);
public event DownloadDataCompletedEventHandler DownloadDataCompleted;
public void CancelAsync(object userState);         // لغو عملیات
public bool IsBusy { get; }                        // وضعیت در حال اجرا
public event DownloadProgressChangedEventHandler DownloadProgressChanged;
</code></pre>
<p><strong>نحوه کار:</strong></p>
<ul>
<li>متدهای <code>*Async</code> عملیات را شروع می‌کنند.</li>
<li>وقتی عملیات تکمیل شد، <strong>رویداد <code>*Completed</code></strong> فراخوانی می‌شود و نتیجه، Exception یا وضعیت لغو را ارائه می‌دهد.</li>
<li>گزارش پیشرفت می‌تواند از طریق رویداد <code>DownloadProgressChanged</code> انجام شود.</li>
<li>اگر <strong>SynchronizationContext</strong> موجود باشد، رویدادها به صورت امن به thread UI ارسال می‌شوند.</li>
</ul>
<p><strong>مشکل:</strong> پیاده‌سازی EAP نیازمند کد boilerplate زیادی است و الگو به سختی ترکیب‌پذیر است.</p>
<hr>
<h3>۳. BackgroundWorker 🛠️</h3>
<p>کلاس <strong>BackgroundWorker</strong> در <strong>System.ComponentModel</strong> یک پیاده‌سازی عمومی از EAP است که به برنامه‌های rich-client اجازه می‌دهد:</p>
<ul>
<li>اجرای <strong>worker thread</strong> برای عملیات غیرهمزمان</li>
<li>گزارش درصد پیشرفت</li>
<li>اطلاع از اتمام عملیات یا خطا</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var worker = new BackgroundWorker { WorkerSupportsCancellation = true };

worker.DoWork += (sender, args) =&gt; 
{
    if (args.Cancel) return;
    Thread.Sleep(1000); 
    args.Result = 123;
};

worker.RunWorkerCompleted += (sender, args) =&gt;
{
    if (args.Cancelled)
        Console.WriteLine(&quot;Cancelled&quot;);
    else if (args.Error != null)
        Console.WriteLine(&quot;Error: &quot; + args.Error.Message);
    else
        Console.WriteLine(&quot;Result is: &quot; + args.Result);
};

worker.RunWorkerAsync();   // شروع عملیات و capture synchronization context
</code></pre>
<p><strong>ویژگی‌ها:</strong></p>
<ul>
<li><code>DoWork</code> روی <strong>worker thread</strong> اجرا می‌شود.</li>
<li><code>RunWorkerCompleted</code> روی <strong>UI thread</strong> اجرا می‌شود (اگر SynchronizationContext موجود باشد).</li>
<li>برای به‌روزرسانی UI در <code>DoWork</code> باید از <code>Dispatcher.BeginInvoke</code> استفاده شود.</li>
</ul>
<hr>
<p>📌 <strong>جمع‌بندی:</strong></p>
<ul>
<li><strong>APM و EAP</strong> الگوهای قدیمی هستند و امروزه به ندرت مورد استفاده‌اند.</li>
<li><strong>TAP (Task + async/await)</strong> جایگزین مدرن، ساده و انعطاف‌پذیر است و تقریبا همه متدهای جدید .NET از آن استفاده می‌کنند.</li>
</ul>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
