<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل هجدهم:  بازتاب (Reflection) و متادیتا</h1>
<p>همان‌طور که در فصل ۱۷ دیدیم، یک برنامه‌ی C# به یک <strong>Assembly</strong> کامپایل می‌شود که شامل <strong>متادیتا (Metadata)</strong>، کد کامپایل‌شده و منابع (Resources) است. بررسی متادیتا و کد کامپایل‌شده در زمان اجرا را <strong>Reflection (بازتاب)</strong> می‌نامند.</p>
<p>کد کامپایل‌شده در یک Assembly تقریباً تمام محتوای کد منبع اصلی را در بر دارد. با این حال، برخی اطلاعات مانند نام متغیرهای محلی، توضیحات (Comments) و دستورهای پیش‌پردازنده (Preprocessor Directives) از دست می‌روند. اما بازتاب به ما امکان دسترسی به تقریباً تمام موارد دیگر را می‌دهد—حتی تا حدی که می‌توان یک <strong>Decompiler</strong> (دی‌کامپایلر) نوشت. 🔎</p>
<p>بسیاری از سرویس‌های موجود در .NET و در دسترس از طریق C# (مانند <strong>Dynamic Binding</strong>، <strong>Serialization</strong> و <strong>Data Binding</strong>) به وجود متادیتا وابسته هستند. همچنین برنامه‌های شما نیز می‌توانند از این متادیتا استفاده کنند و حتی آن را با اطلاعات جدید از طریق <strong>Custom Attributes</strong> گسترش دهند. فضای نام <code>System.Reflection</code> شامل API مربوط به Reflection است. علاوه بر این، در زمان اجرا می‌توان متادیتا و دستورالعمل‌های اجرایی جدیدی در سطح <strong>Intermediate Language (IL)</strong> با استفاده از کلاس‌های موجود در فضای نام <code>System.Reflection.Emit</code> ایجاد کرد.</p>
<p>نمونه‌های این فصل فرض می‌کنند که شما فضای نام‌های <code>System</code> و <code>System.Reflection</code> و همچنین <code>System.Reflection.Emit</code> را وارد کرده‌اید.</p>
<p>وقتی در این فصل از اصطلاح <strong>«به‌صورت دینامیکی» (Dynamically)</strong> استفاده می‌کنیم، منظور این است که عملی را با Reflection انجام دهیم که <strong>ایمنی نوع (Type Safety)</strong> آن فقط در زمان اجرا کنترل می‌شود. این موضوع از نظر اصول مشابه <strong>Dynamic Binding</strong> در C# با کلیدواژه‌ی <code>dynamic</code> است، اما مکانیزم و عملکرد آن متفاوت است.</p>
<ul>
<li><strong>Dynamic Binding</strong> استفاده‌ی آسان‌تری دارد و از <strong>Dynamic Language Runtime (DLR)</strong> برای سازگاری با زبان‌های پویا استفاده می‌کند.</li>
<li><strong>Reflection</strong> نسبت به آن کمی دست‌وپاگیرتر است، اما انعطاف بیشتری در ارتباط با <strong>CLR</strong> ارائه می‌دهد.</li>
</ul>
<p>برای مثال، Reflection به شما اجازه می‌دهد:
✔️ فهرستی از <strong>Types</strong> و <strong>Members</strong> دریافت کنید.
✔️ یک شیء را با نامی که از یک رشته (String) می‌آید بسازید.
✔️ در لحظه (On the fly) Assembly تولید کنید.</p>
<hr>
<h2>🔍 Reflecting and Activating Types</h2>
<p>در این بخش بررسی می‌کنیم که چگونه می‌توان یک <strong>Type</strong> را به دست آورد، متادیتای آن را بررسی کرد و از آن برای ایجاد دینامیکی یک شیء استفاده نمود.</p>
<h3>📌 Obtaining a Type</h3>
<p>یک نمونه از <code>System.Type</code> نمایانگر متادیتای یک Type است. از آن‌جا که <strong>Type</strong> بسیار پرکاربرد است، در فضای نام <code>System</code> قرار دارد، نه در <code>System.Reflection</code>.</p>
<p>روش‌های به‌دست‌آوردن یک نمونه‌ی <code>System.Type</code>:</p>
<p>۱. فراخوانی متد <code>GetType</code> روی هر شیء:</p>
<pre><code class="language-csharp">Type t1 = DateTime.Now.GetType();     // Type بدست‌آمده در زمان اجرا
</code></pre>
<p>۲. استفاده از عملگر <code>typeof</code> در C#:</p>
<pre><code class="language-csharp">Type t2 = typeof(DateTime);          // Type بدست‌آمده در زمان کامپایل
</code></pre>
<p>با استفاده از <code>typeof</code> می‌توانید Type آرایه‌ها و Typeهای جنریک را نیز بگیرید:</p>
<pre><code class="language-csharp">Type t3 = typeof(DateTime[]);          // آرایه یک‌بعدی
Type t4 = typeof(DateTime[,]);         // آرایه دوبعدی
Type t5 = typeof(Dictionary&lt;int,int&gt;); // جنریک بسته (Closed Generic Type)
Type t6 = typeof(Dictionary&lt;,&gt;);       // جنریک باز (Unbound Generic Type)
</code></pre>
<p>۳. دریافت Type از طریق نام (Name):
اگر یک مرجع به Assembly داشته باشید:</p>
<pre><code class="language-csharp">Type t = Assembly.GetExecutingAssembly().GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>اگر Assembly را نداشته باشید، می‌توانید از <strong>Assembly Qualified Name</strong> استفاده کنید (نام کامل Type به‌همراه نام کامل یا جزئی Assembly). در این حالت Assembly به‌طور ضمنی بارگذاری می‌شود:</p>
<pre><code class="language-csharp">Type t = Type.GetType(&quot;System.Int32, System.Private.CoreLib&quot;);
</code></pre>
<p>پس از در اختیار داشتن یک شیء <code>System.Type</code>، می‌توانید با استفاده از ویژگی‌های آن به اطلاعاتی مانند نام، Assembly، Base Type، سطح دسترسی (Visibility) و ... دسترسی داشته باشید:</p>
<pre><code class="language-csharp">Type stringType = typeof(string);
string name     = stringType.Name;          // String
Type baseType   = stringType.BaseType;      // typeof(Object)
Assembly assem  = stringType.Assembly;      // System.Private.CoreLib
bool isPublic   = stringType.IsPublic;      // true
</code></pre>
<p>یک شیء از نوع <code>System.Type</code> در واقع پنجره‌ای به تمام متادیتای مربوط به آن Type و Assembly حاوی آن است.</p>
<blockquote>
<p><code>System.Type</code> یک کلاس <strong>Abstract</strong> است، بنابراین عملگر <code>typeof</code> در واقع یک زیرکلاس از Type را برمی‌گرداند. زیرکلاسی که CLR استفاده می‌کند داخلی (Internal) بوده و نام آن <strong>RuntimeType</strong> است.</p>
</blockquote>
<hr>
<h2>📘 TypeInfo</h2>
<p>اگر شما هدف‌گذاری روی <strong>.NET Core 1.x</strong> (یا پروفایل‌های قدیمی‌تر Windows Store) داشته باشید، بسیاری از اعضای <code>Type</code> در دسترس نیستند. این اعضا به جای آن در کلاسی به نام <code>TypeInfo</code> ارائه می‌شوند که از طریق فراخوانی <code>GetTypeInfo</code> به‌دست می‌آید.</p>
<p>برای اجرای مثال قبلی در چنین محیطی، کد شما این‌گونه خواهد بود:</p>
<pre><code class="language-csharp">Type stringType = typeof(string);
string name = stringType.Name;
Type baseType = stringType.GetTypeInfo().BaseType;
Assembly assem = stringType.GetTypeInfo().Assembly;
bool isPublic = stringType.GetTypeInfo().IsPublic;
</code></pre>
<p>کلاس <code>TypeInfo</code> در <strong>.NET Core 2 و 3</strong> و <strong>.NET 5+</strong> (و همچنین در <strong>.NET Framework 4.5+</strong> و تمامی نسخه‌های <strong>.NET Standard</strong>) نیز وجود دارد. بنابراین کد بالا تقریباً به‌طور جهانی (Universal) قابل اجراست.</p>
<p>همچنین <code>TypeInfo</code> ویژگی‌ها و متدهای اضافی برای بازتاب روی اعضا (Reflecting over Members) در اختیار قرار می‌دهد.</p>
<h2>📦 به‌دست‌آوردن انواع آرایه‌ها (Obtaining Array Types)</h2>
<p>همان‌طور که دیدیم، <code>typeof</code> و <code>GetType</code> با آرایه‌ها کار می‌کنند. علاوه بر این می‌توانید با فراخوانی <code>MakeArrayType</code> روی <strong>نوع المنت (Element Type)</strong>، یک نوع آرایه بسازید:</p>
<pre><code class="language-csharp">Type simpleArrayType = typeof(int).MakeArrayType();
Console.WriteLine(simpleArrayType == typeof(int[]));  // True
</code></pre>
<p>برای ایجاد آرایه‌های چندبعدی، کافی است یک آرگومان عدد صحیح به <code>MakeArrayType</code> بدهید:</p>
<pre><code class="language-csharp">Type cubeType = typeof(int).MakeArrayType(3);   // آرایه سه‌بعدی (شکل مکعب)
Console.WriteLine(cubeType == typeof(int[,,])); // True
</code></pre>
<p>متد <code>GetElementType</code> عمل معکوس را انجام می‌دهد: نوع المنت یک آرایه را بازمی‌گرداند:</p>
<pre><code class="language-csharp">Type e = typeof(int[]).GetElementType();   // e == typeof(int)
</code></pre>
<p>متد <code>GetArrayRank</code> تعداد ابعاد یک آرایه مستطیلی را برمی‌گرداند:</p>
<pre><code class="language-csharp">int rank = typeof(int[,,]).GetArrayRank();  // 3
</code></pre>
<hr>
<h2>🧩 به‌دست‌آوردن نوع‌های تو در تو (Obtaining Nested Types)</h2>
<p>برای گرفتن نوع‌های تو در تو (Nested Types)، متد <code>GetNestedTypes</code> را روی نوع حاوی (Containing Type) فراخوانی کنید:</p>
<pre><code class="language-csharp">foreach (Type t in typeof(System.Environment).GetNestedTypes())
    Console.WriteLine(t.FullName);
</code></pre>
<p><strong>خروجی:</strong></p>
<pre><code>System.Environment+SpecialFolder
</code></pre>
<p>یا به روش دیگر:</p>
<pre><code class="language-csharp">foreach (TypeInfo t in typeof(System.Environment)
                        .GetTypeInfo().DeclaredNestedTypes)
    Debug.WriteLine(t.FullName);
</code></pre>
<p>⚠️ تنها نکته این است که CLR یک نوع تو در تو را با سطوح دسترسی ویژه «Nested» در نظر می‌گیرد:</p>
<pre><code class="language-csharp">Type t = typeof(System.Environment.SpecialFolder);
Console.WriteLine(t.IsPublic);       // False
Console.WriteLine(t.IsNestedPublic); // True
</code></pre>
<hr>
<h2>🏷 نام انواع (Type Names)</h2>
<p>یک Type دارای ویژگی‌های <code>Namespace</code>، <code>Name</code> و <code>FullName</code> است. در بیشتر موارد، <code>FullName</code> ترکیبی از دو مورد اول است:</p>
<pre><code class="language-csharp">Type t = typeof(System.Text.StringBuilder);
Console.WriteLine(t.Namespace);  // System.Text
Console.WriteLine(t.Name);       // StringBuilder
Console.WriteLine(t.FullName);   // System.Text.StringBuilder
</code></pre>
<p>🔑 دو استثنا وجود دارد:</p>
<ol>
<li>نوع‌های تو در تو (Nested Types)</li>
<li>نوع‌های جنریک بسته (Closed Generic Types)</li>
</ol>
<p>همچنین ویژگی <code>AssemblyQualifiedName</code> وجود دارد که <code>FullName</code> را به‌همراه نام Assembly برمی‌گرداند. این همان رشته‌ای است که می‌توانید به <code>Type.GetType</code> بدهید و به‌طور منحصربه‌فرد یک Type را در محدوده‌ی بارگذاری پیش‌فرض مشخص می‌کند.</p>
<hr>
<h3>🔗 نام نوع‌های تو در تو (Nested Type Names)</h3>
<p>در نوع‌های تو در تو، نوع حاوی تنها در <code>FullName</code> ظاهر می‌شود:</p>
<pre><code class="language-csharp">Type t = typeof(System.Environment.SpecialFolder);
Console.WriteLine(t.Namespace);  // System
Console.WriteLine(t.Name);       // SpecialFolder
Console.WriteLine(t.FullName);   // System.Environment+SpecialFolder
</code></pre>
<p>🔹 علامت <code>+</code> نوع حاوی را از فضای نام تو در تو جدا می‌کند.</p>
<hr>
<h3>🌀 نام نوع‌های جنریک (Generic Type Names)</h3>
<p>نام نوع‌های جنریک با علامت بک‌تیک (<code>`</code>) و سپس تعداد پارامترهای نوع مشخص می‌شوند.</p>
<ul>
<li>اگر جنریک باز (Unbound) باشد، این قانون برای <code>Name</code> و <code>FullName</code> اعمال می‌شود:</li>
</ul>
<pre><code class="language-csharp">Type t = typeof(Dictionary&lt;,&gt;);
Console.WriteLine(t.Name);     // Dictionary`2
Console.WriteLine(t.FullName); // System.Collections.Generic.Dictionary`2
</code></pre>
<ul>
<li>اگر جنریک بسته (Closed) باشد، تنها <code>FullName</code> یک بخش اضافی طولانی شامل نام کامل Assembly هر پارامتر نوع را دریافت می‌کند:</li>
</ul>
<pre><code class="language-csharp">Console.WriteLine(typeof(Dictionary&lt;int,string&gt;).FullName);
</code></pre>
<p><strong>خروجی:</strong></p>
<pre><code>System.Collections.Generic.Dictionary`2[
 [System.Int32, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],
 [System.String, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]
]
</code></pre>
<p>این تضمین می‌کند که <code>AssemblyQualifiedName</code> اطلاعات کافی برای شناسایی کامل نوع جنریک و پارامترهای آن دارد.</p>
<hr>
<h3>📚 نام انواع آرایه و پوینتر (Array and Pointer Type Names)</h3>
<p>آرایه‌ها با همان پسوندی نمایش داده می‌شوند که در عبارت <code>typeof</code> استفاده می‌کنید:</p>
<pre><code class="language-csharp">Console.WriteLine(typeof(int[]).Name);     // Int32[]
Console.WriteLine(typeof(int[,]).Name);    // Int32[,]
Console.WriteLine(typeof(int[,]).FullName);// System.Int32[,]
</code></pre>
<p>نوع‌های پوینتر مشابه هستند:</p>
<pre><code class="language-csharp">Console.WriteLine(typeof(byte*).Name);     // Byte*
</code></pre>
<hr>
<h3>🔄 نام انواع پارامترهای ref و out</h3>
<p>یک <code>Type</code> که نماینده‌ی پارامتر <code>ref</code> یا <code>out</code> باشد، پسوند <code>&amp;</code> دارد:</p>
<pre><code class="language-csharp">public void RefMethod(ref int p)
{
    Type t = MethodInfo.GetCurrentMethod().GetParameters()[0].ParameterType;
    Console.WriteLine(t.Name);   // Int32&amp;
}
</code></pre>
<p>(جزئیات بیشتر در بخش «Reflecting and Invoking Members» در صفحه 813 توضیح داده می‌شود.)</p>
<hr>
<h2>🧬 Base Types و Interfaces</h2>
<p>کلاس <code>Type</code> یک ویژگی به نام <code>BaseType</code> دارد:</p>
<pre><code class="language-csharp">Type base1 = typeof(System.String).BaseType;
Type base2 = typeof(System.IO.FileStream).BaseType;
Console.WriteLine(base1.Name);  // Object
Console.WriteLine(base2.Name);  // Stream
</code></pre>
<p>متد <code>GetInterfaces</code> رابط‌هایی (Interfaces) را که یک Type پیاده‌سازی می‌کند برمی‌گرداند:</p>
<pre><code class="language-csharp">foreach (Type iType in typeof(Guid).GetInterfaces())
    Console.WriteLine(iType.Name);
</code></pre>
<p><strong>خروجی:</strong></p>
<pre><code>IFormattable
IComparable
IComparable`1
IEquatable`1
</code></pre>
<p>(متد <code>GetInterfaceMap</code> یک ساختار بازمی‌گرداند که نشان می‌دهد هر عضو از یک Interface چگونه در یک کلاس یا Struct پیاده‌سازی شده است—نمونه‌ی آن در بخش «Calling Static Virtual/Abstract Interface Members» در صفحه 826 آمده است.)</p>
<hr>
<h2>⚖️ معادل‌های پویا برای عملگر is در C#</h2>
<p>Reflection سه معادل پویا برای عملگر ایستای <code>is</code> در C# ارائه می‌دهد:</p>
<ul>
<li><code>IsInstanceOfType</code> → یک Type و یک نمونه را می‌پذیرد.</li>
<li><code>IsAssignableFrom</code> و (از .NET 5) <code>IsAssignableTo</code> → دو Type را می‌پذیرند.</li>
</ul>
<h3>مثال ۱</h3>
<pre><code class="language-csharp">object obj  = Guid.NewGuid();
Type target = typeof(IFormattable);

bool isTrue   = obj is IFormattable;            // عملگر ایستای C#
bool alsoTrue = target.IsInstanceOfType(obj);   // معادل پویا
</code></pre>
<h3>مثال ۲</h3>
<pre><code class="language-csharp">Type target = typeof(IComparable), source = typeof(string);
Console.WriteLine(target.IsAssignableFrom(source));  // True
</code></pre>
<p>متد <code>IsSubclassOf</code> هم بر اساس همان اصل <code>IsAssignableFrom</code> کار می‌کند، با این تفاوت که Interfaceها را در نظر نمی‌گیرد.</p>
<h2>🏗 ایجاد نمونه از انواع (Instantiating Types)</h2>
<p>دو روش برای ایجاد دینامیکی یک شیء از روی نوع (Type) وجود دارد:</p>
<ol>
<li>فراخوانی متد استاتیک <code>Activator.CreateInstance</code></li>
<li>فراخوانی <code>Invoke</code> روی یک شیء از نوع <code>ConstructorInfo</code> که از متد <code>GetConstructor</code> روی یک Type به‌دست آمده است (برای سناریوهای پیشرفته)</li>
</ol>
<hr>
<h3>🔹 استفاده از Activator.CreateInstance</h3>
<p>متد <code>Activator.CreateInstance</code> یک Type و آرگومان‌های اختیاری دریافت می‌کند و آن‌ها را به سازنده (Constructor) پاس می‌دهد:</p>
<pre><code class="language-csharp">int i = (int)Activator.CreateInstance(typeof(int));

DateTime dt = (DateTime)Activator.CreateInstance(typeof(DateTime),
                                                 2000, 1, 1);
</code></pre>
<p>این متد گزینه‌های بیشتری نیز فراهم می‌کند، مانند مشخص‌کردن Assembly برای بارگذاری نوع یا امکان اتصال به سازنده‌های <strong>Nonpublic</strong>.
اگر CLR نتواند سازنده‌ی مناسب پیدا کند، یک استثناء از نوع <code>MissingMethodException</code> پرتاب می‌شود. ⚠️</p>
<hr>
<h3>🔹 استفاده از ConstructorInfo.Invoke</h3>
<p>گاهی اوقات باید از <code>ConstructorInfo.Invoke</code> استفاده کنید، به‌ویژه زمانی که مقدار آرگومان‌ها نمی‌تواند بین سازنده‌های Overload تمایز ایجاد کند.</p>
<p>فرض کنید کلاس <code>X</code> دو سازنده دارد:</p>
<ul>
<li>یکی با پارامتر <code>string</code></li>
<li>دیگری با پارامتر <code>StringBuilder</code></li>
</ul>
<p>در این حالت اگر مقدار <code>null</code> را به <code>Activator.CreateInstance</code> بدهید، نتیجه مبهم خواهد بود. پس باید مستقیماً از <code>ConstructorInfo</code> استفاده کنید:</p>
<pre><code class="language-csharp">// گرفتن سازنده‌ای که یک پارامتر از نوع string دارد:
ConstructorInfo ci = typeof(X).GetConstructor(new[] { typeof(string) });

// ساخت شیء با همان overload و پاس دادن null:
object foo = ci.Invoke(new object[] { null });
</code></pre>
<p>اگر هدف شما <strong>.NET Core 1</strong> یا پروفایل‌های قدیمی Windows Store باشد:</p>
<pre><code class="language-csharp">ConstructorInfo ci = typeof(X).GetTypeInfo().DeclaredConstructors
    .FirstOrDefault(c =&gt;
        c.GetParameters().Length == 1 &amp;&amp;
        c.GetParameters()[0].ParameterType == typeof(string));
</code></pre>
<p>برای گرفتن سازنده‌های <strong>Nonpublic</strong> باید از <strong>BindingFlags</strong> استفاده کنید (توضیح در بخش «Accessing Nonpublic Members» در صفحه 822).</p>
<hr>
<h3>⚡ نکته‌ی عملکردی</h3>
<p>ایجاد نمونه‌ی دینامیکی چند <strong>میکروثانیه</strong> به زمان ساخت شیء اضافه می‌کند. این مقدار در مقیاس نسبی زیاد است، چون CLR به‌طور عادی بسیار سریع در ایجاد اشیاء عمل می‌کند (یک <code>new</code> ساده روی یک کلاس کوچک در حد چند <strong>نانوسانیه</strong> زمان می‌برد).</p>
<hr>
<h3>📚 ایجاد دینامیکی آرایه‌ها و جنریک‌ها</h3>
<p>برای ایجاد آرایه‌ها به‌صورت دینامیکی، ابتدا باید <code>MakeArrayType</code> را فراخوانی کنید.
ایجاد نوع‌های جنریک نیز ممکن است (در بخش بعدی توضیح داده می‌شود).</p>
<hr>
<h3>🪝 ایجاد دینامیکی Delegateها</h3>
<p>برای ایجاد Delegate به‌صورت دینامیکی، متد <code>Delegate.CreateDelegate</code> را فراخوانی کنید. مثال زیر ایجاد هر دو نوع Delegate (استاتیک و Instance) را نشان می‌دهد:</p>
<pre><code class="language-csharp">class Program
{
    delegate int IntFunc(int x);

    static int Square(int x) =&gt; x * x;        // متد استاتیک
    int        Cube  (int x) =&gt; x * x * x;    // متد Instance

    static void Main()
    {
        Delegate staticD = Delegate.CreateDelegate(
            typeof(IntFunc), typeof(Program), &quot;Square&quot;);

        Delegate instanceD = Delegate.CreateDelegate(
            typeof(IntFunc), new Program(), &quot;Cube&quot;);

        Console.WriteLine(staticD.DynamicInvoke(3));   // 9
        Console.WriteLine(instanceD.DynamicInvoke(3)); // 27
    }
}
</code></pre>
<p>برای فراخوانی Delegate ایجادشده، می‌توانید از <code>DynamicInvoke</code> استفاده کنید (همان‌طور که در مثال بالا دیدیم) یا آن را به نوع Delegate اصلی Cast کنید:</p>
<pre><code class="language-csharp">IntFunc f = (IntFunc)staticD;
Console.WriteLine(f(3));   // 9 (اما بسیار سریع‌تر!)
</code></pre>
<p>همچنین می‌توانید به‌جای نام متد، یک <code>MethodInfo</code> به <code>CreateDelegate</code> بدهید. جزئیات مربوط به <code>MethodInfo</code> در بخش <strong>“Reflecting and Invoking Members”</strong> در صفحه 813 آمده است، همراه با دلیل اینکه چرا بهتر است یک Delegate ایجادشده‌ی دینامیکی را دوباره به نوع Delegate ایستای خودش Cast کنیم.</p>
<h2>🧩 انواع جنریک (Generic Types)</h2>
<p>یک شیء از نوع <code>Type</code> می‌تواند نشان‌دهنده‌ی یک نوع جنریک <strong>بسته (Closed)</strong> یا <strong>باز (Unbound)</strong> باشد.
همانند زمان کامپایل، فقط نوع جنریک بسته را می‌توان نمونه‌سازی کرد، در حالی‌که نوع باز غیرقابل نمونه‌سازی است:</p>
<pre><code class="language-csharp">Type closed = typeof(List&lt;int&gt;);
List&lt;int&gt; list = (List&lt;int&gt;)Activator.CreateInstance(closed);  // OK ✅

Type unbound = typeof(List&lt;&gt;);
object anError = Activator.CreateInstance(unbound);            // خطای زمان اجرا ❌
</code></pre>
<p>برای تبدیل یک نوع جنریک باز به بسته از متد <code>MakeGenericType</code> استفاده می‌کنیم:</p>
<pre><code class="language-csharp">Type unbound = typeof(List&lt;&gt;);
Type closed = unbound.MakeGenericType(typeof(int));
</code></pre>
<p>برعکس آن، متد <code>GetGenericTypeDefinition</code> یک نوع بسته را دوباره به شکل باز برمی‌گرداند:</p>
<pre><code class="language-csharp">Type unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2
</code></pre>
<p>🔎 ویژگی‌های کلیدی:</p>
<ul>
<li><code>IsGenericType</code> → بررسی می‌کند که آیا یک نوع، جنریک است یا نه.</li>
<li><code>IsGenericTypeDefinition</code> → بررسی می‌کند که آیا نوع، <strong>باز (unbound)</strong> است یا نه.</li>
</ul>
<p>مثال بررسی نوع Nullable:</p>
<pre><code class="language-csharp">Type nullable = typeof(bool?);
Console.WriteLine(
    nullable.IsGenericType &amp;&amp;
    nullable.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;));   // True
</code></pre>
<p>همچنین، متد <code>GetGenericArguments</code> آرگومان‌های نوع را بازمی‌گرداند:</p>
<pre><code class="language-csharp">Console.WriteLine(closed.GetGenericArguments()[0]);   // System.Int32
Console.WriteLine(nullable.GetGenericArguments()[0]); // System.Boolean
Console.WriteLine(unbound.GetGenericArguments()[0]);  // T (پلا‌یس‌هولدر)
</code></pre>
<p>📌 در زمان اجرا، تمام انواع جنریک یا <strong>باز (Unbound)</strong> هستند یا <strong>بسته (Closed)</strong>.</p>
<ul>
<li>حالت باز فقط در موارد نادری مثل <code>typeof(Foo&lt;&gt;)</code> رخ می‌دهد.</li>
<li>هیچ‌وقت نوع «باز» واقعی در زمان اجرا وجود ندارد؛ کامپایلر همه را به نوع بسته تبدیل می‌کند.</li>
</ul>
<p>مثال زیر همیشه False چاپ می‌کند:</p>
<pre><code class="language-csharp">class Foo&lt;T&gt;
{
    public void Test()
        =&gt; Console.Write(GetType().IsGenericTypeDefinition);  
}
</code></pre>
<hr>
<h2>🔍 بازتاب اعضا (Reflecting and Invoking Members)</h2>
<p>برای بازتاب اعضای یک نوع، از متد <code>GetMembers</code> استفاده می‌کنیم.</p>
<pre><code class="language-csharp">class Walnut
{
    private bool cracked;
    public void Crack() { cracked = true; }
}

MemberInfo[] members = typeof(Walnut).GetMembers();
foreach (MemberInfo m in members)
    Console.WriteLine(m);
</code></pre>
<p>نتیجه:</p>
<pre><code>Void Crack()
System.Type GetType()
System.String ToString()
Boolean Equals(System.Object)
Int32 GetHashCode()
Void .ctor()
</code></pre>
<hr>
<h3>🔹 TypeInfo و بازتاب اعضا</h3>
<p>کلاس <code>TypeInfo</code> یک پروتکل ساده‌تر برای بازتاب اعضا ارائه می‌دهد.</p>
<ul>
<li>به جای متدهایی مثل <code>GetMembers</code> که آرایه بازمی‌گردانند، این کلاس ویژگی‌هایی از نوع <code>IEnumerable&lt;T&gt;</code> ارائه می‌دهد که معمولاً با <strong>LINQ</strong> استفاده می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">IEnumerable&lt;MemberInfo&gt; members =
    typeof(Walnut).GetTypeInfo().DeclaredMembers;
</code></pre>
<p>نتیجه (برخلاف <code>GetMembers</code> که اعضای ارث‌برده‌شده را هم برمی‌گرداند):</p>
<pre><code>Void Crack()
Void .ctor()
Boolean cracked
</code></pre>
<p>همچنین ویژگی‌های خاصی برای گرفتن نوع مشخصی از اعضا وجود دارد (مثل <code>DeclaredMethods</code>, <code>DeclaredProperties</code> و غیره).
برای گرفتن یک متد خاص با نام (اما بدون امکان تعیین پارامترها)، از <code>GetDeclaredMethod</code> استفاده می‌شود.</p>
<p>برای متدهای overload باید از LINQ استفاده کرد:</p>
<pre><code class="language-csharp">MethodInfo method = typeof(int).GetTypeInfo().DeclaredMethods
    .FirstOrDefault(m =&gt; m.Name == &quot;ToString&quot; &amp;&amp;
                         m.GetParameters().Length == 0);
</code></pre>
<hr>
<h3>🔹 جزئیات بیشتر در مورد GetMembers</h3>
<ul>
<li>بدون آرگومان → تمام اعضای public نوع و پایه‌هایش برگردانده می‌شوند.</li>
<li><code>GetMember(&quot;Crack&quot;)</code> → عضو خاصی را با نام می‌گیرد (اما به‌صورت آرایه برمی‌گرداند چون ممکن است overload داشته باشد).</li>
</ul>
<pre><code class="language-csharp">MemberInfo[] m = typeof(Walnut).GetMember(&quot;Crack&quot;);
Console.WriteLine(m[0]);   // Void Crack()
</code></pre>
<p><code>MemberInfo.MemberType</code> یک enum از نوع <code>MemberTypes</code> است که مقادیر زیر را دارد:</p>
<pre><code>All, Constructor, Custom, Event, Field, Method,
NestedType, Property, TypeInfo
</code></pre>
<p>می‌توان با استفاده از این enum نتیجه‌ی متد <code>GetMembers</code> را محدود کرد یا مستقیماً از متدهای اختصاصی مثل <code>GetMethods</code>, <code>GetFields</code>, <code>GetProperties</code> و ... استفاده کرد.</p>
<p>✅ توصیه: همیشه هنگام گرفتن اعضا، تا جای ممکن دقیق باشید. مثلاً هنگام گرفتن متدی با نام خاص، نوع همه‌ی پارامترها را مشخص کنید تا اگر بعداً متد overload شد، کد شما همچنان درست کار کند.</p>
<hr>
<h3>🔹 DeclaringType و ReflectedType</h3>
<p>یک شیء <code>MemberInfo</code> دو ویژگی دارد:</p>
<ul>
<li><code>DeclaringType</code> → نوعی که عضو را تعریف کرده.</li>
<li><code>ReflectedType</code> → نوعی که متد <code>GetMembers</code> روی آن فراخوانی شده.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">MethodInfo test = typeof(Program).GetMethod(&quot;ToString&quot;);
MethodInfo obj  = typeof(object).GetMethod(&quot;ToString&quot;);

Console.WriteLine(test.DeclaringType);   // System.Object
Console.WriteLine(obj.DeclaringType);    // System.Object
Console.WriteLine(test.ReflectedType);   // Program
Console.WriteLine(obj.ReflectedType);    // System.Object
Console.WriteLine(test == obj);          // False
</code></pre>
<p>در اینجا، تفاوت فقط به خاطر Reflection API است؛ در حقیقت <code>Program</code> هیچ متد جدیدی به نام <code>ToString</code> ندارد.</p>
<p>برای بررسی اینکه آیا دو متد واقعاً یکی هستند:</p>
<pre><code class="language-csharp">Console.WriteLine(test.MethodHandle == obj.MethodHandle); // True
Console.WriteLine(test.MetadataToken == obj.MetadataToken
                  &amp;&amp; test.Module == obj.Module);           // True
</code></pre>
<hr>
<h3>📝 نکات پایانی</h3>
<ul>
<li><code>MethodHandle</code> → برای هر متد متمایز در یک پروسه یکتا است.</li>
<li><code>MetadataToken</code> → برای تمام انواع و اعضا در یک Assembly Module یکتا است.</li>
<li><code>MemberInfo</code> متدهایی برای دریافت Attributeهای سفارشی هم دارد (بخش «Retrieving Attributes at Runtime» در صفحه 832).</li>
<li>متد <code>MethodBase.GetCurrentMethod</code>، متد در حال اجرا را بازمی‌گرداند.</li>
</ul>
<p>📌 در نهایت، <code>MemberInfo</code> خودش انتزاعی است و پایه‌ای برای انواع دیگر است (به شکل <strong>Figure 18-1</strong> در کتاب).</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>شما می‌توانید یک MemberInfo را بر اساس ویژگی MemberType آن به زیرکلاس مناسبش Cast کنید. اگر یک عضو را از طریق GetMethod, GetField, GetProperty, GetEvent, GetConstructor یا GetNestedType (یا نسخه‌های جمع آن‌ها) به دست آورده باشید، نیازی به Cast نیست.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>هر زیرکلاس از <code>MemberInfo</code> مجموعه‌ای غنی از ویژگی‌ها و متدها دارد که تمام جنبه‌های متادیتای یک عضو را آشکار می‌کند. این شامل مواردی مثل سطح دسترسی (visibility)، اصلاح‌کننده‌ها (modifiers)، آرگومان‌های نوع جنریک، پارامترها، نوع بازگشتی و ویژگی‌های سفارشی (custom attributes) می‌شود.</p>
<p>نمونه‌ای از استفاده از <code>GetMethod</code>:</p>
<pre><code class="language-csharp">MethodInfo m = typeof (Walnut).GetMethod (&quot;Crack&quot;);
Console.WriteLine (m);            // Void Crack()
Console.WriteLine (m.ReturnType); // System.Void
</code></pre>
<p>تمام نمونه‌های *Info توسط Reflection API در اولین استفاده کش می‌شوند:</p>
<pre><code class="language-csharp">MethodInfo method = typeof (Walnut).GetMethod (&quot;Crack&quot;);
MemberInfo member = typeof (Walnut).GetMember (&quot;Crack&quot;)[0];
Console.Write (method == member);   // True
</code></pre>
<p>این کش شدن علاوه بر حفظ هویت شیء، کارایی را هم در یک API نسبتاً کند بهبود می‌دهد.</p>
<h3>اعضای C# در برابر اعضای CLR ⚖️</h3>
<p>جدول قبلی نشان داد که برخی از ساختارهای C# به‌طور مستقیم و یک‌به‌یک (1:1) با ساختارهای CLR متناظر نیستند. این منطقی است چون CLR و Reflection API برای تمام زبان‌های .NET طراحی شده‌اند—حتی می‌توان از Reflection در Visual Basic هم استفاده کرد.</p>
<p>برخی ساختارهای C# (مثل indexer، enum، operator و finalizer) در CLR به شکل متفاوتی پیاده‌سازی می‌شوند:</p>
<ul>
<li>یک <strong>C# indexer</strong> به پراپرتی‌ای ترجمه می‌شود که یک یا چند آرگومان می‌گیرد و با <code>[DefaultMember]</code> مشخص می‌شود.</li>
<li>یک <strong>C# enum</strong> به زیرکلاسی از <code>System.Enum</code> ترجمه می‌شود که برای هر عضو یک فیلد استاتیک دارد.</li>
<li>یک <strong>C# operator</strong> به متدی استاتیک با نامی خاص (شروع‌شده با <code>op_</code> مثل <code>&quot;op_Addition&quot;</code>) ترجمه می‌شود.</li>
<li>یک <strong>C# finalizer</strong> به متدی ترجمه می‌شود که <code>Finalize</code> را override می‌کند.</li>
</ul>
<p>❗ پیچیدگی دیگر این است که پراپرتی‌ها و رویدادها در واقع شامل دو چیز هستند:</p>
<ul>
<li>متادیتایی که پراپرتی یا رویداد را توصیف می‌کند (در قالب <code>PropertyInfo</code> یا <code>EventInfo</code>)</li>
<li>یک یا دو متد پشتیبان (backing methods)</li>
</ul>
<p>در برنامه C#، این متدهای پشتیبان داخل تعریف پراپرتی یا رویداد قرار دارند. اما وقتی به IL کامپایل می‌شود، این متدها مثل متدهای عادی دیده می‌شوند و می‌توان آن‌ها را فراخوانی کرد.</p>
<p>به همین دلیل <code>GetMethods</code> علاوه بر متدهای عادی، متدهای پشتیبان پراپرتی و رویدادها را هم برمی‌گرداند:</p>
<pre><code class="language-csharp">class Test { public int X { get { return 0; } set {} } }

void Demo()
{
  foreach (MethodInfo mi in typeof (Test).GetMethods())
    Console.Write (mi.Name + &quot;  &quot;);
}
// OUTPUT:
// get_X  set_X  GetType  ToString  Equals  GetHashCode
</code></pre>
<p>برای شناسایی این متدها می‌توان از ویژگی <code>IsSpecialName</code> در <code>MethodInfo</code> استفاده کرد. مقدار آن برای متدهای پراپرتی، ایندکسر، رویداد و عملگرها <strong>true</strong> است. برای متدهای معمولی C# (و متد <code>Finalize</code> در صورت وجود finalizer) مقدار آن <strong>false</strong> خواهد بود.</p>
<p>در ادامه، متدهای پشتیبانی که C# تولید می‌کند را خواهیم دید.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>هر متد پشتیبان (backing method) شیء مخصوص به خودش از نوع <code>MethodInfo</code> دارد. می‌توانید به این صورت به آن‌ها دسترسی پیدا کنید:</p>
<pre><code class="language-csharp">PropertyInfo pi = typeof (Console).GetProperty (&quot;Title&quot;);
MethodInfo getter = pi.GetGetMethod();                   // get_Title
MethodInfo setter = pi.GetSetMethod();                   // set_Title
MethodInfo[] both = pi.GetAccessors();                   // Length==2
</code></pre>
<p>برای رویدادها (Event)، متدهای <code>GetAddMethod</code> و <code>GetRemoveMethod</code> کار مشابهی برای <code>EventInfo</code> انجام می‌دهند.</p>
<p>برای حرکت در جهت عکس—یعنی رفتن از یک <code>MethodInfo</code> به <code>PropertyInfo</code> یا <code>EventInfo</code> مربوطه—باید یک کوئری انجام دهید. در اینجا LINQ برای این کار ایدئال است:</p>
<pre><code class="language-csharp">PropertyInfo p = mi.DeclaringType.GetProperties()
                  .First (x =&gt; x.GetAccessors (true).Contains (mi));
</code></pre>
<hr>
<h3>پراپرتی‌های Init-only 🛠️</h3>
<p>پراپرتی‌های Init-only که در C# 9 معرفی شدند، می‌توانند از طریق <strong>object initializer</strong> مقداردهی شوند، اما بعد از آن توسط کامپایلر فقط به‌عنوان <em>فقط-خواندنی</em> در نظر گرفته می‌شوند.</p>
<p>از دید CLR، یک <strong>init accessor</strong> درست مثل یک <strong>set accessor</strong> عادی است، با این تفاوت که یک فلگ خاص روی نوع بازگشتی متد <code>set</code> اعمال می‌شود (این فلگ برای کامپایلر معنا دارد).</p>
<p>نکته جالب این است که این فلگ به شکل یک <strong>attribute قراردادی</strong> رمزگذاری نشده است. در عوض، از یک مکانیزم کمتر شناخته‌شده به نام <strong>modreq</strong> استفاده می‌کند. این باعث می‌شود که نسخه‌های قدیمی‌تر کامپایلر C# (که modreq جدید را نمی‌شناسند) آن accessor را نادیده بگیرند، به‌جای اینکه پراپرتی را قابل نوشتن در نظر بگیرند.</p>
<p>نام modreq برای accessorهای init-only برابر است با <code>IsExternalInit</code> و می‌توانید به این صورت آن را بررسی کنید:</p>
<pre><code class="language-csharp">bool IsInitOnly (PropertyInfo pi) =&gt; pi
 .GetSetMethod().ReturnParameter.GetRequiredCustomModifiers()
 .Any (t =&gt; t.Name == &quot;IsExternalInit&quot;);
</code></pre>
<hr>
<h3>NullabilityInfoContext ☑️</h3>
<p>از .NET 6 به بعد، می‌توانید با کلاس <code>NullabilityInfoContext</code> اطلاعاتی درباره <strong>annotation</strong>‌های nullability برای فیلد، پراپرتی، رویداد یا پارامترها به دست آورید:</p>
<pre><code class="language-csharp">void PrintPropertyNullability (PropertyInfo pi)
{
 var info = new NullabilityInfoContext().Create (pi);
 Console.WriteLine (pi.Name + &quot; read &quot; + info.ReadState);
 Console.WriteLine (pi.Name + &quot; write &quot; + info.WriteState);
 // از info.Element برای گرفتن اطلاعات nullability عناصر آرایه استفاده کنید
}
</code></pre>
<hr>
<h3>اعضای نوع جنریک 🔁</h3>
<p>می‌توانید متادیتای اعضا را هم برای <strong>انواع جنریک باز (unbound generic types)</strong> و هم برای <strong>انواع جنریک بسته (closed generic types)</strong> به دست آورید:</p>
<pre><code class="language-csharp">PropertyInfo unbound = typeof (IEnumerator&lt;&gt;)  .GetProperty (&quot;Current&quot;);
PropertyInfo closed = typeof (IEnumerator&lt;int&gt;).GetProperty (&quot;Current&quot;);
Console.WriteLine (unbound);   // T Current
Console.WriteLine (closed);    // Int32 Current
Console.WriteLine (unbound.PropertyType.IsGenericParameter);  // True
Console.WriteLine (closed.PropertyType.IsGenericParameter);   // False
</code></pre>
<p>شیءهای <code>MemberInfo</code> که از انواع جنریک باز و بسته بازگردانده می‌شوند همیشه متمایز هستند، حتی اگر امضای اعضا شامل پارامترهای نوع جنریک نباشد:</p>
<pre><code class="language-csharp">PropertyInfo unbound = typeof (List&lt;&gt;)  .GetProperty (&quot;Count&quot;);
PropertyInfo closed = typeof (List&lt;int&gt;).GetProperty (&quot;Count&quot;);
Console.WriteLine (unbound);   // Int32 Count
Console.WriteLine (closed);    // Int32 Count
Console.WriteLine (unbound == closed);   // False
Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True
Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False
</code></pre>
<p>❌ اعضای انواع جنریک باز (<strong>unbound generic types</strong>) را نمی‌توان به‌صورت داینامیک invoke کرد.</p>
<h3>فراخوانی پویا اعضا ⚡</h3>
<p>فراخوانی پویا یک عضو می‌تواند با استفاده از کتابخانه‌ی <strong>Uncapsulator</strong> (متن‌باز و موجود در NuGet و GitHub) بسیار راحت‌تر انجام شود. این کتابخانه که توسط نویسنده‌ی کتاب نوشته شده، یک API روان برای فراخوانی اعضای عمومی و غیرعمومی از طریق Reflection، با استفاده از یک <strong>dynamic binder</strong> سفارشی ارائه می‌دهد.</p>
<p>پس از آنکه یک شیء از نوع <code>MethodInfo</code>، <code>PropertyInfo</code> یا <code>FieldInfo</code> داشته باشید، می‌توانید آن را به‌صورت پویا فراخوانی کنید یا مقدارش را بگیرید/تعیین کنید. این کار <strong>late binding</strong> نام دارد، زیرا شما انتخاب می‌کنید کدام عضو در زمان اجرا (runtime) فراخوانی شود، نه در زمان کامپایل.</p>
<p>برای نمونه، این کد با <strong>static binding</strong> عادی نوشته شده است:</p>
<pre><code class="language-csharp">string s = &quot;Hello&quot;;
int length = s.Length;
</code></pre>
<p>و همین کار با <strong>late binding</strong> پویا چنین خواهد بود:</p>
<pre><code class="language-csharp">object s = &quot;Hello&quot;;
PropertyInfo prop = s.GetType().GetProperty (&quot;Length&quot;);
int length = (int) prop.GetValue (s, null);   // 5
</code></pre>
<p>متدهای <code>GetValue</code> و <code>SetValue</code> مقدار یک <code>PropertyInfo</code> یا <code>FieldInfo</code> را می‌گیرند یا تنظیم می‌کنند. آرگومان اول نمونه (instance) است، که برای اعضای <code>static</code> می‌تواند <code>null</code> باشد.</p>
<p>برای دسترسی به <strong>Indexer</strong> نیز درست مثل پراپرتی‌ای به نام <code>&quot;Item&quot;</code> رفتار می‌شود، با این تفاوت که مقادیر indexer به‌عنوان آرگومان دوم به <code>GetValue</code> یا <code>SetValue</code> داده می‌شوند.</p>
<p>برای فراخوانی پویا یک متد، متد <code>Invoke</code> را روی یک <code>MethodInfo</code> صدا می‌زنید و یک آرایه از آرگومان‌ها به آن می‌دهید. اگر نوع یکی از آرگومان‌ها اشتباه باشد، یک <strong>exception</strong> در زمان اجرا رخ خواهد داد. با فراخوانی پویا، ایمنی نوع در زمان کامپایل را از دست می‌دهید، اما همچنان ایمنی نوع در زمان اجرا را دارید (دقیقاً مثل استفاده از کلیدواژه‌ی <code>dynamic</code>).</p>
<hr>
<h3>پارامترهای متد 📑</h3>
<p>فرض کنید بخواهیم متد <code>Substring</code> رشته را پویا فراخوانی کنیم. در حالت عادی (static):</p>
<pre><code class="language-csharp">Console.WriteLine (&quot;stamp&quot;.Substring(2));   // &quot;amp&quot;
</code></pre>
<p>معادل پویا با reflection و late binding:</p>
<pre><code class="language-csharp">Type type = typeof (string);
Type[] parameterTypes = { typeof (int) };
MethodInfo method = type.GetMethod (&quot;Substring&quot;, parameterTypes);
object[] arguments = { 2 };
object returnValue = method.Invoke (&quot;stamp&quot;, arguments);
Console.WriteLine (returnValue);   // &quot;amp&quot;
</code></pre>
<p>از آنجا که متد <code>Substring</code> overload دارد، مجبور شدیم یک آرایه از نوع پارامترها بدهیم تا مشخص شود کدام نسخه‌ی متد را می‌خواهیم. در غیر این صورت، <code>GetMethod</code> خطای <code>AmbiguousMatchException</code> خواهد داد.</p>
<p>متد <code>GetParameters</code> که در کلاس پایه‌ی <code>MethodBase</code> (برای <code>MethodInfo</code> و <code>ConstructorInfo</code>) تعریف شده، اطلاعات متادیتا درباره‌ی پارامترها را برمی‌گرداند:</p>
<pre><code class="language-csharp">ParameterInfo[] paramList = method.GetParameters();
foreach (ParameterInfo x in paramList)
{
 Console.WriteLine (x.Name);          // startIndex
 Console.WriteLine (x.ParameterType); // System.Int32
}
</code></pre>
<hr>
<h3>برخورد با پارامترهای ref و out 🔄</h3>
<p>برای پاس دادن پارامترهای <code>ref</code> یا <code>out</code>، باید قبل از گرفتن متد، متد <code>MakeByRefType</code> را روی نوع صدا بزنید. برای نمونه، اجرای پویا کد زیر:</p>
<pre><code class="language-csharp">int x;
bool successfulParse = int.TryParse (&quot;23&quot;, out x);
</code></pre>
<p>به شکل زیر خواهد بود:</p>
<pre><code class="language-csharp">object[] args = { &quot;23&quot;, 0 };
Type[] argTypes = { typeof (string), typeof (int).MakeByRefType() };
MethodInfo tryParse = typeof (int).GetMethod (&quot;TryParse&quot;, argTypes);
bool successfulParse = (bool) tryParse.Invoke (null, args);
Console.WriteLine (successfulParse + &quot; &quot; + args[1]);   // True 23
</code></pre>
<p>همین روش برای هر دو نوع <code>ref</code> و <code>out</code> کار می‌کند.</p>
<hr>
<h3>بازیابی و فراخوانی متدهای جنریک 🔧</h3>
<p>گاهی لازم است هنگام فراخوانی <code>GetMethod</code> نوع پارامترها را مشخص کنیم تا بین متدهای overload تمایز قائل شویم. اما امکان مشخص کردن <strong>نوع‌های جنریک</strong> به‌طور مستقیم وجود ندارد.</p>
<p>برای نمونه، کلاس <code>System.Linq.Enumerable</code> دو overload برای متد <code>Where</code> دارد:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);

public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate);
</code></pre>
<p>برای بازیابی یک overload خاص، باید همه‌ی متدها را بگیریم و سپس مورد دلخواه را دستی انتخاب کنیم. کوئری زیر overload اول را برمی‌گرداند:</p>
<pre><code class="language-csharp">from m in typeof (Enumerable).GetMethods()
where m.Name == &quot;Where&quot; &amp;&amp; m.IsGenericMethod 
let parameters = m.GetParameters()
where parameters.Length == 2
let genArg = m.GetGenericArguments().First()
let enumerableOfT = typeof (IEnumerable&lt;&gt;).MakeGenericType (genArg)
let funcOfTBool = typeof (Func&lt;,&gt;).MakeGenericType (genArg, typeof (bool))
where parameters[0].ParameterType == enumerableOfT
  &amp;&amp; parameters[1].ParameterType == funcOfTBool
select m
</code></pre>
<p>فراخوانی <code>.Single()</code> روی این کوئری، شیء <code>MethodInfo</code> درست با پارامترهای نوع باز (unbound) را برمی‌گرداند. گام بعدی بستن پارامترهای نوعی است، با استفاده از <code>MakeGenericMethod</code>:</p>
<pre><code class="language-csharp">var closedMethod = unboundMethod.MakeGenericMethod (typeof (int));
</code></pre>
<p>در این حالت، نوع <code>TSource</code> با <code>int</code> بسته شده و می‌توانیم <code>Enumerable.Where</code> را با منبعی از نوع <code>IEnumerable&lt;int&gt;</code> و شرطی از نوع <code>Func&lt;int,bool&gt;</code> صدا بزنیم:</p>
<pre><code class="language-csharp">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;   // فقط اعداد فرد
var query = (IEnumerable&lt;int&gt;) closedMethod.Invoke 
 (null, new object[] { source, predicate });
foreach (int element in query) Console.Write (element + &quot;|&quot;);   // 3|5|7|
</code></pre>
<hr>
<h3>استفاده از System.Linq.Expressions 🎭</h3>
<p>اگر از API مربوط به <code>System.Linq.Expressions</code> برای ساخت داینامیک expressionها استفاده کنید (فصل ۸)، دیگر نیازی به این کارهای دستی برای مشخص کردن متد جنریک ندارید. متد <code>Expression.Call</code> overloadهایی دارد که اجازه می‌دهد نوع‌های بسته‌ی جنریک را مشخص کنید:</p>
<pre><code class="language-csharp">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;
var sourceExpr = Expression.Constant (source);
var predicateExpr = Expression.Constant (predicate);
var callExpression = Expression.Call (
 typeof (Enumerable), &quot;Where&quot;,
 new[] { typeof (int) },  // نوع جنریک بسته
 sourceExpr, predicateExpr);
</code></pre>
<h3>استفاده از Delegate برای بهبود عملکرد ⚡</h3>
<p>فراخوانی‌های داینامیک نسبتاً کم‌کارآمد هستند و معمولاً overhead آن‌ها در محدوده‌ی چند میکروثانیه است. اگر یک متد را بارها در یک حلقه فراخوانی می‌کنید، می‌توانید این overhead را به سطح نانوثانیه کاهش دهید، با ایجاد یک <strong>delegate داینامیک</strong> که به متد داینامیک شما اشاره می‌کند.</p>
<p>مثال زیر، متد <code>Trim</code> رشته را یک میلیون بار بدون overhead قابل توجه فراخوانی می‌کند:</p>
<pre><code class="language-csharp">delegate string StringToString(string s);

MethodInfo trimMethod = typeof(string).GetMethod(&quot;Trim&quot;, new Type[0]);
var trim = (StringToString) Delegate.CreateDelegate(typeof(StringToString), trimMethod);

for (int i = 0; i &lt; 1000000; i++)
    trim(&quot;test&quot;);
</code></pre>
<p>این روش سریع‌تر است زیرا <strong>late binding</strong> پرهزینه فقط یک بار اتفاق می‌افتد.</p>
<hr>
<h3>دسترسی به اعضای غیرعمومی 🔒</h3>
<p>تمام متدهای بازتابی برای بررسی metadata (مثل <code>GetProperty</code>, <code>GetField</code> و غیره) overloadهایی دارند که یک <code>BindingFlags</code> می‌گیرند. این enum به‌عنوان یک فیلتر عمل می‌کند و اجازه می‌دهد معیارهای انتخاب پیش‌فرض را تغییر دهید. رایج‌ترین کاربرد، بازیابی اعضای غیرعمومی است (کار می‌کند فقط در اپلیکیشن‌های دسکتاپ).</p>
<p>نمونه:</p>
<pre><code class="language-csharp">class Walnut
{
    private bool cracked;
    public void Crack() { cracked = true; }
    public override string ToString() { return cracked.ToString(); }
}

Type t = typeof(Walnut);
Walnut w = new Walnut();
w.Crack();

FieldInfo f = t.GetField(&quot;cracked&quot;, BindingFlags.NonPublic | BindingFlags.Instance);
f.SetValue(w, false);

Console.WriteLine(w);   // False
</code></pre>
<p>دسترسی به اعضای غیرعمومی با reflection قدرتمند است، اما خطرناک هم هست؛ زیرا می‌توانید <strong>encapsulation</strong> را دور بزنید و وابستگی به پیاده‌سازی داخلی ایجاد کنید.</p>
<hr>
<h3>مقدمه‌ای بر BindingFlags 🏷</h3>
<p><code>BindingFlags</code> برای ترکیب بیتی طراحی شده است. برای اینکه چیزی پیدا شود، باید یکی از چهار ترکیب زیر را انتخاب کنید:</p>
<ul>
<li><code>BindingFlags.Public | BindingFlags.Instance</code></li>
<li><code>BindingFlags.Public | BindingFlags.Static</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Instance</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Static</code></li>
</ul>
<p><code>NonPublic</code> شامل internal، protected، protected internal و private می‌شود.</p>
<p>مثال:</p>
<pre><code class="language-csharp">// همه اعضای public و static
BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;
MemberInfo[] members = typeof(object).GetMembers(publicStatic);

// همه اعضای nonpublic (static و instance)
BindingFlags nonPublicBinding = BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
members = typeof(object).GetMembers(nonPublicBinding);
</code></pre>
<p>پرچم <code>DeclaredOnly</code> اعضای ارث‌بری شده را کنار می‌گذارد، مگر اینکه override شده باشند. این flag کمی گیج‌کننده است زیرا <strong>مجموعه نتیجه را محدود می‌کند</strong>، در حالی که بقیه flagها مجموعه نتیجه را گسترش می‌دهند.</p>
<hr>
<h3>فراخوانی متدهای جنریک 🎯</h3>
<p>شما نمی‌توانید مستقیماً متدهای جنریک را Invoke کنید؛ مثال زیر خطا می‌دهد:</p>
<pre><code class="language-csharp">class Program
{
    public static T Echo&lt;T&gt;(T x) { return x; }
    static void Main()
    {
        MethodInfo echo = typeof(Program).GetMethod(&quot;Echo&quot;);
        Console.WriteLine(echo.IsGenericMethodDefinition);    // True
        echo.Invoke(null, new object[] { 123 });             // Exception
    }
}
</code></pre>
<p>راه حل: ابتدا متد <code>MakeGenericMethod</code> را روی <code>MethodInfo</code> صدا بزنید و <strong>نوع‌های جنریک مشخص</strong> بدهید. این یک <code>MethodInfo</code> جدید برمی‌گرداند که می‌توان آن را فراخوانی کرد:</p>
<pre><code class="language-csharp">MethodInfo echo = typeof(Program).GetMethod(&quot;Echo&quot;);
MethodInfo intEcho = echo.MakeGenericMethod(typeof(int));

Console.WriteLine(intEcho.IsGenericMethodDefinition);          // False
Console.WriteLine(intEcho.Invoke(null, new object[] { 3 }));   // 3
</code></pre>
<p>گاهی لازم است تا یک عضو از <strong>رابط جنریک</strong> را فراخوانی کنیم ولی پارامترهای نوع آن تا زمان اجرا مشخص نیستند. این مورد در طراحی‌های ایده‌آل کمیاب است، اما در عمل کاربرد دارد.</p>
<p>برای مثال، اگر بخواهیم نسخه‌ای قدرتمندتر از <code>ToString</code> بسازیم که نتایج LINQ را نیز گسترش دهد:</p>
<pre><code class="language-csharp">public static string ToStringEx&lt;T&gt;(IEnumerable&lt;T&gt; sequence) { ... }
</code></pre>
<p>اما این محدود است. اگر <code>sequence</code> شامل مجموعه‌های تو در تو باشد، باید overloadهای متعدد بسازیم که عملی نیست. راه حل بهتر، نوشتن متدی است که <strong>هر شیء دلخواهی</strong> را پردازش کند:</p>
<pre><code class="language-csharp">public static string ToStringEx(object value)
{
    if (value == null) return &quot;&lt;null&gt;&quot;;
    StringBuilder sb = new StringBuilder();

    if (value is IList)
        sb.AppendLine(&quot;A list with &quot; + ((IList)value).Count + &quot; items&quot;);

    // بررسی IGrouping&lt;,&gt; با reflection
    Type closedIGrouping = value.GetType().GetInterfaces()
        .Where(t =&gt; t.IsGenericType &amp;&amp;
                    t.GetGenericTypeDefinition() == typeof(IGrouping&lt;,&gt;))
        .FirstOrDefault();

    if (closedIGrouping != null)
    {
        PropertyInfo pi = closedIGrouping.GetProperty(&quot;Key&quot;);
        object key = pi.GetValue(value, null);
        sb.Append(&quot;Group with key=&quot; + key + &quot;: &quot;);
    }

    if (value is IEnumerable)
        foreach (object element in (IEnumerable)value)
            sb.Append(ToStringEx(element) + &quot; &quot;);

    if (sb.Length == 0) sb.Append(value.ToString());
    return &quot;\r\n&quot; + sb.ToString();
}
</code></pre>
<ul>
<li>برای <code>List&lt;&gt;</code> می‌توان از <code>IList</code> غیرجنریک استفاده کرد، زیرا <code>List&lt;&gt;</code> این رابط را پیاده‌سازی کرده است.</li>
<li>برای <code>IGrouping&lt;,&gt;</code> باید از <strong>نوع بسته (closed generic)</strong> استفاده کنیم و سپس با reflection عضو <code>Key</code> را فراخوانی کنیم.</li>
</ul>
<p>این روش پایدار است و چه <code>IGrouping&lt;,&gt;</code> به‌صورت <strong>ضمنی</strong> یا <strong>صریح</strong> پیاده‌سازی شده باشد، کار می‌کند.</p>
<p>مثال استفاده:</p>
<pre><code class="language-csharp">Console.WriteLine(ToStringEx(new List&lt;int&gt; { 5, 6, 7 }));
Console.WriteLine(ToStringEx(&quot;xyyzzz&quot;.GroupBy(c =&gt; c)));
</code></pre>
<p>خروجی:</p>
<pre><code>List of 3 items: 5 6 7
Group with key=x: x
Group with key=y: y y
Group with key=z: z z z
</code></pre>
<p>برای بازتاب یک Assembly به‌صورت دینامیک، می‌توان از <code>GetType</code> یا <code>GetTypes</code> استفاده کرد.</p>
<p>مثال دریافت نوع <code>Demos.TestProgram</code> از assembly جاری:</p>
<pre><code class="language-csharp">Type t = Assembly.GetExecutingAssembly().GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>یا از روی یک نوع موجود:</p>
<pre><code class="language-csharp">typeof(Foo).Assembly.GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>لیست تمام انواع در یک Assembly خارجی:</p>
<pre><code class="language-csharp">Assembly a = Assembly.LoadFile(@&quot;e:\demo\mylib.dll&quot;);
foreach (Type t in a.GetTypes())
    Console.WriteLine(t);
</code></pre>
<p>یا با <code>TypeInfo</code>:</p>
<pre><code class="language-csharp">Assembly a = typeof(Foo).GetTypeInfo().Assembly;
foreach (Type t in a.ExportedTypes)
    Console.WriteLine(t);
</code></pre>
<blockquote>
<p>توجه: <code>GetTypes</code> و <code>ExportedTypes</code> فقط انواع سطح بالا را برمی‌گردانند، انواع تو در تو را خیر.
فراخوانی <code>GetTypes</code> روی یک اسمبلی چندماژوله، تمام نوع‌ها را در همه ماژول‌ها برمی‌گرداند. در نتیجه، می‌توانید وجود ماژول‌ها را نادیده بگیرید و یک اسمبلی را به‌عنوان <strong>کانتینر نوع‌ها</strong> در نظر بگیرید. با این حال، یک مورد وجود دارد که ماژول‌ها اهمیت پیدا می‌کنند—و آن زمانی است که با <strong>توکن‌های متادیتا (metadata tokens)</strong> کار می‌کنید.</p>
</blockquote>
<p>توکن متادیتا یک عدد صحیح است که به‌طور یکتا به یک نوع، عضو، رشته یا منبع در محدوده یک ماژول اشاره می‌کند. IL از توکن‌های متادیتا استفاده می‌کند، بنابراین اگر در حال تحلیل IL هستید، باید بتوانید آن‌ها را حل کنید. متدهای مرتبط در نوع <code>Module</code> تعریف شده‌اند و شامل <code>ResolveType</code>، <code>ResolveMember</code>، <code>ResolveString</code> و <code>ResolveSignature</code> می‌شوند. در بخش پایانی این فصل، هنگام نوشتن <strong>disassembler</strong> دوباره به این موضوع بازمی‌گردیم.</p>
<p>می‌توانید لیست همه ماژول‌های یک اسمبلی را با فراخوانی <code>GetModules</code> به‌دست آورید. همچنین می‌توانید به ماژول اصلی یک اسمبلی مستقیماً از طریق ویژگی <code>ManifestModule</code> دسترسی داشته باشید.</p>
<h3>کار با Attributes 🏷️</h3>
<p>CLR اجازه می‌دهد <strong>متادیتای اضافی</strong> به نوع‌ها، اعضا و اسمبلی‌ها از طریق Attributes متصل شود. این مکانیزم باعث می‌شود برخی از عملکردهای مهم CLR (مانند شناسایی اسمبلی یا marshaling نوع‌ها برای تعامل با native code) هدایت شوند و Attributes را به بخشی جدایی‌ناپذیر از برنامه تبدیل می‌کند.</p>
<p>یکی از ویژگی‌های کلیدی Attributes این است که شما می‌توانید <strong>Attributes خودتان</strong> را بنویسید و سپس مانند هر Attribute دیگری، آن‌ها را برای “تزئین” یک عنصر کد با اطلاعات اضافی استفاده کنید. این اطلاعات اضافی در اسمبلی پایه کامپایل می‌شوند و می‌توان آن‌ها را در زمان اجرا با استفاده از <strong>reflection</strong> بازیابی کرد تا سرویس‌هایی بسازید که به صورت <strong>دکوراتوری و خودکار</strong> عمل می‌کنند، مانند <strong>تست واحد خودکار (automated unit testing)</strong>.</p>
<p>سه نوع Attribute وجود دارد:</p>
<ul>
<li><strong>Bit-mapped attributes</strong></li>
<li><strong>Custom attributes</strong></li>
<li><strong>Pseudocustom attributes</strong></li>
</ul>
<p>از میان این‌ها، تنها <strong>custom attributes</strong> قابل توسعه هستند.</p>
<p>اصطلاح «attribute» به تنهایی می‌تواند به هر سه نوع اشاره کند، اما در دنیای C# بیشتر به <strong>custom attributes</strong> یا <strong>pseudocustom attributes</strong> اشاره دارد.</p>
<p><strong>Bit-mapped attributes</strong> (اصطلاح ما) به بیت‌های اختصاصی در متادیتای نوع نگاشت می‌شوند. اکثر کلمات کلیدی modifier در C#، مانند <code>public</code>، <code>abstract</code> و <code>sealed</code> به Bit-mapped attributes تبدیل می‌شوند. این Attributes بسیار کارآمد هستند زیرا فضای کمی در متادیتا مصرف می‌کنند (معمولاً تنها یک بیت) و CLR می‌تواند آن‌ها را با کمترین یا بدون هیچ واسطه‌ای پیدا کند.</p>
<p>API <strong>reflection</strong> آن‌ها را از طریق ویژگی‌های اختصاصی روی <code>Type</code> (و سایر زیرکلاس‌های <code>MemberInfo</code>) مانند <code>IsPublic</code>، <code>IsAbstract</code> و <code>IsSealed</code> نمایش می‌دهد. ویژگی <code>Attributes</code> یک <strong>enum با flag</strong> برمی‌گرداند که اکثر آن‌ها را به‌صورت یکجا توصیف می‌کند:</p>
<pre><code class="language-csharp">static void Main()
{
    TypeAttributes ta = typeof(Console).Attributes;
    MethodAttributes ma = MethodInfo.GetCurrentMethod().Attributes;
    Console.WriteLine(ta + &quot;\r\n&quot; + ma);
}
</code></pre>
<p>نتیجه:</p>
<pre><code>AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit
PrivateScope, Private, Static, HideBySig
</code></pre>
<p>در مقابل، <strong>custom attributes</strong> به یک Blob در متادیتای اصلی نوع متصل می‌شوند. همه Custom attributes توسط یک زیرکلاس از <code>System.Attribute</code> نمایش داده می‌شوند و برخلاف Bit-mapped attributes، <strong>قابل توسعه</strong> هستند. این Blob کلاس Attribute را شناسایی می‌کند و همچنین مقادیر هر آرگومان موقعیتی یا نام‌گذاری‌شده‌ای که هنگام اعمال Attribute مشخص شده را ذخیره می‌کند. Custom attributes که خودتان تعریف می‌کنید، از نظر معماری کاملاً مشابه آن‌هایی هستند که در کتابخانه‌های .NET تعریف شده‌اند.</p>
<p>در <strong>فصل 4</strong> توضیح داده شده است که چگونه می‌توان Custom attributes را به یک نوع یا عضو در C# متصل کرد. مثال زیر، Attribute از پیش تعریف‌شده <code>Obsolete</code> را به کلاس <code>Foo</code> اعمال می‌کند:</p>
<pre><code class="language-csharp">[Obsolete] public class Foo { ... }
</code></pre>
<p>این به کامپایلر دستور می‌دهد که یک نمونه از <code>ObsoleteAttribute</code> را در متادیتای <code>Foo</code> قرار دهد، که سپس می‌توان آن را در زمان اجرا با فراخوانی <code>GetCustomAttributes</code> روی یک <code>Type</code> یا <code>MemberInfo</code> بازیابی کرد.</p>
<p><strong>Pseudocustom attributes</strong> ظاهر و عملکردی شبیه custom attributes استاندارد دارند. آن‌ها توسط یک زیرکلاس از <code>System.Attribute</code> نمایش داده می‌شوند و به روش استاندارد متصل می‌شوند:</p>
<pre><code class="language-csharp">[System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
class SystemTime { ... }
</code></pre>
<p>تفاوت این است که کامپایلر یا CLR به‌صورت داخلی، Pseudocustom attributes را با تبدیل آن‌ها به Bit-mapped attributes بهینه می‌کند. نمونه‌ها شامل <code>StructLayout</code>، <code>In</code> و <code>Out</code> هستند (فصل 24). Reflection، Pseudocustom attributes را از طریق ویژگی‌های اختصاصی مانند <code>IsLayoutSequential</code> نمایش می‌دهد و در بسیاری از موارد، وقتی <code>GetCustomAttributes</code> فراخوانی شود، به‌عنوان شیء <code>System.Attribute</code> نیز برمی‌گردند.</p>
<p>این بدان معناست که می‌توانید تقریباً تفاوت بین <strong>pseudo-</strong> و <strong>non-pseudo custom attributes</strong> را نادیده بگیرید (استثنای مهم، زمانی است که از <code>Reflection.Emit</code> برای تولید نوع‌ها به‌صورت داینامیک در زمان اجرا استفاده می‌کنید؛ نگاه کنید به فصل «Emitting Assemblies and Types» صفحه 841).
<strong>AttributeUsage</strong> یک Attribute است که روی کلاس‌های Attribute اعمال می‌شود و به کامپایلر می‌گوید چگونه باید Attribute هدف استفاده شود:</p>
<pre><code class="language-csharp">public sealed class AttributeUsageAttribute : Attribute
{
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool AllowMultiple        { get; set; }
    public bool Inherited            { get; set; }
    public AttributeTargets ValidOn  { get; }
}
</code></pre>
<ul>
<li><code>AllowMultiple</code> مشخص می‌کند که آیا Attribute تعریف‌شده می‌تواند بیش از یک بار روی همان هدف اعمال شود یا خیر.</li>
<li><code>Inherited</code> مشخص می‌کند که آیا Attribute اعمال‌شده روی یک کلاس پایه، به کلاس‌های مشتق نیز اعمال شود (یا در مورد متدها، آیا Attribute اعمال‌شده روی متد virtual به متدهای overriding نیز منتقل شود).</li>
<li><code>ValidOn</code> مجموعه اهدافی را تعیین می‌کند که Attribute می‌تواند به آن‌ها متصل شود، مانند کلاس‌ها، اینترفیس‌ها، Properties، متدها، پارامترها و غیره. این ویژگی هر ترکیبی از مقادیر enum <code>AttributeTargets</code> را می‌پذیرد، که شامل موارد زیر است:</li>
</ul>
<pre><code>All, Assembly, Class, Delegate, GenericParameter, Parameter,
Enum, Event, Constructor, Field, Interface, Method, Module,
Property, ReturnValue, Struct
</code></pre>
<p>مثال از نحوه استفاده توسعه‌دهندگان .NET از <code>AttributeUsage</code> روی <code>Serializable</code>:</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Delegate |
                AttributeTargets.Enum     |
                AttributeTargets.Struct   |
                AttributeTargets.Class, Inherited = false)]
public sealed class SerializableAttribute : Attribute { }
</code></pre>
<p>این تقریباً کل تعریف Attribute <code>Serializable</code> است. نوشتن یک کلاس Attribute بدون property یا constructor ویژه، به همین سادگی است.</p>
<h3>تعریف Attribute سفارشی</h3>
<p>برای تعریف Attribute خودتان مراحل زیر را دنبال کنید:</p>
<ol>
<li>از کلاس <code>System.Attribute</code> یا یکی از زیرکلاس‌های آن مشتق شوید. طبق قرارداد، نام کلاس باید با <code>Attribute</code> ختم شود، اگرچه اجباری نیست.</li>
<li>Attribute <code>AttributeUsage</code> را اعمال کنید (توضیح داده شده در بخش قبل). اگر Attribute نیاز به property یا آرگومان ندارد، کار تمام است.</li>
<li>یک یا چند constructor عمومی بنویسید. پارامترهای constructor، پارامترهای موقعیتی (positional) Attribute را تعریف می‌کنند و هنگام استفاده از Attribute اجباری خواهند بود.</li>
<li>برای هر پارامتر نام‌گذاری‌شده (named parameter) که می‌خواهید پشتیبانی کنید، یک فیلد یا property عمومی تعریف کنید. پارامترهای نام‌گذاری‌شده هنگام استفاده از Attribute اختیاری هستند.</li>
</ol>
<p><strong>نوع propertyها و پارامترهای constructor باید یکی از موارد زیر باشد:</strong></p>
<ul>
<li>نوع primitive بسته‌شده (sealed)، مانند <code>bool</code>، <code>byte</code>، <code>char</code>، <code>double</code>، <code>float</code>، <code>int</code>، <code>long</code>، <code>short</code> یا <code>string</code></li>
<li>نوع <code>Type</code></li>
<li>یک enum</li>
<li>آرایه تک‌بعدی از هر یک از موارد بالا</li>
</ul>
<p>هنگام اعمال Attribute، باید امکان ارزیابی <strong>static</strong> compiler برای هر property یا آرگومان constructor وجود داشته باشد.</p>
<p>مثال: یک Attribute برای پشتیبانی از سیستم <strong>آزمون خودکار واحد (unit testing)</strong>:</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Method)]
public sealed class TestAttribute : Attribute
{
    public int    Repetitions;
    public string FailureMessage;
    public TestAttribute() : this(1)     { }
    public TestAttribute(int repetitions) { Repetitions = repetitions; }
}
</code></pre>
<p>و کلاس <code>Foo</code> با متدهایی که با Test Attribute تزئین شده‌اند:</p>
<pre><code class="language-csharp">class Foo
{
    [Test]
    public void Method1() { ... }

    [Test(20)]
    public void Method2() { ... }

    [Test(20, FailureMessage=&quot;Debugging Time!&quot;)]
    public void Method3() { ... }
}
</code></pre>
<p>دو روش استاندارد برای بازیابی Attributes در زمان اجرا وجود دارد:</p>
<ul>
<li>فراخوانی <code>GetCustomAttributes</code> روی هر شیء <code>Type</code> یا <code>MemberInfo</code></li>
<li>فراخوانی <code>Attribute.GetCustomAttribute</code> یا <code>Attribute.GetCustomAttributes</code></li>
</ul>
<p>این دو متد اخیر <strong>overload</strong> شده‌اند تا هر شیء reflection که با یک هدف Attribute معتبر مطابقت دارد (مانند <code>Type</code>، <code>Assembly</code>، <code>Module</code>، <code>MemberInfo</code> یا <code>ParameterInfo</code>) را بپذیرند.</p>
<p>همچنین می‌توان از <code>GetCustomAttributesData()</code> روی یک نوع یا عضو استفاده کرد تا اطلاعات Attribute را به‌دست آورد. تفاوت آن با <code>GetCustomAttributes()</code> این است که نسخه Data به شما نشان می‌دهد Attribute چگونه ایجاد شده است:</p>
<ul>
<li>کدام overload از constructor استفاده شده</li>
<li>مقدار هر آرگومان constructor و پارامتر نام‌گذاری‌شده</li>
</ul>
<p>این قابلیت زمانی مفید است که بخواهید کد یا IL تولید کنید تا Attribute را به همان وضعیت بازسازی کنید (نگاه کنید به «Emitting Type Members» صفحه 844).</p>
<p>مثال: فهرست کردن هر متدی در کلاس <code>Foo</code> که دارای <code>TestAttribute</code> است:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetMethods())
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, typeof(TestAttribute));
    if (att != null)
        Console.WriteLine(&quot;Method {0} will be tested; reps={1}; msg={2}&quot;,
                          mi.Name, att.Repetitions, att.FailureMessage);
}
</code></pre>
<p>یا به شکل زیر:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetTypeInfo().DeclaredMethods)
{ ... }
</code></pre>
<p>خروجی:</p>
<pre><code>Method Method1 will be tested; reps=1; msg=
Method Method2 will be tested; reps=20; msg=
Method Method3 will be tested; reps=20; msg=Debugging Time!
</code></pre>
<p>برای تکمیل مثال و نشان دادن اینکه چگونه می‌توان از این روش برای نوشتن یک <strong>سیستم Unit Testing خودکار</strong> استفاده کرد، نسخه‌ای که متدها را واقعاً فراخوانی می‌کند:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetMethods())
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, typeof(TestAttribute));
    if (att != null)
        for (int i = 0; i &lt; att.Repetitions; i++)
            try
            {
                mi.Invoke(new Foo(), null);  // فراخوانی متد بدون آرگومان
            }
            catch (Exception ex)
            {
                throw new Exception(&quot;Error: &quot; + att.FailureMessage, ex);
            }
}
</code></pre>
<p>نمونه دیگر: فهرست کردن Attributes موجود روی یک نوع مشخص:</p>
<pre><code class="language-csharp">object[] atts = Attribute.GetCustomAttributes(typeof(Test));
foreach (object att in atts) Console.WriteLine(att);

[Serializable, Obsolete]
class Test { }
</code></pre>
<p>خروجی:</p>
<pre><code>System.ObsoleteAttribute
System.SerializableAttribute
</code></pre>
<p>فضای نام <code>System.Reflection.Emit</code> شامل کلاس‌هایی برای ایجاد <strong>متادیتا و IL در زمان اجرا</strong> است. تولید کد به‌صورت داینامیک برای برخی از انواع برنامه‌نویسی کاربرد دارد. به‌عنوان مثال:</p>
<ul>
<li>API <strong>Regular Expressions</strong>، که انواع بهینه‌شده برای هر عبارت منظم تولید می‌کند.</li>
<li><strong>Entity Framework Core</strong>، که از Reflection.Emit برای ایجاد کلاس‌های Proxy جهت فعال‌سازی <strong>Lazy Loading</strong> استفاده می‌کند.</li>
</ul>
<h3>تولید IL با DynamicMethod</h3>
<p>کلاس <code>DynamicMethod</code> یک ابزار سبک در فضای نام <code>System.Reflection.Emit</code> برای ایجاد متدها در لحظه است. برخلاف <code>TypeBuilder</code>، نیازی به تعریف ابتدا یک <strong>Assembly داینامیک</strong>، <strong>Module</strong> و <strong>Type</strong> برای نگهداری متد ندارد. این باعث می‌شود برای کارهای ساده مناسب باشد و همچنین معرفی خوبی برای Reflection.Emit ارائه کند.</p>
<p>یک <code>DynamicMethod</code> و IL مربوط به آن هنگامی که دیگر به آن ارجاعی وجود نداشته باشد، <strong>توسط Garbage Collector پاک می‌شوند</strong>. این یعنی می‌توانید بارها متد داینامیک تولید کنید بدون پر شدن حافظه. (برای انجام همان کار با <strong>dynamic assemblies</strong>، باید پرچم <code>AssemblyBuilderAccess.RunAndCollect</code> را هنگام ایجاد Assembly اعمال کنید.)</p>
<p>نمونه‌ای ساده از استفاده <code>DynamicMethod</code> برای ایجاد متدی که <code>Hello world</code> را در کنسول می‌نویسد:</p>
<pre><code class="language-csharp">public class Test
{
    static void Main()
    {
        var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        gen.EmitWriteLine(&quot;Hello world&quot;);
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(null, null); // Hello world
    }
}
</code></pre>
<p><code>OpCodes</code> شامل یک فیلد <code>static readonly</code> برای هر IL opcode است. بیشتر قابلیت‌ها از طریق این opcodes ارائه می‌شوند، اگرچه <code>ILGenerator</code> متدهای ویژه‌ای برای تولید <strong>Labels</strong>، <strong>متغیرهای محلی</strong> و <strong>مدیریت استثناها</strong> دارد.</p>
<p>یک متد همیشه با <code>OpCodes.Ret</code> که به معنی &quot;return&quot; است یا نوعی دستور branching/throwing پایان می‌یابد. متد <code>EmitWriteLine</code> در <code>ILGenerator</code> یک <strong>میان‌بر</strong> برای تولید تعدادی opcode سطح پایین‌تر است. می‌توانیم همان نتیجه را با جایگزینی آن به شکل زیر به دست آوریم:</p>
<pre><code class="language-csharp">MethodInfo writeLineStr = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(string) });
gen.Emit(OpCodes.Ldstr, &quot;Hello world&quot;); // بارگذاری رشته
gen.Emit(OpCodes.Call, writeLineStr);   // فراخوانی متد
</code></pre>
<p>توجه کنید که <code>typeof(Test)</code> را به سازنده <code>DynamicMethod</code> دادیم. این دسترسی متد داینامیک به <strong>متدهای غیر عمومی</strong> آن نوع را فراهم می‌کند، مانند مثال زیر:</p>
<pre><code class="language-csharp">public class Test
{
    static void Main()
    {
        var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        MethodInfo privateMethod = typeof(Test).GetMethod(&quot;HelloWorld&quot;, BindingFlags.Static | BindingFlags.NonPublic);
        gen.Emit(OpCodes.Call, privateMethod); // فراخوانی HelloWorld
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(null, null); // Hello world
    }

    static void HelloWorld() // متد private، ولی می‌توان آن را فراخوانی کرد
    {
        Console.WriteLine(&quot;Hello world&quot;);
    }
}
</code></pre>
<h3>درک IL و Evaluation Stack</h3>
<p>درک IL نیازمند <strong>سرمایه‌گذاری زمانی قابل توجه</strong> است. به جای فهمیدن همه opcodes، آسان‌تر است که یک برنامه C# کامپایل کنید و سپس IL آن را بررسی، کپی و تغییر دهید. ابزارهایی مانند <strong>LINQPad</strong> IL هر متد یا قطعه کدی را نمایش می‌دهد و ابزارهایی مانند <strong>ILSpy</strong> برای بررسی Assemblyهای موجود مفید هستند.</p>
<p>مفهوم <strong>Evaluation Stack</strong> در IL مرکزی است. برای فراخوانی یک متد با آرگومان‌ها:</p>
<ol>
<li>ابتدا آرگومان‌ها را روی <strong>Evaluation Stack</strong> بارگذاری کنید.</li>
<li>سپس متد را فراخوانی کنید.</li>
</ol>
<p>متد مقدار مورد نیاز خود را از Stack می‌گیرد. مثال مشابه با یک عدد صحیح:</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();
MethodInfo writeLineInt = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(int) });

gen.Emit(OpCodes.Ldc_I4, 123); // بارگذاری عدد 4 بایتی روی Stack
gen.Emit(OpCodes.Call, writeLineInt);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null); // 123
</code></pre>
<p>برای جمع دو عدد: ابتدا هر عدد را روی Stack بارگذاری کرده و سپس <code>Add</code> را فراخوانی می‌کنیم. <code>Add</code> دو مقدار را از Stack برمی‌دارد و نتیجه را روی Stack قرار می‌دهد:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 2); // بارگذاری عدد 2
gen.Emit(OpCodes.Ldc_I4, 2); // بارگذاری عدد 2
gen.Emit(OpCodes.Add);        // جمع دو عدد
gen.Emit(OpCodes.Call, writeLineInt); // نمایش نتیجه
</code></pre>
<p>برای محاسبه <code>10 / 2 + 1</code> می‌توان یکی از این دو روش را انجام داد:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldc_I4, 2);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<p>یا:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldc_I4, 2);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<h3>ارسال آرگومان‌ها به یک متد داینامیک</h3>
<p>Opcodeهای <code>Ldarg</code> و <code>Ldarg_XXX</code> آرگومان‌های <strong>ارسال‌شده به متد</strong> را روی Stack بارگذاری می‌کنند. برای بازگرداندن یک مقدار، در پایان <strong>دقیقاً یک مقدار روی Stack</strong> باقی بگذارید. برای این کار، هنگام ایجاد <code>DynamicMethod</code> باید <strong>نوع بازگشتی</strong> و <strong>نوع آرگومان‌ها</strong> را مشخص کنید.</p>
<p>نمونه ایجاد متدی که جمع دو عدد صحیح را برمی‌گرداند:</p>
<pre><code class="language-csharp">DynamicMethod dynMeth = new DynamicMethod(
    &quot;Foo&quot;,
    typeof(int),                          // نوع بازگشتی = int
    new[] { typeof(int), typeof(int) },   // نوع پارامترها = int, int
    typeof(void)
);

ILGenerator gen = dynMeth.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);  // بارگذاری آرگومان اول روی Stack
gen.Emit(OpCodes.Ldarg_1);  // بارگذاری آرگومان دوم روی Stack
gen.Emit(OpCodes.Add);       // جمع دو عدد (نتیجه روی Stack)
gen.Emit(OpCodes.Ret);       // بازگشت با یک مقدار روی Stack

int result = (int)dynMeth.Invoke(null, new object[] { 3, 4 }); // 7
</code></pre>
<p>اگر از قوانین Stack پیروی نکنید، CLR اجرای متد را رد می‌کند. برای حذف یک مقدار بدون پردازش آن می‌توان از <code>OpCodes.Pop</code> استفاده کرد.</p>
<h3>استفاده از Delegate</h3>
<p>به جای فراخوانی <code>Invoke</code>، می‌توان از یک <strong>delegate تایپ‌شده</strong> استفاده کرد تا راحت‌تر کار کرد. متد <code>CreateDelegate</code> این کار را انجام می‌دهد. در مثال بالا:</p>
<pre><code class="language-csharp">var func = (Func&lt;int,int,int&gt;)dynMeth.CreateDelegate(typeof(Func&lt;int,int,int&gt;));
int result = func(3, 4);  // 7
</code></pre>
<p>این کار همچنین <strong>overhead فراخوانی داینامیک</strong> را حذف می‌کند و چند میکروثانیه صرفه‌جویی می‌کند.</p>
<h3>تعریف متغیرهای محلی</h3>
<p>برای تعریف یک متغیر محلی از <code>DeclareLocal</code> روی <code>ILGenerator</code> استفاده کنید. این متد یک <code>LocalBuilder</code> برمی‌گرداند که می‌توان همراه با opcodeهایی مانند <code>Ldloc</code> (بارگذاری متغیر) یا <code>Stloc</code> (ذخیره متغیر) استفاده کرد. <code>Ldloc</code> مقدار را روی Stack می‌گذارد و <code>Stloc</code> آن را از Stack برمی‌دارد.</p>
<p>مثال کد C#:</p>
<pre><code class="language-csharp">int x = 6;
int y = 7;
x *= y;
Console.WriteLine(x); // 42
</code></pre>
<p>ایجاد همان کد به صورت داینامیک:</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Test&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();

LocalBuilder localX = gen.DeclareLocal(typeof(int)); // متغیر x
LocalBuilder localY = gen.DeclareLocal(typeof(int)); // متغیر y

gen.Emit(OpCodes.Ldc_I4, 6);
gen.Emit(OpCodes.Stloc, localX);

gen.Emit(OpCodes.Ldc_I4, 7);
gen.Emit(OpCodes.Stloc, localY);

gen.Emit(OpCodes.Ldloc, localX);
gen.Emit(OpCodes.Ldloc, localY);
gen.Emit(OpCodes.Mul);
gen.Emit(OpCodes.Stloc, localX);

gen.EmitWriteLine(localX);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null); // 42
</code></pre>
<h3>شاخه‌بندی (Branching) 🔀</h3>
<p>در IL، حلقه‌های <code>while</code>، <code>do</code> و <code>for</code> وجود ندارند؛ همه با <strong>Labels</strong> و opcodeهای مشابه <code>goto</code> و شرطی انجام می‌شود:</p>
<ul>
<li><code>Br</code>: شاخه بدون شرط</li>
<li><code>Brtrue</code>: شاخه اگر مقدار روی Stack درست باشد</li>
<li><code>Blt</code>: شاخه اگر مقدار اول کمتر از مقدار دوم باشد</li>
</ul>
<p>برای ایجاد یک شاخه:</p>
<ol>
<li>با <code>DefineLabel</code> یک Label تعریف کنید.</li>
<li>با <code>MarkLabel</code> مکان Label را مشخص کنید.</li>
</ol>
<p>مثال حلقه <code>while</code> در C#:</p>
<pre><code class="language-csharp">int x = 5;
while (x &lt;= 10) Console.WriteLine(x++);
</code></pre>
<p>ایجاد همان حلقه به صورت IL:</p>
<pre><code class="language-csharp">ILGenerator gen = ...;
Label startLoop = gen.DefineLabel();
Label endLoop = gen.DefineLabel();

LocalBuilder x = gen.DeclareLocal(typeof(int));

gen.Emit(OpCodes.Ldc_I4, 5);
gen.Emit(OpCodes.Stloc, x);

gen.MarkLabel(startLoop);

gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Blt, endLoop); // if (x &gt; 10) goto endLoop

gen.EmitWriteLine(x);

gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Stloc, x);

gen.Emit(OpCodes.Br, startLoop);
gen.MarkLabel(endLoop);

gen.Emit(OpCodes.Ret);
</code></pre>
<h3>ساخت اشیاء</h3>
<p>معادل IL برای <code>new</code>، opcode <strong>Newobj</strong> است. این opcode یک <strong>constructor</strong> می‌گیرد و شیء ساخته‌شده را روی <strong>evaluation stack</strong> قرار می‌دهد.</p>
<p>مثال: ساخت یک <code>StringBuilder</code> داینامیک</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Test&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();

ConstructorInfo ci = typeof(StringBuilder).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Newobj, ci);
</code></pre>
<h3>فراخوانی متدهای نمونه</h3>
<p>پس از قرار دادن شیء روی <strong>stack</strong>، می‌توانید با opcodeهای <strong>Call</strong> یا <strong>Callvirt</strong> متدهای نمونه آن را فراخوانی کنید.</p>
<p>مثال: گرفتن مقدار <code>MaxCapacity</code> و نوشتن آن روی کنسول</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Callvirt, typeof(StringBuilder)
                           .GetProperty(&quot;MaxCapacity&quot;).GetGetMethod());
gen.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;WriteLine&quot;, new[] { typeof(int) }));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null);  // 2147483647
</code></pre>
<ul>
<li><strong>Call</strong> برای فراخوانی متدهای static و متدهای نمونه نوع مقدار (value type)</li>
<li><strong>Callvirt</strong> برای فراخوانی متدهای نمونه نوع مرجع (reference type) حتی اگر virtual نباشند</li>
</ul>
<p>استفاده از <code>Callvirt</code> همیشه ایمن است، چون بررسی می‌کند که شیء null نباشد و خطر فراخوانی اشتباه متدهای virtual را کاهش می‌دهد.</p>
<h3>نمونه پیشرفته با پارامترها</h3>
<p>ساخت یک <code>StringBuilder</code> با دو پارامتر، الحاق رشته و تبدیل به رشته:</p>
<pre><code class="language-csharp">ConstructorInfo ci = typeof(StringBuilder).GetConstructor(new[] { typeof(string), typeof(int) });

gen.Emit(OpCodes.Ldstr, &quot;Hello&quot;);
gen.Emit(OpCodes.Ldc_I4, 1000);
gen.Emit(OpCodes.Newobj, ci);

Type[] strT = { typeof(string) };
gen.Emit(OpCodes.Ldstr, &quot;, world!&quot;);
gen.Emit(OpCodes.Call, typeof(StringBuilder).GetMethod(&quot;Append&quot;, strT));
gen.Emit(OpCodes.Callvirt, typeof(object).GetMethod(&quot;ToString&quot;));
gen.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;WriteLine&quot;, strT));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null);  // Hello, world!
</code></pre>
<p>توجه: اگر به‌طور غیرvirtual متد <code>ToString</code> از نوع <code>object</code> را فراخوانی می‌کردیم، نتیجه <code>System.Text.StringBuilder</code> می‌شد و بازنویسی <code>ToString</code> نادیده گرفته می‌شد.</p>
<h3>مدیریت استثناها (Exception Handling) ⚠️</h3>
<p>ILGenerator متدهای مخصوص مدیریت استثنا دارد. مثال معادل IL برای کد C# زیر:</p>
<pre><code class="language-csharp">try { throw new NotSupportedException(); }
catch (NotSupportedException ex) { Console.WriteLine(ex.Message); }
finally { Console.WriteLine(&quot;Finally&quot;); }
</code></pre>
<p>معادل IL:</p>
<pre><code class="language-csharp">MethodInfo getMessageProp = typeof(NotSupportedException)
                           .GetProperty(&quot;Message&quot;).GetGetMethod();
MethodInfo writeLineString = typeof(Console).GetMethod(&quot;WriteLine&quot;, new[] { typeof(object) });

gen.BeginExceptionBlock();

ConstructorInfo ci = typeof(NotSupportedException).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Throw);

gen.BeginCatchBlock(typeof(NotSupportedException));
gen.Emit(OpCodes.Callvirt, getMessageProp);
gen.Emit(OpCodes.Call, writeLineString);

gen.BeginFinallyBlock();
gen.EmitWriteLine(&quot;Finally&quot;);
gen.EndExceptionBlock();
</code></pre>
<ul>
<li>می‌توانید چند catch block تعریف کنید.</li>
<li>برای پرتاب مجدد همان استثنا از opcode <code>Rethrow</code> استفاده می‌شود.</li>
<li>متد کمکی <code>ThrowException</code> فقط با <strong>MethodBuilder</strong> کار می‌کند و در DynamicMethod کاربرد ندارد.</li>
</ul>
<p>اگرچه <strong>DynamicMethod</strong> بسیار راحت است، اما فقط قادر به تولید <strong>متدها</strong>ست. برای ایجاد هر ساختار دیگر یا یک <strong>Type کامل</strong>، باید از API “سنگین” <strong>Reflection.Emit</strong> استفاده کنید. این یعنی ساخت یک <strong>assembly</strong> و <strong>module</strong> داینامیک.</p>
<p>توجه: assembly داینامیک نیازی به وجود روی دیسک ندارد و در .NET 5+ و .NET Core نمی‌توان آن را ذخیره کرد.</p>
<h3>ساخت Assembly و Module</h3>
<p>برای ایجاد یک نوع داینامیک، ابتدا باید <strong>assembly</strong> و <strong>module</strong> بسازیم:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyDynamicAssembly&quot;);
AssemblyBuilder assemBuilder =
    AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;DynModule&quot;);
</code></pre>
<ul>
<li>نمی‌توان یک type را به assembly موجود اضافه کرد، زیرا <strong>assembly پس از ایجاد، تغییرناپذیر است</strong>.</li>
<li>assemblyهای داینامیک معمولاً توسط <strong>garbage collector</strong> پاک نمی‌شوند و تا پایان فرآیند در حافظه می‌مانند، مگر اینکه هنگام تعریف، گزینه <strong>AssemblyBuilderAccess.RunAndCollect</strong> را استفاده کنید.</li>
</ul>
<h3>ایجاد یک Type داینامیک</h3>
<p>پس از داشتن module، می‌توان با <strong>TypeBuilder</strong> یک type ایجاد کرد:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
</code></pre>
<p>ویژگی‌های <code>TypeAttributes</code> شامل <strong>modifierهای CLR</strong>، <strong>visibility member flags</strong> و modifierهایی مانند <code>Abstract</code>، <code>Sealed</code> و <code>Interface</code> است. همچنین <code>Serializable</code> معادل [Serializable] در C# و <code>Explicit</code> معادل [StructLayout(LayoutKind.Explicit)] است. سایر attributeها را در بخش “Attaching Attributes” توضیح خواهیم داد.</p>
<p>همچنین می‌توان base type اختیاری مشخص کرد:</p>
<ul>
<li>برای struct: <code>System.ValueType</code></li>
<li>برای delegate: <code>System.MulticastDelegate</code></li>
<li>برای interface: آرایه‌ای از interfaceها</li>
<li>برای تعریف interface: <code>TypeAttributes.Interface | TypeAttributes.Abstract</code></li>
</ul>
<p>تعریف delegate نیازمند مراحل اضافی است (رجوع به مقاله Joel Pobar: “Creating delegate types via Reflection.Emit”).</p>
<h3>ایجاد متد در Type</h3>
<p>می‌توان اعضا را داخل type ایجاد کرد:</p>
<pre><code class="language-csharp">MethodBuilder methBuilder = tb.DefineMethod(&quot;SayHello&quot;,
                                             MethodAttributes.Public,
                                             null, null);
ILGenerator gen = methBuilder.GetILGenerator();
gen.EmitWriteLine(&quot;Hello world&quot;);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>نهایی‌سازی Type</h3>
<pre><code class="language-csharp">Type t = tb.CreateType();  // نهایی کردن Type
</code></pre>
<p>پس از ایجاد Type، می‌توان از <strong>reflection معمولی</strong> برای بازرسی و <strong>late binding</strong> استفاده کرد:</p>
<pre><code class="language-csharp">object o = Activator.CreateInstance(t);
t.GetMethod(&quot;SayHello&quot;).Invoke(o, null);  // Hello world
</code></pre>
<h3>مدل شیء Reflection.Emit</h3>
<p>هر نوع در <strong>System.Reflection.Emit</strong> معادل یک ساختار CLR است و پایه آن در <strong>System.Reflection</strong> تعریف شده. این امکان را می‌دهد که از constructs داینامیک به جای constructs معمولی هنگام ساخت type استفاده کنید.</p>
<p>مثال: فراخوانی متد داینامیک به جای MethodInfo معمولی:</p>
<pre><code class="language-csharp">MethodInfo writeLine = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(string) });
gen.Emit(OpCodes.Call, writeLine);
</code></pre>
<p>با استفاده از <strong>MethodBuilder</strong> نیز می‌توان متد داینامیک دیگری را فراخوانی کرد، که برای ایجاد تعامل بین متدهای داینامیک در یک type ضروری است.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>نکته مهم درباره CreateType</h3>
<p>پس از تکمیل تعریف یک <strong>TypeBuilder</strong>، باید <strong>CreateType</strong> را فراخوانی کنید. این کار باعث می‌شود:</p>
<ul>
<li>TypeBuilder و تمام اعضایش <strong>seal</strong> شوند (دیگر نمی‌توان چیزی اضافه یا تغییر داد).</li>
<li>یک <strong>Type واقعی</strong> برگردانده شود که بتوان آن را instantiate کرد.</li>
</ul>
<p>قبل از فراخوانی <strong>CreateType</strong>، TypeBuilder در حالت «uncreated» است و محدودیت‌های زیادی دارد:</p>
<ul>
<li>نمی‌توان متدهایی مانند <code>GetMembers</code>، <code>GetMethod</code> یا <code>GetProperty</code> را روی آن فراخوانی کرد، چون باعث ایجاد Exception می‌شوند.</li>
<li>اگر می‌خواهید به اعضای یک type ساخته نشده اشاره کنید، باید از <strong>MethodBuilder یا FieldBuilder اصلی</strong> استفاده کنید:</li>
</ul>
<pre><code class="language-csharp">TypeBuilder tb = ...
MethodBuilder method1 = tb.DefineMethod(&quot;Method1&quot;, ...);
MethodBuilder method2 = tb.DefineMethod(&quot;Method2&quot;, ...);
ILGenerator gen1 = method1.GetILGenerator();

// فراخوانی درست
gen1.Emit(OpCodes.Call, method2);

// فراخوانی اشتباه (روی TypeBuilder نامعتبر)
gen1.Emit(OpCodes.Call, tb.GetMethod(&quot;Method2&quot;));  // Wrong
</code></pre>
<p>پس از <code>CreateType</code>، می‌توان روی <strong>Type واقعی</strong> و حتی <strong>TypeBuilder اولیه</strong> بازتاب (reflect) و instantiate انجام داد. TypeBuilder به‌نوعی به proxy برای Type واقعی تبدیل می‌شود.</p>
<hr>
<h3>ایجاد متدها با TypeBuilder</h3>
<p>فرض کنید یک <strong>TypeBuilder</strong> داریم:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyEmissions&quot;);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;MainModule&quot;);
TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
</code></pre>
<p>برای ایجاد یک متد مانند:</p>
<pre><code class="language-csharp">public static double SquareRoot(double value) =&gt; Math.Sqrt(value);
</code></pre>
<p>از <strong>DefineMethod</strong> و ILGenerator استفاده می‌کنیم:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    typeof(double),                // Return type
    new[] { typeof(double) }       // Parameter types
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;); // Assign name
ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);                                // Load first arg
gen.Emit(OpCodes.Call, typeof(Math).GetMethod(&quot;Sqrt&quot;));   
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
double x = (double)tb.GetMethod(&quot;SquareRoot&quot;).Invoke(null, new object[] { 10.0 });
Console.WriteLine(x);  // 3.16227766016838
</code></pre>
<ul>
<li>فراخوانی <strong>DefineParameter</strong> اختیاری است و فقط برای دادن نام به پارامتر استفاده می‌شود (<code>__p1</code>, <code>__p2</code> به‌صورت پیش‌فرض).</li>
<li><strong>ParameterBuilder</strong> برمی‌گرداند که می‌توان با <code>SetCustomAttribute</code> به آن attribute اضافه کرد.</li>
</ul>
<hr>
<h3>پارامترهای مرجع (ref)</h3>
<p>برای متدی با پارامتر <strong>ref</strong>، از <code>MakeByRefType()</code> استفاده می‌کنیم:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    null,
    new Type[] { typeof(double).MakeByRefType() }
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;);
ILGenerator gen = mb.GetILGenerator();

gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldind_R8);
gen.Emit(OpCodes.Call, typeof(Math).GetMethod(&quot;Sqrt&quot;));
gen.Emit(OpCodes.Stind_R8);
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
object[] args = { 10.0 };
tb.GetMethod(&quot;SquareRoot&quot;).Invoke(null, args);
Console.WriteLine(args[0]);  // 3.16227766016838
</code></pre>
<ul>
<li><code>Ldind</code> و <code>Stind</code> به معنی <strong>load/store indirectly</strong> هستند و <code>R8</code> مربوط به <strong>عدد شناور 8 بایتی</strong> است.</li>
</ul>
<p>برای <strong>out parameters</strong> نیز روند مشابه است، تنها تفاوت این است که هنگام <code>DefineParameter</code> از <code>ParameterAttributes.Out</code> استفاده می‌کنید.</p>
<h3>متدهای نمونه (Instance Methods)</h3>
<p>برای ایجاد یک متد نمونه، هنگام فراخوانی <strong>DefineMethod</strong> از <code>MethodAttributes.Instance</code> استفاده کنید:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Instance | MethodAttributes.Public,
    typeof(double),
    new[] { typeof(double) }
);
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>در متدهای نمونه، <strong>argument صفر (Ldarg_0)</strong> به <code>this</code> اشاره دارد.</li>
<li>آرگومان‌های واقعی از <strong>1 شروع می‌شوند</strong> (<code>Ldarg_1</code> اولین پارامتر واقعی را بارگذاری می‌کند).</li>
</ul>
<hr>
<h3>بازتعریف متدها (Overriding)</h3>
<p>برای override یک متد مجازی در کلاس پایه:</p>
<ul>
<li>متدی با <strong>همان نام، امضا و نوع بازگشتی</strong> تعریف کنید و <code>MethodAttributes.Virtual</code> را اضافه کنید.</li>
<li>برای پیاده‌سازی متدهای interface، روش مشابه اعمال می‌شود.</li>
<li>اگر می‌خواهید یک متد با نام متفاوت override شود (معمولاً برای explicit interface implementation)، از <code>DefineMethodOverride</code> استفاده کنید.</li>
</ul>
<h3>HideBySig</h3>
<p>هنگام subclassing بهتر است <code>MethodAttributes.HideBySig</code> را اضافه کنید:</p>
<ul>
<li>تضمین می‌کند که <strong>فقط متدی با امضای یکسان</strong> در subtype، متد base را مخفی کند.</li>
<li>بدون این، تنها نام متد بررسی می‌شود و ممکن است رفتار ناخواسته ایجاد شود.</li>
</ul>
<hr>
<h3>ایجاد فیلدها</h3>
<p>برای تعریف فیلد از <strong>DefineField</strong> استفاده کنید:</p>
<pre><code class="language-csharp">FieldBuilder field = tb.DefineField(
    &quot;_text&quot;,
    typeof(string),
    FieldAttributes.Private
);
</code></pre>
<hr>
<h3>ایجاد Properties</h3>
<p>برای ایجاد یک property:</p>
<ol>
<li><strong>DefineProperty</strong> روی TypeBuilder فراخوانی می‌کنیم:</li>
</ol>
<pre><code class="language-csharp">PropertyBuilder prop = tb.DefineProperty(
    &quot;Text&quot;,                     // نام property
    PropertyAttributes.None,
    typeof(string),             // نوع property
    new Type[0]                 // نوع ایندکس (برای indexer)
);
</code></pre>
<ol start="2">
<li>ایجاد متدهای get و set:</li>
</ol>
<pre><code class="language-csharp">// Getter
MethodBuilder getter = tb.DefineMethod(
    &quot;get_Text&quot;,
    MethodAttributes.Public | MethodAttributes.SpecialName,
    typeof(string),
    new Type[0]
);
ILGenerator getGen = getter.GetILGenerator();
getGen.Emit(OpCodes.Ldarg_0);
getGen.Emit(OpCodes.Ldfld, field);
getGen.Emit(OpCodes.Ret);

// Setter
MethodBuilder setter = tb.DefineMethod(
    &quot;set_Text&quot;,
    MethodAttributes.Assembly | MethodAttributes.SpecialName,
    null,
    new Type[] { typeof(string) }
);
ILGenerator setGen = setter.GetILGenerator();
setGen.Emit(OpCodes.Ldarg_0);
setGen.Emit(OpCodes.Ldarg_1);
setGen.Emit(OpCodes.Stfld, field);
setGen.Emit(OpCodes.Ret);

// اتصال متدها به property
prop.SetGetMethod(getter);
prop.SetSetMethod(setter);
</code></pre>
<ol start="3">
<li>تست property:</li>
</ol>
<pre><code class="language-csharp">Type t = tb.CreateType();
object o = Activator.CreateInstance(t);
t.GetProperty(&quot;Text&quot;).SetValue(o, &quot;Good emissions!&quot;, null);
string text = (string)t.GetProperty(&quot;Text&quot;).GetValue(o, null);
Console.WriteLine(text);  // Good emissions!
</code></pre>
<p>نکات:</p>
<ul>
<li><code>SpecialName</code> باعث می‌شود این متدها به صورت مستقیم در کامپایلر قابل دسترسی نباشند و توسط ابزارهای reflection و IntelliSense به درستی شناسایی شوند.</li>
</ul>
<hr>
<h3>Events</h3>
<ul>
<li>برای ایجاد events، از <code>DefineEvent</code> روی TypeBuilder استفاده کنید.</li>
<li>سپس متدهای add و remove را نوشته و با <code>SetAddOnMethod</code> و <code>SetRemoveOnMethod</code> به EventBuilder متصل کنید.</li>
</ul>
<h3>تولید سازنده‌ها 🏗️</h3>
<p>می‌توانید سازنده‌های دلخواه خود را با فراخوانی <strong>DefineConstructor</strong> روی یک <strong>TypeBuilder</strong> تعریف کنید. لازم نیست حتماً این کار را انجام دهید—اگر این کار را نکنید، یک سازنده‌ی پیش‌فرض بدون پارامتر به‌طور خودکار ارائه می‌شود. سازنده‌ی پیش‌فرض، سازنده‌ی کلاس پایه را فراخوانی می‌کند (اگر از یک کلاس دیگر ارث‌بری می‌کنید)، دقیقاً مانند C#. اما اگر یک یا چند سازنده تعریف کنید، این سازنده‌ی پیش‌فرض جایگزین می‌شود.</p>
<p>اگر نیاز دارید فیلدها را مقداردهی اولیه کنید، سازنده بهترین مکان برای این کار است. در واقع، تنها مکان مناسب همین است، زیرا <strong>Field Initializers</strong> در C# پشتیبانی ویژه‌ای در CLR ندارند—آنها صرفاً یک میان‌بر نحوی برای مقداردهی به فیلدها در سازنده هستند.</p>
<p>مثلاً برای تولید معادل زیر:</p>
<pre><code class="language-csharp">class Widget
{
    int _capacity = 4000;
}
</code></pre>
<p>می‌توان یک سازنده به این شکل تعریف کرد:</p>
<pre><code class="language-csharp">FieldBuilder field = tb.DefineField(&quot;_capacity&quot;, typeof(int), FieldAttributes.Private);

ConstructorBuilder c = tb.DefineConstructor(
    MethodAttributes.Public,
    CallingConventions.Standard,
    new Type[0]   // پارامترهای سازنده
);

ILGenerator gen = c.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);        // بارگذاری &quot;this&quot; روی استک ارزیابی
gen.Emit(OpCodes.Ldc_I4, 4000);   // بارگذاری عدد 4000 روی استک
gen.Emit(OpCodes.Stfld, field);   // ذخیره مقدار در فیلد
gen.Emit(OpCodes.Ret);            // بازگشت
</code></pre>
<hr>
<h3>فراخوانی سازنده‌های پایه 🏛️</h3>
<p>اگر از یک کلاس دیگر ارث‌بری می‌کنید، سازنده‌ای که تعریف کردیم، <strong>سازنده‌ی کلاس پایه را نادیده می‌گیرد</strong>. این برخلاف C# است، که سازنده‌ی کلاس پایه همیشه فراخوانی می‌شود (مستقیماً یا غیرمستقیم).</p>
<p>مثال در C#:</p>
<pre><code class="language-csharp">class A { public A() { Console.Write(&quot;A&quot;); } }
class B : A { public B() {} }
</code></pre>
<p>کامپایلر در واقع خط دوم را به شکل زیر ترجمه می‌کند:</p>
<pre><code class="language-csharp">class B : A { public B() : base() {} }
</code></pre>
<p>در IL تولیدی، شما <strong>باید به‌صورت صریح سازنده‌ی پایه را فراخوانی کنید</strong> تا اجرا شود (که تقریباً همیشه می‌خواهید این کار انجام شود). فرض کنید کلاس پایه <strong>A</strong> است، می‌توانید این‌گونه عمل کنید:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldarg_0);
ConstructorInfo baseConstr = typeof(A).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Call, baseConstr);
</code></pre>
<p>فراخوانی سازنده‌ها با پارامتر نیز دقیقاً مشابه متدها است. 🎯</p>
<hr>
<h3>الحاق ویژگی‌ها (Attributes) 🏷️</h3>
<p>می‌توانید <strong>Custom Attribute</strong>ها را به یک سازه‌ی داینامیک اضافه کنید با فراخوانی <strong>SetCustomAttribute</strong> و استفاده از <strong>CustomAttributeBuilder</strong>.</p>
<p>مثلاً اگر بخواهیم ویژگی زیر را به یک فیلد یا پراپرتی اضافه کنیم:</p>
<pre><code class="language-csharp">[XmlElement(&quot;FirstName&quot;, Namespace=&quot;http://test/&quot;, Order=3)]
</code></pre>
<p>این ویژگی از سازنده‌ی <strong>XmlElementAttribute</strong> که یک رشته می‌پذیرد استفاده می‌کند. برای استفاده از <strong>CustomAttributeBuilder</strong>، ابتدا باید سازنده و همچنین دو پراپرتی اضافی که می‌خواهیم مقداردهی کنیم (<strong>Namespace</strong> و <strong>Order</strong>) را بازیابی کنیم:</p>
<pre><code class="language-csharp">Type attType = typeof(XmlElementAttribute);
ConstructorInfo attConstructor = attType.GetConstructor(new Type[] { typeof(string) });

var att = new CustomAttributeBuilder(
    attConstructor,                 // سازنده
    new object[] { &quot;FirstName&quot; },   // آرگومان‌های سازنده
    new PropertyInfo[] 
    {
        attType.GetProperty(&quot;Namespace&quot;),  // پراپرتی‌ها
        attType.GetProperty(&quot;Order&quot;)
    },
    new object[] { &quot;http://test/&quot;, 3 }    // مقادیر پراپرتی
);

myFieldBuilder.SetCustomAttribute(att);
// یا
// propBuilder.SetCustomAttribute(att);
// یا
// typeBuilder.SetCustomAttribute(att);  و غیره
</code></pre>
<p>این روش به شما امکان می‌دهد ویژگی‌ها را به صورت داینامیک به فیلدها، پراپرتی‌ها و خود نوع‌ها اضافه کنید. 🛠️</p>
<h3>انتشار متدها و تایپ‌های جنریک 🧩</h3>
<p>تمام مثال‌های این بخش فرض می‌کنند که <strong>modBuilder</strong> به شکل زیر مقداردهی اولیه شده است:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyEmissions&quot;);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(
    aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;MainModule&quot;);
</code></pre>
<hr>
<h4>تعریف متدهای جنریک 📝</h4>
<p>برای انتشار یک متد جنریک:</p>
<ol>
<li>
<p>روی <strong>MethodBuilder</strong> تابع <strong>DefineGenericParameters</strong> را فراخوانی کنید تا یک آرایه از <strong>GenericTypeParameterBuilder</strong> دریافت کنید.</p>
</li>
<li>
<p>روی <strong>MethodBuilder</strong> با استفاده از این پارامترهای جنریک، <strong>SetSignature</strong> را فراخوانی کنید.</p>
</li>
<li>
<p>به‌صورت اختیاری، نام پارامترها را همان‌طور که معمولاً انجام می‌دهید، تعیین کنید.</p>
</li>
</ol>
<p>مثال: متد جنریک زیر</p>
<pre><code class="language-csharp">public static T Echo&lt;T&gt;(T value)
{
    return value;
}
</code></pre>
<p>می‌تواند به شکل زیر منتشر شود:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(&quot;Echo&quot;, MethodAttributes.Public |
                                          MethodAttributes.Static);

GenericTypeParameterBuilder[] genericParams
    = mb.DefineGenericParameters(&quot;T&quot;);

mb.SetSignature(
    genericParams[0],     // نوع بازگشتی
    null, null,
    genericParams,        // نوع پارامترها
    null, null
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;);   // اختیاری

ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>تابع <strong>DefineGenericParameters</strong> هر تعداد آرگومان رشته‌ای را می‌پذیرد—این آرگومان‌ها نام‌های موردنظر برای نوع‌های جنریک هستند. در این مثال تنها یک نوع جنریک به نام <strong>T</strong> نیاز داشتیم.</p>
<p><strong>GenericTypeParameterBuilder</strong> بر پایه <strong>System.Type</strong> ساخته شده است، بنابراین می‌توانید از آن به جای <strong>TypeBuilder</strong> هنگام انتشار کد IL استفاده کنید.</p>
<p>همچنین <strong>GenericTypeParameterBuilder</strong> امکان تعیین محدودیت نوع پایه را فراهم می‌کند:</p>
<pre><code class="language-csharp">genericParams[0].SetBaseTypeConstraint(typeof(Foo));
</code></pre>
<p>و محدودیت‌های رابط‌ها:</p>
<pre><code class="language-csharp">genericParams[0].SetInterfaceConstraints(typeof(IComparable));
</code></pre>
<p>برای بازتولید این متد:</p>
<pre><code class="language-csharp">public static T Echo&lt;T&gt;(T value) where T : IComparable&lt;T&gt;
</code></pre>
<p>می‌توانید بنویسید:</p>
<pre><code class="language-csharp">genericParams[0].SetInterfaceConstraints(
    typeof(IComparable&lt;&gt;).MakeGenericType(genericParams[0])
);
</code></pre>
<p>برای انواع دیگر محدودیت‌ها، <strong>SetGenericParameterAttributes</strong> را فراخوانی کنید. این تابع یک عضو از <strong>GenericParameterAttributes</strong> می‌پذیرد که شامل مقادیر زیر است:</p>
<ul>
<li><strong>DefaultConstructorConstraint</strong></li>
<li><strong>NotNullableValueTypeConstraint</strong></li>
<li><strong>ReferenceTypeConstraint</strong></li>
<li><strong>Covariant</strong></li>
<li><strong>Contravariant</strong></li>
</ul>
<p>دو مقدار آخر معادل استفاده از <strong>out</strong> و <strong>in</strong> روی پارامترهای نوع هستند. ✅</p>
<h3>تعریف تایپ‌های جنریک 🏗️</h3>
<p>می‌توانید تایپ‌های جنریک را به شکل مشابه متدها تعریف کنید. تفاوت اصلی این است که <strong>DefineGenericParameters</strong> را روی <strong>TypeBuilder</strong> فراخوانی می‌کنید، نه <strong>MethodBuilder</strong>.</p>
<p>برای بازتولید این کلاس:</p>
<pre><code class="language-csharp">public class Widget&lt;T&gt;
{
    public T Value;
}
</code></pre>
<p>می‌توانید به شکل زیر عمل کنید:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
GenericTypeParameterBuilder[] genericParams
    = tb.DefineGenericParameters(&quot;T&quot;);

tb.DefineField(&quot;Value&quot;, genericParams[0], FieldAttributes.Public);
</code></pre>
<p>محدودیت‌های جنریک را می‌توان دقیقاً همانند متدها اضافه کرد. ✅</p>
<hr>
<h3>اهداف انتشار نامتعارف ⚠️</h3>
<p>تمام مثال‌های این بخش فرض می‌کنند که <strong>modBuilder</strong> همانند بخش‌های قبلی مقداردهی اولیه شده است.</p>
<hr>
<h4>جنریک‌های بسته ایجاد نشده</h4>
<p>فرض کنید می‌خواهید یک متد منتشر کنید که از یک تایپ جنریک بسته استفاده می‌کند:</p>
<pre><code class="language-csharp">public class Widget
{
    public static void Test() { var list = new List&lt;int&gt;(); }
}
</code></pre>
<p>این کار نسبتاً ساده است:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(&quot;Test&quot;, MethodAttributes.Public | MethodAttributes.Static);

ILGenerator gen = mb.GetILGenerator();
Type variableType = typeof(List&lt;int&gt;);
ConstructorInfo ci = variableType.GetConstructor(new Type[0]);
LocalBuilder listVar = gen.DeclareLocal(variableType);

gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>حالا فرض کنید به جای یک لیست از اعداد صحیح، می‌خواهیم لیستی از ویجت‌ها داشته باشیم:</p>
<pre><code class="language-csharp">public class Widget
{
    public static void Test() { var list = new List&lt;Widget&gt;(); }
}
</code></pre>
<p>در تئوری، این تغییر ساده است؛ فقط خط زیر را جایگزین می‌کنیم:</p>
<pre><code class="language-csharp">Type variableType = typeof(List&lt;int&gt;);
</code></pre>
<p>با این خط:</p>
<pre><code class="language-csharp">Type variableType = typeof(List&lt;&gt;).MakeGenericType(tb);
</code></pre>
<p>اما متأسفانه این باعث پرتاب <strong>NotSupportedException</strong> هنگام فراخوانی <strong>GetConstructor</strong> می‌شود. مشکل این است که نمی‌توان <strong>GetConstructor</strong> را روی یک تایپ جنریک بسته با <strong>TypeBuilder</strong> ایجاد نشده فراخوانی کرد. همین موضوع برای <strong>GetField</strong> و <strong>GetMethod</strong> نیز صادق است.</p>
<hr>
<h4>راه حل غیر مستقیم 💡</h4>
<p><strong>TypeBuilder</strong> سه متد استاتیک ارائه می‌دهد:</p>
<pre><code class="language-csharp">public static ConstructorInfo GetConstructor(Type, ConstructorInfo);
public static FieldInfo       GetField(Type, FieldInfo);
public static MethodInfo      GetMethod(Type, MethodInfo);
</code></pre>
<p>اگرچه به نظر نمی‌آید، این متدها دقیقاً برای گرفتن اعضای تایپ‌های جنریک بسته با <strong>TypeBuilder</strong> ایجاد نشده طراحی شده‌اند!</p>
<p>پارامتر اول: تایپ جنریک بسته
پارامتر دوم: عضوی که می‌خواهید از تایپ جنریک بدون بسته دریافت کنید</p>
<p>نسخه اصلاح‌شده مثال ما به شکل زیر است:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(&quot;Test&quot;, MethodAttributes.Public | MethodAttributes.Static);
ILGenerator gen = mb.GetILGenerator();

Type variableType = typeof(List&lt;&gt;).MakeGenericType(tb);
ConstructorInfo unbound = typeof(List&lt;&gt;).GetConstructor(new Type[0]);
ConstructorInfo ci = TypeBuilder.GetConstructor(variableType, unbound);

LocalBuilder listVar = gen.DeclareLocal(variableType);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>وابستگی‌های دایره‌ای 🔄</h3>
<p>فرض کنید می‌خواهید دو تایپ بسازید که به یکدیگر ارجاع دارند، مانند این مثال:</p>
<pre><code class="language-csharp">class A { public B Bee; }
class B { public A Aye; }
</code></pre>
<p>می‌توانید این را به صورت داینامیک به شکل زیر ایجاد کنید:</p>
<pre><code class="language-csharp">var publicAtt = FieldAttributes.Public;

TypeBuilder aBuilder = modBuilder.DefineType(&quot;A&quot;);
TypeBuilder bBuilder = modBuilder.DefineType(&quot;B&quot;);

FieldBuilder bee = aBuilder.DefineField(&quot;Bee&quot;, bBuilder, publicAtt);
FieldBuilder aye = bBuilder.DefineField(&quot;Aye&quot;, aBuilder, publicAtt);

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();
</code></pre>
<p>توجه کنید که ما <strong>تا زمانی که هر دو تایپ پر نشده‌اند،</strong> روی <strong>aBuilder</strong> یا <strong>bBuilder</strong> تابع <strong>CreateType</strong> را فراخوانی نکردیم. اصل موضوع این است: اول همه چیز را متصل کنید، سپس <strong>CreateType</strong> را روی هر <strong>TypeBuilder</strong> فراخوانی کنید. ✅</p>
<hr>
<p>جالب است بدانید که <strong>realA</strong> تا قبل از فراخوانی <strong>CreateType</strong> روی <strong>bBuilder</strong> معتبر اما غیرفعال است. (اگر قبل از این از <strong>aBuilder</strong> استفاده کنید، هنگام دسترسی به فیلد <strong>Bee</strong> استثنا پرتاب می‌شود.)</p>
<p>ممکن است بپرسید چگونه <strong>bBuilder</strong> می‌داند که پس از ایجاد <strong>realB</strong> باید <strong>realA</strong> را «اصلاح» کند. پاسخ این است که نمی‌داند: <strong>realA</strong> خودش هنگام استفاده بعدی اصلاح می‌شود. این امکان‌پذیر است زیرا پس از فراخوانی <strong>CreateType</strong>، <strong>TypeBuilder</strong> به یک پروکسی برای تایپ واقعی زمان اجرا تبدیل می‌شود. بنابراین <strong>realA</strong> با ارجاع به <strong>bBuilder</strong> می‌تواند به راحتی متادیتای مورد نیاز برای ارتقا را دریافت کند.</p>
<hr>
<p>این سیستم زمانی کار می‌کند که <strong>TypeBuilder</strong> تنها به اطلاعات ساده از تایپ ایجاد نشده نیاز داشته باشد—اطلاعاتی که از قبل قابل تعیین هستند—مثل نوع، اعضا و ارجاعات به اشیاء.</p>
<p>هنگام ایجاد <strong>realA</strong>، <strong>TypeBuilder</strong> نیازی به دانستن تعداد بایت‌های اشغال‌شده توسط <strong>realB</strong> در حافظه ندارد. این خوب است زیرا <strong>realB</strong> هنوز ایجاد نشده است!</p>
<p>اما تصور کنید <strong>realB</strong> یک <strong>struct</strong> باشد. اندازه نهایی <strong>realB</strong> اطلاعات حیاتی برای ایجاد <strong>realA</strong> است.</p>
<hr>
<p>اگر رابطه غیر دایره‌ای باشد؛ برای مثال:</p>
<pre><code class="language-csharp">struct A { public B Bee; }
struct B { }
</code></pre>
<p>می‌توان با ایجاد اول <strong>struct B</strong> و سپس <strong>struct A</strong> مشکل را حل کرد.</p>
<p>اما اگر رابطه دایره‌ای باشد:</p>
<pre><code class="language-csharp">struct A { public B Bee; }
struct B { public A Aye; }
</code></pre>
<p>ما نمی‌توانیم این را منتشر کنیم زیرا منطقی نیست که دو struct یکدیگر را شامل شوند (C# هنگام کامپایل خطا می‌دهد).</p>
<p>اما نسخه زیر هم قانونی و هم مفید است:</p>
<pre><code class="language-csharp">public struct S&lt;T&gt; { ... }    // S می‌تواند خالی باشد و این دمو کار می‌کند.
class A { S&lt;B&gt; Bee; }
class B { S&lt;A&gt; Aye; }
</code></pre>
<p>در ایجاد <strong>A</strong>، <strong>TypeBuilder</strong> اکنون باید اندازه حافظه <strong>B</strong> را بداند و بالعکس. فرض کنید <strong>struct S</strong> به صورت استاتیک تعریف شده باشد. کد انتشار کلاس‌های <strong>A</strong> و <strong>B</strong> به شکل زیر است:</p>
<pre><code class="language-csharp">var pub = FieldAttributes.Public;
TypeBuilder aBuilder = modBuilder.DefineType(&quot;A&quot;);
TypeBuilder bBuilder = modBuilder.DefineType(&quot;B&quot;);

aBuilder.DefineField(&quot;Bee&quot;, typeof(S&lt;&gt;).MakeGenericType(bBuilder), pub);
bBuilder.DefineField(&quot;Aye&quot;, typeof(S&lt;&gt;).MakeGenericType(aBuilder), pub);

Type realA = aBuilder.CreateType();    // خطا: نمی‌توان تایپ B را بارگذاری کرد
Type realB = bBuilder.CreateType();
</code></pre>
<p>اکنون <strong>CreateType</strong> یک <strong>TypeLoadException</strong> پرتاب می‌کند، فرقی نمی‌کند که به چه ترتیبی عمل کنید:</p>
<ul>
<li>اگر اول <strong>aBuilder.CreateType</strong> را فراخوانی کنید، می‌گوید «نمی‌توان تایپ B را بارگذاری کرد».</li>
<li>اگر اول <strong>bBuilder.CreateType</strong> را فراخوانی کنید، می‌گوید «نمی‌توان تایپ A را بارگذاری کرد».</li>
</ul>
<hr>
<p>برای حل این مشکل، باید اجازه دهید <strong>TypeBuilder</strong> هنگام ایجاد <strong>realA</strong>، <strong>realB</strong> را به صورت موقت ایجاد کند. این کار با هندل کردن رویداد <strong>TypeResolve</strong> روی کلاس <strong>AppDomain</strong> درست قبل از فراخوانی <strong>CreateType</strong> انجام می‌شود.</p>
<p>در مثال ما، دو خط آخر را با این کد جایگزین می‌کنیم:</p>
<pre><code class="language-csharp">TypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };

ResolveEventHandler handler = delegate(object o, ResolveEventArgs args)
{
    var type = uncreatedTypes.FirstOrDefault(t =&gt; t.FullName == args.Name);
    return type == null ? null : type.CreateType().Assembly;
};

AppDomain.CurrentDomain.TypeResolve += handler;

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();

AppDomain.CurrentDomain.TypeResolve -= handler;
</code></pre>
<p>رویداد <strong>TypeResolve</strong> هنگام فراخوانی <strong>aBuilder.CreateType</strong> فعال می‌شود، در نقطه‌ای که نیاز است شما <strong>CreateType</strong> را روی <strong>bBuilder</strong> فراخوانی کنید.</p>
<h3>تجزیه IL 🧩</h3>
<p>می‌توانید اطلاعاتی درباره محتوای یک متد موجود با فراخوانی <strong>GetMethodBody</strong> روی یک شیء <strong>MethodBase</strong> به دست آورید. این متد یک <strong>MethodBody</strong> بازمی‌گرداند که دارای خصوصیات برای بررسی متغیرهای محلی، بلوک‌های مدیریت استثنا، اندازه پشته و همچنین <strong>IL خام</strong> است. تقریباً مانند معکوس <strong>Reflection.Emit</strong>!</p>
<p>بررسی <strong>IL خام</strong> یک متد می‌تواند در <strong>پروفایلینگ کد</strong> مفید باشد. یک استفاده ساده آن می‌تواند تعیین این باشد که هنگام به‌روزرسانی یک اسمبلی، کدام متدها تغییر کرده‌اند.</p>
<p>برای مثال، می‌خواهیم یک برنامه بنویسیم که <strong>IL را به سبک ildasm جدا کند</strong>. این می‌تواند نقطه شروعی برای یک ابزار تحلیل کد یا <strong>دیس‌اسمبلر زبان سطح بالاتر</strong> باشد.</p>
<p>به یاد داشته باشید که در <strong>Reflection API</strong>، تمام ساختارهای تابعی C# یا توسط یک زیرکلاس <strong>MethodBase</strong> نمایش داده می‌شوند یا (در مورد <strong>properties</strong>، <strong>events</strong> و <strong>indexers</strong>) به آنها اشیاء <strong>MethodBase</strong> متصل هستند.</p>
<hr>
<h3>نوشتن یک دیس‌اسمبلر 🛠️</h3>
<p>نمونه‌ای از خروجی که دیس‌اسمبلر ما تولید خواهد کرد:</p>
<pre><code>IL_00EB:  ldfld        Disassembler._pos
IL_00F0:  ldloc.2
IL_00F1:  add
IL_00F2:  ldelema      System.Byte
IL_00F7:  ldstr        &quot;Hello world&quot;
IL_00FC:  call         System.Byte.ToString
IL_0101:  ldstr        &quot; &quot;
IL_0106:  call         System.String.Concat
</code></pre>
<p>برای به دست آوردن این خروجی، باید <strong>توکن‌های باینری تشکیل‌دهنده IL</strong> را تجزیه کنیم.</p>
<hr>
<h4>مرحله اول: گرفتن IL به صورت آرایه بایت</h4>
<p>برای آسان‌تر کردن کار، این را در یک کلاس می‌نویسیم:</p>
<pre><code class="language-csharp">public class Disassembler
{
    public static string Disassemble(MethodBase method)
        =&gt; new Disassembler(method).Dis();

    StringBuilder _output;    // خروجی که به آن اضافه می‌کنیم
    Module _module;           // بعداً به کار خواهد آمد
    byte[] _il;               // کد بایت خام
    int _pos;                 // موقعیتی که در کد بایت هستیم

    Disassembler(MethodBase method)
    {
        _module = method.DeclaringType.Module;
        _il = method.GetMethodBody().GetILAsByteArray();
    }

    string Dis()
    {
        _output = new StringBuilder();
        while (_pos &lt; _il.Length) DisassembleNextInstruction();
        return _output.ToString();
    }
}
</code></pre>
<ul>
<li>متد استاتیک <strong>Disassemble</strong> تنها عضو عمومی این کلاس خواهد بود.</li>
<li>بقیه اعضا خصوصی و مختص فرآیند دیس‌اسمبلی هستند.</li>
<li>متد <strong>Dis</strong> حلقه اصلی را شامل می‌شود که هر دستور را پردازش می‌کند.</li>
</ul>
<hr>
<h4>آماده‌سازی برای تجزیه دستورات</h4>
<p>با این ساختار، تنها کاری که باقی می‌ماند نوشتن <strong>DisassembleNextInstruction</strong> است.</p>
<p>اما قبل از آن، بهتر است همه <strong>opcodes</strong> را در یک دیکشنری استاتیک بارگذاری کنیم تا بتوانیم بر اساس مقدار ۸ یا ۱۶ بیتی به آنها دسترسی داشته باشیم. ساده‌ترین روش، استفاده از <strong>Reflection</strong> برای دریافت تمام فیلدهای استاتیک از کلاس <strong>OpCodes</strong> است که نوع آنها <strong>OpCode</strong> باشد:</p>
<pre><code class="language-csharp">static Dictionary&lt;short, OpCode&gt; _opcodes = new Dictionary&lt;short, OpCode&gt;();

static Disassembler()
{
    Dictionary&lt;short, OpCode&gt; opcodes = new Dictionary&lt;short, OpCode&gt;();
    foreach (FieldInfo fi in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
        if (typeof(OpCode).IsAssignableFrom(fi.FieldType))
        {
            OpCode code = (OpCode)fi.GetValue(null);   // گرفتن مقدار فیلد
            if (code.OpCodeType != OpCodeType.Nternal)
                _opcodes.Add(code.Value, code);
        }
}
</code></pre>
<ul>
<li>این کار در <strong>سازنده استاتیک</strong> انجام شده تا تنها یک بار اجرا شود. ✅</li>
</ul>
<h3>نوشتن DisassembleNextInstruction 🛠️</h3>
<p>هر دستور IL از یک <strong>opcode یک یا دو بایتی</strong> تشکیل شده و پس از آن یک <strong>عملوند</strong> با طول صفر، یک، دو، چهار یا هشت بایت می‌آید.
(استثنا: <strong>inline switch opcodes</strong> که پس از آن تعداد متغیری از عملوندها می‌آید.)</p>
<p>الگوریتم کلی این است: ابتدا opcode را می‌خوانیم، سپس عملوند را، و در نهایت نتیجه را می‌نویسیم:</p>
<pre><code class="language-csharp">void DisassembleNextInstruction()
{
    int opStart = _pos;
    OpCode code = ReadOpCode();
    string operand = ReadOperand(code);
    _output.AppendFormat(&quot;IL_{0:X4}:  {1,-12} {2}&quot;, opStart, code.Name, operand);
    _output.AppendLine();
}
</code></pre>
<hr>
<h4>خواندن یک Opcode 🔍</h4>
<p>برای خواندن یک <strong>opcode</strong>:</p>
<ol>
<li>یک بایت جلو می‌رویم و بررسی می‌کنیم آیا دستور معتبر است.</li>
<li>اگر نبود، یک بایت دیگر جلو رفته و به دنبال دستور دو بایتی می‌گردیم:</li>
</ol>
<pre><code class="language-csharp">OpCode ReadOpCode()
{
    byte byteCode = _il[_pos++];
    if (_opcodes.ContainsKey(byteCode)) return _opcodes[byteCode];
    if (_pos == _il.Length) throw new Exception(&quot;Unexpected end of IL&quot;);
    short shortCode = (short)(byteCode * 256 + _il[_pos++]);
    if (!_opcodes.ContainsKey(shortCode))
        throw new Exception(&quot;Cannot find opcode &quot; + shortCode);
    return _opcodes[shortCode];
}
</code></pre>
<hr>
<h4>خواندن عملوند ⚙️</h4>
<p>ابتدا باید طول عملوند را تعیین کنیم. می‌توان این کار را بر اساس <strong>نوع عملوند</strong> انجام داد.
چون بیشتر عملوندها ۴ بایت طول دارند، استثناها به راحتی در یک شرط فیلتر می‌شوند.</p>
<p>سپس متد <strong>FormatOperand</strong> فراخوانی می‌شود تا عملوند را قالب‌بندی کند:</p>
<pre><code class="language-csharp">string ReadOperand(OpCode c)
{
    int operandLength =
        c.OperandType == OperandType.InlineNone ? 0 :
        c.OperandType == OperandType.ShortInlineBrTarget ||
        c.OperandType == OperandType.ShortInlineI ||
        c.OperandType == OperandType.ShortInlineVar ? 1 :
        c.OperandType == OperandType.InlineVar ? 2 :
        c.OperandType == OperandType.InlineI8 ||
        c.OperandType == OperandType.InlineR ? 8 :
        c.OperandType == OperandType.InlineSwitch ? 4 * (BitConverter.ToInt32(_il, _pos) + 1) :
        4;  // بقیه عملوندها 4 بایت هستند

    if (_pos + operandLength &gt; _il.Length)
        throw new Exception(&quot;Unexpected end of IL&quot;);

    string result = FormatOperand(c, operandLength);

    if (result == null)   // اگر قالب‌بندی خاص نیاز نباشد
    {
        result = &quot;&quot;;
        for (int i = 0; i &lt; operandLength; i++)
            result += _il[_pos + i].ToString(&quot;X2&quot;) + &quot; &quot;;
    }

    _pos += operandLength;
    return result;
}
</code></pre>
<ul>
<li>اگر <strong>FormatOperand</strong> مقدار <strong>null</strong> برگرداند، یعنی عملوند نیازی به قالب‌بندی خاص ندارد و به صورت <strong>هگزادسیمال</strong> نوشته می‌شود.</li>
</ul>
<p>می‌توان دیس‌اسمبلر را در این مرحله تست کرد با یک <strong>FormatOperand</strong> که همیشه <strong>null</strong> برگرداند. خروجی شبیه به این خواهد بود:</p>
<pre><code>IL_00A8:  ldfld        98 00 00 04
IL_00AD:  ldloc.2
IL_00AE:  add
IL_00AF:  ldelema      64 00 00 01
IL_00B4:  ldstr        26 04 00 70
IL_00B9:  call         B6 00 00 0A
IL_00BE:  ldstr        11 01 00 70
IL_00C3:  call         91 00 00 0A
</code></pre>
<ul>
<li>در این حالت، <strong>opcodes</strong> درست هستند اما عملوندها به درد خیلی نمی‌خورند.</li>
<li>ما می‌خواهیم به جای اعداد هگزادسیمال، <strong>نام اعضا و رشته‌ها</strong> را ببینیم.</li>
</ul>
<hr>
<h4>قالب‌بندی عملوندها 📐</h4>
<p>متد <strong>FormatOperand</strong> این کار را انجام می‌دهد و موارد خاصی که نیاز به قالب‌بندی دارند، شناسایی می‌کند. این شامل اکثر عملوندهای چهار بایتی و دستورهای <strong>short branch</strong> است:</p>
<pre><code class="language-csharp">string FormatOperand(OpCode c, int operandLength)
{
    if (operandLength == 0) return &quot;&quot;;
    if (operandLength == 4)
        return Get4ByteOperand(c);
    else if (c.OperandType == OperandType.ShortInlineBrTarget)
        return GetShortRelativeTarget();
    else if (c.OperandType == OperandType.InlineSwitch)
        return GetSwitchTarget(operandLength);
    else
        return null;
}
</code></pre>
<hr>
<p>با این روش، اکنون پایه برای <strong>یک دیس‌اسمبلر IL کامل و قابل توسعه</strong> آماده است. ✅</p>
<h3>پردازش عملوندهای چهار بایتی و شاخه‌ها 🧩</h3>
<p>سه نوع عملوند چهار بایتی وجود دارد که باید به شکل خاصی پردازش شوند:</p>
<ol>
<li>
<p><strong>ارجاع به اعضا یا تایپ‌ها</strong>
با این نوع، نام عضو یا تایپ را با فراخوانی <strong>ResolveMember</strong> روی ماژول تعریف‌کننده استخراج می‌کنیم.</p>
</li>
<li>
<p><strong>رشته‌ها</strong>
رشته‌ها در <strong>metadata</strong> ماژول اسمبلی ذخیره شده‌اند و با <strong>ResolveString</strong> بازیابی می‌شوند.</p>
</li>
<li>
<p><strong>شاخه‌ها (Branch targets)</strong>
عملوند به یک آفست بایتی در IL اشاره می‌کند. این‌ها را با محاسبه آدرس مطلق بعد از دستور فعلی (+ چهار بایت) قالب‌بندی می‌کنیم.</p>
</li>
</ol>
<p>مثال کد:</p>
<pre><code class="language-csharp">string Get4ByteOperand(OpCode c)
{
    int intOp = BitConverter.ToInt32(_il, _pos);
    switch (c.OperandType)
    {
        case OperandType.InlineTok:
        case OperandType.InlineMethod:
        case OperandType.InlineField:
        case OperandType.InlineType:
            MemberInfo mi;
            try { mi = _module.ResolveMember(intOp); }
            catch { return null; }
            if (mi == null) return null;
            if (mi.ReflectedType != null)
                return mi.ReflectedType.FullName + &quot;.&quot; + mi.Name;
            else if (mi is Type)
                return ((Type)mi).FullName;
            else
                return mi.Name;

        case OperandType.InlineString:
            string s = _module.ResolveString(intOp);
            if (s != null) s = &quot;'&quot; + s + &quot;'&quot;;
            return s;

        case OperandType.InlineBrTarget:
            return &quot;IL_&quot; + (_pos + intOp + 4).ToString(&quot;X4&quot;);

        default:
            return null;
    }
}
</code></pre>
<ul>
<li>نقطه‌ای که <strong>ResolveMember</strong> فراخوانی می‌شود، پنجره خوبی برای ابزارهای تحلیل کد است تا وابستگی‌های متدها را گزارش کنند.</li>
<li>برای سایر opcodes چهار بایتی، <strong>null</strong> برگردانده می‌شود تا <strong>ReadOperand</strong> عملوند را به صورت هگزادسیمال نمایش دهد.</li>
</ul>
<hr>
<h3>شاخه‌های کوتاه و inline switch 🚦</h3>
<ul>
<li><strong>شاخه کوتاه (Short branch target)</strong>: آفست مقصد به صورت یک بایت با علامت نشان داده می‌شود (در انتهای دستور فعلی، + یک بایت).</li>
<li><strong>Switch target</strong>: پس از آن تعداد متغیری از مقاصد چهار بایتی قرار می‌گیرد.</li>
</ul>
<pre><code class="language-csharp">string GetShortRelativeTarget()
{
    int absoluteTarget = _pos + (sbyte)_il[_pos] + 1;
    return &quot;IL_&quot; + absoluteTarget.ToString(&quot;X4&quot;);
}

string GetSwitchTarget(int operandLength)
{
    int targetCount = BitConverter.ToInt32(_il, _pos);
    string[] targets = new string[targetCount];
    for (int i = 0; i &lt; targetCount; i++)
    {
        int ilTarget = BitConverter.ToInt32(_il, _pos + (i + 1) * 4);
        targets[i] = &quot;IL_&quot; + (_pos + ilTarget + operandLength).ToString(&quot;X4&quot;);
    }
    return &quot;(&quot; + string.Join(&quot;, &quot;, targets) + &quot;)&quot;;
}
</code></pre>
<hr>
<p>با این کد، دیس‌اسمبلر کامل می‌شود.
می‌توان آن را با دیس‌اسمبل کردن یکی از متدهای خودش تست کرد:</p>
<pre><code class="language-csharp">MethodInfo mi = typeof(Disassembler).GetMethod(
    &quot;ReadOperand&quot;, BindingFlags.Instance | BindingFlags.NonPublic);
Console.WriteLine(Disassembler.Disassemble(mi));
</code></pre>
<ul>
<li>این خروجی IL خوانا و مشابه <strong>ildasm</strong> تولید می‌کند. ✅</li>
</ul>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
