<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل اول: آشنایی با سی‌شارپ و دات‌نت</h1>
<p>سی شارپ یک زبان برنامه‌نویسی همه‌منظوره (general-purpose)، ایمن از نظر نوع داده (type-safe)، و شی‌گرا (object-oriented) است.</p>
<p>هدف اصلی این زبان، افزایش بهره‌وری برنامه‌نویس است.
برای رسیدن به این هدف، #C تلاش می‌کند میان سادگی، قدرت بیان (expressiveness)، و کارایی (performance) تعادل برقرار کند.</p>
<p>طراح اصلی زبان #C از همان نسخه اول، آندرس هایلسبرگ (Anders Hejlsberg) بوده؛ کسی که قبلاً Turbo Pascal را خلق کرده و معمار زبان Delphi نیز بوده است.</p>
<p>زبان #C به‌گونه‌ای طراحی شده که وابسته به هیچ پلتفرم خاصی نیست (platform-neutral) و می‌تواند با اجراکننده‌های خاص پلتفرم‌های مختلف (platform-specific runtimes) کار کند.</p>
<h2>شی‌ءگرایی</h2>
<p>زبان #C یک پیاده‌سازی قدرتمند از الگوی برنامه‌نویسی شی‌گرا (Object-Oriented Programming) است.
این الگو شامل سه اصل اصلی است:</p>
<ul>
<li>
<p>کپسوله‌سازی (Encapsulation)</p>
</li>
<li>
<p>ارث‌بری (Inheritance)</p>
</li>
<li>
<p>چندریختی (Polymorphism)</p>
</li>
</ul>
<p>🔹 کپسوله‌سازی یعنی اینکه برای هر شی (Object) یک مرز مشخص تعریف کنیم تا رفتار خارجی (عمومی) آن را از جزئیات پیاده‌سازی داخلی (خصوصی) جدا کنیم.</p>
<h4>ویژگی‌های منحصربه‌فرد #C در شی‌گرایی</h4>
<p>🔸 سیستم نوع یکپارچه (Unified Type System)
در #C، واحد اصلی ساخت برنامه، نوع (Type) است — یعنی یک واحد کپسوله‌شده از داده و توابع.</p>
<p>در این زبان، همه نوع‌ها در نهایت زیرمجموعه‌ای از یک نوع پایه مشترک هستند.
این یعنی فرقی نمی‌کند با یک شی تجاری (Business Object) کار می‌کنید یا با یک عدد ساده، همه این نوع‌ها از یک سری قابلیت‌های پایه برخوردارند.</p>
<p>برای مثال:</p>
<p>می‌تونید روی هر شیئی در #C متد ToString را صدا بزنید و نسخه متنی (رشته‌ای) از آن دریافت کنید — چون همه نوع‌ها این متد را دارند.</p>
<p>🔸 کلاس‌ها و اینترفیس‌ها (Classes and Interfaces)
در مدل سنتی شی‌گرایی، تنها نوع موجود کلاس (Class) است. اما در #C انواع دیگری هم وجود دارد، از جمله:</p>
<p>اینترفیس (Interface)
اینترفیس‌ها شبیه کلاس‌ها هستند با این تفاوت که نمی‌توانند داده نگه دارند. یعنی فقط رفتار تعریف می‌کنند، نه وضعیت.</p>
<p>این ویژگی چند مزیت دارد:</p>
<ul>
<li>
<p>پشتیبانی از ارث‌بری چندگانه (Multiple Inheritance)</p>
</li>
<li>
<p>جدا کردن تعریف (specification) از پیاده‌سازی (implementation)</p>
</li>
</ul>
<p>🔸 ویژگی‌ها، متدها، و رویدادها
(Properties, Methods, and Events)</p>
<p>در الگوی شی‌گرایی ناب، همه توابع به شکل متد (Method) هستند. اما در #C، متدها تنها یک نوع از اعضای تابعی (Function Members) محسوب می‌شوند.
نوع‌های دیگر شامل:</p>
<ul>
<li>ویژگی‌ها (Properties):</li>
<li></li>
</ul>
<p>اعضایی که بخشی از وضعیت یک شی را کپسوله می‌کنند، مثل رنگ یک دکمه یا متن یک برچسب.</p>
<ul>
<li>رویدادها (Events):</li>
<li></li>
</ul>
<p>اعضایی که برای ساده‌تر کردن واکنش به تغییرات وضعیت شی‌ها طراحی شده‌اند.</p>
<p>تأثیرات برنامه‌نویسی تابعی در #C</p>
<p>با اینکه #C به‌طور عمده یک زبان شی‌گراست، اما از الگوهای برنامه‌نویسی تابعی (Functional Programming) هم الهام گرفته. برخی از این ویژگی‌ها عبارت‌اند از:</p>
<p>🔹 توابع به‌عنوان مقدار (Functions as Values)
با استفاده از نماینده‌ها (Delegates) در #C، می‌توانید توابع را مانند داده، به دیگر توابع ارسال یا از آن‌ها بازگردانید.</p>
<p>🔹 پشتیبانی از الگوهای برنامه‌نویسی تابعی
در برنامه‌نویسی تابعی، ترجیح داده می‌شود که مقدار متغیرها تغییر نکند، و به‌جای آن از الگوهای اعلانی (Declarative Patterns) استفاده شود.</p>
<p>زبان #C ابزارهایی برای این سبک برنامه‌نویسی فراهم کرده، از جمله:</p>
<ul>
<li>توابع بی‌نام (Lambda Expressions):</li>
<li></li>
</ul>
<p>می‌توان توابعی را در لحظه تعریف کرد که به متغیرهای اطرافشان دسترسی دارند (یعنی آن‌ها را &quot;capture&quot; می‌کنند).</p>
<ul>
<li>عبارات پرس‌وجو (Query Expressions):</li>
<li></li>
</ul>
<p>برای برنامه‌نویسی لیستی یا واکنشی (Reactive Programming) به‌کار می‌روند.</p>
<ul>
<li>رکوردها (Records):</li>
<li></li>
</ul>
<p>نوع‌هایی هستند که به‌سادگی می‌توان با آن‌ها اشیایی فقط‌خواندنی و تغییرناپذیر (Immutable) ساخت.</p>
<h2>ایمنی نوع در #C</h2>
<p>(Type Safety)</p>
<p>زبان #C در اصل یک زبان ایمن از نظر نوع (Type-Safe) است. این یعنی اشیای مختلف (یعنی نمونه‌هایی از انواع مختلف داده‌ها) فقط از طریق سازوکارهایی که خود نوع آن‌ها تعریف کرده، می‌توانند با هم تعامل داشته باشند.</p>
<p>این کار باعث می‌شود که انسجام داخلی هر نوع (Type) حفظ شود.</p>
<p>برای مثال:</p>
<p>در #C نمی‌توانید با یک مقدار از نوع رشته (string) طوری رفتار کنید که انگار یک عدد صحیح (int) است — زبان جلوی این کار را می‌گیرد.</p>
<p><strong>تایپ ایستا (Static Typing)</strong></p>
<p>زبان #C از تایپ ایستا پشتیبانی می‌کند.
یعنی بررسی نوع داده‌ها نه فقط در زمان اجرا، بلکه در زمان کامپایل (ساخت برنامه) هم انجام می‌شود.</p>
<p>🔹 این یعنی بسیاری از خطاهای احتمالی قبل از اجرای برنامه شناسایی می‌شوند.
🔹 به‌جای اینکه فقط با نوشتن تست‌های واحد (Unit Tests) در زمان اجرا به دنبال خطاها باشید، کامپایلر خودش بررسی می‌کند که همه نوع‌ها در برنامه درست به‌کار رفته‌اند یا نه.</p>
<p>این ویژگی چند مزیت مهم داره:</p>
<ul>
<li>
<p>برنامه‌های بزرگ راحت‌تر قابل مدیریت هستند</p>
</li>
<li>
<p>کدها قابل پیش‌بینی‌تر و مطمئن‌تر (Robust) می‌شن</p>
</li>
<li>
<p>ابزارهایی مثل IntelliSense در ویژوال استودیو می‌تونن کمک کنن کدها رو سریع‌تر و بهتر بنویسید، چون دقیقاً می‌دونن که هر متغیر از چه نوعیه و چه متدهایی می‌تونید روش اجرا کنید</p>
</li>
<li>
<p>همچنین این ابزارها می‌تونن بررسی کنن که یک متغیر یا متد یا نوع، در کجای برنامه استفاده شده — که این موضوع برای بازسازی و تغییر ساختار کد (Refactoring) بسیار مهمه</p>
</li>
</ul>
<p><strong>تایپ پویا با dynamic</strong></p>
<p>در عین حال که #C عمدتاً یک زبان با تایپ ایستاست، اجازه می‌ده که بخش‌هایی از کد را به‌صورت پویا تایپ کنید.
برای این کار می‌تونید از کلیدواژه‌ی dynamic استفاده کنید.</p>
<p>اما با این وجود، #C در ذات خود همچنان یک زبان با تایپ ایستا باقی می‌مونه.</p>
<p><strong>تایپ قوی (Strong Typing)</strong></p>
<p>زبان #C همچنین به عنوان یک زبان با تایپ قوی (Strongly Typed) شناخته می‌شود.
یعنی قوانین مربوط به نوع‌ها به‌شدت رعایت می‌شن — چه در زمان کامپایل و چه در زمان اجرا.</p>
<p>مثلاً:
شما نمی‌تونید تابعی که انتظار داره یک عدد صحیح (int) دریافت کنه، با یک عدد اعشاری (float) صدا بزنید — مگر اینکه صراحتاً عدد اعشاری رو به عدد صحیح تبدیل (Cast) کرده باشید.</p>
<p>این موضوع کمک می‌کنه تا از بروز خطاهای رایج و پنهان جلوگیری بشه.</p>
<p>✅ این ویژگی‌ها باعث می‌شن زبان #C هم قدرتمند باشه و هم امن و قابل اعتماد — مخصوصاً برای ساخت برنامه‌های بزرگ و پیچیده.</p>
<h2>مدیریت حافظه</h2>
<p>(Memory Management)</p>
<p>در زبان #C، مدیریت حافظه به‌صورت خودکار توسط زمان اجرای مشترک (Common Language Runtime یا CLR) انجام می‌شود.</p>
<p>به عبارت ساده‌تر:
در هنگام اجرای برنامه، یک زباله‌روب (Garbage Collector) وجود دارد که به‌طور خودکار حافظه اشیایی را که دیگر استفاده نمی‌شوند آزاد می‌کند.</p>
<p>✅ این یعنی برنامه‌نویس دیگر نیازی ندارد خودش به‌صورت دستی حافظه اشیاء را آزاد کند — چیزی که در زبان‌هایی مثل ++C ضروری بود.</p>
<p>❌ در ++C اگر فراموش می‌کردید حافظه‌ای را آزاد کنید، یا اشتباه آن را دوباره آزاد می‌کردید، برنامه‌تان با خطاهای خطرناک مثل اشاره‌گرهای نامعتبر (Dangling Pointers) روبه‌رو می‌شد.
اما در #C این مشکل به‌طور کامل از بین رفته.</p>
<p>آیا در #C اصلاً اشاره‌گر (Pointer) وجود ندارد؟
❌ خیر، زبان #C اشاره‌گرها را کاملاً حذف نکرده؛ فقط استفاده از آن‌ها را برای اکثر کارها غیرضروری کرده است.</p>
<p>در برخی موارد خاص که:</p>
<ul>
<li>
<p>عملکرد (Performance) خیلی حیاتی باشد</p>
</li>
<li>
<p>یا نیاز به تعامل با کدهای Native یا کتابخانه‌های سطح پایین باشد</p>
</li>
</ul>
<p>می‌توانید از اشاره‌گرها و مدیریت حافظه دستی استفاده کنید — اما فقط در بخش‌هایی از کد که با کلیدواژه unsafe علامت‌گذاری شده‌اند.</p>
<p>✅ بنابراین:</p>
<ul>
<li>
<p>در استفاده روزمره، شما بدون اشاره‌گر هم می‌توانید همه کارها را به‌سادگی انجام دهید.</p>
</li>
<li>
<p>اما اگر لازم باشد، #C امکان نوشتن کدهای سطح پایین و بهینه را هم در اختیار شما قرار می‌دهد — با آگاهی کامل و در محیطی ایزوله.</p>
</li>
</ul>
<h2>پشتیبانی از پلتفرم‌ها</h2>
<p>(Platform Support)</p>
<p>زبان #C اجراکننده‌هایی (Runtimes) دارد که از پلتفرم‌های زیر پشتیبانی می‌کنند:</p>
<ul>
<li>
<p>ویندوز 7 به بعد (Windows 7+)
برای ساخت اپلیکیشن‌های:</p>
<ul>
<li>
<p>دسکتاپ با رابط گرافیکی (Rich Client)</p>
</li>
<li>
<p>تحت وب (Web)</p>
</li>
<li>
<p>سمت سرور (Server)</p>
</li>
<li>
<p>خط فرمان (Command-Line)</p>
</li>
</ul>
</li>
<li>
<p>سیستم‌عامل macOS
برای ساخت:</p>
<ul>
<li>
<p>برنامه‌های تحت وب و خط فرمان</p>
</li>
<li>
<p>همچنین برنامه‌های گرافیکی از طریق فناوری Mac Catalyst</p>
</li>
</ul>
</li>
<li>
<p>لینوکس (Linux)
برای اپلیکیشن‌های:</p>
<ul>
<li>
<p>تحت وب</p>
</li>
<li>
<p>خط فرمان</p>
</li>
</ul>
</li>
<li>
<p>اندروید و iOS
برای توسعه برنامه‌های موبایل</p>
</li>
<li>
<p>دستگاه‌های ویندوز 10
مثل:</p>
<ul>
<li>
<p>Xbox</p>
</li>
<li>
<p>Surface Hub</p>
</li>
<li>
<p>HoloLens
(از طریق فناوری UWP یا Universal Windows Platform)</p>
</li>
</ul>
</li>
</ul>
<p>علاوه بر این، فناوری‌ای به نام Blazor وجود دارد که می‌تواند کدهای #C را به WebAssembly تبدیل کند تا مستقیماً در مرورگر اجرا شوند.</p>
<p>✅ این یعنی می‌توانید با استفاده از #C حتی برنامه‌های تحت وب مدرن و بدون نیاز به جاوااسکریپت بنویسید — و کدتان در مرورگر اجرا شود!</p>
<h2>محیط‌های زمان اجرا (CLRs)، کتابخانه‌های کلاس پایه (BCLs) و رانتایم‌ها</h2>
<p>برای اجرای برنامه‌های نوشته‌شده با زبان #C، به دو بخش اصلی نیاز داریم:</p>
<ol>
<li>
<p>یک زمان اجرای مشترک (Common Language Runtime یا CLR)</p>
</li>
<li>
<p>یک کتابخانه کلاس پایه (Base Class Library یا BCL)</p>
</li>
</ol>
<p>علاوه بر این‌ها، یک زمان اجرا (Runtime) ممکنه شامل لایه‌های سطح بالاتر هم باشه؛
مثلاً کتابخانه‌هایی برای توسعه:</p>
<ul>
<li>
<p>برنامه‌های دسکتاپ با رابط گرافیکی (Rich-Client)</p>
</li>
<li>
<p>برنامه‌های موبایل</p>
</li>
<li>
<p>یا برنامه‌های تحت وب</p>
</li>
</ul>
<p>📊 این ساختار معمولاً در قالب نموداری مثل شکل 1-1 نمایش داده می‌شه (که در ادامه کتاب میاد).</p>
<p><strong>چرا چند نوع Runtime وجود داره؟</strong>
💡 دلیلش اینه که:</p>
<ul>
<li>
<p>انواع مختلفی از اپلیکیشن‌ها وجود دارن (وب، موبایل، دسکتاپ، بازی و...)</p>
</li>
<li>
<p>و این اپلیکیشن‌ها باید روی پلتفرم‌های مختلف (مثل ویندوز، لینوکس، اندروید و...) اجرا بشن</p>
</li>
</ul>
<p>بنابراین برای پشتیبانی از این تنوع، نسخه‌های مختلفی از Runtimes وجود دارن —
ولی همه‌ی اون‌ها بر پایه مفاهیم CLR و BCL ساخته شده‌اند.</p>
<div align="center">
<p><img src="../../../assets/image/01/Runtime-architecture.png" alt="Conventions-UsedThis-Book"></p>
</div>
## زمان اجرای مشترک (CLR)
<p>(Common Language Runtime)</p>
<p>این CLR یا زمان اجرای مشترک، بخشی از زیرساخت #C است که خدمات حیاتی زمان اجرا را فراهم می‌کند — از جمله:</p>
<ul>
<li>
<p>مدیریت خودکار حافظه (Garbage Collection)</p>
</li>
<li>
<p>مدیریت خطاها یا استثناها (Exception Handling)</p>
</li>
</ul>
<p>🔹 واژه‌ی &quot;مشترک&quot; در نام CLR به این نکته اشاره دارد که زبان‌های مختلفی از یک Runtime یکسان استفاده می‌کنند.
برای مثال، زبان‌هایی مثل:</p>
<ul>
<li>
<p>F#</p>
</li>
<li>
<p>Visual Basic</p>
</li>
<li>
<p>Managed C++</p>
</li>
</ul>
<p>همه از همین CLR استفاده می‌کنند و با آن سازگار هستند.</p>
<p><strong>کد مدیریت‌شده (Managed Code) و زبان میانی (IL)</strong></p>
<p>زبان #C به‌عنوان یک زبان مدیریت‌شده (Managed Language) شناخته می‌شود، چون کد منبع آن ابتدا به کد مدیریت‌شده کامپایل می‌شود.</p>
<p>این کد مدیریت‌شده به‌صورت زبان میانی (Intermediate Language یا IL) ذخیره می‌شود.</p>
<p>سپس CLR این کد IL را به کد ماشین (مثلاً X64 یا X86) تبدیل می‌کند تا توسط سیستم اجرا شود.
این فرآیند تبدیل درست قبل از اجرای برنامه انجام می‌شود و به آن کامپایل در لحظه (Just-In-Time یا JIT) گفته می‌شود.</p>
<p>🔸 در برخی موارد (مثل برنامه‌های حجیم یا دستگاه‌های ضعیف‌تر)، می‌توان پیش از زمان اجرا کل برنامه را کامپایل کرد — که به آن کامپایل پیش‌زمانی (Ahead-of-Time) گفته می‌شود.
برای مثال، در اپلیکیشن‌های iOS، این روش اجباری است تا با قوانین اپ‌استور سازگار باشد.</p>
<p><strong>اسمبلی چیست؟</strong>
(Assembly)</p>
<p>کد مدیریت‌شده درون یک واحد به نام اسمبلی (Assembly) قرار می‌گیرد.</p>
<p>یک اسمبلی شامل موارد زیر است:</p>
<ul>
<li>
<p>کد IL</p>
</li>
<li>
<p>و اطلاعات نوع (Type Metadata)</p>
</li>
</ul>
<p>وجود متادیتا باعث می‌شود که اسمبلی‌ها بتوانند به نوع‌های موجود در اسمبلی‌های دیگر ارجاع دهند — بدون اینکه نیازی به فایل‌های اضافی باشد.</p>
<p><strong>ابزارهای بررسی و بازگردانی کد</strong></p>
<p>برای مشاهده و تحلیل محتوای یک اسمبلی، می‌توانید از ابزارهایی استفاده کنید:</p>
<ul>
<li>ildasm از مایکروسافت
(برای بررسی ساختار اسمبلی و IL)</li>
</ul>
<p>ابزارهایی مثل:</p>
<ul>
<li>
<p>ILSpy</p>
</li>
<li>
<p>dotPeek از JetBrains</p>
</li>
</ul>
<p>این ابزارها می‌توانند حتی IL را به کد #C بازگردانند (Decompile).
چرا؟ چون IL نسبت به کد ماشین سطح بالاتری دارد، و بنابراین بازسازی کد #C از روی آن کار شدنی و مؤثری است.</p>
<p><strong>بازتاب (Reflection) و تولید کد در زمان اجرا</strong></p>
<p>برنامه‌های نوشته‌شده با #C می‌توانند:</p>
<ul>
<li>
<p>متادیتای خود را در زمان اجرا بررسی کنند — این قابلیت را Reflection می‌نامند.</p>
</li>
<li>
<p>حتی می‌توانند در زمان اجرا کد جدید تولید کنند — با استفاده از reflection.emit</p>
</li>
</ul>
<p>✅ این ویژگی‌ها قدرت بسیار زیادی به برنامه‌نویسان می‌دهند تا برنامه‌هایی انعطاف‌پذیر، پویا، و قابل تحلیل بنویسند.</p>
<h2>کتابخانه کلاس پایه</h2>
<p>(Base Class Library)</p>
<p>هر CLR (زمان اجرای مشترک) همیشه همراه با مجموعه‌ای از اسمبلی‌ها عرضه می‌شود که به آن‌ها کتابخانه کلاس پایه (Base Class Library یا BCL) گفته می‌شود.</p>
<p>🔹 این کتابخانه، امکانات پایه و ضروری را برای برنامه‌نویسان فراهم می‌کند؛ از جمله:</p>
<ul>
<li>
<p>کالکشن‌ها (Collections) مثل لیست‌ها و دیکشنری‌ها</p>
</li>
<li>
<p>ورودی/خروجی (I/O) مثل خواندن و نوشتن فایل</p>
</li>
<li>
<p>پردازش متن</p>
</li>
<li>
<p>کار با XML و JSON</p>
</li>
<li>
<p>شبکه (Networking)</p>
</li>
<li>
<p>رمزنگاری (Encryption)</p>
</li>
<li>
<p>برقراری ارتباط با کدهای Native (Interop)</p>
</li>
<li>
<p>برنامه‌نویسی هم‌زمان (Concurrency) و پردازش موازی (Parallel Programming)</p>
</li>
</ul>
<p><strong>پشتیبانی از ویژگی‌های خود زبان #C</strong></p>
<p>کتابخانه BCL فقط امکانات عمومی نیست — بلکه نوع‌هایی را هم پیاده‌سازی می‌کند که خود زبان #C برای عملکرد درست به آن‌ها نیاز دارد؛ مثلاً:</p>
<ul>
<li>
<p>شمردن (Enumeration)</p>
</li>
<li>
<p>پرس‌وجو (Querying)</p>
</li>
<li>
<p>برنامه‌نویسی ناهمگام (Asynchrony)</p>
</li>
</ul>
<p>همچنین BCL این امکان را به شما می‌دهد که:</p>
<p>به‌صورت مستقیم به قابلیت‌های CLR دسترسی داشته باشید، مثل:</p>
<ul>
<li>
<p>بازتاب (Reflection)</p>
</li>
<li>
<p>مدیریت حافظه (Memory Management)</p>
</li>
</ul>
<p>✅ به زبان ساده‌تر:</p>
<p>BCL جعبه‌ابزار اصلی شما در برنامه‌نویسی با #C و دات‌نت است؛ تمام چیزهایی که برای ساخت برنامه‌های واقعی نیاز دارید در همین کتابخانه پایه وجود دارد.</p>
<h2>زمان اجرا (Runtime) چیست؟</h2>
<p>(Runtimes)</p>
<p>Runtime — که گاهی به آن فریم‌ورک (Framework) هم گفته می‌شود — یک بسته قابل نصب است که شما آن را دانلود و نصب می‌کنید.</p>
<p>هر Runtime شامل دو بخش اصلی است:</p>
<ol>
<li>
<p>یک CLR (زمان اجرای مشترک)</p>
</li>
<li>
<p>یک کتابخانه کلاس پایه (BCL)</p>
</li>
</ol>
<p>و در صورت نیاز، ممکنه شامل یک لایه‌ی مخصوص برای نوع خاصی از اپلیکیشن هم باشد، مثل:</p>
<ul>
<li>
<p>برنامه‌های وب</p>
</li>
<li>
<p>اپلیکیشن‌های موبایل</p>
</li>
<li>
<p>برنامه‌های دسکتاپ با رابط گرافیکی (Rich Client)</p>
</li>
</ul>
<p>🔹 اگر دارید یک برنامه خط فرمان (Command-Line) یا یک کتابخانه بدون واسط کاربری (Non-UI Library) می‌نویسید،
نیازی به این لایه‌های اضافه نخواهید داشت.</p>
<p><strong>وقتی برنامه‌ای می‌نویسید، چه Runtimeی را هدف قرار می‌دهید؟</strong></p>
<p>وقتی برنامه‌ای می‌نویسید، مشخص می‌کنید که کدام Runtime هدف برنامه‌ی شماست.
این یعنی:</p>
<ul>
<li>
<p>برنامه‌ی شما از امکاناتی استفاده می‌کند که آن Runtime در اختیارش می‌گذارد</p>
</li>
<li>
<p>برنامه‌تان به همان Runtime وابسته است</p>
</li>
</ul>
<p>همچنین، نوع Runtimeی که انتخاب می‌کنید تعیین می‌کند برنامه‌تان روی چه پلتفرم‌هایی قابل اجراست.</p>
<p>✅ مثلاً:</p>
<p>اگر از .NET MAUI استفاده کنید، می‌تونید برنامه‌تان را برای اندروید، iOS، ویندوز و مک بسازید.
ولی اگر از ASP.NET Core استفاده کنید، برنامه‌ی شما برای تحت‌وب بودن طراحی می‌شه.</p>
<p>جدول زیر گزینه‌های اصلی محیط‌های اجرایی را فهرست می‌کند:</p>
<div align="center">
<p><img src="../../../assets/image/01/Introduction-02.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>تصویر ۱-۲ این اطلاعات را به صورت گرافیکی نمایش می‌دهد و همچنین به عنوان راهنمایی برای مطالبی که در کتاب پوشش داده شده‌اند، عمل می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/01/Introduction-03.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>.NET 8 چیست؟</h2>
<p>(.NET 8)</p>
<p>.NET 8 زمان اجرای اصلی و متن‌باز مایکروسافت محسوب می‌شود.</p>
<p>با استفاده از .NET 8 می‌توانید انواع مختلفی از برنامه‌ها بنویسید، از جمله:</p>
<ul>
<li>
<p>برنامه‌های وب و خط فرمان (Console)
که روی سیستم‌عامل‌های:</p>
<ul>
<li>
<p>ویندوز</p>
</li>
<li>
<p>لینوکس</p>
</li>
<li>
<p>macOS
قابل اجرا هستند.</p>
</li>
</ul>
</li>
<li>
<p>برنامه‌های دسکتاپ با رابط کاربری غنی (Rich-Client Applications)
که روی:</p>
<ul>
<li>
<p>ویندوز 10 و نسخه‌های جدیدتر</p>
</li>
<li>
<p>macOS
اجرا می‌شوند.</p>
</li>
</ul>
</li>
<li>
<p>برنامه‌های موبایل
که روی:</p>
<ul>
<li>
<p>iOS</p>
</li>
<li>
<p>Android
اجرا می‌شوند.</p>
</li>
</ul>
</li>
</ul>
<p>📘 این کتاب تمرکز اصلی‌اش بر روی CLR و BCL در .NET 8 است.</p>
<p><strong>تفاوت با .NET Framework</strong></p>
<p>برخلاف .NET Framework که به‌صورت پیش‌فرض روی ویندوز نصب بود،
.NET 8 به‌صورت پیش‌فرض روی ویندوز نصب نیست.</p>
<p>❗ بنابراین، اگر برنامه‌ای با .NET 8 بنویسید و بخواهید روی سیستمی اجرا کنید که .NET 8 نصب ندارد، پیامی نمایش داده می‌شود که از شما می‌خواهد Runtime را از یک صفحه وب دانلود کنید.</p>
<p>✅ برای جلوگیری از این مشکل، می‌توانید برنامه را به‌صورت Self-Contained Deployment منتشر کنید؛
یعنی تمام اجزای موردنیاز از Runtime داخل فایل برنامه گنجانده می‌شوند.</p>
<p>تاریخچه نسخه‌های .NET
تاریخچه انتشار نسخه‌های اصلی به این صورت است:</p>
<pre><code>.NET Core 1.x  
→ .NET Core 2.x  
→ .NET Core 3.x  
→ .NET 5  
→ .NET 6  
→ .NET 7  
→ .NET 8
</code></pre>
<p>🔹 بعد از .NET Core 3، مایکروسافت واژه‌ی &quot;Core&quot; را از نام نسخه‌ها حذف کرد.
🔹 همچنین نسخه‌ی 4 را کاملاً رد کرد تا با .NET Framework 4.x که نسخه‌ای کاملاً متفاوت و قدیمی‌تر است اشتباه گرفته نشود.</p>
<p><strong>سازگاری نسخه‌ها</strong></p>
<ul>
<li>
<p>اسمبلی‌هایی که با .NET Core 1 تا .NET 7 ساخته شده‌اند، در بیشتر موارد بدون تغییر روی .NET 8 اجرا می‌شوند.</p>
</li>
<li>
<p>اما اسمبلی‌هایی که با .NET Framework (هر نسخه‌ای) ساخته شده‌اند، معمولاً با .NET 8 ناسازگار هستند.</p>
</li>
</ul>
<h2>برنامه‌های دسکتاپ ویندوز و WinUI 3</h2>
<p>(Windows Desktop and WinUI 3)</p>
<p>برای نوشتن برنامه‌های دسکتاپ با رابط کاربری غنی که روی ویندوز 10 و نسخه‌های جدیدتر اجرا شوند، می‌توانید از بین دو گزینه انتخاب کنید:</p>
<ul>
<li>
<p>رابط‌های برنامه‌نویسی کلاسیک دسکتاپ ویندوز (Windows Desktop APIs)
مانند:</p>
<ul>
<li>
<p>Windows Forms</p>
</li>
<li>
<p>WPF (Windows Presentation Foundation)</p>
</li>
<li>
<p>WinUI 3</p>
</li>
</ul>
</li>
</ul>
<p><strong>تفاوت‌ها و نکات مهم</strong></p>
<ul>
<li>
<p>Windows Desktop APIs جزئی از Runtime دسکتاپ دات‌نت (.NET Desktop Runtime) هستند.</p>
</li>
<li>
<p>اما WinUI 3 بخشی از Windows App SDK است که باید به‌صورت جداگانه دانلود و نصب شود.</p>
</li>
</ul>
<p><strong>تاریخچه و پشتیبانی</strong></p>
<ul>
<li>
<p>رابط‌های کلاسیک دسکتاپ ویندوز از سال ۲۰۰۶ وجود دارند و از نظر کتابخانه‌های شخص ثالث بسیار قوی هستند.</p>
</li>
<li>
<p>همچنین سوالات و پاسخ‌های زیادی درباره‌ی آن‌ها در سایت‌هایی مثل StackOverflow وجود دارد که یادگیری و رفع اشکال را آسان می‌کند.</p>
</li>
<li>
<p>WinUI 3 در سال ۲۰۲۲ منتشر شده و هدف آن نوشتن برنامه‌های مدرن و جذاب است که از آخرین کنترل‌ها و امکانات ویندوز ۱۰ و بالاتر بهره می‌برند.</p>
</li>
<li>
<p>این فناوری جانشین Universal Windows Platform (UWP) به‌شمار می‌رود.</p>
</li>
</ul>
<p>✅ اگر می‌خواهید برنامه‌های دسکتاپی با ظاهر و قابلیت‌های به‌روز بسازید، WinUI 3 انتخاب مناسبی است، ولی اگر دنبال راه‌حلی پایدار و با پشتیبانی گسترده هستید، می‌توانید از Windows Forms یا WPF استفاده کنید.</p>
<h2>MAUI</h2>
<p>(Multi-platform App UI)</p>
<p>MAUI بیشتر برای ساخت برنامه‌های موبایل روی iOS و اندروید طراحی شده است، اما می‌توان از آن برای ساخت برنامه‌های دسکتاپ روی macOS و ویندوز نیز استفاده کرد،
که این کار از طریق فناوری‌هایی مانند Mac Catalyst و WinUI 3 انجام می‌شود.</p>
<p>MAUI ادامه و تکامل پروژه Xamarin است و به شما اجازه می‌دهد که با یک پروژه، برنامه‌تان را برای چند پلتفرم مختلف بسازید.</p>
<p><strong>Avalonia</strong></p>
<p>برای ساخت برنامه‌های دسکتاپ چندسکویی (Cross-platform)،
کتابخانه‌ی شخص ثالثی به نام Avalonia وجود دارد که جایگزینی برای MAUI به شمار می‌رود.</p>
<p>ویژگی‌های Avalonia:</p>
<ul>
<li>
<p>روی لینوکس نیز اجرا می‌شود</p>
</li>
<li>
<p>معماری ساده‌تری نسبت به MAUI دارد (چون از لایه‌های میانی مانند Catalyst یا WinUI استفاده نمی‌کند)</p>
</li>
<li>
<p>API آن شبیه به WPF است</p>
</li>
<li>
<p>یک افزونه تجاری به نام XPF دارد که تقریباً سازگاری کامل با WPF را فراهم می‌کند.</p>
</li>
</ul>
<p><strong>.NET Framework</strong></p>
<p>.NET Framework نسخه‌ی اولیه و قدیمی‌تر مایکروسافت است که فقط برای برنامه‌های تحت ویندوز طراحی شده:</p>
<ul>
<li>
<p>برنامه‌های وب</p>
</li>
<li>
<p>برنامه‌های دسکتاپ و سرور ویندوز</p>
</li>
</ul>
<p>مایکروسافت برنامه‌ای برای انتشار نسخه‌های جدید این فریم‌ورک ندارد، ولی همچنان نسخه‌ی 4.8 را پشتیبانی و نگهداری می‌کند،
چون تعداد زیادی برنامه قدیمی بر اساس آن ساخته شده‌اند.</p>
<p><strong>تفاوت‌های مهم درباره .NET Framework و .NET 8</strong></p>
<ul>
<li>
<p>در .NET Framework، CLR و BCL با لایه‌ی اپلیکیشن کاملاً یکپارچه هستند.</p>
</li>
<li>
<p>برنامه‌هایی که با .NET Framework نوشته شده‌اند، می‌توانند تحت .NET 8 مجدداً کامپایل شوند،
ولی معمولاً به تغییراتی نیاز دارند.</p>
</li>
<li>
<p>برخی قابلیت‌های .NET Framework در .NET 8 وجود ندارند، و بالعکس.</p>
</li>
</ul>
<p><strong>نصب و نسخه‌های C#</strong></p>
<ul>
<li>
<p>.NET Framework به‌صورت پیش‌فرض روی ویندوز نصب است و از طریق Windows Update به‌روزرسانی می‌شود.</p>
</li>
<li>
<p>اگر برنامه‌تان را روی .NET Framework 4.8 هدف قرار دهید، می‌توانید از ویژگی‌های زبان C# 7.3 و نسخه‌های قبل استفاده کنید.</p>
</li>
<li>
<p>البته می‌توانید نسخه‌ی زبان جدیدتر را در فایل پروژه تنظیم کنید تا برخی قابلیت‌های جدید فعال شود (البته به جز ویژگی‌هایی که به Runtime جدید نیاز دارند).</p>
</li>
</ul>
<p><strong>توضیح اصطلاحات “.NET”</strong></p>
<p>واژه‌ی “.NET” همیشه به عنوان اصطلاح کلی برای همه‌ی فناوری‌هایی که این کلمه را در نامشان دارند استفاده شده، مثل:</p>
<ul>
<li>
<p>.NET Framework</p>
</li>
<li>
<p>.NET Core</p>
</li>
<li>
<p>.NET Standard</p>
</li>
<li>
<p>و غیره</p>
</li>
</ul>
<p>این باعث شده که نامگذاری جدید مایکروسافت (که .NET Core را به صرفه .NET تغییر داده) گاهی اوقات گیج‌کننده باشد.</p>
<p>📌 در این کتاب:</p>
<ul>
<li>
<p>وقتی به نسخه‌های جدید اشاره می‌کنیم، از عبارت “.NET 5+” استفاده می‌کنیم.</p>
</li>
<li>
<p>و برای اشاره به کل دنباله‌ی .NET Core و نسخه‌های جدیدتر، می‌گوییم “.NET Core و .NET 5+”.</p>
</li>
</ul>
<p>همچنین، اگرچه .NET (5+) یک فریم‌ورک است،
اما با .NET Framework قدیمی کاملاً متفاوت است،
پس تا جایی که ممکن است در این کتاب از اصطلاح runtime به جای framework استفاده می‌کنیم تا ابهام کمتر شود.</p>
<h2>محیط‌های اجرایی خاص Niche Runtimes</h2>
<p>علاوه بر Runtimeهای اصلی، چند Runtime خاص و تخصصی نیز وجود دارد:</p>
<p><strong>Unity</strong></p>
<p>Unity یک پلتفرم توسعه بازی است که به شما امکان می‌دهد منطق بازی را با زبان #C بنویسید.</p>
<p><strong>Universal Windows Platform (UWP)</strong></p>
<p>UWP برای نوشتن برنامه‌هایی طراحی شده که اولویت‌شان صفحه‌نمایش لمسی (Touch-First) است و روی ویندوز ۱۰ به بالا اجرا می‌شوند،
از جمله دستگاه‌هایی مثل:</p>
<ul>
<li>
<p>Xbox</p>
</li>
<li>
<p>Surface Hub</p>
</li>
<li>
<p>HoloLens</p>
</li>
</ul>
<p>برنامه‌های UWP در محیطی ایزوله (Sandbox) اجرا می‌شوند و معمولاً از طریق Windows Store منتشر می‌شوند.</p>
<p>UWP از نسخه‌ای از CLR/BCL دات‌نت کور 2.2 استفاده می‌کند،
و به‌احتمال زیاد این نسخه به‌روزرسانی نخواهد شد.
مایکروسافت به کاربران توصیه کرده به جای UWP از جایگزین مدرن آن، یعنی WinUI 3 استفاده کنند.</p>
<p>اما چون WinUI 3 فقط از برنامه‌های دسکتاپ ویندوز پشتیبانی می‌کند،
UWP هنوز برای هدف‌گذاری روی Xbox، Surface Hub و HoloLens کاربرد خاص خود را دارد.</p>
<p><strong>.NET Micro Framework</strong></p>
<p>.NET Micro Framework برای اجرای کد دات‌نت روی دستگاه‌های بسیار محدود از نظر منابع طراحی شده است،
مثلاً دستگاه‌هایی که کمتر از یک مگابایت حافظه دارند.</p>
<p><strong>اجرای کد مدیریت شده داخل SQL Server</strong></p>
<p>امکان اجرای کدهای مدیریت شده (#C) داخل SQL Server هم وجود دارد.
با استفاده از قابلیت SQL Server CLR integration، می‌توانید:</p>
<ul>
<li>
<p>توابع سفارشی</p>
</li>
<li>
<p>روال‌های ذخیره شده (Stored Procedures)</p>
</li>
<li>
<p>و عملگرهای جمعی (Aggregations)</p>
</li>
</ul>
<p>را با زبان #C بنویسید و سپس در کوئری‌های SQL خود فراخوانی کنید.</p>
<p>این ویژگی با .NET Framework و یک CLR ویژه که در محیطی ایزوله (Sandbox) اجرا می‌شود کار می‌کند،
تا از صحت و امنیت پردازش‌های SQL Server محافظت کند.</p>
<h2>تاریخچه‌ای کوتاه از سی‌شارپ</h2>
<p>در ادامه، ویژگی‌های جدید هر نسخه از زبان #C به ترتیب زمانی معکوس فهرست شده‌اند،
تا برای خوانندگانی که با نسخه‌های قدیمی‌تر زبان آشنا هستند، مفید باشد.</p>
<h2>ویژگی‌های جدید در #C 12</h2>
<p>نسخه‌ی ۱۲ زبان #C همراه با Visual Studio 2022 عرضه شده است و زمانی استفاده می‌شود که هدف برنامه،
نسخه‌ی .NET 8 باشد.</p>
<h2>عبارات مجموعه‌ای (Collection Expressions)</h2>
<p>قبلاً برای مقداردهی اولیه یک آرایه، مثلاً آرایه‌ای از حروف صدادار، از این شکل استفاده می‌کردید:</p>
<pre><code class="language-csharp">char[ ] vowels = {'a','e','i','o','u'};
</code></pre>
<p>اما حالا می‌توانید از براکت‌های مربعی (علامت []) به این صورت استفاده کنید:</p>
<pre><code class="language-csharp">char[ ] vowels = ['a','e','i','o','u'];
</code></pre>
<p><strong>مزایای عبارات مجموعه‌ای</strong></p>
<p>عبارات مجموعه‌ای دو مزیت بزرگ دارند:</p>
<ol>
<li>قابلیت استفاده در انواع دیگر مجموعه‌ها</li>
</ol>
<p>همین نگارش می‌تواند برای انواع مختلف مجموعه‌ها استفاده شود، مثل لیست‌ها، مجموعه‌ها (Set) و حتی نوع‌های پایین‌رده مثل Span:</p>
<pre><code class="language-csharp">List&lt;char&gt; list         = ['a','e','i','o','u'];
HashSet&lt;char&gt; set       = ['a','e','i','o','u'];
ReadOnlySpan&lt;char&gt; span = ['a','e','i','o','u'];
</code></pre>
<ol start="2">
<li>هدف‌مند بودن نوع (Target-typed)</li>
</ol>
<p>یعنی کامپایلر می‌تواند نوع مجموعه را در بسیاری از موقعیت‌ها حدس بزند، و شما نیازی به نوشتن نوع ندارید، مثل وقتی که آرایه را به عنوان آرگومان به یک متد می‌دهید:</p>
<pre><code class="language-csharp">Foo(['a','e','i','o','u']);

void Foo(char[] letters) { ... }
</code></pre>
<p>برای جزئیات بیشتر، می‌توانید به بخش «Collection Initializers and Collection Expressions» در صفحه ۲۰۵ مراجعه کنید.</p>
<h2>سازنده‌های اولیه در کلاس‌ها و استراکچرها  Primary constructors in classes and structs</h2>
<p>(Primary Constructors in Classes and Structs)</p>
<p>از نسخه #C 12 به بعد، می‌تونید لیست پارامترهای سازنده رو مستقیم بعد از تعریف کلاس یا استراکچر بنویسید.
برای مثال:</p>
<pre><code class="language-csharp">class Person (string firstName, string lastName)
{
    public void Print() =&gt; Console.WriteLine(firstName + &quot; &quot; + lastName);
}
</code></pre>
<p>در اینجا، کامپایلر به‌طور خودکار یک سازنده اولیه (Primary Constructor) برای کلاس Person می‌سازه.
بنابراین می‌تونید مثل زیر ازش استفاده کنید:</p>
<pre><code class="language-csharp">Person p = new Person(&quot;Alice&quot;, &quot;Jones&quot;);
p.Print();    // خروجی: Alice Jones
</code></pre>
<p><strong>تفاوت با Recordها</strong></p>
<p>این قابلیت از #C 9 برای record‌ها وجود داشت،
اما در recordها، کامپایلر به‌صورت پیش‌فرض برای هر پارامتر یک property عمومی فقط‌خواندنی (init-only) هم می‌سازه.</p>
<p>اما در کلاس‌ها و استراکچرها این اتفاق نمی‌افته.
اگر بخواهید پارامترهای سازنده اولیه را به صورت Property در اختیار داشته باشید، باید خودتان به‌طور صریح آن‌ها را تعریف کنید:</p>
<pre><code class="language-csharp">class Person (string firstName, string lastName)
{
    public string FirstName { get; set; } = firstName;
    public string LastName { get; set; } = lastName;
}
</code></pre>
<p>✅ سازنده‌های اولیه برای سناریوهای ساده، بسیار مفید و تمیز هستند.
جزئیات بیشتر درباره تفاوت‌ها و محدودیت‌های آن‌ها در بخش
“Primary Constructors (C# 12)” در صفحه ۱۱۹ ارائه شده است.</p>
<h2>پارامتر پیش‌فرض در لامبداها Default lambda parameters</h2>
<p>در #C، مثل همیشه می‌تونید برای پارامترهای یک متد مقدار پیش‌فرض تعیین کنید:</p>
<pre><code class="language-csharp">void Print(string message = &quot;&quot;) =&gt; Console.WriteLine(message);
</code></pre>
<p>حالا در نسخه #C 12، همین امکان برای لامبداها (Lambda Expressions) هم فراهم شده:</p>
<pre><code class="language-csharp">var print = (string message = &quot;&quot;) =&gt; Console.WriteLine(message);

print(&quot;Hello&quot;);  // خروجی: Hello  
print();         // خروجی: (هیچ‌چیز)
</code></pre>
<p>✅ این قابلیت خصوصاً در کتابخانه‌هایی مثل ASP.NET Minimal API بسیار مفید است،
چون اجازه می‌دهد تابع‌ها انعطاف‌پذیرتر باشند و پارامترهای اختیاری داشته باشند.</p>
<h2>تعریف نام مستعار (Alias) برای هر نوع</h2>
<p>قبلاً در #C فقط می‌تونستید با استفاده از دستور using برای نوع‌های ساده یا جنریک نام مستعار تعریف کنید.
برای مثال:</p>
<pre><code class="language-csharp">using ListOfInt = System.Collections.Generic.List&lt;int&gt;;
var list = new ListOfInt();
</code></pre>
<p>ولی حالا در #C 12، می‌تونید برای انواع دیگری مثل آرایه‌ها و Tupleها هم alias تعریف کنید:</p>
<pre><code class="language-csharp">using NumberList = double[];
using Point = (int X, int Y);

NumberList numbers = { 2.5, 3.5 };
Point p = (3, 4);
</code></pre>
<p>✅ این باعث می‌شه کد خواناتر و قابل نگهداری‌تر بشه — مخصوصاً وقتی از نوع‌های پیچیده به دفعات استفاده می‌کنید.</p>
<h2>سایر ویژگی‌های جدید</h2>
<p>سی‌شارپ ۱۲ همچنین از ویژگی جدیدی به نام آرایه‌های درون‌خطی (Inline Arrays) پشتیبانی می‌کند.
این ویژگی از طریق اتریبیوت:</p>
<pre><code class="language-csharp">[System.Runtime.CompilerServices.InlineArray]
</code></pre>
<p>قابل استفاده است.</p>
<p>🔹 با استفاده از آن می‌توانید درون یک struct، آرایه‌هایی با اندازه ثابت بسازید — بدون اینکه نیاز به قرار دادن کد در بلاک unsafe داشته باشید.
🔹 این قابلیت بیشتر برای استفاده در APIهای سطح پایین و داخلیِ runtime طراحی شده است.</p>
<h2>ویژگی‌های جدید در C# 11</h2>
<p>(What’s New in C# 11)</p>
<h1>C 11 همراه با Visual Studio 2022 منتشر شد،</h1>
<p>و زمانی به‌صورت پیش‌فرض استفاده می‌شود که هدف پروژه، .NET 7 باشد.</p>
<p><strong>رشته‌های خام (Raw String Literals)</strong></p>
<p>در C# 11، اگر یک رشته را با سه علامت نقل قول یا بیشتر (مثل &quot;&quot;&quot;) بنویسید،
به آن رشته خام (Raw String Literal) گفته می‌شود.</p>
<p>✅ این نوع رشته می‌تواند هر کاراکتری را شامل شود — بدون اینکه نیاز به Escape کردن یا تکرار نقل قول‌ها داشته باشید.</p>
<p>برای مثال، تعریف یک رشته خام برای نمایش XML:</p>
<pre><code class="language-csharp">string raw = &quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;;
</code></pre>
<p>🟢 رشته‌های خام می‌توانند چندخطی باشند، و حتی می‌توانند از درج مقادیر (String Interpolation) با پیشوند $ پشتیبانی کنند:</p>
<pre><code class="language-csharp">string multiLineRaw = $&quot;&quot;&quot;
  Line 1
  Line 2
  The date and time is {DateTime.Now}
&quot;&quot;&quot;;
</code></pre>
<p><strong>درج آکولاد داخل رشته‌های خام</strong></p>
<p>اگر بخواهید آکولاد {} واقعی را داخل رشته نگه دارید، می‌توانید با استفاده از دو $ یا بیشتر در ابتدای رشته،
الگوی درج مقادیر را تغییر دهید (تا به جای {} از { {} } یا { { {} } } استفاده شود):</p>
<pre><code class="language-csharp">Console.WriteLine($$&quot;&quot;&quot;{ &quot;TimeStamp&quot;: &quot;&quot; }&quot;&quot;&quot;);
</code></pre>
<p>// خروجی: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }
📘 برای توضیح کامل‌تر این ویژگی، به بخش‌های:</p>
<ul>
<li>
<p>«رشته‌های خام (Raw String Literals)» در صفحه ۵۹</p>
</li>
<li>
<p>«درج مقادیر در رشته‌ها (String Interpolation)» در صفحه ۶۰
مراجعه کنید.</p>
</li>
</ul>
<h3>رشته‌های UTF-8</h3>
<p>(UTF-8 Strings)</p>
<p>از نسخه #C 11، می‌توانید رشته‌هایی را با پسوند u8 تعریف کنید،
که به‌جای اینکه به‌صورت پیش‌فرض در قالب UTF-16 باشند، به‌صورت UTF-8 کدگذاری می‌شوند.</p>
<p>🔹 این ویژگی برای سناریوهای پیشرفته طراحی شده،
مثلاً وقتی می‌خواهید متن JSON را با عملکرد بالا و مصرف کم حافظه پردازش کنید.</p>
<p>مثال:</p>
<pre><code class="language-csharp">ReadOnlySpan&lt;byte&gt; utf8 = &quot;ab→cd&quot;u8;  // → سه بایت مصرف می‌کند
Console.WriteLine(utf8.Length);      // خروجی: 7
</code></pre>
<p>نوع این مقدار، ReadOnlySpan<byte> است (توضیح آن در فصل ۲۳ آمده).
برای تبدیل آن به آرایه بایت می‌توانید از ToArray() استفاده کنید.</p>
<h3>الگوهای لیستی (List Patterns)</h3>
<p>الگوهای لیستی اجازه می‌دهند که ساختار و محتوای یک مجموعه را بررسی (Pattern Match) کنید.
این الگوها با براکت‌های مربعی [] تعریف می‌شن و روی هر مجموعه‌ای قابل استفاده‌اند که:</p>
<ul>
<li>
<p>دارای تعداد عناصر (Count یا Length) باشد</p>
</li>
<li>
<p>و از طریق ایندکس (Indexer) قابل دسترسی باشد (مثل آرایه‌ها یا لیست‌ها)</p>
</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">int[] numbers = { 0, 1, 2, 3, 4 };
Console.WriteLine(numbers is [0, 1, 2, 3, 4]);  // خروجی: True
</code></pre>
<p>🔸 علامت _ با هر مقدار دلخواه در یک موقعیت مطابقت دارد:</p>
<pre><code class="language-csharp">Console.WriteLine(numbers is [_, 1, .., 4]);    // خروجی: True
</code></pre>
<p>🔸 دو نقطه .. نشان‌دهنده‌ی یک بُرش (Slice) است — یعنی صفر یا چند عنصر در وسط.</p>
<p>📘 همچنین می‌توانید از var بعد از slice برای گرفتن بخش میانی استفاده کنید.
توضیحات کامل در بخش «List Patterns» در صفحه ۲۴۳ ارائه شده است.</p>
<h3>اعضای اجباری (Required Members)</h3>
<p>با استفاده از کلیدواژه‌ی required در تعریف یک فیلد یا Property،
کامپایلر مجبور می‌کنه که هر کسی این کلاس یا struct رو می‌سازه،
حتماً آن عضو را مقداردهی کند — مثلاً از طریق Object Initializer.</p>
<p>مثال:</p>
<pre><code class="language-csharp">class Asset { public required string Name; }

Asset a1 = new Asset { Name = &quot;House&quot; };  // ✅ مجاز  
Asset a2 = new Asset();                   // ❌ خطا — مقداردهی نشده!
</code></pre>
<p>✅ این ویژگی کمک می‌کنه نیازی به نوشتن سازنده‌هایی با پارامترهای زیاد نداشته باشید،
که این موضوع در کلاس‌های فرزند (Subclasses) ساده‌سازی بزرگی به‌حساب می‌آد.</p>
<p>🔸 اگه خواستید هم سازنده (Constructor) بنویسید و هم از required استفاده کنید،
می‌تونید از اتریبیوت [SetsRequiredMembers] روی سازنده استفاده کنید تا از محدودیت عبور کنید.</p>
<p>📘 توضیحات بیشتر در بخش «Required members (C# 11)» در صفحه ۱۳۶ موجوده.</p>
<h3>اعضای استاتیک مجازی/انتزاعی در اینترفیس‌ها Static virtual/abstract interface members</h3>
<p>از نسخه C# 11، امکان جدیدی اضافه شده که به شما اجازه می‌دهد درون یک Interface، متدهای استاتیک با نوع virtual یا abstract تعریف کنید.</p>
<p>مثال:</p>
<pre><code class="language-csharp">public interface IParsable&lt;TSelf&gt;
{
    static abstract TSelf Parse(string s);
}
</code></pre>
<p>🔹 این یعنی کلاس یا structی که این اینترفیس را پیاده‌سازی می‌کند، باید یک تابع استاتیک با همین امضا ارائه دهد.</p>
<p>📌 مزیت اصلی:
می‌توان این توابع را به‌صورت پلی‌مورفیک (چندریخت) فراخوانی کرد، با استفاده از یک پارامتر generic که محدود به آن Interface شده:</p>
<pre><code class="language-csharp">T ParseAny&lt;T&gt;(string s) where T : IParsable&lt;T&gt; =&gt; T.Parse(s);
</code></pre>
<p>✅ حتی می‌توانید توابع عملگر (Operators) مثل +, -, *, / را هم به صورت static virtual یا static abstract در اینترفیس‌ها تعریف کنید.</p>
<p>📘 برای اطلاعات بیشتر:</p>
<ul>
<li>
<p>«Static virtual/abstract interface members» در صفحه ۱۵۳</p>
</li>
<li>
<p>«Static Polymorphism» در صفحه ۲۶۰</p>
</li>
<li>
<p>و همچنین نحوه‌ی فراخوانی این متدهای استاتیک از طریق Reflection در صفحه ۸۲۶</p>
</li>
</ul>
<h3>ریاضی عمومی (Generic Math)</h3>
<p>از نسخه .NET 7، اینترفیس جدیدی به نام:</p>
<pre><code class="language-csharp">System.Numerics.INumber&lt;TSelf&gt;
</code></pre>
<p>معرفی شده که امکان انجام عملیات ریاضی روی نوع‌های عددی به‌صورت Generic را فراهم می‌کند.</p>
<p>مثلاً می‌توان یک متد جمع‌زن (Sum) نوشت که برای هر نوع عددی کار کند:</p>
<pre><code class="language-csharp">T Sum&lt;T&gt;(T[] numbers) where T : INumber&lt;T&gt;
{
    T total = T.Zero;
    foreach (T n in numbers)
        total += n;  // عملگر + برای هر نوع عددی فراخوانی می‌شود
    return total;
}
</code></pre>
<p>و حالا می‌توانید این تابع را روی انواع مختلفی صدا بزنید:</p>
<pre><code class="language-csharp">int intSum = Sum(new[] { 3, 5, 7 });
double doubleSum = Sum(new[] { 3.2, 5.3, 7.1 });
decimal decimalSum = Sum(new[] { 3.2m, 5.3m, 7.1m });
</code></pre>
<p>✅ رابط INumber<TSelf> توسط تمام انواع عددی حقیقی و صحیح در دات‌نت (و حتی char) پیاده‌سازی شده است.</p>
<p>این رابط شامل تعاریف عملگرها به‌صورت static abstract هم هست، مثل:</p>
<pre><code class="language-csharp">static abstract TResult operator + (TSelf left, TOther right);
</code></pre>
<p>📘 این موضوعات در بخش‌های:</p>
<ul>
<li>
<p>«Polymorphic Operators» در صفحه ۲۶۱</p>
</li>
<li>
<p>و «Generic Math» در صفحه ۲۶۲
به‌طور کامل توضیح داده شده‌اند.</p>
</li>
</ul>
<h3>سایر ویژگی‌های جدید در C# 11</h3>
<p>(Other New Features in C# 11)</p>
<p>🔸 دسترسی فایل (File Accessibility Modifier)</p>
<p>از نسخه #C 11 می‌توانید با استفاده از کلمه کلیدی file، یک کلاس یا نوع را فقط در همان فایل منبع قابل دسترس کنید:</p>
<pre><code class="language-csharp">file class Foo { ... }
</code></pre>
<p>✅ این ویژگی مخصوصاً برای source generator‌ها طراحی شده،
جایی که نیاز دارید نوع‌هایی بسازید که فقط در محدوده همان فایل قابل استفاده باشند و به بیرون درز نکنند.</p>
<p><strong>🔸 عملگرهای بررسی‌شده (Checked Operators)</strong></p>
<p>در C# 11 امکان تعریف عملگرهایی که داخل بلاک‌های checked فراخوانی می‌شوند فراهم شده است.
این قابلیت برای پیاده‌سازی کامل ریاضی generic ضروری بود.</p>
<p>📘 برای اطلاعات بیشتر، به بخش &quot;Checked operators&quot; در صفحه ۲۵۸ مراجعه کنید.</p>
<p><strong>🔸 تسهیل مقداردهی اولیه در سازنده Structها</strong></p>
<p>در نسخه‌های قبلی، سازنده‌های Struct باید تمام فیلدها را مقداردهی می‌کردند.
در C# 11 این محدودیت سبک‌تر شده و اجباری نیست که همه فیلدها درون سازنده مقداردهی شوند.</p>
<p>📘 توضیح کامل در &quot;Struct Construction Semantics&quot; در صفحه ۱۴۲ آمده است.</p>
<p><strong>🔸 بهبود در نوع‌های عددی هم‌اندازه با معماری سیستم (nint و nuint)</strong></p>
<p>در نسخه C# 9، دو نوع جدید معرفی شده بود:</p>
<ul>
<li>
<p>nint (عدد صحیح native-size)</p>
</li>
<li>
<p>nuint (عدد صحیح بدون علامت native-size)</p>
</li>
</ul>
<p>این نوع‌ها بسته به سیستم عامل، به‌اندازه‌ی فضای آدرس‌دهی اجرا در زمان اجرا هستند:
مثلاً در سیستم‌های ۶۴ بیتی، این عددها ۶۴ بیتی‌اند و در سیستم‌های ۳۲ بیتی، ۳۲ بیتی.</p>
<p>در C# 11 (در صورتی که هدف پروژه .NET 7 یا بالاتر باشد)، تفاوت در زمان کامپایل بین این نوع‌ها و نوع‌های پایه‌شان:</p>
<ul>
<li>
<p>IntPtr</p>
</li>
<li>
<p>UIntPtr</p>
</li>
</ul>
<p>عملاً از بین رفته است، و رفتارشان یکپارچه‌تر شده.</p>
<p>📘 برای توضیح کامل به بخش &quot;Native-Sized Integers&quot; در صفحه ۲۶۶ مراجعه کنید.</p>
<h2>✨ چه چیزهایی در C# 10 جدید هستند؟</h2>
<p>(What’s New in C# 10)</p>
<h3>📁 فضای نام در سطح فایل (File-Scoped Namespaces)</h3>
<p>در شرایطی که تمام کلاس‌ها یا نوع‌ها در یک فایل، داخل یک فضای نام (namespace) قرار دارند، C# 10 به شما اجازه می‌ده با یک اعلان کوتاه‌تر و ساده‌تر، از تورفتگی‌های اضافی جلوگیری کنید:</p>
<pre><code class="language-csharp">namespace MyNamespace;  // این فضای نام برای کل فایل اعمال می‌شود

class Class1 {}         // درون MyNamespace
class Class2 {}         // درون MyNamespace
</code></pre>
<p>✅ این کار، کد شما رو مرتب‌تر، کوتاه‌تر و خواناتر می‌کنه.</p>
<h3>🌍 دستور global using</h3>
<p>با اضافه کردن کلیدواژه‌ی global قبل از دستور using،
می‌تونید اون namespace رو به تمام فایل‌های پروژه اعمال کنید:</p>
<pre><code class="language-csharp">global using System;
global using System.Collections.Generic;
</code></pre>
<p>✅ به این ترتیب، دیگه نیازی نیست توی هر فایل دوباره using بنویسید.</p>
<p>🔹 حتی می‌تونید از global using static هم استفاده کنید.</p>
<p>🛠 علاوه بر این، در پروژه‌های .NET 6، یک ویژگی جدید به نام Implicit Global Usings اضافه شده.
اگه در فایل پروژه (csproj) بنویسید:</p>
<pre><code class="language-xml">&lt;ImplicitUsings&gt;true&lt;/ImplicitUsings&gt;
</code></pre>
<p>تعدادی از namespaceهای پرکاربرد، به‌صورت خودکار وارد پروژه می‌شن (بسته به نوع پروژه‌تون).
📘 جزئیات بیشتر در صفحه ۹۶: «The global using Directive»</p>
<h3>✍️ تغییر بدون تخریب روی نوع‌های ناشناس</h3>
<p>(Nondestructive Mutation for Anonymous Types)</p>
<p>در C# 9، با کلیدواژه‌ی with می‌تونستید مقادیر جدیدی به recordها بدید بدون اینکه شیء اصلی تغییر کنه.</p>
<p>در C# 10، این قابلیت برای نوع‌های ناشناس (anonymous types) هم اضافه شده:</p>
<pre><code class="language-csharp">var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 };

Console.WriteLine(a2);  // خروجی: { A = 1, B = 2, C = 3, D = 4, E = 10 }
</code></pre>
<p>✅ شیء a1 بدون تغییر باقی می‌مونه، و a2 نسخه‌ی جدیدی از همون با مقدار E = 10 هست.</p>
<h3>🧮 سینتکس جدید برای Deconstruction</h3>
<p>در C# 7، امکان بازکردن مقدارهای Tuple یا Struct به متغیرها (Deconstruct) اضافه شد.</p>
<p>در C# 10، می‌تونید اعلان و مقداردهی را ترکیب کنید، یعنی همزمان یک متغیر جدید تعریف کنید و به یک متغیر قدیمی مقدار بدهید:</p>
<pre><code class="language-csharp">var point = (3, 4);
double x = 0;

(x, double y) = point;
</code></pre>
<p>در این مثال:</p>
<ul>
<li>
<p>متغیر x از قبل وجود داشته و مقدار جدیدی می‌گیره.</p>
</li>
<li>
<p>متغیر y همون‌جا تعریف و مقداردهی می‌شه.</p>
</li>
<li></li>
</ul>
<h3>🧱 مقداردهی اولیه فیلدها و سازنده‌ی بدون پارامتر در Structها</h3>
<p>(Field Initializers and Parameterless Constructors in Structs)</p>
<p>از نسخه‌ی #C 10 به بعد، Structها هم می‌تونن:</p>
<ul>
<li>
<p>فیلدهاشون رو همون موقع تعریف، مقداردهی اولیه کنن</p>
</li>
<li>
<p>سازنده بدون پارامتر (parameterless constructor) داشته باشن</p>
</li>
</ul>
<p>🟡 توجه: این سازنده فقط وقتی اجرا می‌شه که به‌صورت صریح فراخوانی بشه
(مثلاً با new MyStruct())، و نه وقتی از default استفاده می‌کنید.</p>
<p>🎯 این قابلیت بیشتر برای پشتیبانی از record struct‌ها طراحی شده.</p>
<p>📘 جزئیات بیشتر: «Structs» در صفحه ۱۴۲</p>
<p><strong>🧾 Struct به عنوان Record</strong>
(Record Structs)</p>
<p>در نسخه C# 9، نوع جدیدی به نام record معرفی شد که نسخه‌ای ساده‌شده و بهینه‌شده از کلاس‌ها بود.</p>
<p>در C# 10، حالا می‌تونید همون قابلیت رو برای structها هم داشته باشید:</p>
<pre><code class="language-csharp">record struct Point(int X, int Y);
</code></pre>
<p>📌 شباهت‌ها و تفاوت‌ها:</p>
<ul>
<li>
<p>تقریباً همه ویژگی‌های record برای record struct هم وجود دارن</p>
</li>
<li>
<p>تنها تفاوت اصلی:
در record structها، ویژگی‌های (property) ساخته‌شده توسط کامپایلر به صورت قابل‌تغییر (writable) هستن
مگر اینکه قبل از record از کلمه‌ی readonly استفاده کنید.</p>
</li>
</ul>
<h3>🔁 بهبودهای مربوط به عبارت‌های Lambda</h3>
<p>(Lambda Expression Enhancements)</p>
<p>عبارت‌های lambda در C# 10 چند قابلیت جدید و کاربردی دریافت کردن:</p>
<p>✅ ۱. پشتیبانی از تایپ ضمنی (var)
حالا می‌تونید از var برای تعریف lambda استفاده کنید:</p>
<pre><code class="language-csharp">var greeter = () =&gt; &quot;Hello, world&quot;;  // نوع: Func&lt;string&gt;
</code></pre>
<p>در اینجا، greeter به‌طور خودکار به Func<string> تبدیل می‌شه.</p>
<p>🔸 اگر پارامتر داشته باشید، باید نوع اون رو صراحتاً مشخص کنید:</p>
<pre><code class="language-csharp">var square = (int x) =&gt; x * x;
</code></pre>
<p>📌 ۲. امکان تعیین نوع بازگشتی (explicit return type)
می‌تونید نوع بازگشتی یک lambda رو مشخص کنید:</p>
<pre><code class="language-csharp">var sqr = int (int x) =&gt; x;
</code></pre>
<p>✳️ این کار به ساده‌سازی فرآیند کامپایل در lambdaهای تو در تو کمک می‌کنه.</p>
<p>📥 ۳. پذیرش lambda در متدهایی با نوع پارامتر عمومی
حالا می‌تونید lambda رو به‌عنوان آرگومان به متدهایی بدید که نوع پارامترشون object یا Delegate یا Expression هست:</p>
<pre><code class="language-csharp">M1(() =&gt; &quot;test&quot;);   // تبدیل به Func&lt;string&gt;
M2(() =&gt; &quot;test&quot;);
M3(() =&gt; &quot;test&quot;);

void M1(object x) {}
void M2(Delegate x) {}
void M3(Expression x) {}
</code></pre>
<p>🏷 ۴. افزودن Attribute به lambda
حالا می‌تونید به خود lambda، به پارامترهاش یا حتی به مقدار بازگشتی اون، attribute اضافه کنید:</p>
<pre><code class="language-csharp">Action a = [Description(&quot;test&quot;)] () =&gt; { };
</code></pre>
<p>📘 جزئیات کامل در «Applying Attributes to Lambda Expressions» صفحه ۲۴۵</p>
<h3>🧩 سایر ویژگی‌های جدید در C# 10</h3>
<p>(Nested Property Patterns, Caller Argument Expressions, and More)</p>
<h3>🧬 الگوی تطبیق در ویژگی‌های تو در تو (Nested Property Patterns)</h3>
<p>در C# 10، برای بررسی ویژگی‌های تو در تو (nested properties) می‌تونید از سینتکس ساده‌تری استفاده کنید. مثلاً:</p>
<pre><code class="language-csharp">var obj = new Uri(&quot;https://www.linqpad.net&quot;);

if (obj is Uri { Scheme.Length: 5 })
  Console.WriteLine(&quot;طول Scheme برابر ۵ است&quot;);
</code></pre>
<p>⬅️ این معادل با کدی با ساختار پیچیده‌تر در نسخه‌های قبلی است:</p>
<pre><code class="language-csharp">if (obj is Uri { Scheme: { Length: 5 } })
</code></pre>
<p>🔹 این روش به نوشتن شرط‌ها با خوانایی بیشتر کمک می‌کنه.
📘 برای اطلاعات بیشتر: «Property Patterns» صفحه ۲۴۱</p>
<h3>🧾 ویژگی CallerArgumentExpression</h3>
<p>اگه بخواید عبارت اصلی‌ای که برای یک پارامتر متد استفاده شده رو بگیرید، می‌تونید از CallerArgumentExpression استفاده کنید:</p>
<pre><code class="language-csharp">Print(Math.PI * 2);

void Print(
    double number,
    [CallerArgumentExpression(&quot;number&quot;)] string expr = null)
    =&gt; Console.WriteLine(expr);
</code></pre>
<p>🟢 خروجی:</p>
<pre><code class="language-javascript">Math.PI * 2
</code></pre>
<p>✅ این قابلیت بیشتر برای کتابخانه‌های اعتبارسنجی (validation) و assertion کاربرد داره.
📘 جزئیات: صفحه ۲۴۷، بخش «CallerArgumentExpression»</p>
<h3>📌 سایر ویژگی‌های جدید</h3>
<p>🧵 رشته‌های درون‌تابی (Interpolated Strings) می‌تونن ثابت (const) باشن
به شرطی که مقادیری که درون‌شون استفاده شده هم const باشه:</p>
<pre><code class="language-csharp">const string name = &quot;Ali&quot;;
const string message = $&quot;Hello, {name}!&quot;;
</code></pre>
<p><strong>📏 دستور #line پیشرفته‌تر شده</strong></p>
<p>حالا می‌تونید شماره ستون و بازه (range) هم تعیین کنید — مخصوصاً برای ابزارهای آنالیز کد مفیده.</p>
<p>📛 در Recordها می‌تونید متد ToString() رو ببندید (seal کنید)
یعنی نذارید کلاس‌های مشتق‌شده بتونن اون رو override کنن:</p>
<pre><code class="language-csharp">public record Person
{
    public sealed override string ToString() =&gt; &quot;Hidden&quot;;
}
</code></pre>
<p><strong>🧠 تجزیه و تحلیل انتساب قطعی (Definite Assignment) بهبود پیدا کرده</strong></p>
<p>در نسخه‌های قبلی C#، این کد باعث خطا می‌شد چون کامپایلر فکر می‌کرد متغیر number ممکنه مقدار نگرفته باشه:</p>
<pre><code class="language-csharp">if (foo?.TryParse(&quot;123&quot;, out var number) ?? false)
    Console.WriteLine(number);
</code></pre>
<p>اما از C# 10 به بعد، این کد کاملاً مجازه و کامپایل می‌شه.</p>
<h2>🚀 چه چیزهایی در C# 9.0 جدید است؟</h2>
<p>🔸 C# 9.0 همراه با Visual Studio 2019 عرضه شد و زمانی استفاده می‌شود که پروژه‌ی شما برای .NET 5 هدف‌گذاری شده باشد.</p>
<p><strong>🧾 دستورات سطح بالا (Top-Level Statements)</strong></p>
<p>با استفاده از Top-Level Statements، می‌تونی برنامه‌ای بنویسی بدون اینکه مجبور باشی کلاس Program و متد Main رو تعریف کنی:</p>
<pre><code class="language-csharp">using System;
Console.WriteLine(&quot;Hello, world&quot;);
</code></pre>
<p>✅ این ویژگی باعث می‌شه کدهای نمونه و آموزشی خیلی ساده‌تر و مختصرتر نوشته بشن.</p>
<p>🔍 نکات تکمیلی:</p>
<ul>
<li>
<p>می‌تونی در این بخش، متد هم تعریف کنی (مثل متد محلی یا local method).</p>
</li>
<li>
<p>به متغیر جادویی args برای گرفتن آرگومان‌های خط فرمان دسترسی داری.</p>
</li>
<li>
<p>می‌تونی مقداری رو به فراخوان (caller) برگردونی.</p>
</li>
<li>
<p>بعد از دستورات سطح بالا، همچنان می‌تونی کلاس‌ها و فضای نام (namespace) تعریف کنی.</p>
</li>
</ul>
<p>📘 جزئیات بیشتر در صفحه ۴۱: «Top-Level Statements»</p>
<p><strong>🧷 ست‌کننده فقط-در-ابتدا (Init-Only Setters)</strong></p>
<p>در C# 9.0، می‌تونی در تعریف ویژگی (property)، به جای set از init استفاده کنی:</p>
<pre><code class="language-csharp">class Foo
{
    public int ID { get; init; }
}
</code></pre>
<p>این یعنی ویژگی فقط در زمان مقداردهی اولیه قابل تنظیم هست، و بعد از اون فقط خواندنیه.</p>
<p>👨‍💻 استفاده از init بهت این امکان رو می‌ده که نوع‌هایی تغییرناپذیر (immutable) بسازی و با استفاده از initializer اون‌ها رو مقداردهی کنی، بدون نیاز به تعریف چندین سازنده (constructor):</p>
<pre><code class="language-csharp">var foo = new Foo { ID = 123 };
</code></pre>
<p>🔄 در کنار رکوردها (records)، این قابلیت باعث می‌شه بتونی تغییرات غیرویرانگر (non-destructive mutation) انجام بدی — یعنی به جای تغییر شیء فعلی، یه نمونه‌ی جدید بسازی با مقادیر تغییر یافته.</p>
<p>📘 جزئیات بیشتر در صفحه ۱۱۶: «Init-only Setters»</p>
<h3>🧾 رکوردها (Records)</h3>
<p>🔹 یک record (بخش کامل در صفحه ۲۲۷: «Records») نوع خاصی از کلاس است که برای داده‌های تغییرناپذیر (immutable) طراحی شده است.</p>
<p>✨ مهم‌ترین ویژگی آن، پشتیبانی از تغییر غیرویرانگر (nondestructive mutation) از طریق کلمه‌ی کلیدی جدید with است:</p>
<pre><code class="language-csharp">Point p1 = new Point(2, 3);
Point p2 = p1 with { Y = 4 };   // p2 کپی‌ای از p1 است با مقدار جدید Y
Console.WriteLine(p2);         // خروجی: Point { X = 2, Y = 4 }
</code></pre>
<p>🔸 تعریف کلاس رکورد ما می‌تونه به این شکل باشه:</p>
<pre><code class="language-csharp">record Point
{
    public Point(double x, double y) =&gt; (X, Y) = (x, y);
    public double X { get; init; }
    public double Y { get; init; }
}
</code></pre>
<p>🔹 در موارد ساده، رکوردها می‌تونن ما رو از نوشتن کدهای تکراری (مثل تعریف ویژگی‌ها، سازنده و deconstructor) بی‌نیاز کنن. برای مثال، تعریف بالا رو می‌تونیم این‌طور خلاصه کنیم بدون از دست دادن قابلیت‌ها:</p>
<pre><code class="language-csharp">record Point(double X, double Y);
</code></pre>
<p>📌 رکوردها مشابه تاپل‌ها (tuples)، به طور پیش‌فرض از برابری ساختاری (structural equality) استفاده می‌کنن، نه فقط مرجع (reference equality).</p>
<ul>
<li>
<p>رکوردها می‌تونن از رکوردهای دیگه ارث‌بری کنن.</p>
</li>
<li>
<p>می‌تونن شامل همه‌ی اجزایی باشن که کلاس‌ها می‌تونن داشته باشن.</p>
</li>
<li>
<p>در زمان اجرا، توسط کامپایلر به کلاس تبدیل می‌شن.</p>
</li>
</ul>
<p><strong>🧩 بهبودهای تطبیق الگو (Pattern Matching)</strong></p>
<p><strong>🔸 الگوهای رابطه‌ای (Relational Patterns)</strong>
از نسخه 9.0، می‌تونی عملگرهای &lt;، &gt;، &lt;= و &gt;= رو داخل الگوها استفاده کنی:</p>
<pre><code class="language-csharp">string GetWeightCategory(decimal bmi) =&gt; bmi switch
{
    &lt; 18.5m =&gt; &quot;underweight&quot;,
    &lt; 25m   =&gt; &quot;normal&quot;,
    &lt; 30m   =&gt; &quot;overweight&quot;,
    _       =&gt; &quot;obese&quot;
};
</code></pre>
<p><strong>🔸 ترکیب‌گرهای الگو (Pattern Combinators)</strong>
حالا می‌تونی الگوها رو با استفاده از کلمات کلیدی and، or و not ترکیب کنی:</p>
<pre><code class="language-csharp">bool IsVowel(char c) =&gt; c is 'a' or 'e' or 'i' or 'o' or 'u';

bool IsLetter(char c) =&gt;
    c is &gt;= 'a' and &lt;= 'z'
    or &gt;= 'A' and &lt;= 'Z';
</code></pre>
<p>📌 درست مثل عملگرهای &amp;&amp; و ||:</p>
<ul>
<li>
<p>and اولویت بالاتری از or دارد.</p>
</li>
<li>
<p>می‌تونی با استفاده از پرانتزها اولویت رو تغییر بدی.</p>
</li>
</ul>
<p>🔍 از not هم می‌تونی با الگوی نوع (type pattern) استفاده کنی، برای مثال بررسی اینکه یک شیء از نوع خاصی نیست:</p>
<pre><code class="language-csharp">if (obj is not string) ...
</code></pre>
<p>📘 برای جزئیات بیشتر، به صفحه ۲۳۸: «Patterns» مراجعه کن.</p>
<p><strong>🆕 عبارات new با نوع هدف (Target-Typed new Expressions)</strong>
در C# 9.0 می‌تونی در جایی که کامپایلر می‌تونه نوع رو حدس بزنه، اسم نوع رو در new حذف کنی:</p>
<pre><code class="language-csharp">System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new(&quot;Test&quot;);
</code></pre>
<p>📌 این ویژگی وقتی خیلی مفیده که تعریف متغیر و مقداردهی اولیه در دو بخش متفاوت از کدت باشه:</p>
<pre><code class="language-csharp">class Foo
{
    System.Text.StringBuilder sb;

    public Foo(string initialValue) =&gt; sb = new(initialValue);
}
</code></pre>
<p>یا مثلاً وقتی می‌خوای مستقیماً به متد آرگومان بدی:</p>
<pre><code class="language-csharp">MyMethod(new(&quot;test&quot;));

void MyMethod(System.Text.StringBuilder sb) { ... }
</code></pre>
<p>📘 جزئیات بیشتر در صفحه ۷۷: «Target-Typed new Expressions»</p>
<h3>بهبودهای بین‌زبانی (Interop)</h3>
<p>C# 9 قابلیت اشاره‌گرهای تابع (function pointers) را معرفی می‌کند (رجوع شود به صفحات 268 و 991، «اشاره‌گرهای تابع» و «Callbackها با استفاده از اشاره‌گرهای تابع»). هدف اصلی آن‌ها این است که کدهای غیرمدیریت‌شده (unmanaged) بتوانند متدهای ایستا (static) در C# را بدون سربار ناشی از نمونه‌ی delegate فراخوانی کنند، و در صورتی که نوع آرگومان‌ها و مقادیر بازگشتی به صورت blittable باشند (یعنی در هر دو سمت به‌طور یکسان نمایش داده شوند)، بتوانند لایه‌ی P/Invoke را دور بزنند.</p>
<p>C# 9 همچنین نوع‌های صحیح با اندازه‌ی بومی (nint و nuint) را معرفی می‌کند (رجوع شود به صفحه 266، «صحیح‌های بومی‌سایز»). این نوع‌ها در زمان اجرا به System.IntPtr و System.UIntPtr نگاشته می‌شوند. در زمان کامپایل، آن‌ها مانند نوع‌های عددی عمل می‌کنند و از عملیات‌های حسابی پشتیبانی می‌کنند.</p>
<p><strong>سایر ویژگی‌های جدید</strong></p>
<p>همچنین، C# 9 به شما اجازه می‌دهد:</p>
<ul>
<li>
<p>بازنویسی یک متد یا ویژگی فقط-خواندنی را طوری انجام دهید که مقدار بازگشتی آن نوعی مشتق‌شده‌تر باشد
(رجوع شود به صفحه 131، «نوع‌های هم‌ریخت بازگشتی» / Covariant Return Types).</p>
</li>
<li>
<p>اعمال ویژگی‌ها (attribute) را بر روی توابع محلی انجام دهید
(رجوع شود به صفحه 243، «Attributes»).</p>
</li>
<li>
<p>از کلمه‌ی کلیدی static برای عبارت‌های لامبدا یا توابع محلی استفاده کنید تا از گرفتن تصادفی متغیرهای محلی یا نمونه‌ای جلوگیری شود
(رجوع شود به صفحه 192، «لامبداهای ایستا» / Static Lambdas).</p>
</li>
<li>
<p>کاری کنید که هر نوعی با دستور foreach کار کند، با تعریف یک متد GetEnumerator به صورت extension method.</p>
</li>
<li>
<p>یک متد initialization ماژول تعریف کنید که تنها یک‌بار و در هنگام بارگذاری اسمبلی اجرا می‌شود، با اعمال ویژگی [ModuleInitializer] به یک متد ایستا، بدون پارامتر و void.</p>
</li>
<li>
<p>از نشانه‌ی دورریختنی (_) به عنوان آرگومان یک عبارت لامبدا استفاده کنید.</p>
</li>
<li>
<p>متدهای partial توسعه‌یافته (extended partial methods) بنویسید که اجباری برای پیاده‌سازی دارند — این امکان سناریوهایی مانند تولیدکننده‌های جدید کد سورس در Roslyn را فراهم می‌کند
(رجوع شود به صفحه 125، «متدهای partial توسعه‌یافته»).</p>
</li>
<li>
<p>یک attribute به متدها، نوع‌ها یا ماژول‌ها اعمال کنید تا از مقداردهی اولیه‌ی متغیرهای محلی توسط زمان اجرا جلوگیری شود
(رجوع شود به صفحه 269، ویژگی [SkipLocalsInit]).</p>
</li>
</ul>
<h2>چه چیزهایی در C# 8.0 جدید هستند</h2>
<p>C# 8.0 نخستین‌بار همراه با Visual Studio 2019 عرضه شد و هنوز هم در حال استفاده است، زمانی که شما هدف را بر روی .NET Core 3 یا .NET Standard 2.1 تنظیم می‌کنید.</p>
<p><strong>اندیس‌ها و بازه‌ها (Indices and Ranges)</strong></p>
<p>اندیس‌ها و بازه‌ها کار با عناصر یا بخش‌هایی از یک آرایه (یا نوع‌های سطح پایین‌تر مانند Span<T> و ReadOnlySpan<T>) را ساده می‌کنند.</p>
<p>اندیس‌ها به شما اجازه می‌دهند به عناصری نسبت به انتهای یک آرایه اشاره کنید، با استفاده از عملگر ^.
^1 به عنصر آخر اشاره می‌کند، ^2 به دومی از انتها، و به همین ترتیب:</p>
<pre><code class="language-csharp">char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [^1];   // 'u'
char secondToLast = vowels [^2];   // 'o'
</code></pre>
<p>بازه‌ها (ranges) به شما اجازه می‌دهند یک آرایه را با استفاده از عملگر .. «برش» دهید:</p>
<pre><code class="language-csharp">char[] firstTwo   = vowels [..2];     // 'a', 'e'
char[] lastThree  = vowels [2..];     // 'i', 'o', 'u'
char[] middleOne  = vowels [2..3];    // 'i'
char[] lastTwo    = vowels [^2..];    // 'o', 'u'
</code></pre>
<p>C# اندیس‌ها و بازه‌ها را با کمک نوع‌های Index و Range پیاده‌سازی می‌کند:</p>
<pre><code class="language-csharp">Index last = ^1;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'
</code></pre>
<p>شما می‌توانید پشتیبانی از اندیس‌ها و بازه‌ها را در کلاس‌های خودتان نیز فراهم کنید،
با تعریف یک ایندکسر (indexer) که نوع پارامتر آن Index یا Range باشد:</p>
<pre><code class="language-csharp">class Sentence
{
    string[] words = &quot;The quick brown fox&quot;.Split();
    public string   this[Index index] =&gt; words[index];
    public string[] this[Range range] =&gt; words[range];
}
</code></pre>
<p>برای اطلاعات بیشتر، رجوع کنید به صفحه 63، «Indices and Ranges».</p>
<h3>✅ عملگر نسبت‌دهی در صورت تهی بودن (Null-coalescing assignment)</h3>
<p>عملگر ??= تنها زمانی به یک متغیر مقدار می‌دهد که مقدار فعلی آن null باشد. به‌جای نوشتن کد زیر:</p>
<pre><code class="language-csharp">if (s == null) s = &quot;Hello, world&quot;;
</code></pre>
<p>اکنون می‌توان ساده‌تر نوشت:</p>
<pre><code class="language-csharp">s ??= &quot;Hello, world&quot;;
</code></pre>
<p>این نوشتار کد را کوتاه‌تر و خواناتر می‌کند. 📏🧹</p>
<h4>🧹 اعلان‌های using (Using declarations)</h4>
<p>اگر پس از یک دستور using، از آکولاد و بلوک کدی استفاده نکنید، آن‌وقت به آن اعلان using گفته می‌شود. منبع (resource) مربوطه در این حالت، زمانی آزاد (dispose) می‌شود که اجرای برنامه از بلوک محاط‌کننده خارج شود:</p>
<pre><code class="language-csharp">if (File.Exists(&quot;file.txt&quot;))
{
    using var reader = File.OpenText(&quot;file.txt&quot;);
    Console.WriteLine(reader.ReadLine());
}
</code></pre>
<p>در این مثال، شیء reader هنگام خروج از بلوک if به‌طور خودکار از بین می‌رود. ♻️📄</p>
<h4>🛡️ اعضای فقط‌خواندنی (Read-only members)</h4>
<p>در C# 8 می‌توانید به توابع موجود در یک struct، ویژگی readonly بدهید. این کار تضمین می‌کند که تابع مذکور نتواند هیچ یک از فیلدها را تغییر دهد، وگرنه خطای زمان کامپایل رخ خواهد داد:</p>
<pre><code class="language-csharp">struct Point
{
    public int X, Y;
    public readonly void ResetX() =&gt; X = 0;  // Error!
}
</code></pre>
<p>اگر یک تابع readonly، تابعی غیرـ‌readonly را فراخوانی کند، کامپایلر یک هشدار می‌دهد و برای جلوگیری از تغییر احتمالی، ساختار را کپی می‌کند. 🚫✍️</p>
<h4>🧩 توابع محلی ایستا (Static local methods)</h4>
<p>اضافه کردن کلیدواژه static به یک تابع محلی، باعث می‌شود که این تابع نتواند به متغیرها و پارامترهای محلی تابع بالادست دسترسی داشته باشد. این ویژگی باعث کاهش وابستگی شده و به تابع اجازه می‌دهد متغیرهای خودش را بدون تداخل با سایر بخش‌ها تعریف کند. ⚙️📦</p>
<h4>🧱 اعضای پیش‌فرض در واسط‌ها (Default interface members)</h4>
<p>C# 8 امکان افزودن پیاده‌سازی پیش‌فرض به اعضای واسط‌ها (interfaces) را فراهم کرده است. این بدان معناست که پیاده‌سازی آن عضو، برای کلاس‌هایی که از آن واسط استفاده می‌کنند اختیاری است:</p>
<pre><code class="language-csharp">interface ILogger
{
    void Log(string text) =&gt; Console.WriteLine(text);
}
</code></pre>
<p>برای فراخوانی پیاده‌سازی پیش‌فرض، باید آن را به‌صورت صریح از طریق واسط صدا زد:</p>
<pre><code class="language-csharp">((ILogger)new Logger()).Log(&quot;message&quot;);
</code></pre>
<p>علاوه بر این، واسط‌ها می‌توانند اعضای ایستا مانند متدها و فیلدها را نیز تعریف کنند. این اعضا می‌توانند از درون پیاده‌سازی پیش‌فرض یا حتی از بیرون واسط استفاده شوند:</p>
<pre><code class="language-csharp">interface ILogger
{
    void Log(string text) =&gt; Console.WriteLine(Prefix + text);
    static string Prefix = &quot;&quot;;
}

// استفاده از بیرون واسط:
ILogger.Prefix = &quot;File log: &quot;;
</code></pre>
<p>⚠️ فیلدهای نمونه (instance fields) همچنان در واسط‌ها ممنوع هستند. برای جزئیات بیشتر، به بخش «اعضای پیش‌فرض واسط‌ها» در صفحه 151 مراجعه کنید. 📘📌</p>
<h4>✨ عبارات سوییچ (Switch Expressions)</h4>
<p>از نسخه C# 8 به بعد، می‌توانید از switch به‌عنوان یک عبارت (expression) استفاده کنید، نه صرفاً یک ساختار شرطی:</p>
<pre><code class="language-csharp">string cardName = cardNumber switch
{
    13 =&gt; &quot;King&quot;,
    12 =&gt; &quot;Queen&quot;,
    11 =&gt; &quot;Jack&quot;,
    _ =&gt; &quot;Pip card&quot; // معادل default
};
</code></pre>
<p>🔄 این قابلیت، نگارش کدهای تصمیم‌گیری را ساده‌تر و خواناتر می‌کند. برای مثال‌های بیشتر به بخش «Switch expressions» در صفحه ۹۰ مراجعه کنید.</p>
<h4>🧩 الگوهای Tuple، موقعیتی و ویژگی‌ها</h4>
<p>از C# 8، سه الگوی جدید معرفی شده‌اند که بیشتر در عبارات و دستورات switch استفاده می‌شوند:</p>
<p>🔹 الگوی Tuple (تاپل)
اجازه می‌دهد هم‌زمان بر اساس چند مقدار تصمیم‌گیری کنید:</p>
<pre><code class="language-csharp">int cardNumber = 12; 
string suite = &quot;spades&quot;;

string cardName = (cardNumber, suite) switch
{
    (13, &quot;spades&quot;) =&gt; &quot;King of spades&quot;,
    (13, &quot;clubs&quot;) =&gt; &quot;King of clubs&quot;,
    _ =&gt; &quot;Unknown card&quot;
};
</code></pre>
<p><strong>🔹 الگوهای موقعیتی (Positional Patterns)</strong></p>
<p>اگر شیء شما یک deconstructor داشته باشد، می‌توانید با همین ساختار سوییچ کنید.</p>
<p><strong>🔹 الگوی ویژگی‌ها (Property Patterns)</strong></p>
<p>به شما امکان می‌دهد بر اساس ویژگی‌های داخلی یک شیء تصمیم بگیرید. برای مثال:</p>
<pre><code class="language-csharp">if (obj is string { Length: 4 }) ...
</code></pre>
<p>👆 بررسی می‌کند آیا obj یک رشته با طول ۴ است یا نه.</p>
<h4>❓ نوع‌های مرجع nullable (Nullable Reference Types)</h4>
<p>همان‌طور که nullable بودن قبلاً فقط برای نوع‌های مقدار (value types) ممکن بود، اکنون در C# 8 به نوع‌های مرجع (reference types) نیز گسترش یافته است.</p>
<p>🎯 هدف از این ویژگی، جلوگیری از بروز خطای معروف NullReferenceException است.</p>
<p>📌 این ویژگی صرفاً توسط کامپایلر کنترل می‌شود و اگر احتمال دهد که دسترسی به مقدار null ممکن است، اخطار یا خطا صادر می‌کند.</p>
<p><strong>فعال‌سازی</strong>
می‌توان از طریق فایل پروژه (.csproj) یا با دستور #nullable در کد فعالش کرد:</p>
<pre><code class="language-csharp">#nullable enable

string s1 = null;   // ⚠️ اخطار! s1 به طور پیش‌فرض nullable نیست
string? s2 = null;  // ✅ مجاز است چون نوع nullable دارد
</code></pre>
<p>اگر فیلدی را که nullable نیست مقداردهی اولیه نکنید، یا از یک مقدار nullable استفاده کنید بدون بررسی null بودن، کامپایلر هشدار می‌دهد:</p>
<pre><code class="language-csharp">void Foo(string? s) =&gt; Console.Write(s.Length);  // ⚠️ هشدار
</code></pre>
<p>برای رفع هشدار می‌توان از عملگر اطمینان از عدم null بودن (!) استفاده کرد:</p>
<pre><code class="language-csharp">void Foo(string? s) =&gt; Console.Write(s!.Length); // ✅ بدون هشدار
</code></pre>
<p>📖 برای اطلاعات کامل‌تر، به بخش «Nullable Reference Types» در صفحه ۲۱۵ مراجعه کنید.</p>
<h4>🌀 جریان‌های ناهمزمان (Asynchronous Streams)</h4>
<p>تا پیش از C# 8، می‌توانستید با استفاده از yield return یک ایتراتور (iterator) بنویسید یا با استفاده از await یک تابع ناهمزمان (asynchronous function). اما نمی‌توانستید هر دو را با هم ترکیب کنید — یعنی ایتراتوری بنویسید که درون آن await استفاده شود و مقدارها را به‌صورت ناهمزمان بازگرداند.</p>
<p>🔥 در C# 8 این امکان با معرفی جریان‌های ناهمزمان (asynchronous streams) فراهم شده است:</p>
<pre><code class="language-csharp">async IAsyncEnumerable&lt;int&gt; RangeAsync(int start, int count, int delay)
{
    for (int i = start; i &lt; start + count; i++)
    {
        await Task.Delay(delay);
        yield return i;
    }
}
</code></pre>
<p>⬅️ متد بالا، اعدادی را از start تا start + count به‌صورت ناهمزمان و با تأخیر مشخص بازمی‌گرداند.</p>
<p>برای مصرف کردن یک جریان ناهمزمان از ساختار await foreach استفاده می‌کنیم:</p>
<pre><code class="language-csharp">await foreach (var number in RangeAsync(0, 10, 100))
    Console.WriteLine(number);
</code></pre>
<p>✅ این کد، ۱۰ عدد را با تأخیر ۱۰۰ میلی‌ثانیه‌ای چاپ می‌کند، و هر بار منتظر مقدار جدید می‌ماند.</p>
<p>📖 برای اطلاعات بیشتر، به بخش «Asynchronous Streams» در صفحه ۶۷۲ مراجعه کنید.</p>
<h3>🔹 چه چیزهایی در C# نسخه 7.x جدید است</h3>
<p>C# 7.x نخستین بار همراه با Visual Studio 2017 منتشر شد. نسخه C# 7.3 همچنان در Visual Studio 2019 استفاده می‌شود، زمانی که هدف شما .NET Core 2، .NET Framework 4.6 تا 4.8 یا .NET Standard 2.0 باشد.</p>
<p>🚀 C# 7.3
C# 7.3 بهبودهای کوچکی در ویژگی‌های موجود ایجاد کرد، مانند:</p>
<p>+امکان استفاده از عملگرهای برابری با تاپل‌ها</p>
<p>+بهبود در انتخاب نسخه مناسب متد (Overload Resolution)</p>
<p>+قابلیت اعمال Attribute روی فیلد پشتیبان (Backing Field) در ویژگی‌های خودکار:</p>
<pre><code class="language-csharp">[field:NonSerialized]
public int MyProperty { get; set; }
</code></pre>
<p>همچنین این نسخه ویژگی‌های برنامه‌نویسی با تخصیص حافظه کم را که در C# 7.2 معرفی شده بود، گسترش داد:</p>
<ul>
<li>
<p>توانایی تخصیص مجدد متغیرهای محلی با ref</p>
</li>
<li>
<p>عدم نیاز به Pin کردن هنگام ایندکس‌گذاری روی فیلدهای ثابت (fixed fields)</p>
</li>
<li>
<p>پشتیبانی از مقداردهی اولیه فیلدها با stackalloc:</p>
</li>
</ul>
<pre><code class="language-csharp">int* pointer  = stackalloc int[] { 1, 2, 3 };
Span&lt;int&gt; arr = stackalloc[] { 1, 2, 3 };
</code></pre>
<p>📌 توجه: حافظه اختصاص‌یافته با stackalloc را می‌توان مستقیماً به یک Span<T> نسبت داد (توضیحات بیشتر در فصل 23).</p>
<h4>🔐 C# 7.2</h4>
<p>تغییرات مهم این نسخه:</p>
<ul>
<li>
<p>اضافه شدن کلیدواژه private protected (ترکیبی از internal و protected)</p>
</li>
<li>
<p>امکان استفاده از آرگومان‌های موقعیتی پس از آرگومان‌های نام‌گذاری‌شده هنگام فراخوانی متدها</p>
</li>
<li>
<p>معرفی ساختارهای فقط‌خواندنی (readonly struct) که باعث می‌شود تمام فیلدها readonly باشند:</p>
</li>
</ul>
<pre><code class="language-csharp">readonly struct Point
{
    public readonly int X, Y; // هر دو باید readonly باشند
}
</code></pre>
<p>این ویژگی باعث بیان واضح‌تر قصد برنامه‌نویس و فراهم شدن بهینه‌سازی بیشتر توسط کامپایلر می‌شود.</p>
<p>همچنین امکاناتی برای ریزبهینه‌سازی (micro-optimization) و برنامه‌نویسی با تخصیص حافظه کم افزوده شد:</p>
<ul>
<li>
<p>in modifier</p>
</li>
<li>
<p>Ref Locals</p>
</li>
<li>
<p>Ref Returns</p>
</li>
<li>
<p>Ref Structs</p>
</li>
</ul>
<h4>⚡ C# 7.1</h4>
<p>از نسخه 7.1 به بعد:</p>
<ul>
<li>می‌توان نوع داده را هنگام استفاده از default حذف کرد، اگر قابل استنتاج باشد:</li>
</ul>
<pre><code class="language-csharp">decimal number = default; // نوع decimal است
</code></pre>
<ul>
<li>
<p>قوانین switch ساده‌تر شدند (امکان الگوگیری از پارامترهای نوع عمومی)</p>
</li>
<li>
<p>متد اصلی برنامه (Main) می‌تواند asynchronous باشد</p>
</li>
<li>
<p>امکان استنتاج نام عناصر تاپل از نام متغیرها:</p>
</li>
</ul>
<pre><code class="language-csharp">var now = DateTime.Now;
var tuple = (now.Hour, now.Minute, now.Second);
</code></pre>
<h3>بهبودهای مربوط به اعداد (Numeric Literal Improvements) 🔢</h3>
<p>در نسخه‌ی C# 7، می‌توانیم داخل عددها از کاراکتر زیرخط (_) استفاده کنیم تا خوانایی‌شان بهتر شود. به این‌ها جداکننده ارقام (digit separators) می‌گویند و کامپایلر این زیرخط‌ها را نادیده می‌گیرد:</p>
<pre><code class="language-csharp">int million = 1_000_000;
</code></pre>
<p>همچنین می‌توانیم اعداد باینری را با پیشوند 0b بنویسیم:</p>
<pre><code class="language-csharp">var b = 0b1010_1011_1100_1101_1110_1111;
</code></pre>
<h4>متغیرهای Out و Discardها 🎯</h4>
<p>در C# 7 کار با متدهایی که پارامتر out دارند راحت‌تر شده است.
حالا می‌توانید متغیرهای out را در لحظه تعریف کنید (بخش «Out variables and discards» در صفحه 72 را ببینید):</p>
<pre><code class="language-csharp">bool successful = int.TryParse(&quot;123&quot;, out int result);
Console.WriteLine(result);
</code></pre>
<p>اگر متدی چند پارامتر out داشته باشد و شما فقط به بعضی از آن‌ها نیاز داشته باشید، می‌توانید بقیه را با کاراکتر زیرخط (_) نادیده بگیرید:</p>
<pre><code class="language-csharp">SomeBigMethod(out _, out _, out _, out int x, out _, out _, out _);
Console.WriteLine(x);
</code></pre>
<h4>الگوهای نوع و متغیرهای Pattern 🧩</h4>
<p>می‌توانید با استفاده از عملگر is، متغیرهایی را در لحظه معرفی کنید. به این‌ها متغیرهای الگو (pattern variables) می‌گویند (بخش «Introducing a pattern variable» در صفحه 130 را ببینید):</p>
<pre><code class="language-csharp">void Foo(object x)
{
    if (x is string s)
        Console.WriteLine(s.Length);
}
</code></pre>
<h4>دستور Switch با پشتیبانی از الگوهای نوع 🔀</h4>
<p>دستور switch حالا می‌تواند علاوه بر ثابت‌ها، بر اساس نوع داده هم تصمیم‌گیری کند (بخش «Switching on types» در صفحه 89 را ببینید).
همچنین می‌توانید با استفاده از عبارت when شرط اضافه کنید و حتی روی مقدار null هم سوئیچ کنید:</p>
<pre><code class="language-csharp">switch (x)
{
    case int i:
        Console.WriteLine(&quot;It's an int!&quot;);
        break;
    case string s:
        Console.WriteLine(s.Length); // می‌توانیم از متغیر s استفاده کنیم
        break;
    case bool b when b == true: // فقط وقتی b برابر true باشد
        Console.WriteLine(&quot;True&quot;);
        break;
    case null:
        Console.WriteLine(&quot;Nothing&quot;);
        break;
}
</code></pre>
<h4>متدهای محلی 🛠️</h4>
<p>متد محلی (Local Method) متدی است که داخل یک تابع دیگر تعریف می‌شود (نگاه کنید به بخش «متدهای محلی» در صفحه 106).</p>
<pre><code class="language-csharp">void WriteCubes()
{
    Console.WriteLine(Cube(3));
    Console.WriteLine(Cube(4));
    Console.WriteLine(Cube(5));

    int Cube(int value) =&gt; value * value * value;
}
</code></pre>
<p>🔹 متدهای محلی فقط برای همان تابعی که در آن تعریف شده‌اند قابل مشاهده هستند و می‌توانند متغیرهای محلی همان تابع را بگیرند و استفاده کنند، درست مثل عبارات لامبدا.</p>
<h4>اعضای بدنه-بیان بیشتر ➡️</h4>
<p>در C# 6، سینتکس expression-bodied یا همان «پیکان چاق» (=&gt;) برای متدها، پراپرتی‌های فقط-خواندنی، عملگرها و ایندکسرها معرفی شد.
در C# 7 این قابلیت گسترش یافت و شامل سازنده‌ها، پراپرتی‌های خواندنی/نوشتنی و فاینالایزرها هم شد:</p>
<pre><code class="language-csharp">public class Person
{
    string name;

    public Person(string name) =&gt; Name = name;

    public string Name
    {
        get =&gt; name;
        set =&gt; name = value ?? &quot;&quot;;
    }

    ~Person() =&gt; Console.WriteLine(&quot;finalize&quot;);
}
</code></pre>
<h4>دی‌کانستراکتورها 🔄</h4>
<p>در C# 7، الگوی Deconstructor معرفی شد (بخش «دی‌کانستراکتورها» در صفحه 110).
🔹 برعکس سازنده (Constructor) که معمولاً یک سری مقادیر را به‌عنوان پارامتر گرفته و در فیلدها ذخیره می‌کند، یک دی‌کانستراکتور برعکس عمل می‌کند و مقدار فیلدها را به مجموعه‌ای از متغیرها برمی‌گرداند.</p>
<p>برای مثال، می‌توانیم برای کلاس Person بالا یک دی‌کانستراکتور به این صورت بنویسیم:</p>
<pre><code class="language-csharp">public void Deconstruct(out string firstName, out string lastName)
{
    int spacePos = name.IndexOf(' ');
    firstName = name.Substring(0, spacePos);
    lastName = name.Substring(spacePos + 1);
}
</code></pre>
<p>📌 دی‌کانستراکتورها با سینتکس خاصی صدا زده می‌شوند:</p>
<pre><code class="language-csharp">var joe = new Person(&quot;Joe Bloggs&quot;);
var (first, last) = joe;   // دی‌کانستراکشن
Console.WriteLine(first);  // Joe
Console.WriteLine(last);   // Bloggs
</code></pre>
<h4>تاپل‌ها (Tuples) 🧩</h4>
<p>شاید مهم‌ترین بهبود در C# 7، پشتیبانی مستقیم و واضح از تاپل‌ها باشد (نگاه کنید به بخش «Tuples» در صفحه 222 📖).
تاپل‌ها یک روش ساده برای ذخیره یک مجموعه از مقادیر مرتبط فراهم می‌کنند:</p>
<pre><code class="language-csharp">var bob = (&quot;Bob&quot;, 23);
Console.WriteLine(bob.Item1);   // Bob
Console.WriteLine(bob.Item2);   // 23
</code></pre>
<p>تاپل‌های جدید در C# در واقع نوعی syntactic sugar (شیرینی语 نحوی 😄) برای استفاده از ساختارهای جنریک System.ValueTuple&lt;…&gt; هستند.
اما به لطف قابلیت‌های کامپایلر، می‌توان به عناصر تاپل نام هم داد:</p>
<pre><code class="language-csharp">var tuple = (name: &quot;Bob&quot;, age: 23);
Console.WriteLine(tuple.name);   // Bob
Console.WriteLine(tuple.age);    // 23
</code></pre>
<p>با استفاده از تاپل‌ها، توابع می‌توانند چند مقدار را برگردانند، بدون اینکه مجبور باشیم از پارامترهای out یا انواع اضافه و پیچیده استفاده کنیم:</p>
<pre><code class="language-csharp">static (int row, int column) GetFilePosition() =&gt; (3, 10);

static void Main()
{
    var pos = GetFilePosition();
    Console.WriteLine(pos.row);      // 3
    Console.WriteLine(pos.column);   // 10
}
</code></pre>
<p>تاپل‌ها به‌طور ضمنی از الگوی deconstruction پشتیبانی می‌کنند، بنابراین می‌توان آن‌ها را به‌راحتی به متغیرهای جداگانه تجزیه کرد:</p>
<pre><code class="language-csharp">static void Main()
{
    (int row, int column) = GetFilePosition(); // ایجاد دو متغیر محلی
    Console.WriteLine(row);      // 3
    Console.WriteLine(column);   // 10
}
</code></pre>
<h4>عبارت‌های throw 🚨</h4>
<p>قبل از نسخه C# 7، دستور throw همیشه یک statement (دستور مستقل) بود.
اما اکنون می‌تواند به عنوان یک expression (عبارت) هم استفاده شود، مثلاً در توابع expression-bodied:</p>
<pre><code class="language-csharp">public string Foo() =&gt; throw new NotImplementedException();
</code></pre>
<p>همچنین می‌توان از throw در یک عبارت شرطی سه‌تایی (ternary conditional expression) استفاده کرد:</p>
<pre><code class="language-csharp">string Capitalize(string value) =&gt;
    value == null ? throw new ArgumentException(&quot;value&quot;) :
    value == &quot;&quot; ? &quot;&quot; :
    char.ToUpper(value[0]) + value.Substring(1);
</code></pre>
<p>💡 این ویژگی باعث می‌شود بتوانید پرتاب استثنا (Exception) را در جاهایی انجام دهید که قبلاً فقط می‌توانستید یک مقدار برگردانید یا عملیات انجام دهید، و این انعطاف‌پذیری کد را افزایش می‌دهد.</p>
<h3>چه چیزهایی در ‎C# 6.0‎ جدید است</h3>
<p>C# ‎6.0‎ که همراه با Visual Studio 2015 عرضه شد، یک کامپایلر نسل جدید دارد که به‌طور کامل با خود زبان C# نوشته شده است. این کامپایلر که با نام پروژه Roslyn شناخته می‌شود، کل فرایند کامپایل را از طریق کتابخانه‌ها در اختیار شما قرار می‌دهد و این امکان را فراهم می‌کند که روی هر کدی که بخواهید، آنالیز انجام دهید. خود کامپایلر متن‌باز (Open Source) است و کد منبع آن در این آدرس موجود است:
<a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a></p>
<p>علاوه بر این، C# ‎6.0‎ شامل چند بهبود کوچک اما مهم است که بیشتر برای کاهش شلوغی و طول کد طراحی شده‌اند:</p>
<p><strong>1. عملگر شرطی تهی (Null-Conditional) یا «Elvis»</strong></p>
<p>(بخش Null Operators در صفحه 82)
با این عملگر دیگر لازم نیست قبل از فراخوانی یک متد یا دسترسی به یک عضو، مقدار null را بررسی کنید. در مثال زیر، متغیر result به جای پرتاب کردن خطای NullReferenceException، برابر null می‌شود:</p>
<pre><code class="language-csharp">System.Text.StringBuilder sb = null;
string result = sb?.ToString(); // result برابر null است
</code></pre>
<p><strong>2. توابع بدنه‌-بیان (Expression-Bodied)</strong></p>
<p>(بخش Methods در صفحه 106)
اجازه می‌دهد متدها، پراپرتی‌ها، عملگرها و ایندکسرهایی که فقط شامل یک عبارت هستند، کوتاه و شبیه به lambda expression نوشته شوند:</p>
<pre><code class="language-csharp">public int TimesTwo(int x) =&gt; x * 2;
public string SomeProperty =&gt; &quot;Property value&quot;;
</code></pre>
<p><strong>3. مقداردهی اولیه به پراپرتی‌ها (Property Initializers)</strong></p>
<p>(فصل 3)
قابلیت مقداردهی اولیه به یک پراپرتی خودکار هنگام تعریف آن:</p>
<pre><code class="language-csharp">public DateTime TimeCreated { get; set; } = DateTime.Now;
</code></pre>
<p>حتی می‌توان پراپرتی‌های فقط‌خواندنی را مقداردهی کرد:</p>
<pre><code class="language-csharp">public DateTime TimeCreated { get; } = DateTime.Now;
</code></pre>
<p>این پراپرتی‌های فقط‌خواندنی همچنین می‌توانند در سازنده (Constructor) مقداردهی شوند، که ایجاد نوع‌های تغییرناپذیر (Immutable) را ساده‌تر می‌کند.</p>
<p><strong>4. مقداردهی اولیه اندیس‌ها (Index Initializers)</strong></p>
<p>(فصل 4)
اجازه می‌دهد هر نوعی که ایندکسر دارد را در یک مرحله مقداردهی کنید:</p>
<pre><code class="language-csharp">var dict = new Dictionary&lt;int, string&gt;()
{
    [3] = &quot;three&quot;,
    [10] = &quot;ten&quot;
};
</code></pre>
<p><strong>5. درون‌گذاری رشته‌ای (String Interpolation)</strong></p>
<p>(بخش String Type در صفحه 58)
جایگزینی خلاصه‌تر برای string.Format:</p>
<pre><code class="language-csharp">string s = $&quot;It is {DateTime.Now.DayOfWeek} today&quot;;
</code></pre>
<p><strong>6. فیلترهای استثنا (Exception Filters)</strong></p>
<p>(بخش try Statements and Exceptions در صفحه 195)
امکان تعیین شرط برای یک بلوک catch:</p>
<pre><code class="language-csharp">string html;
try
{
    html = await new HttpClient().GetStringAsync(&quot;http://asef&quot;);
}
catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{
    ...
}
</code></pre>
<p><strong>7. دستور using static</strong></p>
<p>(بخش Namespaces در صفحه 95)
تمام اعضای استاتیک یک نوع را وارد می‌کند تا بتوانید بدون نام‌گذاری کامل از آن‌ها استفاده کنید:</p>
<pre><code class="language-csharp">using static System.Console;

WriteLine(&quot;Hello, world&quot;); // به‌جای Console.WriteLine
</code></pre>
<p><strong>8. عملگر nameof</strong></p>
<p>(فصل 3)
نام یک متغیر، نوع، یا نماد دیگر را به‌صورت رشته برمی‌گرداند. این کار باعث می‌شود در هنگام تغییر نام نمادها در Visual Studio، کد خراب نشود:</p>
<pre><code class="language-csharp">int capacity = 123;
string x = nameof(capacity);   // &quot;capacity&quot;
string y = nameof(Uri.Host);   // &quot;Host&quot;
</code></pre>
<p><strong>9. امکان await داخل بلوک‌های catch و finally</strong></p>
<p>اکنون مجاز هستید داخل catch و finally از await استفاده کنید.</p>
<h3>چه چیزهای جدیدی در C# 5.0 وجود دارد</h3>
<p>بزرگ‌ترین ویژگی جدید در C# 5.0، پشتیبانی از توابع ناهمگام (Asynchronous Functions) از طریق دو کلمه کلیدی جدید async و await بود.</p>
<p>توابع ناهمگام این امکان را فراهم می‌کنند که ادامهٔ اجرای برنامه به صورت ناهمگام انجام شود، که این موضوع باعث می‌شود نوشتن برنامه‌های کلاینت قدرتمند، واکنش‌گرا و ایمن از نظر رشته‌ای (Thread-Safe) بسیار ساده‌تر شود.</p>
<p>همچنین، این قابلیت کمک می‌کند تا بتوانید به راحتی برنامه‌های ورودی/خروجی (I/O) محور بنویسید که همزمانی (Concurrency) بالایی دارند و کارآمد هستند، بدون اینکه برای هر عملیات، یک رشته (Thread) جداگانه اشغال شود.</p>
<p>در فصل ۱۴، این موضوع یعنی توابع ناهمگام را به طور کامل بررسی خواهیم کرد. 🚀</p>
<h3>چه چیزهای جدیدی در C# 4.0 وجود دارد</h3>
<p>در C# 4.0، چهار بهبود مهم معرفی شدند:</p>
<ol>
<li>
<p>اتصال داینامیک (Dynamic Binding)
اتصال داینامیک باعث می‌شود که تعیین نوع و اعضای یک متغیر به جای زمان کامپایل، در زمان اجرا انجام شود. این قابلیت در مواقعی که باید از کدهای پیچیده ریفلکشن استفاده کنیم، بسیار کاربردی است. همچنین، برای تعامل با زبان‌های داینامیک و کامپوننت‌های COM بسیار مفید است. 🌀</p>
</li>
<li>
<p>پارامترهای اختیاری و پارامترهای نام‌گذاری‌شده (Optional and Named Parameters)
پارامترهای اختیاری اجازه می‌دهند تا در تعریف تابع، برای پارامترها مقدار پیش‌فرض تعیین کنید و هنگام فراخوانی، نیازی به ارسال همه پارامترها نباشد. پارامترهای نام‌گذاری‌شده نیز به شما امکان می‌دهند که هنگام فراخوانی، آرگومان‌ها را بر اساس نامشان مشخص کنید، نه صرفاً موقعیتشان. 🎯</p>
</li>
<li>
<p>قوانین واریانس نوع (Type Variance)
در C# 4.0، قوانین واریانس برای پارامترهای نوع در رابط‌های عمومی (Generic Interfaces) و نماینده‌های عمومی (Generic Delegates) شل‌تر شدند. به این معنی که می‌توان این پارامترها را به صورت کوواریانت (covariant) یا کانتر واریانت (contravariant) علامت‌گذاری کرد و این اجازه می‌دهد تبدیل‌های طبیعی‌تری بین انواع انجام شود. 🔄</p>
</li>
<li>
<p>بهبود تعامل با COM
در سه جنبه:</p>
</li>
</ol>
<ul>
<li>
<p>امکان ارسال آرگومان‌ها به صورت ارجاعی بدون نیاز به کلیدواژه ref (مخصوصاً هنگام استفاده از پارامترهای اختیاری).</p>
</li>
<li>
<p>امکان لینک کردن اسمبلی‌های حاوی نوع‌های interop COM به جای ارجاع مستقیم، که باعث کاهش مشکلات نسخه‌بندی و استقرار می‌شود.</p>
</li>
<li>
<p>توابعی که نوع Variant کامپوننت‌های COM را باز می‌گردانند، حالا به صورت dynamic نگاشت می‌شوند، نه object، که نیاز به تبدیل نوع (cast) را از بین می‌برد. ⚙️</p>
</li>
</ul>
<p>این ویژگی‌ها به توسعه‌دهندگان کمک می‌کنند کدهای انعطاف‌پذیرتر و قابل استفاده‌تر بنویسند، به خصوص هنگام کار با محیط‌های ترکیبی و دینامیک.</p>
<h3>چه چیزهای جدیدی در C# 3.0 وجود دارد 🎉</h3>
<p>تمرکز اصلی ویژگی‌هایی که در C# 3.0 اضافه شدند، بر روی قابلیت‌های Language-Integrated Query (LINQ) بود. LINQ به شما اجازه می‌دهد تا بتوانید کوئری‌ها را مستقیماً درون برنامه‌ی C# بنویسید و در زمان کامپایل هم صحت آنها بررسی شود. این کوئری‌ها می‌توانند روی مجموعه‌های محلی مثل لیست‌ها یا اسناد XML، یا منابع داده‌ای راه دور مثل دیتابیس اجرا شوند. 🔍</p>
<p>ویژگی‌های C# 3.0 که برای پشتیبانی از LINQ اضافه شدند عبارتند از:</p>
<ul>
<li>
<p>متغیرهای محلی با نوع استنباط شده (Implicitly typed local variables)
با کلیدواژه var می‌توانید نوع متغیر را در هنگام تعریف ذکر نکنید و کامپایلر خودش نوع را حدس می‌زند. این کار باعث کاهش شلوغی کد می‌شود و همچنین امکان استفاده از انواع ناشناس را فراهم می‌کند که کلاس‌های ساده‌ای هستند که در لحظه ساخته می‌شوند و معمولاً در نتایج نهایی کوئری‌های LINQ استفاده می‌شوند.</p>
</li>
<li>
<p>مقداردهی اولیه به اشیا (Object initializers)
این امکان به شما اجازه می‌دهد بعد از فراخوانی سازنده (constructor)، به‌صورت مستقیم خصوصیات (properties) یک شیء را مقداردهی کنید. این ویژگی هم برای انواع نام‌گذاری شده و هم برای انواع ناشناس کاربرد دارد.</p>
</li>
<li>
<p>عبارات لامبدا (Lambda expressions)
این‌ها توابع کوچک و سرراستی هستند که کامپایلر در لحظه می‌سازد و در کوئری‌های LINQ به خصوص در حالت &quot;fluent&quot; خیلی کاربردی هستند.</p>
</li>
<li>
<p>متدهای الحاقی (Extension methods)
به شما امکان می‌دهد که بدون تغییر تعریف اصلی یک نوع، متدهای جدیدی به آن اضافه کنید. متدهای الحاقی در واقع متدهای استاتیکی هستند که مثل متدهای نمونه‌ای به نظر می‌رسند. بسیاری از اپراتورهای کوئری LINQ به صورت متدهای الحاقی پیاده‌سازی شده‌اند.</p>
</li>
<li>
<p>عبارات کوئری (Query expressions)
این‌ها نحو سطح بالاتری برای نوشتن کوئری‌های LINQ فراهم می‌کنند که وقتی با چند مجموعه یا متغیر دامنه کار می‌کنید، کد شما بسیار ساده‌تر و خواناتر می‌شود.</p>
</li>
<li>
<p>درخت‌های عبارت (Expression trees)
این‌ها مدل‌های کوچکی از کد (Document Object Models یا DOM) هستند که عبارات لامبدا را توصیف می‌کنند. با استفاده از درخت‌های عبارت، امکان اجرای کوئری‌های LINQ در محیط‌های راه دور مثل سرور دیتابیس وجود دارد، چون می‌توان آنها را در زمان اجرا بررسی و به زبان‌های دیگری مثل SQL ترجمه کرد.</p>
</li>
</ul>
<p>علاوه بر این‌ها، در C# 3.0 دو ویژگی مهم دیگر هم اضافه شدند:</p>
<ul>
<li>
<p>ویژگی‌های خودکار (Automatic properties)
این ویژگی نوشتن خصوصیات ساده که فقط یک فیلد خصوصی را دریافت و تنظیم می‌کنند، بسیار آسان‌تر می‌کند، چون کامپایلر خودش این فیلد پشتیبان را می‌سازد.</p>
</li>
<li>
<p>متدهای جزئی (Partial methods)
این متدها به کلاسی که به صورت خودکار تولید شده، امکان می‌دهند نقاط قابل تنظیمی برای کد دستی اضافه کنند که اگر استفاده نشوند، کاملاً حذف می‌شوند.</p>
</li>
</ul>
<h3>چه چیزهای جدیدی در C# 2.0 وجود دارد 🎉</h3>
<p>ویژگی‌های بزرگ و مهمی که در C# 2.0 اضافه شدند، شامل موارد زیر هستند:</p>
<ul>
<li>
<p>جنریک‌ها (Generics)
این قابلیت به شما اجازه می‌دهد تا بتوانید کلاس‌ها، متدها و ساختارهایی بنویسید که نوع داده‌ای آنها به صورت پارامتریک تعریف می‌شود. یعنی می‌توانید یکبار کد بنویسید و با انواع مختلف آن را استفاده کنید، بدون نیاز به کپی کردن یا تبدیل نوع. این ویژگی به طور قابل توجهی باعث افزایش انعطاف‌پذیری و کارایی کد می‌شود.
نکته مهم: پشتیبانی از جنریک‌ها نیازمند یک نسخه جدید از CLR بود (نسخه 2.0) تا بتواند در زمان اجرا هم نوع داده را حفظ کند.</p>
</li>
<li>
<p>نوع‌های nullable برای مقادیر (Nullable value types)
این امکان به شما می‌دهد تا نوع‌های مقداردهی‌شده مثل int یا bool بتوانند مقدار null هم داشته باشند. این ویژگی برای مواقعی که داده ممکن است مقدار نداشته باشد، خیلی کاربردی است.</p>
</li>
<li>
<p>ایتراتورها (Iterators)
امکان نوشتن کدهای تکرارشونده به شکل ساده‌تر و خواناتر، با استفاده از کلیدواژه yield برای بازگرداندن عناصر به صورت یکی‌یکی.</p>
</li>
<li>
<p>متدهای ناشناس (Anonymous methods)
این قابلیت پیش‌نیاز عبارات لامبدا بود و به شما اجازه می‌داد که توابع کوچک و بدون نام را به صورت مستقیم تعریف و استفاده کنید.</p>
</li>
</ul>
<p>علاوه بر این‌ها، C# 2.0 ویژگی‌های دیگری مثل:</p>
<ul>
<li>
<p>کلاس‌های جزئی (Partial classes)
که امکان تقسیم تعریف یک کلاس به چند فایل را می‌دهند.</p>
</li>
<li>
<p>کلاس‌های استاتیک (Static classes)
که فقط شامل اعضای استاتیک هستند و نمی‌توان از آنها نمونه ساخت.</p>
</li>
<li>
<p>و مجموعه‌ای از ویژگی‌های کوچک‌تر و متنوع مانند مخفف‌های فضای نام (namespace alias qualifier)، دوستان اسمبلی (friend assemblies)، و بافرهای با اندازه ثابت (fixed-size buffers)</p>
</li>
</ul>
<p>را نیز اضافه کرد.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
