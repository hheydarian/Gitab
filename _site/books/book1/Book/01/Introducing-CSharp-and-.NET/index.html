<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>کتابخانه من</title>
  <link rel="stylesheet" href="/styles/main.css" />
</head>
<body class="rtl-site">
  <header>
    <h1>📚 پارس کتاب</h1>
  </header>

  <main class="markdown-body">
    <h1>فصل دوم: آشنایی با سی‌شارپ و دات‌نت</h1>
<p>سی شارپ یک زبان برنامه‌نویسی همه‌منظوره (general-purpose)، ایمن از نظر نوع داده (type-safe)، و شی‌گرا (object-oriented) است.</p>
<p>هدف اصلی این زبان، افزایش بهره‌وری برنامه‌نویس است.
برای رسیدن به این هدف، #C تلاش می‌کند میان سادگی، قدرت بیان (expressiveness)، و کارایی (performance) تعادل برقرار کند.</p>
<p>طراح اصلی زبان #C از همان نسخه اول، آندرس هایلسبرگ (Anders Hejlsberg) بوده؛ کسی که قبلاً Turbo Pascal را خلق کرده و معمار زبان Delphi نیز بوده است.</p>
<p>زبان #C به‌گونه‌ای طراحی شده که وابسته به هیچ پلتفرم خاصی نیست (platform-neutral) و می‌تواند با اجراکننده‌های خاص پلتفرم‌های مختلف (platform-specific runtimes) کار کند.</p>
<h2>شی‌ءگرایی</h2>
<p>زبان #C یک پیاده‌سازی قدرتمند از الگوی برنامه‌نویسی شی‌گرا (Object-Oriented Programming) است.
این الگو شامل سه اصل اصلی است:</p>
<ul>
<li>
<p>کپسوله‌سازی (Encapsulation)</p>
</li>
<li>
<p>ارث‌بری (Inheritance)</p>
</li>
<li>
<p>چندریختی (Polymorphism)</p>
</li>
</ul>
<p>🔹 کپسوله‌سازی یعنی اینکه برای هر شی (Object) یک مرز مشخص تعریف کنیم تا رفتار خارجی (عمومی) آن را از جزئیات پیاده‌سازی داخلی (خصوصی) جدا کنیم.</p>
<p>ویژگی‌های منحصربه‌فرد #C در شی‌گرایی</p>
<p>🔸 سیستم نوع یکپارچه (Unified Type System)
در #C، واحد اصلی ساخت برنامه، نوع (Type) است — یعنی یک واحد کپسوله‌شده از داده و توابع.</p>
<p>در این زبان، همه نوع‌ها در نهایت زیرمجموعه‌ای از یک نوع پایه مشترک هستند.
این یعنی فرقی نمی‌کند با یک شی تجاری (Business Object) کار می‌کنید یا با یک عدد ساده، همه این نوع‌ها از یک سری قابلیت‌های پایه برخوردارند.</p>
<p>برای مثال:</p>
<p>می‌تونید روی هر شیئی در #C متد ToString را صدا بزنید و نسخه متنی (رشته‌ای) از آن دریافت کنید — چون همه نوع‌ها این متد را دارند.</p>
<p>🔸 کلاس‌ها و اینترفیس‌ها (Classes and Interfaces)
در مدل سنتی شی‌گرایی، تنها نوع موجود کلاس (Class) است. اما در #C انواع دیگری هم وجود دارد، از جمله:</p>
<p>اینترفیس (Interface)
اینترفیس‌ها شبیه کلاس‌ها هستند با این تفاوت که نمی‌توانند داده نگه دارند. یعنی فقط رفتار تعریف می‌کنند، نه وضعیت.</p>
<p>این ویژگی چند مزیت دارد:</p>
<ul>
<li>
<p>پشتیبانی از ارث‌بری چندگانه (Multiple Inheritance)</p>
</li>
<li>
<p>جدا کردن تعریف (specification) از پیاده‌سازی (implementation)</p>
</li>
</ul>
<p>🔸 ویژگی‌ها، متدها، و رویدادها
(Properties, Methods, and Events)</p>
<p>در الگوی شی‌گرایی ناب، همه توابع به شکل متد (Method) هستند. اما در #C، متدها تنها یک نوع از اعضای تابعی (Function Members) محسوب می‌شوند.
نوع‌های دیگر شامل:</p>
<ul>
<li>ویژگی‌ها (Properties):</li>
<li></li>
</ul>
<p>اعضایی که بخشی از وضعیت یک شی را کپسوله می‌کنند، مثل رنگ یک دکمه یا متن یک برچسب.</p>
<ul>
<li>رویدادها (Events):</li>
<li></li>
</ul>
<p>اعضایی که برای ساده‌تر کردن واکنش به تغییرات وضعیت شی‌ها طراحی شده‌اند.</p>
<p>تأثیرات برنامه‌نویسی تابعی در #C</p>
<p>با اینکه #C به‌طور عمده یک زبان شی‌گراست، اما از الگوهای برنامه‌نویسی تابعی (Functional Programming) هم الهام گرفته. برخی از این ویژگی‌ها عبارت‌اند از:</p>
<p>🔹 توابع به‌عنوان مقدار (Functions as Values)
با استفاده از نماینده‌ها (Delegates) در #C، می‌توانید توابع را مانند داده، به دیگر توابع ارسال یا از آن‌ها بازگردانید.</p>
<p>🔹 پشتیبانی از الگوهای برنامه‌نویسی تابعی
در برنامه‌نویسی تابعی، ترجیح داده می‌شود که مقدار متغیرها تغییر نکند، و به‌جای آن از الگوهای اعلانی (Declarative Patterns) استفاده شود.</p>
<p>زبان #C ابزارهایی برای این سبک برنامه‌نویسی فراهم کرده، از جمله:</p>
<ul>
<li>توابع بی‌نام (Lambda Expressions):</li>
<li></li>
</ul>
<p>می‌توان توابعی را در لحظه تعریف کرد که به متغیرهای اطرافشان دسترسی دارند (یعنی آن‌ها را &quot;capture&quot; می‌کنند).</p>
<ul>
<li>عبارات پرس‌وجو (Query Expressions):</li>
<li></li>
</ul>
<p>برای برنامه‌نویسی لیستی یا واکنشی (Reactive Programming) به‌کار می‌روند.</p>
<ul>
<li>رکوردها (Records):</li>
<li></li>
</ul>
<p>نوع‌هایی هستند که به‌سادگی می‌توان با آن‌ها اشیایی فقط‌خواندنی و تغییرناپذیر (Immutable) ساخت.</p>
<h2>ایمنی نوع در #C</h2>
<p>(Type Safety)</p>
<p>زبان #C در اصل یک زبان ایمن از نظر نوع (Type-Safe) است. این یعنی اشیای مختلف (یعنی نمونه‌هایی از انواع مختلف داده‌ها) فقط از طریق سازوکارهایی که خود نوع آن‌ها تعریف کرده، می‌توانند با هم تعامل داشته باشند.</p>
<p>این کار باعث می‌شود که انسجام داخلی هر نوع (Type) حفظ شود.</p>
<p>برای مثال:</p>
<p>در #C نمی‌توانید با یک مقدار از نوع رشته (string) طوری رفتار کنید که انگار یک عدد صحیح (int) است — زبان جلوی این کار را می‌گیرد.</p>
<p><strong>تایپ ایستا (Static Typing)</strong></p>
<p>زبان #C از تایپ ایستا پشتیبانی می‌کند.
یعنی بررسی نوع داده‌ها نه فقط در زمان اجرا، بلکه در زمان کامپایل (ساخت برنامه) هم انجام می‌شود.</p>
<p>🔹 این یعنی بسیاری از خطاهای احتمالی قبل از اجرای برنامه شناسایی می‌شوند.
🔹 به‌جای اینکه فقط با نوشتن تست‌های واحد (Unit Tests) در زمان اجرا به دنبال خطاها باشید، کامپایلر خودش بررسی می‌کند که همه نوع‌ها در برنامه درست به‌کار رفته‌اند یا نه.</p>
<p>این ویژگی چند مزیت مهم داره:</p>
<ul>
<li>
<p>برنامه‌های بزرگ راحت‌تر قابل مدیریت هستند</p>
</li>
<li>
<p>کدها قابل پیش‌بینی‌تر و مطمئن‌تر (Robust) می‌شن</p>
</li>
<li>
<p>ابزارهایی مثل IntelliSense در ویژوال استودیو می‌تونن کمک کنن کدها رو سریع‌تر و بهتر بنویسید، چون دقیقاً می‌دونن که هر متغیر از چه نوعیه و چه متدهایی می‌تونید روش اجرا کنید</p>
</li>
<li>
<p>همچنین این ابزارها می‌تونن بررسی کنن که یک متغیر یا متد یا نوع، در کجای برنامه استفاده شده — که این موضوع برای بازسازی و تغییر ساختار کد (Refactoring) بسیار مهمه</p>
</li>
</ul>
<p><strong>تایپ پویا با dynamic</strong></p>
<p>در عین حال که #C عمدتاً یک زبان با تایپ ایستاست، اجازه می‌ده که بخش‌هایی از کد را به‌صورت پویا تایپ کنید.
برای این کار می‌تونید از کلیدواژه‌ی dynamic استفاده کنید.</p>
<p>اما با این وجود، #C در ذات خود همچنان یک زبان با تایپ ایستا باقی می‌مونه.</p>
<p><strong>تایپ قوی (Strong Typing)</strong></p>
<p>زبان #C همچنین به عنوان یک زبان با تایپ قوی (Strongly Typed) شناخته می‌شود.
یعنی قوانین مربوط به نوع‌ها به‌شدت رعایت می‌شن — چه در زمان کامپایل و چه در زمان اجرا.</p>
<p>مثلاً:
شما نمی‌تونید تابعی که انتظار داره یک عدد صحیح (int) دریافت کنه، با یک عدد اعشاری (float) صدا بزنید — مگر اینکه صراحتاً عدد اعشاری رو به عدد صحیح تبدیل (Cast) کرده باشید.</p>
<p>این موضوع کمک می‌کنه تا از بروز خطاهای رایج و پنهان جلوگیری بشه.</p>
<p>✅ این ویژگی‌ها باعث می‌شن زبان #C هم قدرتمند باشه و هم امن و قابل اعتماد — مخصوصاً برای ساخت برنامه‌های بزرگ و پیچیده.</p>
<h2>مدیریت حافظه</h2>
<p>(Memory Management)</p>
<p>در زبان #C، مدیریت حافظه به‌صورت خودکار توسط زمان اجرای مشترک (Common Language Runtime یا CLR) انجام می‌شود.</p>
<p>به عبارت ساده‌تر:
در هنگام اجرای برنامه، یک زباله‌روب (Garbage Collector) وجود دارد که به‌طور خودکار حافظه اشیایی را که دیگر استفاده نمی‌شوند آزاد می‌کند.</p>
<p>✅ این یعنی برنامه‌نویس دیگر نیازی ندارد خودش به‌صورت دستی حافظه اشیاء را آزاد کند — چیزی که در زبان‌هایی مثل ++C ضروری بود.</p>
<p>❌ در ++C اگر فراموش می‌کردید حافظه‌ای را آزاد کنید، یا اشتباه آن را دوباره آزاد می‌کردید، برنامه‌تان با خطاهای خطرناک مثل اشاره‌گرهای نامعتبر (Dangling Pointers) روبه‌رو می‌شد.
اما در #C این مشکل به‌طور کامل از بین رفته.</p>
<p>آیا در #C اصلاً اشاره‌گر (Pointer) وجود ندارد؟
❌ خیر، زبان #C اشاره‌گرها را کاملاً حذف نکرده؛ فقط استفاده از آن‌ها را برای اکثر کارها غیرضروری کرده است.</p>
<p>در برخی موارد خاص که:</p>
<ul>
<li>
<p>عملکرد (Performance) خیلی حیاتی باشد</p>
</li>
<li>
<p>یا نیاز به تعامل با کدهای Native یا کتابخانه‌های سطح پایین باشد</p>
</li>
</ul>
<p>می‌توانید از اشاره‌گرها و مدیریت حافظه دستی استفاده کنید — اما فقط در بخش‌هایی از کد که با کلیدواژه unsafe علامت‌گذاری شده‌اند.</p>
<p>✅ بنابراین:</p>
<ul>
<li>
<p>در استفاده روزمره، شما بدون اشاره‌گر هم می‌توانید همه کارها را به‌سادگی انجام دهید.</p>
</li>
<li>
<p>اما اگر لازم باشد، #C امکان نوشتن کدهای سطح پایین و بهینه را هم در اختیار شما قرار می‌دهد — با آگاهی کامل و در محیطی ایزوله.</p>
</li>
</ul>
<h2>پشتیبانی از پلتفرم‌ها</h2>
<p>(Platform Support)</p>
<p>زبان #C اجراکننده‌هایی (Runtimes) دارد که از پلتفرم‌های زیر پشتیبانی می‌کنند:</p>
<ul>
<li>
<p>ویندوز 7 به بعد (Windows 7+)
برای ساخت اپلیکیشن‌های:</p>
<ul>
<li>
<p>دسکتاپ با رابط گرافیکی (Rich Client)</p>
</li>
<li>
<p>تحت وب (Web)</p>
</li>
<li>
<p>سمت سرور (Server)</p>
</li>
<li>
<p>خط فرمان (Command-Line)</p>
</li>
</ul>
</li>
<li>
<p>سیستم‌عامل macOS
برای ساخت:</p>
<ul>
<li>
<p>برنامه‌های تحت وب و خط فرمان</p>
</li>
<li>
<p>همچنین برنامه‌های گرافیکی از طریق فناوری Mac Catalyst</p>
</li>
</ul>
</li>
<li>
<p>لینوکس (Linux)
برای اپلیکیشن‌های:</p>
<ul>
<li>
<p>تحت وب</p>
</li>
<li>
<p>خط فرمان</p>
</li>
</ul>
</li>
<li>
<p>اندروید و iOS
برای توسعه برنامه‌های موبایل</p>
</li>
<li>
<p>دستگاه‌های ویندوز 10
مثل:</p>
<ul>
<li>
<p>Xbox</p>
</li>
<li>
<p>Surface Hub</p>
</li>
<li>
<p>HoloLens
(از طریق فناوری UWP یا Universal Windows Platform)</p>
</li>
</ul>
</li>
</ul>
<p>علاوه بر این، فناوری‌ای به نام Blazor وجود دارد که می‌تواند کدهای #C را به WebAssembly تبدیل کند تا مستقیماً در مرورگر اجرا شوند.</p>
<p>✅ این یعنی می‌توانید با استفاده از #C حتی برنامه‌های تحت وب مدرن و بدون نیاز به جاوااسکریپت بنویسید — و کدتان در مرورگر اجرا شود!</p>
<h2>محیط‌های زمان اجرا (CLRs)، کتابخانه‌های کلاس پایه (BCLs) و رانتایم‌ها</h2>
<p>برای اجرای برنامه‌های نوشته‌شده با زبان #C، به دو بخش اصلی نیاز داریم:</p>
<ol>
<li>
<p>یک زمان اجرای مشترک (Common Language Runtime یا CLR)</p>
</li>
<li>
<p>یک کتابخانه کلاس پایه (Base Class Library یا BCL)</p>
</li>
</ol>
<p>علاوه بر این‌ها، یک زمان اجرا (Runtime) ممکنه شامل لایه‌های سطح بالاتر هم باشه؛
مثلاً کتابخانه‌هایی برای توسعه:</p>
<ul>
<li>
<p>برنامه‌های دسکتاپ با رابط گرافیکی (Rich-Client)</p>
</li>
<li>
<p>برنامه‌های موبایل</p>
</li>
<li>
<p>یا برنامه‌های تحت وب</p>
</li>
</ul>
<p>📊 این ساختار معمولاً در قالب نموداری مثل شکل 1-1 نمایش داده می‌شه (که در ادامه کتاب میاد).</p>
<p><strong>چرا چند نوع Runtime وجود داره؟</strong>
💡 دلیلش اینه که:</p>
<ul>
<li>
<p>انواع مختلفی از اپلیکیشن‌ها وجود دارن (وب، موبایل، دسکتاپ، بازی و...)</p>
</li>
<li>
<p>و این اپلیکیشن‌ها باید روی پلتفرم‌های مختلف (مثل ویندوز، لینوکس، اندروید و...) اجرا بشن</p>
</li>
</ul>
<p>بنابراین برای پشتیبانی از این تنوع، نسخه‌های مختلفی از Runtimes وجود دارن —
ولی همه‌ی اون‌ها بر پایه مفاهیم CLR و BCL ساخته شده‌اند.</p>
<div align="center">
<p><img src="../../assets/image/01/Runtime-architecture.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>زمان اجرای مشترک (CLR)</h2>
<p>(Common Language Runtime)</p>
<p>CLR یا زمان اجرای مشترک، بخشی از زیرساخت #C است که خدمات حیاتی زمان اجرا را فراهم می‌کند — از جمله:</p>
<ul>
<li>
<p>مدیریت خودکار حافظه (Garbage Collection)</p>
</li>
<li>
<p>مدیریت خطاها یا استثناها (Exception Handling)</p>
</li>
</ul>
<p>🔹 واژه‌ی &quot;مشترک&quot; در نام CLR به این نکته اشاره دارد که زبان‌های مختلفی از یک Runtime یکسان استفاده می‌کنند.
برای مثال، زبان‌هایی مثل:</p>
<ul>
<li>
<p>F#</p>
</li>
<li>
<p>Visual Basic</p>
</li>
<li>
<p>Managed C++</p>
</li>
</ul>
<p>همه از همین CLR استفاده می‌کنند و با آن سازگار هستند.</p>
<p><strong>کد مدیریت‌شده (Managed Code) و زبان میانی (IL)</strong></p>
<p>زبان #C به‌عنوان یک زبان مدیریت‌شده (Managed Language) شناخته می‌شود، چون کد منبع آن ابتدا به کد مدیریت‌شده کامپایل می‌شود.</p>
<p>این کد مدیریت‌شده به‌صورت زبان میانی (Intermediate Language یا IL) ذخیره می‌شود.</p>
<p>سپس CLR این کد IL را به کد ماشین (مثلاً X64 یا X86) تبدیل می‌کند تا توسط سیستم اجرا شود.
این فرآیند تبدیل درست قبل از اجرای برنامه انجام می‌شود و به آن کامپایل در لحظه (Just-In-Time یا JIT) گفته می‌شود.</p>
<p>🔸 در برخی موارد (مثل برنامه‌های حجیم یا دستگاه‌های ضعیف‌تر)، می‌توان پیش از زمان اجرا کل برنامه را کامپایل کرد — که به آن کامپایل پیش‌زمانی (Ahead-of-Time) گفته می‌شود.
برای مثال، در اپلیکیشن‌های iOS، این روش اجباری است تا با قوانین اپ‌استور سازگار باشد.</p>
<p><strong>اسمبلی چیست؟</strong>
(Assembly)</p>
<p>کد مدیریت‌شده درون یک واحد به نام اسمبلی (Assembly) قرار می‌گیرد.</p>
<p>یک اسمبلی شامل موارد زیر است:</p>
<ul>
<li>
<p>کد IL</p>
</li>
<li>
<p>و اطلاعات نوع (Type Metadata)</p>
</li>
</ul>
<p>وجود متادیتا باعث می‌شود که اسمبلی‌ها بتوانند به نوع‌های موجود در اسمبلی‌های دیگر ارجاع دهند — بدون اینکه نیازی به فایل‌های اضافی باشد.</p>
<p><strong>ابزارهای بررسی و بازگردانی کد</strong></p>
<p>برای مشاهده و تحلیل محتوای یک اسمبلی، می‌توانید از ابزارهایی استفاده کنید:</p>
<ul>
<li>ildasm از مایکروسافت
(برای بررسی ساختار اسمبلی و IL)</li>
</ul>
<p>ابزارهایی مثل:</p>
<ul>
<li>
<p>ILSpy</p>
</li>
<li>
<p>dotPeek از JetBrains</p>
</li>
</ul>
<p>این ابزارها می‌توانند حتی IL را به کد #C بازگردانند (Decompile).
چرا؟ چون IL نسبت به کد ماشین سطح بالاتری دارد، و بنابراین بازسازی کد #C از روی آن کار شدنی و مؤثری است.</p>
<p><strong>بازتاب (Reflection) و تولید کد در زمان اجرا</strong></p>
<p>برنامه‌های نوشته‌شده با #C می‌توانند:</p>
<ul>
<li>
<p>متادیتای خود را در زمان اجرا بررسی کنند — این قابلیت را Reflection می‌نامند.</p>
</li>
<li>
<p>حتی می‌توانند در زمان اجرا کد جدید تولید کنند — با استفاده از reflection.emit</p>
</li>
</ul>
<p>✅ این ویژگی‌ها قدرت بسیار زیادی به برنامه‌نویسان می‌دهند تا برنامه‌هایی انعطاف‌پذیر، پویا، و قابل تحلیل بنویسند.</p>
<h2>کتابخانه کلاس پایه</h2>
<p>(Base Class Library)</p>
<p>هر CLR (زمان اجرای مشترک) همیشه همراه با مجموعه‌ای از اسمبلی‌ها عرضه می‌شود که به آن‌ها کتابخانه کلاس پایه (Base Class Library یا BCL) گفته می‌شود.</p>
<p>🔹 این کتابخانه، امکانات پایه و ضروری را برای برنامه‌نویسان فراهم می‌کند؛ از جمله:</p>
<ul>
<li>
<p>کالکشن‌ها (Collections) مثل لیست‌ها و دیکشنری‌ها</p>
</li>
<li>
<p>ورودی/خروجی (I/O) مثل خواندن و نوشتن فایل</p>
</li>
<li>
<p>پردازش متن</p>
</li>
<li>
<p>کار با XML و JSON</p>
</li>
<li>
<p>شبکه (Networking)</p>
</li>
<li>
<p>رمزنگاری (Encryption)</p>
</li>
<li>
<p>برقراری ارتباط با کدهای Native (Interop)</p>
</li>
<li>
<p>برنامه‌نویسی هم‌زمان (Concurrency) و پردازش موازی (Parallel Programming)</p>
</li>
</ul>
<p><strong>پشتیبانی از ویژگی‌های خود زبان #C</strong></p>
<p>کتابخانه BCL فقط امکانات عمومی نیست — بلکه نوع‌هایی را هم پیاده‌سازی می‌کند که خود زبان #C برای عملکرد درست به آن‌ها نیاز دارد؛ مثلاً:</p>
<ul>
<li>
<p>شمردن (Enumeration)</p>
</li>
<li>
<p>پرس‌وجو (Querying)</p>
</li>
<li>
<p>برنامه‌نویسی ناهمگام (Asynchrony)</p>
</li>
</ul>
<p>همچنین BCL این امکان را به شما می‌دهد که:</p>
<p>به‌صورت مستقیم به قابلیت‌های CLR دسترسی داشته باشید، مثل:</p>
<ul>
<li>
<p>بازتاب (Reflection)</p>
</li>
<li>
<p>مدیریت حافظه (Memory Management)</p>
</li>
</ul>
<p>✅ به زبان ساده‌تر:</p>
<p>BCL جعبه‌ابزار اصلی شما در برنامه‌نویسی با #C و دات‌نت است؛ تمام چیزهایی که برای ساخت برنامه‌های واقعی نیاز دارید در همین کتابخانه پایه وجود دارد.</p>
<h2>زمان اجرا (Runtime) چیست؟</h2>
<p>(Runtimes)</p>
<p>Runtime — که گاهی به آن فریم‌ورک (Framework) هم گفته می‌شود — یک بسته قابل نصب است که شما آن را دانلود و نصب می‌کنید.</p>
<p>هر Runtime شامل دو بخش اصلی است:</p>
<ol>
<li>
<p>یک CLR (زمان اجرای مشترک)</p>
</li>
<li>
<p>یک کتابخانه کلاس پایه (BCL)</p>
</li>
</ol>
<p>و در صورت نیاز، ممکنه شامل یک لایه‌ی مخصوص برای نوع خاصی از اپلیکیشن هم باشد، مثل:</p>
<ul>
<li>
<p>برنامه‌های وب</p>
</li>
<li>
<p>اپلیکیشن‌های موبایل</p>
</li>
<li>
<p>برنامه‌های دسکتاپ با رابط گرافیکی (Rich Client)</p>
</li>
</ul>
<p>🔹 اگر دارید یک برنامه خط فرمان (Command-Line) یا یک کتابخانه بدون واسط کاربری (Non-UI Library) می‌نویسید،
نیازی به این لایه‌های اضافه نخواهید داشت.</p>
<p><strong>وقتی برنامه‌ای می‌نویسید، چه Runtimeی را هدف قرار می‌دهید؟</strong></p>
<p>وقتی برنامه‌ای می‌نویسید، مشخص می‌کنید که کدام Runtime هدف برنامه‌ی شماست.
این یعنی:</p>
<ul>
<li>
<p>برنامه‌ی شما از امکاناتی استفاده می‌کند که آن Runtime در اختیارش می‌گذارد</p>
</li>
<li>
<p>برنامه‌تان به همان Runtime وابسته است</p>
</li>
</ul>
<p>همچنین، نوع Runtimeی که انتخاب می‌کنید تعیین می‌کند برنامه‌تان روی چه پلتفرم‌هایی قابل اجراست.</p>
<p>✅ مثلاً:</p>
<p>اگر از .NET MAUI استفاده کنید، می‌تونید برنامه‌تان را برای اندروید، iOS، ویندوز و مک بسازید.
ولی اگر از ASP.NET Core استفاده کنید، برنامه‌ی شما برای تحت‌وب بودن طراحی می‌شه.</p>
<p>جدول زیر گزینه‌های اصلی محیط‌های اجرایی را فهرست می‌کند:</p>
<div align="center">
<p><img src="../../assets/image/01/Introduction-02.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>تصویر ۱-۲ این اطلاعات را به صورت گرافیکی نمایش می‌دهد و همچنین به عنوان راهنمایی برای مطالبی که در کتاب پوشش داده شده‌اند، عمل می‌کند.</p>
<div align="center">
<p><img src="../../assets/image/01/Introduction-03.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>.NET 8 چیست؟</h2>
<p>(.NET 8)</p>
<p>.NET 8 زمان اجرای اصلی و متن‌باز مایکروسافت محسوب می‌شود.</p>
<p>با استفاده از .NET 8 می‌توانید انواع مختلفی از برنامه‌ها بنویسید، از جمله:</p>
<ul>
<li>
<p>برنامه‌های وب و خط فرمان (Console)
که روی سیستم‌عامل‌های:</p>
<ul>
<li>
<p>ویندوز</p>
</li>
<li>
<p>لینوکس</p>
</li>
<li>
<p>macOS
قابل اجرا هستند.</p>
</li>
</ul>
</li>
<li>
<p>برنامه‌های دسکتاپ با رابط کاربری غنی (Rich-Client Applications)
که روی:</p>
<ul>
<li>
<p>ویندوز 10 و نسخه‌های جدیدتر</p>
</li>
<li>
<p>macOS
اجرا می‌شوند.</p>
</li>
</ul>
</li>
<li>
<p>برنامه‌های موبایل
که روی:</p>
<ul>
<li>
<p>iOS</p>
</li>
<li>
<p>Android
اجرا می‌شوند.</p>
</li>
</ul>
</li>
</ul>
<p>📘 این کتاب تمرکز اصلی‌اش بر روی CLR و BCL در .NET 8 است.</p>
<p><strong>تفاوت با .NET Framework</strong></p>
<p>برخلاف .NET Framework که به‌صورت پیش‌فرض روی ویندوز نصب بود،
.NET 8 به‌صورت پیش‌فرض روی ویندوز نصب نیست.</p>
<p>❗ بنابراین، اگر برنامه‌ای با .NET 8 بنویسید و بخواهید روی سیستمی اجرا کنید که .NET 8 نصب ندارد، پیامی نمایش داده می‌شود که از شما می‌خواهد Runtime را از یک صفحه وب دانلود کنید.</p>
<p>✅ برای جلوگیری از این مشکل، می‌توانید برنامه را به‌صورت Self-Contained Deployment منتشر کنید؛
یعنی تمام اجزای موردنیاز از Runtime داخل فایل برنامه گنجانده می‌شوند.</p>
<p>تاریخچه نسخه‌های .NET
تاریخچه انتشار نسخه‌های اصلی به این صورت است:</p>
<pre><code>.NET Core 1.x  
→ .NET Core 2.x  
→ .NET Core 3.x  
→ .NET 5  
→ .NET 6  
→ .NET 7  
→ .NET 8
</code></pre>
<p>🔹 بعد از .NET Core 3، مایکروسافت واژه‌ی &quot;Core&quot; را از نام نسخه‌ها حذف کرد.
🔹 همچنین نسخه‌ی 4 را کاملاً رد کرد تا با .NET Framework 4.x که نسخه‌ای کاملاً متفاوت و قدیمی‌تر است اشتباه گرفته نشود.</p>
<p><strong>سازگاری نسخه‌ها</strong></p>
<ul>
<li>
<p>اسمبلی‌هایی که با .NET Core 1 تا .NET 7 ساخته شده‌اند، در بیشتر موارد بدون تغییر روی .NET 8 اجرا می‌شوند.</p>
</li>
<li>
<p>اما اسمبلی‌هایی که با .NET Framework (هر نسخه‌ای) ساخته شده‌اند، معمولاً با .NET 8 ناسازگار هستند.</p>
</li>
</ul>
<h2>برنامه‌های دسکتاپ ویندوز و WinUI 3</h2>
<p>(Windows Desktop and WinUI 3)</p>
<p>برای نوشتن برنامه‌های دسکتاپ با رابط کاربری غنی که روی ویندوز 10 و نسخه‌های جدیدتر اجرا شوند، می‌توانید از بین دو گزینه انتخاب کنید:</p>
<ul>
<li>
<p>رابط‌های برنامه‌نویسی کلاسیک دسکتاپ ویندوز (Windows Desktop APIs)
مانند:</p>
<ul>
<li>
<p>Windows Forms</p>
</li>
<li>
<p>WPF (Windows Presentation Foundation)</p>
</li>
<li>
<p>WinUI 3</p>
</li>
</ul>
</li>
</ul>
<p><strong>تفاوت‌ها و نکات مهم</strong></p>
<ul>
<li>
<p>Windows Desktop APIs جزئی از Runtime دسکتاپ دات‌نت (.NET Desktop Runtime) هستند.</p>
</li>
<li>
<p>اما WinUI 3 بخشی از Windows App SDK است که باید به‌صورت جداگانه دانلود و نصب شود.</p>
</li>
</ul>
<p><strong>تاریخچه و پشتیبانی</strong></p>
<ul>
<li>
<p>رابط‌های کلاسیک دسکتاپ ویندوز از سال ۲۰۰۶ وجود دارند و از نظر کتابخانه‌های شخص ثالث بسیار قوی هستند.</p>
</li>
<li>
<p>همچنین سوالات و پاسخ‌های زیادی درباره‌ی آن‌ها در سایت‌هایی مثل StackOverflow وجود دارد که یادگیری و رفع اشکال را آسان می‌کند.</p>
</li>
<li>
<p>WinUI 3 در سال ۲۰۲۲ منتشر شده و هدف آن نوشتن برنامه‌های مدرن و جذاب است که از آخرین کنترل‌ها و امکانات ویندوز ۱۰ و بالاتر بهره می‌برند.</p>
</li>
<li>
<p>این فناوری جانشین Universal Windows Platform (UWP) به‌شمار می‌رود.</p>
</li>
</ul>
<p>✅ اگر می‌خواهید برنامه‌های دسکتاپی با ظاهر و قابلیت‌های به‌روز بسازید، WinUI 3 انتخاب مناسبی است، ولی اگر دنبال راه‌حلی پایدار و با پشتیبانی گسترده هستید، می‌توانید از Windows Forms یا WPF استفاده کنید.</p>
<h2>MAUI</h2>
<p>(Multi-platform App UI)</p>
<p>MAUI بیشتر برای ساخت برنامه‌های موبایل روی iOS و اندروید طراحی شده است، اما می‌توان از آن برای ساخت برنامه‌های دسکتاپ روی macOS و ویندوز نیز استفاده کرد،
که این کار از طریق فناوری‌هایی مانند Mac Catalyst و WinUI 3 انجام می‌شود.</p>
<p>MAUI ادامه و تکامل پروژه Xamarin است و به شما اجازه می‌دهد که با یک پروژه، برنامه‌تان را برای چند پلتفرم مختلف بسازید.</p>
<p><strong>Avalonia</strong></p>
<p>برای ساخت برنامه‌های دسکتاپ چندسکویی (Cross-platform)،
کتابخانه‌ی شخص ثالثی به نام Avalonia وجود دارد که جایگزینی برای MAUI به شمار می‌رود.</p>
<p>ویژگی‌های Avalonia:</p>
<ul>
<li>
<p>روی لینوکس نیز اجرا می‌شود</p>
</li>
<li>
<p>معماری ساده‌تری نسبت به MAUI دارد (چون از لایه‌های میانی مانند Catalyst یا WinUI استفاده نمی‌کند)</p>
</li>
<li>
<p>API آن شبیه به WPF است</p>
</li>
<li>
<p>یک افزونه تجاری به نام XPF دارد که تقریباً سازگاری کامل با WPF را فراهم می‌کند.</p>
</li>
</ul>
<p><strong>.NET Framework</strong></p>
<p>.NET Framework نسخه‌ی اولیه و قدیمی‌تر مایکروسافت است که فقط برای برنامه‌های تحت ویندوز طراحی شده:</p>
<ul>
<li>
<p>برنامه‌های وب</p>
</li>
<li>
<p>برنامه‌های دسکتاپ و سرور ویندوز</p>
</li>
</ul>
<p>مایکروسافت برنامه‌ای برای انتشار نسخه‌های جدید این فریم‌ورک ندارد، ولی همچنان نسخه‌ی 4.8 را پشتیبانی و نگهداری می‌کند،
چون تعداد زیادی برنامه قدیمی بر اساس آن ساخته شده‌اند.</p>
<p><strong>تفاوت‌های مهم درباره .NET Framework و .NET 8</strong></p>
<ul>
<li>
<p>در .NET Framework، CLR و BCL با لایه‌ی اپلیکیشن کاملاً یکپارچه هستند.</p>
</li>
<li>
<p>برنامه‌هایی که با .NET Framework نوشته شده‌اند، می‌توانند تحت .NET 8 مجدداً کامپایل شوند،
ولی معمولاً به تغییراتی نیاز دارند.</p>
</li>
<li>
<p>برخی قابلیت‌های .NET Framework در .NET 8 وجود ندارند، و بالعکس.</p>
</li>
</ul>
<p><strong>نصب و نسخه‌های C#</strong></p>
<ul>
<li>
<p>.NET Framework به‌صورت پیش‌فرض روی ویندوز نصب است و از طریق Windows Update به‌روزرسانی می‌شود.</p>
</li>
<li>
<p>اگر برنامه‌تان را روی .NET Framework 4.8 هدف قرار دهید، می‌توانید از ویژگی‌های زبان C# 7.3 و نسخه‌های قبل استفاده کنید.</p>
</li>
<li>
<p>البته می‌توانید نسخه‌ی زبان جدیدتر را در فایل پروژه تنظیم کنید تا برخی قابلیت‌های جدید فعال شود (البته به جز ویژگی‌هایی که به Runtime جدید نیاز دارند).</p>
</li>
</ul>
<p><strong>توضیح اصطلاحات “.NET”</strong></p>
<p>واژه‌ی “.NET” همیشه به عنوان اصطلاح کلی برای همه‌ی فناوری‌هایی که این کلمه را در نامشان دارند استفاده شده، مثل:</p>
<ul>
<li>
<p>.NET Framework</p>
</li>
<li>
<p>.NET Core</p>
</li>
<li>
<p>.NET Standard</p>
</li>
<li>
<p>و غیره</p>
</li>
</ul>
<p>این باعث شده که نامگذاری جدید مایکروسافت (که .NET Core را به صرفه .NET تغییر داده) گاهی اوقات گیج‌کننده باشد.</p>
<p>📌 در این کتاب:</p>
<ul>
<li>
<p>وقتی به نسخه‌های جدید اشاره می‌کنیم، از عبارت “.NET 5+” استفاده می‌کنیم.</p>
</li>
<li>
<p>و برای اشاره به کل دنباله‌ی .NET Core و نسخه‌های جدیدتر، می‌گوییم “.NET Core و .NET 5+”.</p>
</li>
</ul>
<p>همچنین، اگرچه .NET (5+) یک فریم‌ورک است،
اما با .NET Framework قدیمی کاملاً متفاوت است،
پس تا جایی که ممکن است در این کتاب از اصطلاح runtime به جای framework استفاده می‌کنیم تا ابهام کمتر شود.</p>
<h2>محیط‌های اجرایی خاص Niche Runtimes</h2>
<p>علاوه بر Runtimeهای اصلی، چند Runtime خاص و تخصصی نیز وجود دارد:</p>
<p><strong>Unity</strong></p>
<p>Unity یک پلتفرم توسعه بازی است که به شما امکان می‌دهد منطق بازی را با زبان #C بنویسید.</p>
<p><strong>Universal Windows Platform (UWP)</strong></p>
<p>UWP برای نوشتن برنامه‌هایی طراحی شده که اولویت‌شان صفحه‌نمایش لمسی (Touch-First) است و روی ویندوز ۱۰ به بالا اجرا می‌شوند،
از جمله دستگاه‌هایی مثل:</p>
<ul>
<li>
<p>Xbox</p>
</li>
<li>
<p>Surface Hub</p>
</li>
<li>
<p>HoloLens</p>
</li>
</ul>
<p>برنامه‌های UWP در محیطی ایزوله (Sandbox) اجرا می‌شوند و معمولاً از طریق Windows Store منتشر می‌شوند.</p>
<p>UWP از نسخه‌ای از CLR/BCL دات‌نت کور 2.2 استفاده می‌کند،
و به‌احتمال زیاد این نسخه به‌روزرسانی نخواهد شد.
مایکروسافت به کاربران توصیه کرده به جای UWP از جایگزین مدرن آن، یعنی WinUI 3 استفاده کنند.</p>
<p>اما چون WinUI 3 فقط از برنامه‌های دسکتاپ ویندوز پشتیبانی می‌کند،
UWP هنوز برای هدف‌گذاری روی Xbox، Surface Hub و HoloLens کاربرد خاص خود را دارد.</p>
<p><strong>.NET Micro Framework</strong></p>
<p>.NET Micro Framework برای اجرای کد دات‌نت روی دستگاه‌های بسیار محدود از نظر منابع طراحی شده است،
مثلاً دستگاه‌هایی که کمتر از یک مگابایت حافظه دارند.</p>
<p><strong>اجرای کد مدیریت شده داخل SQL Server</strong></p>
<p>امکان اجرای کدهای مدیریت شده (#C) داخل SQL Server هم وجود دارد.
با استفاده از قابلیت SQL Server CLR integration، می‌توانید:</p>
<ul>
<li>
<p>توابع سفارشی</p>
</li>
<li>
<p>روال‌های ذخیره شده (Stored Procedures)</p>
</li>
<li>
<p>و عملگرهای جمعی (Aggregations)</p>
</li>
</ul>
<p>را با زبان #C بنویسید و سپس در کوئری‌های SQL خود فراخوانی کنید.</p>
<p>این ویژگی با .NET Framework و یک CLR ویژه که در محیطی ایزوله (Sandbox) اجرا می‌شود کار می‌کند،
تا از صحت و امنیت پردازش‌های SQL Server محافظت کند.</p>
<h2>تاریخچه‌ای کوتاه از سی‌شارپ</h2>
<p>در ادامه، ویژگی‌های جدید هر نسخه از زبان #C به ترتیب زمانی معکوس فهرست شده‌اند،
تا برای خوانندگانی که با نسخه‌های قدیمی‌تر زبان آشنا هستند، مفید باشد.</p>
<h2>ویژگی‌های جدید در #C 12</h2>
<p>نسخه‌ی ۱۲ زبان #C همراه با Visual Studio 2022 عرضه شده است و زمانی استفاده می‌شود که هدف برنامه،
نسخه‌ی .NET 8 باشد.</p>
<h2>عبارات مجموعه‌ای (Collection Expressions)</h2>
<p>قبلاً برای مقداردهی اولیه یک آرایه، مثلاً آرایه‌ای از حروف صدادار، از این شکل استفاده می‌کردید:</p>
<pre><code class="language-csharp">char[] vowels = {'a','e','i','o','u'};
</code></pre>
<p>اما حالا می‌توانید از براکت‌های مربعی (علامت []) به این صورت استفاده کنید:</p>
<pre><code class="language-csharp">char[] vowels = ['a','e','i','o','u'];
</code></pre>
<p><strong>مزایای عبارات مجموعه‌ای</strong></p>
<p>عبارات مجموعه‌ای دو مزیت بزرگ دارند:</p>
<ol>
<li>قابلیت استفاده در انواع دیگر مجموعه‌ها</li>
</ol>
<p>همین نگارش می‌تواند برای انواع مختلف مجموعه‌ها استفاده شود، مثل لیست‌ها، مجموعه‌ها (Set) و حتی نوع‌های پایین‌رده مثل Span:</p>
<pre><code class="language-csharp">List&lt;char&gt; list         = ['a','e','i','o','u'];
HashSet&lt;char&gt; set       = ['a','e','i','o','u'];
ReadOnlySpan&lt;char&gt; span = ['a','e','i','o','u'];
</code></pre>
<ol start="2">
<li>هدف‌مند بودن نوع (Target-typed)</li>
</ol>
<p>یعنی کامپایلر می‌تواند نوع مجموعه را در بسیاری از موقعیت‌ها حدس بزند، و شما نیازی به نوشتن نوع ندارید، مثل وقتی که آرایه را به عنوان آرگومان به یک متد می‌دهید:</p>
<pre><code class="language-csharp">Foo(['a','e','i','o','u']);

void Foo(char[] letters) { ... }
</code></pre>
<p>برای جزئیات بیشتر، می‌توانید به بخش «Collection Initializers and Collection Expressions» در صفحه ۲۰۵ مراجعه کنید.</p>
<h2>سازنده‌های اولیه در کلاس‌ها و استراکچرها  Primary constructors in classes and structs</h2>
<p>(Primary Constructors in Classes and Structs)</p>
<p>از نسخه #C 12 به بعد، می‌تونید لیست پارامترهای سازنده رو مستقیم بعد از تعریف کلاس یا استراکچر بنویسید.
برای مثال:</p>
<pre><code class="language-csharp">class Person (string firstName, string lastName)
{
    public void Print() =&gt; Console.WriteLine(firstName + &quot; &quot; + lastName);
}
</code></pre>
<p>در اینجا، کامپایلر به‌طور خودکار یک سازنده اولیه (Primary Constructor) برای کلاس Person می‌سازه.
بنابراین می‌تونید مثل زیر ازش استفاده کنید:</p>
<pre><code class="language-csharp">Person p = new Person(&quot;Alice&quot;, &quot;Jones&quot;);
p.Print();    // خروجی: Alice Jones
</code></pre>
<p><strong>تفاوت با Recordها</strong></p>
<p>این قابلیت از #C 9 برای record‌ها وجود داشت،
اما در recordها، کامپایلر به‌صورت پیش‌فرض برای هر پارامتر یک property عمومی فقط‌خواندنی (init-only) هم می‌سازه.</p>
<p>اما در کلاس‌ها و استراکچرها این اتفاق نمی‌افته.
اگر بخواهید پارامترهای سازنده اولیه را به صورت Property در اختیار داشته باشید، باید خودتان به‌طور صریح آن‌ها را تعریف کنید:</p>
<pre><code class="language-csharp">class Person (string firstName, string lastName)
{
    public string FirstName { get; set; } = firstName;
    public string LastName { get; set; } = lastName;
}
</code></pre>
<p>✅ سازنده‌های اولیه برای سناریوهای ساده، بسیار مفید و تمیز هستند.
جزئیات بیشتر درباره تفاوت‌ها و محدودیت‌های آن‌ها در بخش
“Primary Constructors (C# 12)” در صفحه ۱۱۹ ارائه شده است.</p>
<h2>پارامتر پیش‌فرض در لامبداها Default lambda parameters</h2>
<p>در #C، مثل همیشه می‌تونید برای پارامترهای یک متد مقدار پیش‌فرض تعیین کنید:</p>
<pre><code class="language-csharp">void Print(string message = &quot;&quot;) =&gt; Console.WriteLine(message);
</code></pre>
<p>حالا در نسخه #C 12، همین امکان برای لامبداها (Lambda Expressions) هم فراهم شده:</p>
<pre><code class="language-csharp">var print = (string message = &quot;&quot;) =&gt; Console.WriteLine(message);

print(&quot;Hello&quot;);  // خروجی: Hello  
print();         // خروجی: (هیچ‌چیز)
</code></pre>
<p>✅ این قابلیت خصوصاً در کتابخانه‌هایی مثل ASP.NET Minimal API بسیار مفید است،
چون اجازه می‌دهد تابع‌ها انعطاف‌پذیرتر باشند و پارامترهای اختیاری داشته باشند.</p>
<h2>تعریف نام مستعار (Alias) برای هر نوع</h2>
<p>قبلاً در #C فقط می‌تونستید با استفاده از دستور using برای نوع‌های ساده یا جنریک نام مستعار تعریف کنید.
برای مثال:</p>
<pre><code class="language-csharp">using ListOfInt = System.Collections.Generic.List&lt;int&gt;;
var list = new ListOfInt();
</code></pre>
<p>ولی حالا در #C 12، می‌تونید برای انواع دیگری مثل آرایه‌ها و Tupleها هم alias تعریف کنید:</p>
<pre><code class="language-csharp">using NumberList = double[];
using Point = (int X, int Y);

NumberList numbers = { 2.5, 3.5 };
Point p = (3, 4);
</code></pre>
<p>✅ این باعث می‌شه کد خواناتر و قابل نگهداری‌تر بشه — مخصوصاً وقتی از نوع‌های پیچیده به دفعات استفاده می‌کنید.</p>
<h2>سایر ویژگی‌های جدید</h2>
<p>سی‌شارپ ۱۲ همچنین از ویژگی جدیدی به نام آرایه‌های درون‌خطی (Inline Arrays) پشتیبانی می‌کند.
این ویژگی از طریق اتریبیوت:</p>
<pre><code class="language-csharp">[System.Runtime.CompilerServices.InlineArray]
</code></pre>
<p>قابل استفاده است.</p>
<p>🔹 با استفاده از آن می‌توانید درون یک struct، آرایه‌هایی با اندازه ثابت بسازید — بدون اینکه نیاز به قرار دادن کد در بلاک unsafe داشته باشید.
🔹 این قابلیت بیشتر برای استفاده در APIهای سطح پایین و داخلیِ runtime طراحی شده است.</p>
<h2>ویژگی‌های جدید در C# 11</h2>
<p>(What’s New in C# 11)</p>
<p>#C 11 همراه با Visual Studio 2022 منتشر شد،
و زمانی به‌صورت پیش‌فرض استفاده می‌شود که هدف پروژه، .NET 7 باشد.</p>
<p><strong>رشته‌های خام (Raw String Literals)</strong></p>
<p>در C# 11، اگر یک رشته را با سه علامت نقل قول یا بیشتر (مثل &quot;&quot;&quot;) بنویسید،
به آن رشته خام (Raw String Literal) گفته می‌شود.</p>
<p>✅ این نوع رشته می‌تواند هر کاراکتری را شامل شود — بدون اینکه نیاز به Escape کردن یا تکرار نقل قول‌ها داشته باشید.</p>
<p>برای مثال، تعریف یک رشته خام برای نمایش XML:</p>
<pre><code class="language-csharp">string raw = &quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;;
</code></pre>
<p>🟢 رشته‌های خام می‌توانند چندخطی باشند، و حتی می‌توانند از درج مقادیر (String Interpolation) با پیشوند $ پشتیبانی کنند:</p>
<pre><code class="language-csharp">string multiLineRaw = $&quot;&quot;&quot;
  Line 1
  Line 2
  The date and time is {DateTime.Now}
&quot;&quot;&quot;;
</code></pre>
<p><strong>درج آکولاد داخل رشته‌های خام</strong></p>
<p>اگر بخواهید آکولاد {} واقعی را داخل رشته نگه دارید، می‌توانید با استفاده از دو $ یا بیشتر در ابتدای رشته،
الگوی درج مقادیر را تغییر دهید (تا به جای {} از { {} } یا { { {} } } استفاده شود):</p>
<pre><code class="language-csharp">Console.WriteLine($$&quot;&quot;&quot;{ &quot;TimeStamp&quot;: &quot;&quot; }&quot;&quot;&quot;);
</code></pre>
<p>// خروجی: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }
📘 برای توضیح کامل‌تر این ویژگی، به بخش‌های:</p>
<ul>
<li>
<p>«رشته‌های خام (Raw String Literals)» در صفحه ۵۹</p>
</li>
<li>
<p>«درج مقادیر در رشته‌ها (String Interpolation)» در صفحه ۶۰
مراجعه کنید.</p>
</li>
</ul>
<h3>رشته‌های UTF-8</h3>
<p>(UTF-8 Strings)</p>
<p>از نسخه #C 11، می‌توانید رشته‌هایی را با پسوند u8 تعریف کنید،
که به‌جای اینکه به‌صورت پیش‌فرض در قالب UTF-16 باشند، به‌صورت UTF-8 کدگذاری می‌شوند.</p>
<p>🔹 این ویژگی برای سناریوهای پیشرفته طراحی شده،
مثلاً وقتی می‌خواهید متن JSON را با عملکرد بالا و مصرف کم حافظه پردازش کنید.</p>
<p>مثال:</p>
<pre><code class="language-csharp">ReadOnlySpan&lt;byte&gt; utf8 = &quot;ab→cd&quot;u8;  // → سه بایت مصرف می‌کند
Console.WriteLine(utf8.Length);      // خروجی: 7
</code></pre>
<p>نوع این مقدار، ReadOnlySpan<byte> است (توضیح آن در فصل ۲۳ آمده).
برای تبدیل آن به آرایه بایت می‌توانید از ToArray() استفاده کنید.</p>
<h3>الگوهای لیستی (List Patterns)</h3>
<p>الگوهای لیستی اجازه می‌دهند که ساختار و محتوای یک مجموعه را بررسی (Pattern Match) کنید.
این الگوها با براکت‌های مربعی [] تعریف می‌شن و روی هر مجموعه‌ای قابل استفاده‌اند که:</p>
<ul>
<li>
<p>دارای تعداد عناصر (Count یا Length) باشد</p>
</li>
<li>
<p>و از طریق ایندکس (Indexer) قابل دسترسی باشد (مثل آرایه‌ها یا لیست‌ها)</p>
</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">int[] numbers = { 0, 1, 2, 3, 4 };
Console.WriteLine(numbers is [0, 1, 2, 3, 4]);  // خروجی: True
</code></pre>
<p>🔸 علامت _ با هر مقدار دلخواه در یک موقعیت مطابقت دارد:</p>
<pre><code class="language-csharp">Console.WriteLine(numbers is [_, 1, .., 4]);    // خروجی: True
</code></pre>
<p>🔸 دو نقطه .. نشان‌دهنده‌ی یک بُرش (Slice) است — یعنی صفر یا چند عنصر در وسط.</p>
<p>📘 همچنین می‌توانید از var بعد از slice برای گرفتن بخش میانی استفاده کنید.
توضیحات کامل در بخش «List Patterns» در صفحه ۲۴۳ ارائه شده است.</p>
<h3>اعضای اجباری (Required Members)</h3>
<p>با استفاده از کلیدواژه‌ی required در تعریف یک فیلد یا Property،
کامپایلر مجبور می‌کنه که هر کسی این کلاس یا struct رو می‌سازه،
حتماً آن عضو را مقداردهی کند — مثلاً از طریق Object Initializer.</p>
<p>مثال:</p>
<pre><code class="language-csharp">class Asset { public required string Name; }

Asset a1 = new Asset { Name = &quot;House&quot; };  // ✅ مجاز  
Asset a2 = new Asset();                   // ❌ خطا — مقداردهی نشده!
</code></pre>
<p>✅ این ویژگی کمک می‌کنه نیازی به نوشتن سازنده‌هایی با پارامترهای زیاد نداشته باشید،
که این موضوع در کلاس‌های فرزند (Subclasses) ساده‌سازی بزرگی به‌حساب می‌آد.</p>
<p>🔸 اگه خواستید هم سازنده (Constructor) بنویسید و هم از required استفاده کنید،
می‌تونید از اتریبیوت [SetsRequiredMembers] روی سازنده استفاده کنید تا از محدودیت عبور کنید.</p>
<p>📘 توضیحات بیشتر در بخش «Required members (C# 11)» در صفحه ۱۳۶ موجوده.</p>
<h3>اعضای استاتیک مجازی/انتزاعی در اینترفیس‌ها Static virtual/abstract interface members</h3>
<p>از نسخه C# 11، امکان جدیدی اضافه شده که به شما اجازه می‌دهد درون یک Interface، متدهای استاتیک با نوع virtual یا abstract تعریف کنید.</p>
<p>مثال:</p>
<pre><code class="language-csharp">public interface IParsable&lt;TSelf&gt;
{
    static abstract TSelf Parse(string s);
}
</code></pre>
<p>🔹 این یعنی کلاس یا structی که این اینترفیس را پیاده‌سازی می‌کند، باید یک تابع استاتیک با همین امضا ارائه دهد.</p>
<p>📌 مزیت اصلی:
می‌توان این توابع را به‌صورت پلی‌مورفیک (چندریخت) فراخوانی کرد، با استفاده از یک پارامتر generic که محدود به آن Interface شده:</p>
<pre><code class="language-csharp">T ParseAny&lt;T&gt;(string s) where T : IParsable&lt;T&gt; =&gt; T.Parse(s);
</code></pre>
<p>✅ حتی می‌توانید توابع عملگر (Operators) مثل +, -, *, / را هم به صورت static virtual یا static abstract در اینترفیس‌ها تعریف کنید.</p>
<p>📘 برای اطلاعات بیشتر:</p>
<ul>
<li>
<p>«Static virtual/abstract interface members» در صفحه ۱۵۳</p>
</li>
<li>
<p>«Static Polymorphism» در صفحه ۲۶۰</p>
</li>
<li>
<p>و همچنین نحوه‌ی فراخوانی این متدهای استاتیک از طریق Reflection در صفحه ۸۲۶</p>
</li>
</ul>
<h3>ریاضی عمومی (Generic Math)</h3>
<p>از نسخه .NET 7، اینترفیس جدیدی به نام:</p>
<pre><code class="language-csharp">System.Numerics.INumber&lt;TSelf&gt;
</code></pre>
<p>معرفی شده که امکان انجام عملیات ریاضی روی نوع‌های عددی به‌صورت Generic را فراهم می‌کند.</p>
<p>مثلاً می‌توان یک متد جمع‌زن (Sum) نوشت که برای هر نوع عددی کار کند:</p>
<pre><code class="language-csharp">T Sum&lt;T&gt;(T[] numbers) where T : INumber&lt;T&gt;
{
    T total = T.Zero;
    foreach (T n in numbers)
        total += n;  // عملگر + برای هر نوع عددی فراخوانی می‌شود
    return total;
}
</code></pre>
<p>و حالا می‌توانید این تابع را روی انواع مختلفی صدا بزنید:</p>
<pre><code class="language-csharp">int intSum = Sum(new[] { 3, 5, 7 });
double doubleSum = Sum(new[] { 3.2, 5.3, 7.1 });
decimal decimalSum = Sum(new[] { 3.2m, 5.3m, 7.1m });
</code></pre>
<p>✅ رابط INumber<TSelf> توسط تمام انواع عددی حقیقی و صحیح در دات‌نت (و حتی char) پیاده‌سازی شده است.</p>
<p>این رابط شامل تعاریف عملگرها به‌صورت static abstract هم هست، مثل:</p>
<pre><code class="language-csharp">static abstract TResult operator + (TSelf left, TOther right);
</code></pre>
<p>📘 این موضوعات در بخش‌های:</p>
<ul>
<li>
<p>«Polymorphic Operators» در صفحه ۲۶۱</p>
</li>
<li>
<p>و «Generic Math» در صفحه ۲۶۲
به‌طور کامل توضیح داده شده‌اند.</p>
</li>
</ul>
<h3>سایر ویژگی‌های جدید در C# 11</h3>
<p>(Other New Features in C# 11)</p>
<p>🔸 دسترسی فایل (File Accessibility Modifier)</p>
<p>از نسخه #C 11 می‌توانید با استفاده از کلمه کلیدی file، یک کلاس یا نوع را فقط در همان فایل منبع قابل دسترس کنید:</p>
<pre><code class="language-csharp">file class Foo { ... }
</code></pre>
<p>✅ این ویژگی مخصوصاً برای source generator‌ها طراحی شده،
جایی که نیاز دارید نوع‌هایی بسازید که فقط در محدوده همان فایل قابل استفاده باشند و به بیرون درز نکنند.</p>
<p><strong>🔸 عملگرهای بررسی‌شده (Checked Operators)</strong></p>
<p>در C# 11 امکان تعریف عملگرهایی که داخل بلاک‌های checked فراخوانی می‌شوند فراهم شده است.
این قابلیت برای پیاده‌سازی کامل ریاضی generic ضروری بود.</p>
<p>📘 برای اطلاعات بیشتر، به بخش &quot;Checked operators&quot; در صفحه ۲۵۸ مراجعه کنید.</p>
<p><strong>🔸 تسهیل مقداردهی اولیه در سازنده Structها</strong></p>
<p>در نسخه‌های قبلی، سازنده‌های Struct باید تمام فیلدها را مقداردهی می‌کردند.
در C# 11 این محدودیت سبک‌تر شده و اجباری نیست که همه فیلدها درون سازنده مقداردهی شوند.</p>
<p>📘 توضیح کامل در &quot;Struct Construction Semantics&quot; در صفحه ۱۴۲ آمده است.</p>
<p><strong>🔸 بهبود در نوع‌های عددی هم‌اندازه با معماری سیستم (nint و nuint)</strong></p>
<p>در نسخه C# 9، دو نوع جدید معرفی شده بود:</p>
<ul>
<li>
<p>nint (عدد صحیح native-size)</p>
</li>
<li>
<p>nuint (عدد صحیح بدون علامت native-size)</p>
</li>
</ul>
<p>این نوع‌ها بسته به سیستم عامل، به‌اندازه‌ی فضای آدرس‌دهی اجرا در زمان اجرا هستند:
مثلاً در سیستم‌های ۶۴ بیتی، این عددها ۶۴ بیتی‌اند و در سیستم‌های ۳۲ بیتی، ۳۲ بیتی.</p>
<p>در C# 11 (در صورتی که هدف پروژه .NET 7 یا بالاتر باشد)، تفاوت در زمان کامپایل بین این نوع‌ها و نوع‌های پایه‌شان:</p>
<ul>
<li>
<p>IntPtr</p>
</li>
<li>
<p>UIntPtr</p>
</li>
</ul>
<p>عملاً از بین رفته است، و رفتارشان یکپارچه‌تر شده.</p>
<p>📘 برای توضیح کامل به بخش &quot;Native-Sized Integers&quot; در صفحه ۲۶۶ مراجعه کنید.</p>
<h2>✨ چه چیزهایی در C# 10 جدید هستند؟</h2>
<p>(What’s New in C# 10)</p>
<h3>📁 فضای نام در سطح فایل (File-Scoped Namespaces)</h3>
<p>در شرایطی که تمام کلاس‌ها یا نوع‌ها در یک فایل، داخل یک فضای نام (namespace) قرار دارند، C# 10 به شما اجازه می‌ده با یک اعلان کوتاه‌تر و ساده‌تر، از تورفتگی‌های اضافی جلوگیری کنید:</p>
<pre><code class="language-csharp">namespace MyNamespace;  // این فضای نام برای کل فایل اعمال می‌شود

class Class1 {}         // درون MyNamespace
class Class2 {}         // درون MyNamespace
</code></pre>
<p>✅ این کار، کد شما رو مرتب‌تر، کوتاه‌تر و خواناتر می‌کنه.</p>
<h3>🌍 دستور global using</h3>
<p>با اضافه کردن کلیدواژه‌ی global قبل از دستور using،
می‌تونید اون namespace رو به تمام فایل‌های پروژه اعمال کنید:</p>
<pre><code class="language-csharp">global using System;
global using System.Collections.Generic;
</code></pre>
<p>✅ به این ترتیب، دیگه نیازی نیست توی هر فایل دوباره using بنویسید.</p>
<p>🔹 حتی می‌تونید از global using static هم استفاده کنید.</p>
<p>🛠 علاوه بر این، در پروژه‌های .NET 6، یک ویژگی جدید به نام Implicit Global Usings اضافه شده.
اگه در فایل پروژه (csproj) بنویسید:</p>
<pre><code class="language-xml">&lt;ImplicitUsings&gt;true&lt;/ImplicitUsings&gt;
</code></pre>
<p>تعدادی از namespaceهای پرکاربرد، به‌صورت خودکار وارد پروژه می‌شن (بسته به نوع پروژه‌تون).
📘 جزئیات بیشتر در صفحه ۹۶: «The global using Directive»</p>
<h3>✍️ تغییر بدون تخریب روی نوع‌های ناشناس</h3>
<p>(Nondestructive Mutation for Anonymous Types)</p>
<p>در C# 9، با کلیدواژه‌ی with می‌تونستید مقادیر جدیدی به recordها بدید بدون اینکه شیء اصلی تغییر کنه.</p>
<p>در C# 10، این قابلیت برای نوع‌های ناشناس (anonymous types) هم اضافه شده:</p>
<pre><code class="language-csharp">var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 };

Console.WriteLine(a2);  // خروجی: { A = 1, B = 2, C = 3, D = 4, E = 10 }
</code></pre>
<p>✅ شیء a1 بدون تغییر باقی می‌مونه، و a2 نسخه‌ی جدیدی از همون با مقدار E = 10 هست.</p>
<h3>🧮 سینتکس جدید برای Deconstruction</h3>
<p>در C# 7، امکان بازکردن مقدارهای Tuple یا Struct به متغیرها (Deconstruct) اضافه شد.</p>
<p>در C# 10، می‌تونید اعلان و مقداردهی را ترکیب کنید، یعنی همزمان یک متغیر جدید تعریف کنید و به یک متغیر قدیمی مقدار بدهید:</p>
<pre><code class="language-csharp">var point = (3, 4);
double x = 0;

(x, double y) = point;
</code></pre>
<p>در این مثال:</p>
<ul>
<li>
<p>متغیر x از قبل وجود داشته و مقدار جدیدی می‌گیره.</p>
</li>
<li>
<p>متغیر y همون‌جا تعریف و مقداردهی می‌شه.</p>
</li>
<li></li>
</ul>
<h3>🧱 مقداردهی اولیه فیلدها و سازنده‌ی بدون پارامتر در Structها</h3>
<p>(Field Initializers and Parameterless Constructors in Structs)</p>
<p>از نسخه‌ی #C 10 به بعد، Structها هم می‌تونن:</p>
<ul>
<li>
<p>فیلدهاشون رو همون موقع تعریف، مقداردهی اولیه کنن</p>
</li>
<li>
<p>سازنده بدون پارامتر (parameterless constructor) داشته باشن</p>
</li>
</ul>
<p>🟡 توجه: این سازنده فقط وقتی اجرا می‌شه که به‌صورت صریح فراخوانی بشه
(مثلاً با new MyStruct())، و نه وقتی از default استفاده می‌کنید.</p>
<p>🎯 این قابلیت بیشتر برای پشتیبانی از record struct‌ها طراحی شده.</p>
<p>📘 جزئیات بیشتر: «Structs» در صفحه ۱۴۲</p>
<p><strong>🧾 Struct به عنوان Record</strong>
(Record Structs)</p>
<p>در نسخه C# 9، نوع جدیدی به نام record معرفی شد که نسخه‌ای ساده‌شده و بهینه‌شده از کلاس‌ها بود.</p>
<p>در C# 10، حالا می‌تونید همون قابلیت رو برای structها هم داشته باشید:</p>
<pre><code class="language-csharp">record struct Point(int X, int Y);
</code></pre>
<p>📌 شباهت‌ها و تفاوت‌ها:</p>
<ul>
<li>
<p>تقریباً همه ویژگی‌های record برای record struct هم وجود دارن</p>
</li>
<li>
<p>تنها تفاوت اصلی:
در record structها، ویژگی‌های (property) ساخته‌شده توسط کامپایلر به صورت قابل‌تغییر (writable) هستن
مگر اینکه قبل از record از کلمه‌ی readonly استفاده کنید.</p>
</li>
</ul>
<h3>🔁 بهبودهای مربوط به عبارت‌های Lambda</h3>
<p>(Lambda Expression Enhancements)</p>
<p>عبارت‌های lambda در C# 10 چند قابلیت جدید و کاربردی دریافت کردن:</p>
<p>✅ ۱. پشتیبانی از تایپ ضمنی (var)
حالا می‌تونید از var برای تعریف lambda استفاده کنید:</p>
<pre><code class="language-csharp">var greeter = () =&gt; &quot;Hello, world&quot;;  // نوع: Func&lt;string&gt;
</code></pre>
<p>در اینجا، greeter به‌طور خودکار به Func<string> تبدیل می‌شه.</p>
<p>🔸 اگر پارامتر داشته باشید، باید نوع اون رو صراحتاً مشخص کنید:</p>
<pre><code class="language-csharp">var square = (int x) =&gt; x * x;
</code></pre>
<p>📌 ۲. امکان تعیین نوع بازگشتی (explicit return type)
می‌تونید نوع بازگشتی یک lambda رو مشخص کنید:</p>
<pre><code class="language-csharp">var sqr = int (int x) =&gt; x;
</code></pre>
<p>✳️ این کار به ساده‌سازی فرآیند کامپایل در lambdaهای تو در تو کمک می‌کنه.</p>
<p>📥 ۳. پذیرش lambda در متدهایی با نوع پارامتر عمومی
حالا می‌تونید lambda رو به‌عنوان آرگومان به متدهایی بدید که نوع پارامترشون object یا Delegate یا Expression هست:</p>
<pre><code class="language-csharp">M1(() =&gt; &quot;test&quot;);   // تبدیل به Func&lt;string&gt;
M2(() =&gt; &quot;test&quot;);
M3(() =&gt; &quot;test&quot;);

void M1(object x) {}
void M2(Delegate x) {}
void M3(Expression x) {}
</code></pre>
<p>🏷 ۴. افزودن Attribute به lambda
حالا می‌تونید به خود lambda، به پارامترهاش یا حتی به مقدار بازگشتی اون، attribute اضافه کنید:</p>
<pre><code class="language-csharp">Action a = [Description(&quot;test&quot;)] () =&gt; { };
</code></pre>
<p>📘 جزئیات کامل در «Applying Attributes to Lambda Expressions» صفحه ۲۴۵</p>
<h3>🧩 سایر ویژگی‌های جدید در C# 10</h3>
<p>(Nested Property Patterns, Caller Argument Expressions, and More)</p>
<h3>🧬 الگوی تطبیق در ویژگی‌های تو در تو (Nested Property Patterns)</h3>
<p>در C# 10، برای بررسی ویژگی‌های تو در تو (nested properties) می‌تونید از سینتکس ساده‌تری استفاده کنید. مثلاً:</p>
<pre><code class="language-csharp">var obj = new Uri(&quot;https://www.linqpad.net&quot;);

if (obj is Uri { Scheme.Length: 5 })
  Console.WriteLine(&quot;طول Scheme برابر ۵ است&quot;);
</code></pre>
<p>⬅️ این معادل با کدی با ساختار پیچیده‌تر در نسخه‌های قبلی است:</p>
<pre><code class="language-csharp">if (obj is Uri { Scheme: { Length: 5 } })
</code></pre>
<p>🔹 این روش به نوشتن شرط‌ها با خوانایی بیشتر کمک می‌کنه.
📘 برای اطلاعات بیشتر: «Property Patterns» صفحه ۲۴۱</p>
<h3>🧾 ویژگی CallerArgumentExpression</h3>
<p>اگه بخواید عبارت اصلی‌ای که برای یک پارامتر متد استفاده شده رو بگیرید، می‌تونید از CallerArgumentExpression استفاده کنید:</p>
<pre><code class="language-csharp">Print(Math.PI * 2);

void Print(
    double number,
    [CallerArgumentExpression(&quot;number&quot;)] string expr = null)
    =&gt; Console.WriteLine(expr);
</code></pre>
<p>🟢 خروجی:</p>
<pre><code class="language-javascript">Math.PI * 2
</code></pre>
<p>✅ این قابلیت بیشتر برای کتابخانه‌های اعتبارسنجی (validation) و assertion کاربرد داره.
📘 جزئیات: صفحه ۲۴۷، بخش «CallerArgumentExpression»</p>
<h3>📌 سایر ویژگی‌های جدید</h3>
<p>🧵 رشته‌های درون‌تابی (Interpolated Strings) می‌تونن ثابت (const) باشن
به شرطی که مقادیری که درون‌شون استفاده شده هم const باشه:</p>
<pre><code class="language-csharp">const string name = &quot;Ali&quot;;
const string message = $&quot;Hello, {name}!&quot;;
</code></pre>
<p><strong>📏 دستور #line پیشرفته‌تر شده</strong></p>
<p>حالا می‌تونید شماره ستون و بازه (range) هم تعیین کنید — مخصوصاً برای ابزارهای آنالیز کد مفیده.</p>
<p>📛 در Recordها می‌تونید متد ToString() رو ببندید (seal کنید)
یعنی نذارید کلاس‌های مشتق‌شده بتونن اون رو override کنن:</p>
<pre><code class="language-csharp">public record Person
{
    public sealed override string ToString() =&gt; &quot;Hidden&quot;;
}
</code></pre>
<p><strong>🧠 تجزیه و تحلیل انتساب قطعی (Definite Assignment) بهبود پیدا کرده</strong></p>
<p>در نسخه‌های قبلی C#، این کد باعث خطا می‌شد چون کامپایلر فکر می‌کرد متغیر number ممکنه مقدار نگرفته باشه:</p>
<pre><code class="language-csharp">if (foo?.TryParse(&quot;123&quot;, out var number) ?? false)
    Console.WriteLine(number);
</code></pre>
<p>اما از C# 10 به بعد، این کد کاملاً مجازه و کامپایل می‌شه.</p>
<h2>تازه‌های سی‌شارپ ۹.۰</h2>
<p>سی‌شارپ ۹.۰ همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و زمانی که دات‌نت ۵ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>دستورات سطح بالا</h3>
<p>با دستورات سطح بالا (به &quot;دستورات سطح بالا&quot; در صفحه ۴۱ مراجعه کنید)، می‌توانید برنامه‌ای را بدون بار اضافه متد Main و کلاس Program بنویسید:</p>
<pre><code class="language-C#">
using System;
Console.WriteLine (&quot;Hello, world&quot;);
</code></pre>
<p>دستورات سطح بالا می‌توانند شامل متدها (که به عنوان متدهای محلی عمل می‌کنند) باشند. همچنین می‌توانید از طریق متغیر &quot;جادویی&quot; args به آرگومان‌های خط فرمان دسترسی پیدا کنید و یک مقدار به فراخواننده برگردانید. دستورات سطح بالا می‌توانند با اعلان‌های نوع و فضای نام دنبال شوند.</p>
<h3>تنظیم‌کننده‌های فقط مقداردهی اولیه</h3>
<p>یک تنظیم‌کننده فقط مقداردهی اولیه (init-only setter) (به &quot;تنظیم‌کننده‌های فقط مقداردهی اولیه&quot; در صفحه ۱۱۶ مراجعه کنید) در اعلان خصوصیت، به جای کلمه کلیدی set از کلمه کلیدی init استفاده می‌کند:</p>
<pre><code class="language-C#">
class Foo { public int ID { get; init; } }
</code></pre>
<p>این خصوصیت مانند یک خصوصیت فقط خواندنی رفتار می‌کند، با این تفاوت که می‌تواند از طریق یک مقداردهنده اولیه شیء (object initializer) نیز تنظیم شود:</p>
<pre><code class="language-C#">
var foo = new Foo { ID = 123 };
</code></pre>
<p>این امر ایجاد انواع تغییرناپذیر (read-only) را که می‌توانند به جای سازنده از طریق یک مقداردهنده اولیه شیء مقداردهی شوند، ممکن می‌سازد و به جلوگیری از ضدالگوی سازنده‌هایی که تعداد زیادی پارامتر اختیاری را می‌پذیرند، کمک می‌کند. تنظیم‌کننده‌های فقط مقداردهی اولیه همچنین در هنگام استفاده در رِکوردها، امکان تغییر غیرمخرب را فراهم می‌کنند.</p>
<h3>رِکوردها</h3>
<p>یک رِکورد (به &quot;رِکوردها&quot; در صفحه ۲۲۷ مراجعه کنید) نوع خاصی از کلاس است که برای کار با داده‌های تغییرناپذیر طراحی شده است. خاص‌ترین ویژگی آن این است که از تغییر غیرمخرب از طریق یک کلمه کلیدی جدید (with) پشتیبانی می‌کند:</p>
<pre><code class="language-C#">
Point p1 = new Point (2, 3);
Point p2 = p1 with { Y = 4 };   // p2 is a copy of p1, but with Y set to 4
Console.WriteLine (p2);         // Point { X = 2, Y = 4 }
</code></pre>
<pre><code class="language-C#">
record Point
 {
  public Point (double x, double y) =&gt; (X, Y) = (x, y);
  public double X { get; init; }
  public double Y { get; init; }    
}
</code></pre>
<p>در موارد ساده، یک رِکورد می‌تواند کد قالبی تعریف خصوصیات و نوشتن سازنده و تفکیک‌کننده را نیز حذف کند. می‌توانیم تعریف رِکورد Point خود را بدون از دست دادن کارایی، با کد زیر جایگزین کنیم:</p>
<pre><code class="language-C#">
record Point (double X, double Y);
</code></pre>
<p>مانند تاپِل‌ها، رِکوردها به طور پیش‌فرض برابری ساختاری را نشان می‌دهند. رِکوردها می‌توانند از رِکوردهای دیگر زیرکلاس بسازند و می‌توانند شامل همان ساختارهایی باشند که کلاس‌ها می‌توانند شامل شوند. کامپایلر رِکوردها را در زمان اجرا به عنوان کلاس پیاده‌سازی می‌کند.</p>
<h3>بهبودهای تطبیق الگو</h3>
<p>الگوی رابطه‌ای (به &quot;الگوها&quot; در صفحه ۲۳۸ مراجعه کنید) به عملگرهای &lt;, &gt;, &lt;=, و &gt;= اجازه می‌دهد در الگوها ظاهر شوند:</p>
<pre><code class="language-C#">
string GetWeightCategory (decimal bmi) =&gt; bmi switch {
 &lt; 18.5m =&gt; &quot;underweight&quot;,
 &lt; 25m =&gt; &quot;normal&quot;,
 &lt; 30m =&gt; &quot;overweight&quot;,
  _ =&gt; &quot;obese&quot; };
</code></pre>
<p>با ترکیب‌کننده‌های الگو، می‌توانید الگوها را از طریق سه کلمه کلیدی جدید (and, or, و not) ترکیب کنید:</p>
<pre><code class="language-C#">
bool IsVowel (char c) =&gt; c is 'a' or 'e' or 'i' or 'o' or 'u';
bool IsLetter (char c) =&gt; c is &gt;= 'a' and &lt;= 'z'
 or &gt;= 'A' and &lt;= 'Z';
</code></pre>
<p>مانند عملگرهای &amp;&amp; و ||، عملگر and اولویت بالاتری نسبت به or دارد. می‌توانید با پرانتز این اولویت را نادیده بگیرید.</p>
<p>ترکیب‌کننده not می‌تواند با الگوی نوع استفاده شود تا آزمایش کند که آیا یک شیء (نه) از یک نوع خاص است:</p>
<pre><code class="language-C#">
if (obj is not string) ...
</code></pre>
<h3>عبارات new نوع-هدف Target-typed new expressions</h3>
<p>هنگام ساخت یک شیء، سی‌شارپ ۹ به شما اجازه می‌دهد نام نوع را زمانی که کامپایلر می‌تواند به طور unambiguous آن را استنباط کند، حذف کنید:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new (&quot;Test&quot;);
</code></pre>
<p>این به ویژه زمانی مفید است که اعلان متغیر و مقداردهی اولیه در بخش‌های مختلف کد شما قرار دارند:</p>
<pre><code class="language-C#">
class Foo
{
 System.Text.StringBuilder sb;
  public Foo (string initialValue) =&gt; sb = new (initialValue);
 }
</code></pre>
<p>و در سناریوی زیر:</p>
<pre><code class="language-C#">
MyMethod (new (&quot;test&quot;));
void MyMethod (System.Text.StringBuilder sb) { ... }
</code></pre>
<p>برای اطلاعات بیشتر به &quot;عبارات new نوع-هدف&quot; در صفحه ۷۷ مراجعه کنید.</p>
<h3>بهبودهای تعامل‌پذیری</h3>
<p>سی‌شارپ ۹ اشاره‌گرهای تابع (function pointers) را معرفی می‌کند (به &quot;اشاره‌گرهای تابع&quot; در صفحه ۲۶۸ و &quot;فراخوانی‌های برگشتی با اشاره‌گرهای تابع&quot; در صفحه ۹۹۱ مراجعه کنید). هدف اصلی آن‌ها این است که به کدهای مدیریت‌نشده اجازه دهند متدهای static را در سی‌شارپ بدون سربار یک نمونه دلیگیت فراخوانی کنند، با قابلیت نادیده گرفتن لایه فراخوانی تابع خارجی (P/Invoke) زمانی که آرگومان‌ها و انواع بازگشتی از نوع blittable هستند (یعنی در هر دو سمت به یک شکل نمایش داده می‌شوند).</p>
<p>سی‌شارپ ۹ همچنین انواع اعداد صحیح بومی‌اندازه nint و nuint را معرفی می‌کند (به &quot;اعداد صحیح بومی‌اندازه&quot; در صفحه ۲۶۶ مراجعه کنید)، که در زمان اجرا به System.IntPtr و System.UIntPtr نگاشت می‌شوند. در زمان کامپایل، آن‌ها مانند انواع عددی با پشتیبانی از عملیات حسابی رفتار می‌کنند.</p>
<h3>سایر ویژگی‌های جدید</h3>
<p>علاوه بر این، سی‌شارپ ۹ اکنون به شما اجازه می‌دهد:</p>
<p>یک متد یا خصوصیت فقط خواندنی را به گونه‌ای بازنویسی کنید که یک نوع مشتق‌شده‌تر را برگرداند (به &quot;انواع بازگشتی کوواریانت&quot; در صفحه ۱۳۱ مراجعه کنید).
خصوصیات (Attributes) را به توابع محلی اعمال کنید (به &quot;خصوصیات&quot; در صفحه ۲۴۳ مراجعه کنید).
کلمه کلیدی static را به عبارات لامبدا یا توابع محلی اعمال کنید تا مطمئن شوید که به طور تصادفی متغیرهای محلی یا نمونه را شکار نمی‌کنید (به &quot;لامبداهای استاتیک&quot; در صفحه ۱۹۲ مراجعه کنید).
با نوشتن یک متد توسعه‌دهنده GetEnumerator، هر نوعی را با دستور foreach سازگار کنید.
یک متد مقداردهنده اولیه ماژول تعریف کنید که با اولین بارگذاری یک اَسمبلی یک بار اجرا می‌شود، با اعمال خصیصه [ModuleInitializer] به یک متد (static void بدون پارامتر).
از یک &quot;بازیافت&quot; (نماد زیرخط) به عنوان آرگومان عبارت لامبدا استفاده کنید.
متدهای partial توسعه‌یافته بنویسید که پیاده‌سازی آن‌ها اجباری است – امکان سناریوهایی مانند مولدهای منبع جدید Roslyn را فراهم می‌کند (به &quot;متدهای partial توسعه‌یافته&quot; در صفحه ۱۲۵ مراجعه کنید).
یک خصیصه را به متدها، انواع یا ماژول‌ها اعمال کنید تا از مقداردهی اولیه متغیرهای محلی توسط زمان اجرا جلوگیری شود (به &quot;[SkipLocalsInit]&quot; در صفحه ۲۶۹ مراجعه کنید).</p>
<h2>تازه‌های سی‌شارپ ۸.۰</h2>
<p>سی‌شارپ ۸.۰ ابتدا همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و امروزه همچنان زمانی که دات‌نت کور ۳ یا دات‌نت استاندارد ۲.۱ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>اندیس‌ها و محدوده‌ها</h3>
<p>اندیس‌ها و محدوده‌ها کار با عناصر یا بخش‌هایی از یک آرایه (یا انواع سطح پایین Span و ReadOnlySpan) را ساده می‌کنند.</p>
<p>اندیس‌ها به شما اجازه می‌دهند با استفاده از عملگر ^ به عناصر نسبت به انتهای یک آرایه ارجاع دهید. ^1 به آخرین عنصر، ^2 به عنصر یکی مانده به آخر و غیره ارجاع می‌دهد:</p>
<pre><code class="language-C#">
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [^1];   // 'u'
char secondToLast = vowels [^2];   // 'o'
</code></pre>
<p>محدوده‌ها به شما اجازه می‌دهند با استفاده از عملگر .. یک آرایه را &quot;برش&quot; دهید:</p>
<pre><code class="language-C#">
char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3]    // 'i'
char[] lastTwo =   vowels [^2..];   // 'o', 'u'
</code></pre>
<p>سی‌شارپ اندیس‌ها و محدوده‌ها را با کمک انواع Index و Range پیاده‌سازی می‌کند:</p>
<pre><code class="language-C#">
Index last = ^1;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'
</code></pre>
<p>شما می‌توانید با تعریف یک اندیس‌گذار با نوع پارامتر Index یا Range، از اندیس‌ها و محدوده‌ها در کلاس‌های خودتان پشتیبانی کنید:</p>
<pre><code class="language-C#">
class Sentence
{
  string[] words = &quot;The quick brown fox&quot;.Split();
  public string this   [Index index] =&gt; words [index];
  public string[] this [Range range] =&gt; words [range];
}
</code></pre>
<p>برای اطلاعات بیشتر، به &quot;اندیس‌ها و محدوده‌ها&quot; در صفحه ۶۳ مراجعه کنید.</p>
<h3>انتساب ترکیبی نال</h3>
<p>عملگر ??= یک متغیر را تنها در صورتی مقداردهی می‌کند که null باشد. به جای:</p>
<pre><code class="language-C#">
if (s == null) s = &quot;Hello, world&quot;;
</code></pre>
<p>اکنون می‌توانید این گونه بنویسید:</p>
<pre><code class="language-C#">
s ??= &quot;Hello, world&quot;;
</code></pre>
<h3>اعلان‌های using</h3>
<p>اگر براکت‌ها و بلوک دستورات پس از یک دستور using را حذف کنید، تبدیل به یک اعلان using می‌شود. سپس منبع زمانی آزاد می‌شود که اجرا از بلوک دستور احاطه‌کننده خارج شود:</p>
<pre><code class="language-C#">
if (File.Exists (&quot;file.txt&quot;))
{
}
using var reader = File.OpenText (&quot;file.txt&quot;);
  Console.WriteLine (reader.ReadLine());
  ...
</code></pre>
<p>در این حالت، reader زمانی آزاد خواهد شد که اجرا از بلوک دستور if خارج شود.</p>
<h3>اعضای فقط خواندنی</h3>
<p>سی‌شارپ ۸ به شما اجازه می‌دهد اصلاح‌کننده readonly را به توابع یک ساختار اعمال کنید، که این امر تضمین می‌کند اگر تابع تلاش کند هر فیلدی را تغییر دهد، یک خطای زمان کامپایل تولید می‌شود:</p>
<pre><code class="language-C#">
struct Point
{
  public int X, Y;
  public readonly void ResetX() =&gt; X = 0;  // Error!
}
</code></pre>
<p>اگر یک تابع readonly تابع غیر readonly را فراخوانی کند، کامپایلر یک هشدار تولید می‌کند (و به صورت دفاعی ساختار را کپی می‌کند تا از احتمال تغییر جلوگیری شود).</p>
<h3>متدهای محلی static</h3>
<p>افزودن اصلاح‌کننده static به یک متد محلی، از دسترسی آن به متغیرهای محلی و پارامترهای متد احاطه‌کننده جلوگیری می‌کند. این کار به کاهش وابستگی (coupling) کمک می‌کند و به متد محلی اجازه می‌دهد متغیرها را به دلخواه خود اعلان کند، بدون خطر برخورد با متغیرهای موجود در متد حاوی.</p>
<h3>اعضای رابط پیش‌فرض</h3>
<p>سی‌شارپ ۸ به شما اجازه می‌دهد یک پیاده‌سازی پیش‌فرض به عضو یک رابط اضافه کنید، که پیاده‌سازی آن را اختیاری می‌کند:</p>
<pre><code class="language-C#">
interface ILogger
{
  void Log (string text) =&gt; Console.WriteLine (text);
}
</code></pre>
<p>این بدان معناست که می‌توانید بدون اینکه پیاده‌سازی‌های موجود را خراب کنید، عضوی را به یک رابط اضافه کنید. پیاده‌سازی‌های پیش‌فرض باید به صراحت از طریق رابط فراخوانی شوند:</p>
<pre><code class="language-C#">
((ILogger)new Logger()).Log (&quot;message&quot;);
</code></pre>
<p>رابط‌ها همچنین می‌توانند اعضای static (شامل فیلدها) را تعریف کنند، که می‌توان از کد داخل پیاده‌سازی‌های پیش‌فرض به آن‌ها دسترسی پیدا کرد:</p>
<pre><code class="language-C#">
interface ILogger
{
  void Log (string text) =&gt; Console.WriteLine (Prefix + text);
 static string Prefix = &quot;&quot;; 
}
</code></pre>
<p>یا از خارج از رابط، مگر اینکه از طریق یک اصلاح‌کننده دسترسی روی عضو static رابط (مانند private, protected, یا internal) محدود شده باشد:</p>
<pre><code class="language-C#">
ILogger.Prefix = &quot;File log: &quot;;
</code></pre>
<p>فیلدهای نمونه ممنوع هستند. برای جزئیات بیشتر، به &quot;اعضای رابط پیش‌فرض&quot; در صفحه ۱۵۱ مراجعه کنید.</p>
<h3>عبارات switch</h3>
<p>از سی‌شارپ ۸ به بعد، می‌توانید از switch در زمینه یک عبارت استفاده کنید:</p>
<pre><code class="language-C#">
string cardName = cardNumber switch
{
    // assuming cardNumber is an int
  13 =&gt; &quot;King&quot;,
  12 =&gt; &quot;Queen&quot;,
  11 =&gt; &quot;Jack&quot;,
 _ =&gt; &quot;Pip card&quot;   // equivalent to 'default'
};
</code></pre>
<p>برای مثال‌های بیشتر، به &quot;عبارات switch&quot; در صفحه ۹۰ مراجعه کنید.</p>
<h3>الگوهای تاپل، موقعیتی و خصوصیت</h3>
<p>سی‌شارپ ۸ از سه الگوی جدید پشتیبانی می‌کند که بیشتر برای بهره‌مندی از دستورات/عبارات switch هستند (به &quot;الگوها&quot; در صفحه ۲۳۸ مراجعه کنید). الگوهای تاپل به شما اجازه می‌دهند بر روی چندین مقدار switch کنید:</p>
<pre><code class="language-C#">
int cardNumber = 12; string suite = &quot;spades&quot;;
string cardName = (cardNumber, suite) switch
{
 (13, &quot;spades&quot;) =&gt; &quot;King of spades&quot;,
 (13, &quot;clubs&quot;) =&gt; &quot;King of clubs&quot;,
  ...
};
</code></pre>
<p>الگوهای موقعیتی (positional patterns) نحو مشابهی را برای اشیائی که یک تفکیک‌کننده (deconstructor) را نمایش می‌دهند، امکان‌پذیر می‌سازند و الگوهای خصوصیت (property patterns) به شما اجازه می‌دهند بر روی خصوصیات یک شیء مطابقت ایجاد کنید. می‌توانید از تمام الگوها هم در switchها و هم با عملگر is استفاده کنید. مثال زیر از یک الگوی خصوصیت استفاده می‌کند تا بررسی کند آیا obj یک رشته با طول ۴ است:</p>
<pre><code class="language-C#">
if (obj is string { Length:4 }) ...
</code></pre>
<h3>انواع ارجاعی با قابلیت تهی (Nullable Reference Types)</h3>
<p>در حالی که انواع مقداری با قابلیت تهی (nullable value types) قابلیت تهی بودن را به انواع مقداری می‌آورند، انواع ارجاعی با قابلیت تهی عکس این کار را می‌کنند و (درجه‌ای از) عدم قابلیت تهی بودن را به انواع ارجاعی می‌آورند، با این هدف که به جلوگیری از خطاهای NullReferenceException کمک کنند. انواع ارجاعی با قابلیت تهی یک سطح از ایمنی را معرفی می‌کنند که صرفاً توسط کامپایلر در قالب هشدارها یا خطاها هنگام تشخیص کدی که در معرض خطر تولید NullReferenceException است، اعمال می‌شود.</p>
<p>انواع ارجاعی با قابلیت تهی می‌توانند یا در سطح پروژه (از طریق عنصر Nullable در فایل پروژه .csproj) یا در کد (از طریق دستور #nullable) فعال شوند. پس از فعال شدن، کامپایلر عدم قابلیت تهی بودن را به پیش‌فرض تبدیل می‌کند: اگر می‌خواهید یک نوع ارجاعی nullها را بپذیرد، باید پسوند ? را برای نشان دادن یک نوع ارجاعی با قابلیت تهی اعمال کنید:</p>
<pre><code class="language-C#">
#nullable enable    // Enable nullable reference types from this point on
string s1 = null;   // Generates a compiler warning! (s1 is non-nullable)
string? s2 = null;  // OK: s2 is nullable reference type
</code></pre>
<p>فیلدهای مقداردهی نشده نیز (اگر نوع به عنوان nullable علامت‌گذاری نشده باشد) یک هشدار تولید می‌کنند، همانطور که لغو ارجاع یک نوع ارجاعی با قابلیت تهی نیز (اگر کامپایلر فکر کند NullReferenceException ممکن است رخ دهد):</p>
<pre><code class="language-C#">
void Foo (string? s) =&gt; Console.Write (s.Length);  // Warning (.Length)
</code></pre>
<p>برای حذف هشدار، می‌توانید از عملگر null-forgiving (!) استفاده کنید:</p>
<pre><code class="language-C#">
void Foo (string? s) =&gt; Console.Write (s!.Length);
</code></pre>
<p>برای بحث کامل، به &quot;انواع ارجاعی با قابلیت تهی&quot; در صفحه ۲۱۵ مراجعه کنید.</p>
<h3>جریان‌های ناهمگام</h3>
<p>پیش از سی‌شارپ ۸، می‌توانستید از yield return برای نوشتن یک تکرارکننده (iterator) یا از await برای نوشتن یک تابع ناهمگام استفاده کنید. اما نمی‌توانستید هر دو را انجام دهید و یک تکرارکننده بنویسید که منتظر بماند (await) و عناصر را به صورت ناهمگام تولید کند. سی‌شارپ ۸ با معرفی جریان‌های ناهمگام (asynchronous streams) این مشکل را برطرف می‌کند:</p>
<pre><code class="language-C#">
async IAsyncEnumerable&lt;int&gt; RangeAsync (
  int start, int count, int delay)
 {
  for (int i = start; i &lt; start + count; i++)
  {
 await Task.Delay (delay);
 yield return i;
}
  }
</code></pre>
<p>دستور await foreach یک جریان ناهمگام را مصرف می‌کند:</p>
<pre><code class="language-C#">
await foreach (var number in RangeAsync (0, 10, 100))
  Console.WriteLine (number);
</code></pre>
<p>برای اطلاعات بیشتر، به &quot;جریان‌های ناهمگام&quot; در صفحه ۶۷۲ مراجعه کنید.</p>
<h2>تازه‌های سی‌شارپ ۷.x</h2>
<p>سی‌شارپ ۷.x ابتدا با ویژوال استودیو ۲۰۱۷ عرضه شد. سی‌شارپ ۷.۳ امروز نیز توسط ویژوال استودیو ۲۰۱۹ زمانی که دات‌نت کور ۲، چارچوب دات‌نت ۴.۶ تا ۴.۸، یا دات‌نت استاندارد ۲.۰ را هدف قرار می‌دهید، استفاده می‌شود.</p>
<h3>سی‌شارپ ۷.۳</h3>
<p>سی‌شارپ ۷.۳ بهبودهای جزئی در ویژگی‌های موجود ایجاد کرد، مانند فعال کردن استفاده از عملگرهای برابری با تاپِل‌ها، بهبود تفکیک بار اضافی متدها (overload resolution) و قابلیت اعمال خصیصه‌ها به فیلدهای پشتیبان خصوصیات خودکار:</p>
<pre><code class="language-C#">
[field:NonSerialized]
public int MyProperty { get; set; }
</code></pre>
<p>سی‌شارپ ۷.۳ همچنین بر پایه ویژگی‌های برنامه‌نویسی پیشرفته با تخصیص حافظه پایین در سی‌شارپ ۷.۲ بنا شد، با قابلیت انتساب مجدد متغیرهای محلی ref، عدم نیاز به پین کردن هنگام اندیس‌گذاری فیلدهای ثابت، و پشتیبانی از مقداردهنده اولیه فیلد با stackalloc:</p>
<pre><code class="language-C#">
int* pointer  = stackalloc int[] {1, 2, 3};
Span&lt;int&gt; arr = stackalloc []    
{1, 2, 3};
</code></pre>
<p>توجه کنید که حافظه تخصیص‌یافته روی پشته (stack-allocated) را می‌توان مستقیماً به یک Span انتساب داد. ما در فصل ۲۳ اسپَن‌ها و دلیل استفاده از آن‌ها را شرح می‌دهیم.</p>
<h3>سی‌شارپ ۷.۲</h3>
<p>سی‌شارپ ۷.۲ اصلاح‌کننده جدید private protected را اضافه کرد (اشتراک internal و protected)، قابلیت دنبال کردن آرگومان‌های نام‌گذاری شده با آرگومان‌های موقعیتی هنگام فراخوانی متدها، و ساختارهای readonly. یک ساختار readonly تضمین می‌کند که تمام فیلدها readonly هستند تا در اعلان نیت کمک کند و به کامپایلر آزادی بهینه‌سازی بیشتری بدهد:</p>
<pre><code class="language-C#">
readonly struct Point
{
  public readonly int X, Y;   // X and Y must be readonly
}
</code></pre>
<p>سی‌شارپ ۷.۲ همچنین ویژگی‌های تخصصی را برای کمک به بهینه‌سازی‌های کوچک و برنامه‌نویسی با تخصیص حافظه پایین اضافه کرد: به &quot;اصلاح‌کننده in&quot; در صفحه ۷۲، &quot;متغیرهای محلی Ref&quot; در صفحه ۷۵، &quot;بازگشت‌های Ref&quot; در صفحه ۷۶، و &quot;ساختارهای Ref&quot; در صفحه ۱۴۴ مراجعه کنید.</p>
<h3>سی‌شارپ ۷.۱</h3>
<p>از سی‌شارپ ۷.۱، در صورت امکان استنباط نوع، می‌توانید هنگام استفاده از کلمه کلیدی default، نوع را حذف کنید:</p>
<pre><code class="language-C#">
decimal number = default;   // number is decimal
</code></pre>
<p>سی‌شارپ ۷.۱ همچنین قوانین مربوط به دستورات switch را آسان‌تر کرد (به طوری که می‌توانید بر روی پارامترهای نوع عمومی تطبیق الگو انجام دهید)، اجازه داد متد Main یک برنامه ناهمگام باشد، و اجازه داد نام عناصر تاپل استنباط شوند:</p>
<pre><code class="language-C#">
var now = DateTime.Now;
var tuple = (now.Hour, now.Minute, now.Second);
</code></pre>
<h3>بهبودهای ثابت‌های عددی</h3>
<p>ثابت‌های عددی در سی‌شارپ ۷ می‌توانند شامل زیرخط‌هایی برای بهبود خوانایی باشند. این‌ها جداکننده‌های ارقام نامیده می‌شوند و توسط کامپایلر نادیده گرفته می‌شوند:</p>
<pre><code class="language-C#">
int million = 1_000_000;
</code></pre>
<p>ثابت‌های دودویی را می‌توان با پیشوند 0b مشخص کرد:</p>
<pre><code class="language-C#">
var b = 0b1010_1011_1100_1101_1110_1111;
</code></pre>
<h3>متغیرهای out و discardها</h3>
<p>سی‌شارپ ۷ فراخوانی متدهایی که شامل پارامترهای out هستند را آسان‌تر می‌کند. اول اینکه، اکنون می‌توانید متغیرهای out را به صورت لحظه‌ای اعلان کنید (به &quot;متغیرهای out و discardها&quot; در صفحه ۷۲):</p>
<pre><code class="language-C#">
bool successful = int.TryParse (&quot;123&quot;, out int result);
Console.WriteLine (result);
</code></pre>
<p>و هنگام فراخوانی متدی با چندین پارامتر out، می‌توانید با کاراکتر زیرخط (_) آن‌هایی را که به آن‌ها علاقه‌ای ندارید، نادیده بگیرید (discard):</p>
<pre><code class="language-C#">
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
Console.WriteLine (x);
</code></pre>
<h3>الگوهای نوع و متغیرهای الگو</h3>
<p>شما می‌توانید متغیرها را به صورت لحظه‌ای با عملگر is نیز معرفی کنید. این‌ها متغیرهای الگو نامیده می‌شوند (به &quot;معرفی یک متغیر الگو&quot; در صفحه ۱۳۰):</p>
<pre><code class="language-C#">
void Foo (object x)
{
  if (x is string s)
    Console.WriteLine (s.Length);
}
</code></pre>
<p>دستور switch نیز از الگوهای نوع پشتیبانی می‌کند، بنابراین می‌توانید علاوه بر ثابت‌ها، بر اساس نوع نیز switch کنید (به &quot;سوئیچ کردن بر روی انواع&quot; در صفحه ۸۹). می‌توانید شرایط را با یک عبارت when مشخص کنید و همچنین بر روی مقدار null نیز switch کنید:</p>
<pre><code class="language-C#">
switch (x)
{
  case int i:
    Console.WriteLine (&quot;It's an int!&quot;);
    break;
  case string s:
    Console.WriteLine (s.Length);    // We can use the s variable
    break;
  case bool b when b == true:        // Matches only when b is true
    Console.WriteLine (&quot;True&quot;);
    break;
  case null:
    Console.WriteLine (&quot;Nothing&quot;);
    break;
}
</code></pre>
<h3>متدهای محلی</h3>
<p>یک متد محلی، متدی است که در داخل تابع دیگری اعلان می‌شود (به &quot;متدهای محلی&quot; در صفحه ۱۰۶):</p>
<pre><code class="language-C#">
void WriteCubes()
{
  Console.WriteLine (Cube (3));
  Console.WriteLine (Cube (4));
  Console.WriteLine (Cube (5));
 int Cube (int value) =&gt; value * value * value;
}
</code></pre>
<p>متدهای محلی فقط برای تابع حاوی قابل مشاهده هستند و می‌توانند متغیرهای محلی را به همان روشی که عبارات لامبدا انجام می‌دهند، شکار کنند.</p>
<h3>اعضای بیشتر با بدنه عبارت</h3>
<p>سی‌شارپ ۶ نحو &quot;پیکان چاق&quot; با بدنه عبارت را برای متدها، خصوصیات فقط خواندنی، عملگرها و اندیس‌گذارها معرفی کرد. سی‌شارپ ۷ این را به سازنده‌ها، خصوصیات خواندنی/نوشتنی و نهایی‌کننده‌ها (finalizers) گسترش می‌دهد:</p>
<pre><code class="language-C#">
public class Person
{
  string name;
 public Person (string name) =&gt; Name = name;
  public string Name
  {
 get =&gt; name;
 set =&gt; name = value ?? &quot;&quot;;
  }
 ~Person () =&gt; Console.WriteLine (&quot;finalize&quot;);
}
</code></pre>
<h3>تفکیک‌کننده‌ها</h3>
<p>سی‌شارپ ۷ الگوی تفکیک‌کننده (deconstructor) را معرفی می‌کند (به &quot;تفکیک‌کننده‌ها&quot; در صفحه ۱۱۰). در حالی که یک سازنده معمولاً مجموعه‌ای از مقادیر (به عنوان پارامتر) را می‌گیرد و به فیلدها انتساب می‌دهد، یک تفکیک‌کننده برعکس عمل می‌کند و فیلدها را به مجموعه‌ای از متغیرها بازگردانده و انتساب می‌دهد. ما می‌توانیم یک تفکیک‌کننده برای کلاس Person در مثال قبلی به شکل زیر بنویسیم (صرف نظر از مدیریت خطا):</p>
<pre><code class="language-C#">
public void Deconstruct (out string firstName, out string lastName)
{
  int spacePos = name.IndexOf (' ');
  firstName = name.Substring (0, spacePos);
  lastName = name.Substring (spacePos + 1);
}
</code></pre>
<p>تفکیک‌کننده‌ها با نحو خاص زیر فراخوانی می‌شوند:</p>
<pre><code class="language-C#">
var joe = new Person (&quot;Joe Bloggs&quot;);
var (first, last) = joe;          // Deconstruction
Console.WriteLine (first);        // Joe
Console.WriteLine (last);         // Bloggs
</code></pre>
<h3>تاپِل‌ها Tuples</h3>
<p>شاید قابل توجه‌ترین بهبود سی‌شارپ ۷، پشتیبانی صریح از تاپِل‌ها باشد (به &quot;تاپِل‌ها&quot; در صفحه ۲۲۲). تاپِل‌ها راهی ساده برای ذخیره مجموعه‌ای از مقادیر مرتبط فراهم می‌کنند:</p>
<pre><code class="language-C#">
var bob = (&quot;Bob&quot;, 23);
Console.WriteLine (bob.Item1);   // Bob
Console.WriteLine (bob.Item2);   // 23
</code></pre>
<p>تاپِل‌های جدید سی‌شارپ، یک قند نحوی (syntactic sugar) برای استفاده از ساختارهای عمومی System.ValueTuple&lt;…&gt; هستند. اما به لطف جادوی کامپایلر، عناصر تاپل می‌توانند نام‌گذاری شوند:</p>
<pre><code class="language-C#">
var tuple = (name:&quot;Bob&quot;, age:23);
Console.WriteLine (tuple.name);     // Bob
Console.WriteLine (tuple.age);      // 23
</code></pre>
<p>با تاپِل‌ها، توابع می‌توانند چندین مقدار را بدون نیاز به پارامترهای out یا سربار نوع اضافی برگردانند:</p>
<pre><code class="language-C#">
static (int row, int column) GetFilePosition() =&gt; (3, 10);
static void Main()
{
  var pos = GetFilePosition();
  Console.WriteLine (pos.row);      // 3
  Console.WriteLine (pos.column);   // 10
}
</code></pre>
<p>تاپِل‌ها به طور ضمنی از الگوی تفکیک ساختار پشتیبانی می‌کنند، بنابراین می‌توانید به راحتی آن‌ها را به متغیرهای فردی تفکیک کنید:</p>
<pre><code class="language-C#">
static void Main()
{
 (int row, int column) = GetFilePosition();   // Creates 2 local variables
  Console.WriteLine (row);      // 3 
  Console.WriteLine (column);   // 10
}
</code></pre>
<h3>عبارات throw</h3>
<p>پیش از سی‌شارپ ۷، throw همیشه یک دستور بود. اکنون می‌تواند به عنوان یک عبارت در توابع با بدنه عبارت نیز ظاهر شود:</p>
<pre><code class="language-C#">
public string Foo() =&gt; throw new NotImplementedException();
</code></pre>
<p>یک عبارت throw می‌تواند در یک عبارت شرطی سه‌تایی نیز ظاهر شود:</p>
<pre><code class="language-C#">
string Capitalize (string value) =&gt;
  value == null ? throw new ArgumentException (&quot;value&quot;) :
  value == &quot;&quot; ? &quot;&quot; :
  char.ToUpper (value[0]) + value.Substring (1);
</code></pre>
<h2>تازه‌های سی‌شارپ ۶.۰</h2>
<p>سی‌شارپ ۶.۰، که همراه با ویژوال استودیو ۲۰۱۵ عرضه شد، شامل یک کامپایلر نسل جدید است که به طور کامل با سی‌شارپ نوشته شده است. این کامپایلر، که به پروژه &quot;Roslyn&quot; معروف است، کل خط لوله کامپایل را از طریق کتابخانه‌ها در معرض دید قرار می‌دهد و به شما امکان می‌دهد تحلیل کد را بر روی کدهای منبع دلخواه انجام دهید. خود کامپایلر متن‌باز است و کد منبع آن در https://github.com/dotnet/roslyn در دسترس است.</p>
<p>علاوه بر این، سی‌شارپ ۶.۰ شامل چندین بهبود کوچک اما قابل توجه است که عمدتاً با هدف کاهش درهم‌ریختگی کد طراحی شده‌اند.</p>
<p>عملگر نال‌-شرطی (&quot;اِلویس&quot;) (به &quot;عملگرهای نال&quot; در صفحه ۸۲ مراجعه کنید) از نیاز به بررسی صریح null قبل از فراخوانی یک متد یا دسترسی به عضو یک نوع، جلوگیری می‌کند. در مثال زیر، result به جای پرتاب یک NullReferenceException، به null ارزیابی می‌شود:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
string result = sb?.ToString();      // result is null
</code></pre>
<p>توابع با بدنه عبارت (به &quot;متدها&quot; در صفحه ۱۰۶ مراجعه کنید) به متدها، خصوصیات، عملگرها و اندیس‌گذارها که شامل یک عبارت واحد هستند، اجازه می‌دهد به طور فشرده‌تر و به سبک یک عبارت لامبدا نوشته شوند:</p>
<pre><code class="language-C#">
public int TimesTwo (int x) =&gt; x * 2;
public string SomeProperty =&gt; &quot;Property value&quot;;
</code></pre>
<p>مقداردهنده‌های اولیه خصوصیت (فصل ۳) به شما اجازه می‌دهند یک مقدار اولیه را به یک خصوصیت خودکار انتساب دهید:</p>
<pre><code class="language-C#">
public DateTime TimeCreated { get; set; } = DateTime.Now;
</code></pre>
<p>خصوصیات مقداردهی شده می‌توانند فقط خواندنی نیز باشند:</p>
<pre><code class="language-C#">
public DateTime TimeCreated { get; } = DateTime.Now;
</code></pre>
<p>خصوصیات فقط خواندنی را می‌توان در سازنده نیز تنظیم کرد، که ایجاد انواع تغییرناپذیر (فقط خواندنی) را آسان‌تر می‌کند.</p>
<p>مقداردهنده‌های اولیه اندیس (فصل ۴) امکان مقداردهی اولیه یک مرحله‌ای هر نوعی که یک اندیس‌گذار را نمایش می‌دهد، فراهم می‌کنند:</p>
<pre><code class="language-C#">
var dict = new Dictionary&lt;int, string&gt;()
{
  [3] = &quot;three&quot;,
  [10] = &quot;ten&quot;
};
</code></pre>
<p>درون‌یابی رشته (به &quot;نوع رشته&quot; در صفحه ۵۸ مراجعه کنید) جایگزینی مختصر برای string.Format ارائه می‌دهد:</p>
<pre><code class="language-C#">
string s = $&quot;It is {DateTime.Now.DayOfWeek} today&quot;;
</code></pre>
<p>فیلترهای استثنا (به &quot;دستورات try و استثناها&quot; در صفحه ۱۹۵ مراجعه کنید) به شما اجازه می‌دهند یک شرط را به یک بلوک catch اعمال کنید:</p>
<pre><code class="language-C#">
string html;
try
{
  html = await new HttpClient().GetStringAsync (&quot;http://asef&quot;);
}
catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{
  ...
}
</code></pre>
<p>دستور using static (به &quot;فضاهای نام&quot; در صفحه ۹۵ مراجعه کنید) به شما اجازه می‌دهد تمام اعضای static یک نوع را وارد کنید تا بتوانید از آن اعضا بدون نیاز به نام کامل استفاده کنید:</p>
<pre><code class="language-C#">
using static System.Console;
...
WriteLine (&quot;Hello, world&quot;);  // WriteLine instead of Console.WriteLine
</code></pre>
<p>عملگر nameof (فصل ۳) نام یک متغیر، نوع یا نماد دیگر را به صورت یک رشته برمی‌گرداند. این کار از شکسته شدن کد هنگام تغییر نام یک نماد در ویژوال استودیو جلوگیری می‌کند:</p>
<pre><code class="language-C#">
int capacity = 123;
string x = nameof (capacity);   // x is &quot;capacity&quot;
string y = nameof (Uri.Host);   // y is &quot;Host&quot;
</code></pre>
<p>و در نهایت، اکنون اجازه دارید در بلوک‌های catch و finally از await استفاده کنید.</p>
<h2>تازه‌های سی‌شارپ ۵.۰</h2>
<p>ویژگی بزرگ و جدید سی‌شارپ ۵.۰، پشتیبانی از توابع ناهمگام از طریق دو کلمه کلیدی جدید async و await بود. توابع ناهمگام، دنباله‌های ناهمگام (asynchronous continuations) را امکان‌پذیر می‌سازند، که نوشتن برنامه‌های مشتری غنی پاسخگو و امن از نظر ریسه را آسان‌تر می‌کند. آن‌ها همچنین نوشتن برنامه‌های بسیار همروند و کارآمد با وابستگی به ورودی/خروجی را آسان می‌کنند که یک منبع ریسه را در هر عملیات مشغول نمی‌کنند. ما توابع ناهمگام را به تفصیل در فصل ۱۴ پوشش می‌دهیم.</p>
<h2>تازه‌های سی‌شارپ ۴.۰</h2>
<p>سی‌شارپ ۴.۰ چهار بهبود عمده را معرفی کرد:</p>
<p>بسته‌بندی پویا (Chapters 4 and 19) فرآیند حل انواع و اعضا را از زمان کامپایل به زمان اجرا به تعویق می‌اندازد و در سناریوهایی مفید است که در غیر این صورت به کد بازتابی پیچیده نیاز داشتند. بسته‌بندی پویا همچنین هنگام تعامل با زبان‌های پویا و اجزای COM مفید است.</p>
<p>پارامترهای اختیاری (Chapter 2) به توابع اجازه می‌دهند مقادیر پیش‌فرض پارامتر را مشخص کنند تا فراخوانندگان بتوانند آرگومان‌ها را حذف کنند، و آرگومان‌های نام‌گذاری شده به فراخواننده تابع اجازه می‌دهند یک آرگومان را با نام به جای موقعیت شناسایی کند.</p>
<p>قوانین واریانس نوع در سی‌شارپ ۴.۰ آسان‌تر شد (Chapters 3 and 4)، به طوری که پارامترهای نوع در رابط‌های عمومی و دلیگیت‌های عمومی می‌توانند به عنوان کوواریانت (covariant) یا کنتراواریانت (contravariant) علامت‌گذاری شوند، که تبدیل‌های نوع طبیعی‌تر را امکان‌پذیر می‌سازد.</p>
<p>تعامل‌پذیری COM (Chapter 24) در سی‌شارپ ۴.۰ به سه روش بهبود یافت. اول، آرگومان‌ها را می‌توان با ارجاع و بدون کلمه کلیدی ref ارسال کرد (به ویژه در ترکیب با پارامترهای اختیاری مفید است). دوم، اَسمبلی‌هایی که شامل انواع تعامل‌پذیری COM هستند می‌توانند به جای ارجاع، لینک شوند. انواع تعامل‌پذیری لینک شده از هم‌ارزی نوع پشتیبانی می‌کنند، از نیاز به اَسمبلی‌های تعامل‌پذیری اولیه جلوگیری می‌کنند و به مشکلات نگهداری نسخه و استقرار پایان می‌دهند. سوم، توابعی که انواع COM Variant را از انواع تعامل‌پذیری لینک شده برمی‌گردانند، به dynamic به جای object نگاشت می‌شوند و نیاز به casting را از بین می‌برند.</p>
<h2>تازه‌های سی‌شارپ ۳.۰</h2>
<p>ویژگی‌های اضافه شده به سی‌شارپ ۳.۰ عمدتاً بر قابلیت‌های پرس و جوی یکپارچه با زبان (LINQ) متمرکز بود. LINQ امکان نوشتن پرس و جوها را مستقیماً در یک برنامه سی‌شارپ فراهم می‌کند و صحت آن‌ها را به صورت استاتیک بررسی می‌کند، و هم مجموعه‌های محلی (مانند لیست‌ها یا اسناد XML) و هم منابع داده راه دور (مانند یک پایگاه داده) را پرس و جو می‌کند. ویژگی‌های سی‌شارپ ۳.۰ که برای پشتیبانی از LINQ اضافه شدند شامل متغیرهای محلی با نوع ضمنی، انواع بی‌نام، مقداردهنده‌های اولیه شیء، عبارات لامبدا، متدهای توسعه‌دهنده، عبارات پرس و جو و درختان عبارت بودند.</p>
<p>متغیرهای محلی با نوع ضمنی (کلمه کلیدی var، فصل ۲) به شما اجازه می‌دهند نوع متغیر را در یک دستور اعلان حذف کنید و به کامپایلر اجازه دهید آن را استنباط کند. این کار باعث کاهش شلوغی و همچنین امکان استفاده از انواع بی‌نام (فصل ۴) می‌شود، که کلاس‌های ساده‌ای هستند که به صورت لحظه‌ای ایجاد می‌شوند و معمولاً در خروجی نهایی پرس و جوهای LINQ استفاده می‌شوند. شما همچنین می‌توانید آرایه‌ها را به صورت ضمنی تایپ کنید (فصل ۲).</p>
<p>مقداردهنده‌های اولیه شیء (فصل ۳) با اجازه دادن به شما برای تنظیم خصوصیات به صورت درون‌خطی پس از فراخوانی سازنده، ساخت شیء را ساده می‌کنند. مقداردهنده‌های اولیه شیء با انواع نام‌گذاری شده و بی‌نام کار می‌کنند.</p>
<p>عبارات لامبدا (فصل ۴) توابع مینیاتوری هستند که توسط کامپایلر به صورت لحظه‌ای ایجاد می‌شوند؛ آن‌ها به ویژه در پرس و جوهای LINQ &quot;روان&quot; (fluent) مفید هستند (فصل ۸).</p>
<p>متدهای توسعه‌دهنده (فصل ۴) یک نوع موجود را با متدهای جدید گسترش می‌دهند (بدون تغییر تعریف نوع)، و باعث می‌شوند متدهای static مانند متدهای نمونه عمل کنند. عملگرهای پرس و جوی LINQ به عنوان متدهای توسعه‌دهنده پیاده‌سازی شده‌اند.</p>
<p>عبارات پرس و جو (فصل ۸) نحو سطح بالاتری برای نوشتن پرس و جوهای LINQ فراهم می‌کنند که هنگام کار با توالی‌های متعدد یا متغیرهای محدوده، می‌توانند به طور قابل توجهی ساده‌تر باشند.</p>
<p>درختان عبارت (فصل ۸) مدل‌های شیء سند (DOMs) کد مینیاتوری هستند که عبارات لامبدا را که به نوع خاص Expression<TDelegate> اختصاص داده شده‌اند، توصیف می‌کنند. درختان عبارت امکان اجرای پرس و جوهای LINQ را از راه دور (مثلاً روی یک سرور پایگاه داده) فراهم می‌کنند، زیرا می‌توانند در زمان اجرا بازرسی و ترجمه شوند (مثلاً به یک دستور SQL).</p>
<p>سی‌شارپ ۳.۰ همچنین خصوصیات خودکار و متدهای partial را اضافه کرد.</p>
<p>خصوصیات خودکار (فصل ۳) با واداشتن کامپایلر به انجام خودکار کار، از نوشتن خصوصیات که به سادگی یک فیلد پشتیبان خصوصی را دریافت/تنظیم می‌کنند، می‌کاهد.</p>
<p>متدهای partial (فصل ۳) به یک کلاس partial خودکار تولید شده اجازه می‌دهند هوک‌های قابل سفارشی‌سازی برای نویسندگی دستی فراهم کند که در صورت عدم استفاده &quot;از بین می‌روند&quot;.</p>
<h2>تازه‌های سی‌شارپ ۲.۰</h2>
<p>ویژگی‌های بزرگ و جدید در سی‌شارپ ۲ عمومی‌ها (generics) (فصل ۳)، انواع مقداری با قابلیت تهی (nullable value types) (فصل ۴)، تکرارکننده‌ها (iterators) (فصل ۴) و متدهای بی‌نام (anonymous methods) (پیش‌ساز عبارات لامبدا) بودند. این ویژگی‌ها راه را برای معرفی LINQ در سی‌شارپ ۳ هموار کردند.</p>
<p>سی‌شارپ ۲ همچنین پشتیبانی از کلاس‌های partial، کلاس‌های static، و مجموعه‌ای از ویژگی‌های کوچک و متفرقه مانند تعیین‌کننده نام مستعار فضای نام، اَسمبلی‌های دوست، و بافرهای با اندازه ثابت را اضافه کرد.</p>
<p>معرفی عمومی‌ها به یک محیط زمان اجرای مشترک جدید (CLR 2.0) نیاز داشت، زیرا عمومی‌ها وفاداری کامل نوع را در زمان اجرا حفظ می‌کنند.</p>

  </main>

  <footer>
    <p>ساخته شده با ❤️ توسط برنامه نویسان برای برنامه نویسان</p>
  </footer>
</body>
</html>
