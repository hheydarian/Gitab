<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل دوم: مبانی زبان سی شارپ</h1>
<p>در این فصل، با مبانی زبان سی شارپ آشنا می‌شویم.</p>
<p>تقریباً تمام مثال‌های کدی که در این کتاب آمده‌اند، به صورت نمونه‌های تعاملی (Interactive Samples) در LINQPad در دسترس هستند. کار کردن با این نمونه‌ها در کنار مطالعه کتاب، باعث می‌شود یادگیری شما بسیار سریع‌تر شود، چون می‌توانید کدها را ویرایش کرده و نتیجه را فوراً ببینید، بدون اینکه نیازی به ساخت پروژه‌ها و راه‌حل‌ها (Solutions) در Visual Studio داشته باشید.</p>
<p>برای دانلود نمونه‌ها، در LINQPad روی تب Samples کلیک کنید و سپس گزینه Download more samples را انتخاب نمایید.</p>
<p>💡 نکته:
LINQPad رایگان است. می‌توانید آن را از این آدرس دانلود کنید:
<a href="http://www.linqpad.net">http://www.linqpad.net</a></p>
<h2>اولین برنامه سی‌شارپ</h2>
<p>در ادامه، برنامه‌ای را می‌بینید که عدد ۱۲ را در ۳۰ ضرب کرده و نتیجه‌ی ۳۶۰ را روی صفحه چاپ می‌کند. علامت دو اسلش (//) نشان می‌دهد که بقیه‌ی خط یک توضیح (کامنت) است:</p>
<pre><code class="language-csharp">int x = 12 * 30;                  // دستور 1
System.Console.WriteLine(x);      // دستور 2
</code></pre>
<p>برنامه‌ی ما از دو دستور تشکیل شده است. در سی شارپ، دستورات به ترتیب اجرا می‌شوند و با یک سمی‌کالن (;) پایان می‌یابند.</p>
<p>🔹 دستور اول عبارت 12 * 30 را محاسبه کرده و نتیجه را در متغیری به نام x ذخیره می‌کند که نوع آن یک عدد صحیح ۳۲ بیتی (int) است.</p>
<p>🔹 دستور دوم متد WriteLine را از کلاسی به نام Console فراخوانی می‌کند که در یک فضای نام (namespace) به نام System تعریف شده است. این دستور مقدار متغیر x را در یک پنجره متنی روی صفحه نمایش چاپ می‌کند.</p>
<p>یک متد یک وظیفه انجام می‌دهد؛ یک کلاس اعضای تابعی و اعضای داده‌ای را گروه‌بندی می‌کند تا یک بلوک ساختاری شیء‌گرا شکل گیرد. کلاس <strong>Console</strong> اعضایی را گروه‌بندی می‌کند که وظیفه‌ی مدیریت ورودی/خروجی (I/O) خط فرمان را دارند، مانند متد <strong>WriteLine</strong>. یک کلاس نوعی از <strong>type</strong> است که در بخش «Type Basics» در صفحه ۳۶ بررسی می‌کنیم. 🏗️</p>
<p>در بالاترین سطح، انواع (types) در <strong>namespace</strong>ها سازمان‌دهی شده‌اند. بسیاری از انواع پرکاربرد — از جمله کلاس <strong>Console</strong> — در <strong>System namespace</strong> قرار دارند. کتابخانه‌های .NET در <strong>nested namespaces</strong> سازمان‌دهی شده‌اند. برای مثال، <strong>System.Text namespace</strong> شامل انواعی برای مدیریت متن است و <strong>System.IO</strong> شامل انواعی برای ورودی/خروجی می‌باشد. 📚</p>
<p>هر بار که کلاس <strong>Console</strong> را با <strong>System namespace</strong> صدا بزنید، کد شما شلوغ می‌شود. دستور <strong>using</strong> به شما اجازه می‌دهد این شلوغی را حذف کنید و یک namespace را وارد کنید:</p>
<pre><code class="language-csharp">using System;   // وارد کردن System namespace
int x = 12 * 30;
Console.WriteLine(x);    // نیازی به نوشتن System. نیست
</code></pre>
<p>یک شکل پایه‌ای از <strong>code reuse</strong> این است که توابع سطح بالاتر بنویسیم که توابع سطح پایین‌تر را صدا می‌زنند. می‌توانیم برنامه خود را با یک متد قابل استفاده مجدد به نام <strong>FeetToInches</strong> بازسازی کنیم که یک عدد صحیح را در ۱۲ ضرب می‌کند، به صورت زیر:</p>
<pre><code class="language-csharp">using System;

Console.WriteLine(FeetToInches(30));      // 360
Console.WriteLine(FeetToInches(100));     // 1200

int FeetToInches(int feet)
{
    int inches = feet * 12;
    return inches;
}
</code></pre>
<p>متد ما شامل مجموعه‌ای از دستورات است که توسط یک جفت آکولاد احاطه شده‌اند. به این مجموعه، <strong>statement block</strong> گفته می‌شود.</p>
<p>یک متد می‌تواند داده ورودی را از فراخواننده دریافت کند با مشخص کردن <strong>parameters</strong> و داده خروجی را به فراخواننده برگرداند با مشخص کردن <strong>return type</strong>. متد <strong>FeetToInches</strong> ما یک پارامتر برای ورودی <strong>feet</strong> دارد و یک نوع بازگشتی برای خروجی <strong>inches</strong>:</p>
<pre><code class="language-csharp">int FeetToInches(int feet)
...
</code></pre>
<p>🟠 اعداد ۳۰ و ۱۰۰ مقادیری هستند که به متد <strong>FeetToInches</strong> ارسال شده‌اند و به آن <strong>arguments</strong> گفته می‌شود.</p>
<p>اگر یک متد ورودی دریافت نمی‌کند، از پرانتز خالی استفاده کنید. اگر هیچ مقداری باز نمی‌گرداند، از کلیدواژه <strong>void</strong> استفاده کنید:</p>
<pre><code class="language-csharp">using System;

SayHello();

void SayHello()
{
    Console.WriteLine(&quot;Hello, world&quot;);
}
</code></pre>
<p>متدها یکی از انواع مختلف <strong>functions</strong> در سی شارپ هستند. نوع دیگری از توابع که در برنامه نمونه ما استفاده شد، عملگر <code>*</code> بود که <strong>ضرب</strong> را انجام می‌دهد. 🔢</p>
<p>همچنین <strong>constructors</strong>، <strong>properties</strong>، <strong>events</strong>، <strong>indexers</strong> و <strong>finalizers</strong> نیز وجود دارند.</p>
<h3>🛠️ کامپایل (Compilation)</h3>
<p>کامپایلر زبان سی شارپ، کد منبع (مجموعه‌ای از فایل‌ها با پسوند .cs) را به یک Assembly تبدیل می‌کند.
یک Assembly واحد اصلی بسته‌بندی و انتشار در .NET است.</p>
<p>📦 <strong>اسمبلی</strong> می‌تواند:</p>
<p>🔹 یک برنامه (Application) باشد.</p>
<p>🔹 یک کتابخانه (Library) باشد.</p>
<p>یک برنامه معمولی کنسول یا ویندوز، دارای نقطه شروع (Entry Point) است، در حالی که کتابخانه این نقطه شروع را ندارد. هدف کتابخانه این است که توسط یک برنامه یا کتابخانه‌های دیگر فراخوانی (Reference) شود.
خود .NET نیز مجموعه‌ای از کتابخانه‌ها (و همچنین یک محیط اجرایی Runtime) است.</p>
<hr>
<p><strong>✏️ Top-Level Statements</strong></p>
<p>تمام برنامه‌های بخش قبلی، مستقیماً با مجموعه‌ای از دستورات شروع می‌شدند که به آن‌ها Top-Level Statements گفته می‌شود.
وجود این نوع دستورات، به طور ضمنی یک نقطه شروع برای برنامه کنسول یا ویندوز ایجاد می‌کند.</p>
<p>بدون Top-Level Statements، متد Main به‌عنوان نقطه شروع برنامه در نظر گرفته می‌شود. (توضیحات بیشتر در بخش Custom Types صفحه 37 آمده است.)</p>
<p><strong>📂 تفاوت پسوندها در .NET 8</strong></p>
<p>برخلاف .NET Framework، اسمبلی‌های .NET 8 هرگز پسوند .exe ندارند.
فایلی که پس از ساخت یک برنامه .NET 8 با پسوند .exe می‌بینید، در واقع یک بارگذار (Loader) بومی و وابسته به پلتفرم است که مسئول اجرای اسمبلی اصلی شما با پسوند .dll می‌باشد.</p>
<p><strong>📦 انتشار Self-Contained</strong></p>
<p>در .NET 8 می‌توانید یک Self-Contained Deployment ایجاد کنید که شامل:</p>
<p>🔹 Loader</p>
<p>🔹 اسمبلی‌های شما</p>
<p>🔹 بخش‌های لازم از Runtime</p>
<p>همه این موارد در قالب یک فایل .exe تکی قرار می‌گیرند.</p>
<p>همچنین .NET 8 از کامپایل AOT (Ahead-Of-Time) نیز پشتیبانی می‌کند که باعث:</p>
<p>🔹 شروع سریع‌تر برنامه 🚀</p>
<p>🔹 مصرف کمتر حافظه 💾
می‌شود.</p>
<p><strong>💻 ابزار dotnet</strong></p>
<p>ابزار dotnet (یا dotnet.exe در ویندوز) برای مدیریت کد منبع و فایل‌های باینری .NET از خط فرمان استفاده می‌شود.</p>
<p>با این ابزار می‌توانید:</p>
<p>🔹 برنامه خود را بسازید (Build)</p>
<p>🔹 آن را اجرا کنید (Run)</p>
<p>این کار جایگزینی برای استفاده از محیط‌های توسعه یکپارچه مثل Visual Studio یا Visual Studio Code است.</p>
<p><strong>📍 محل نصب پیش‌فرض:</strong></p>
<p>🔹 ویندوز: %ProgramFiles%\dotnet</p>
<p>🔹 لینوکس (Ubuntu): /usr/bin/dotnet</p>
<p><strong>📝 ساخت یک پروژه کنسول جدید</strong></p>
<p>برای کامپایل برنامه، ابزار dotnet به یک فایل پروژه و حداقل یک فایل C# نیاز دارد.
دستور زیر ساختار اولیه یک پروژه کنسول را ایجاد می‌کند:</p>
<pre><code class="language-bash">dotnet new Console -n MyFirstProgram
</code></pre>
<p>🔹 این دستور یک پوشه به نام MyFirstProgram ایجاد می‌کند که شامل:</p>
<p>🔹 فایل پروژه: MyFirstProgram.csproj</p>
<p>🔹 فایل کد: Program.cs (که پیام &quot;Hello world&quot; را چاپ می‌کند)</p>
<p><strong>▶️ اجرای برنامه</strong></p>
<p>برای ساخت و اجرای برنامه از پوشه پروژه:</p>
<pre><code class="language-bash">dotnet run MyFirstProgram
</code></pre>
<p>فقط برای ساخت (بدون اجرا):</p>
<pre><code class="language-bash">dotnet build MyFirstProgram.csproj
</code></pre>
<p>📌 خروجی اسمبلی در یک زیرپوشه از مسیر bin\debug ذخیره می‌شود.</p>
<p>توضیحات کامل در مورد اسمبلی‌ها در فصل 17 خواهد آمد. 📖</p>
<h3>نحو (Syntax)</h3>
<p>نحو یا Syntax در C# از زبان‌های C و C++ الهام گرفته شده است. در این بخش، ما اجزای نحو زبان C# را با استفاده از برنامه‌ی زیر توضیح می‌دهیم:</p>
<pre><code class="language-csharp">using System;
int x = 12 * 30;
Console.WriteLine(x);
</code></pre>
<h4>شناسه‌ها (Identifiers) و کلمات کلیدی (Keywords)</h4>
<p>شناسه‌ها (Identifiers) همان نام‌هایی هستند که برنامه‌نویس برای کلاس‌ها، متدها، متغیرها و سایر اجزای برنامه انتخاب می‌کند. در مثال بالا، شناسه‌ها به ترتیب ظاهر شدن عبارتند از:</p>
<pre><code class="language-arduino">System   x   Console   WriteLine
</code></pre>
<p>یک شناسه باید یک کلمه کامل باشد که اساساً از کاراکترهای یونیکد (Unicode) ساخته شده و با یک حرف یا خط زیرین (_) شروع شود.
شناسه‌ها در C# به بزرگی و کوچکی حروف حساس هستند.</p>
<p>به صورت قراردادی:</p>
<p>🔹 پارامترها، متغیرهای محلی و فیلدهای خصوصی باید به شکل camelCase نوشته شوند. مثال:</p>
<pre><code class="language-nginx">myVariable
</code></pre>
<p>🔹 سایر شناسه‌ها (مثل نام کلاس‌ها و متدها) باید به شکل PascalCase باشند. مثال:</p>
<pre><code class="language-nginx">MyMethod
</code></pre>
<p><strong>کلمات کلیدی (Keywords)</strong></p>
<p>کلمات کلیدی، نام‌هایی هستند که برای کامپایلر معنای خاصی دارند. در مثال ما، دو کلمه کلیدی وجود دارد:</p>
<pre><code class="language-cpp">using   int
</code></pre>
<p>بیشتر کلمات کلیدی رزرو شده هستند، به این معنی که شما نمی‌توانید آن‌ها را به عنوان شناسه استفاده کنید. در اینجا لیست کامل کلمات کلیدی رزرو شده سی‌شارپ آمده است:</p>
<pre><code class="language-csharp">abstract    do          protected     sbyte
as          double      public        sealed
base        else        readonly      short
bool        enum        record        sizeof
break       event       ref           stackalloc
byte        explicit    return        static
case        extern      float         string
catch       false       for           struct
char        finally     foreach       switch
checked     fixed       goto          this
class       if          throw         true
const       implicit    try           typeof
continue    in          uint          ulong
decimal     int         unchecked     unsafe
default     interface   ushort        using
delegate    internal    virtual       void
            is          volatile      while
            lock
            long
            namespace
            new
            null
            object
            operator
            out
            override
            params
            private
</code></pre>
<p>اگر واقعاً بخواهید از یک شناسه استفاده کنید که با یک کلمه کلیدی رزرو شده تداخل دارد، می‌توانید با استفاده از پیشوند @ این کار را انجام دهید. مثال:</p>
<pre><code class="language-csharp">int using = 123;      // غیرمجاز ❌
int @using = 123;     // مجاز ✅
</code></pre>
<p>علامت @ بخشی از خود شناسه محسوب نمی‌شود. بنابراین:</p>
<pre><code class="language-css">@myVariable
</code></pre>
<p>و</p>
<pre><code class="language-nginx">myVariable
</code></pre>
<p>کاملاً یکسان هستند. 🖋️</p>
<h3>کلمات کلیدی متنی</h3>
<p>برخی از کلمات کلیدی متنی (contextual) هستند، به این معنی که می‌توانید از آن‌ها به عنوان شناسه نیز استفاده کنید—بدون نماد @:</p>
<pre><code class="language-csharp">add         descending  global        notnull     remove      var
alias       dynamic     group         nuint       required    with
and         equals      init          on          select      when
ascending   file        into          or          set         where
async       from        join          orderby     unmanaged   yield
await       get         let           partial     value
by          managed     nameof
</code></pre>
<p>با کلمات کلیدی متنی، ابهام نمی‌تواند در متنی که در آن استفاده می‌شوند، ایجاد شود.</p>
<h3>ثابت‌ها (Literals)، نشانه‌گذارها (Punctuators)، و عملگرها (Operators)</h3>
<p>ثابت‌ها، داده‌های اولیه‌ای هستند که به صورت مستقیم و نوشتاری درون برنامه قرار می‌گیرند.
برای مثال، در برنامه نمونه ما، 12 و 30 نمونه‌هایی از ثابت‌ها هستند.</p>
<p>نشانه‌گذارها به ساختاربندی و جدا کردن بخش‌های مختلف برنامه کمک می‌کنند.
یک مثال، سمی‌کالن (;) است که یک دستور را خاتمه می‌دهد.
دستورات می‌توانند در چند خط نوشته شوند:</p>
<pre><code class="language-csharp">Console.WriteLine
    (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);
</code></pre>
<p>عملگرها عبارت‌ها را تغییر داده یا با هم ترکیب می‌کنند. بیشتر عملگرها در C# با یک نماد مشخص می‌شوند؛
مثلاً عملگر ضرب *.</p>
<p>ما عملگرها را در ادامه این فصل به‌طور کامل بررسی خواهیم کرد.
در برنامه نمونه‌مان، عملگرهای زیر را استفاده کردیم:</p>
<pre><code>=   *   .   ()
</code></pre>
<p>🔹 نقطه (.) یک عضو از چیزی را مشخص می‌کند (یا در اعداد اعشاری، نقش ممیز را دارد).</p>
<p>🔹 پرانتزها (()) هنگام تعریف یا فراخوانی یک متد استفاده می‌شوند؛ پرانتز خالی یعنی متد هیچ آرگومانی نمی‌گیرد. (پرانتزها کاربردهای دیگری هم دارند که در ادامه این فصل خواهید دید.)</p>
<p>🔹 علامت مساوی (=) برای انتساب مقدار به کار می‌رود.</p>
<p>🔹 علامت مساوی دوتایی (==) برای مقایسه برابری استفاده می‌شود.</p>
<h3>توضیحات (Comments)</h3>
<p>زبان C# دو روش برای نوشتن توضیحات در کد ارائه می‌دهد:</p>
<ol>
<li>توضیحات تک‌خطی (Single-line)
با دو خط مورب (//) شروع می‌شوند و تا پایان همان خط ادامه دارند:</li>
</ol>
<pre><code class="language-csharp">int x = 3;   // توضیحی درباره مقداردهی 3 به x
</code></pre>
<ol start="2">
<li>توضیحات چندخطی (Multiline)
با /<em>آغاز و با</em>/ پایان می‌یابند:</li>
</ol>
<pre><code class="language-csharp">int x = 3;   /* این یک توضیح است
                که در دو خط نوشته شده */
</code></pre>
<p>همچنین، توضیحات می‌توانند شامل برچسب‌های مستندسازی XML باشند که در بخش «XML Documentation» در صفحه ۲۷۲ توضیح داده خواهد شد. 📝</p>
<h2>اصول اولیه نوع داده 🧩 Types</h2>
<p>یک نوع داده (Type) در واقع نقشه یا قالبی است که برای یک مقدار تعریف می‌شود.</p>
<p>در این مثال، ما دو لیترال (literal) از نوع int با مقادیر 12 و 30 داریم. همچنین یک متغیر از نوع int به نام x تعریف می‌کنیم:</p>
<pre><code class="language-csharp">int x = 12 * 30;
Console.WriteLine(x);
</code></pre>
<p>🟡 از آنجا که بیشتر نمونه‌کدهای این کتاب به نوع‌هایی از فضای نام (namespace) System نیاز دارند، از این به بعد عبارت using System را نمی‌آوریم، مگر این‌که بخواهیم مفهومی مرتبط با فضای نام‌ها را توضیح دهیم.</p>
<p>🔹 متغیر (Variable) به یک محل ذخیره‌سازی اشاره دارد که می‌تواند در طول زمان مقادیر متفاوتی بگیرد.
در مقابل، ثابت (Constant) همیشه یک مقدار ثابت و تغییر‌ناپذیر دارد (در ادامه مفصل توضیح می‌دهیم):</p>
<pre><code class="language-csharp">const int y = 360;
</code></pre>
<p>📌 در زبان سی شارپ، تمام مقادیر، نمونه‌ای از یک نوع داده هستند.
نوع داده تعیین می‌کند که:</p>
<p>🔹 مقدار چه معنایی دارد 📝</p>
<p>🔹 و یک متغیر چه مقادیر ممکنی می‌تواند داشته باشد 🎯</p>
<h3>📌 نمونه‌هایی از انواع از پیش تعریف‌شده (Predefined Type Examples)</h3>
<p>انواع از پیش تعریف‌شده، نوع‌هایی هستند که به شکل ویژه توسط کامپایلر پشتیبانی می‌شوند.
به‌عنوان مثال، نوع int یک نوع از پیش تعریف‌شده برای نمایش مجموعه‌ای از اعداد صحیح است که در ۳۲ بیت حافظه جای می‌گیرند؛ این محدوده از  2³¹ تا 2³¹- را پوشش می‌دهد. همچنین، برای مقادیر عددی که در این بازه هستند، نوع پیش‌فرض int استفاده می‌شود.
شما می‌توانید روی متغیرهایی از نوع int عمل‌هایی مانند محاسبات ریاضی انجام دهید، به شکل زیر:</p>
<pre><code class="language-csharp">int x = 12 * 30;
</code></pre>
<p>نوع از پیش تعریف‌شده دیگر در C#، نوع string است. این نوع نشان‌دهنده‌ی یک دنباله از کاراکترهاست، مثل &quot;.NET&quot; یا &quot;<a href="http://oreilly.com">http://oreilly.com</a>&quot;. شما می‌توانید با استفاده از متدهای این نوع، روی رشته‌ها کار کنید:</p>
<pre><code class="language-csharp">string message = &quot;Hello world&quot;;
string upperMessage = message.ToUpper();
Console.WriteLine(upperMessage); // HELLO WORLD

int x = 2022;
message = message + x.ToString();
Console.WriteLine(message); // Hello world2022
</code></pre>
<p>در این مثال، ما از x.ToString() استفاده کردیم تا یک نمایش رشته‌ای از عدد صحیح x به دست آوریم.
جالب است بدانید که شما می‌توانید روی تقریباً هر نوع داده‌ای متد ToString() را فراخوانی کنید.</p>
<p><strong>✅ نوع بولی (bool)</strong></p>
<p>نوع از پیش تعریف‌شده bool فقط دو مقدار ممکن دارد: true و false.
این نوع معمولاً همراه با دستور if برای اجرای شرطی کد استفاده می‌شود:</p>
<pre><code class="language-csharp">bool simpleVar = false;
if (simpleVar)
    Console.WriteLine(&quot;This will not print&quot;);

int x = 5000;
bool lessThanAMile = x &lt; 5280;
if (lessThanAMile)
    Console.WriteLine(&quot;This will print&quot;);
</code></pre>
<p><strong>🛠 انواع سفارشی (Custom Types)</strong></p>
<p>در C#، انواع از پیش تعریف‌شده (که به آن‌ها Built-in Types هم گفته می‌شود) با یک کلیدواژه‌ی C# شناخته می‌شوند.
فضای نام System در .NET شامل بسیاری از انواع مهم است که در C# از پیش تعریف نشده‌اند (مثلاً DateTime).</p>
<p>همان‌طور که می‌توانیم متدهای خودمان را بنویسیم، می‌توانیم انواع (کلاس‌ها) را هم بسازیم.
در مثال زیر، ما یک نوع سفارشی به نام UnitConverter تعریف کرده‌ایم؛ یک کلاس که به عنوان الگو برای تبدیل واحدها عمل می‌کند:</p>
<pre><code class="language-csharp">UnitConverter feetToInchesConverter = new UnitConverter(12);
UnitConverter milesToFeetConverter  = new UnitConverter(5280);

Console.WriteLine(feetToInchesConverter.Convert(30));    // 360
Console.WriteLine(feetToInchesConverter.Convert(100));   // 1200
Console.WriteLine(feetToInchesConverter.Convert(
                  milesToFeetConverter.Convert(1)));     // 63360

public class UnitConverter
{
    int ratio; // فیلد (Field)

    public UnitConverter(int unitRatio) // سازنده (Constructor)
    {
        ratio = unitRatio;
    }

    public int Convert(int unit) // متد (Method)
    {
        return unit * ratio;
    }
}
</code></pre>
<p>در این مثال، تعریف کلاس ما در همان فایلی قرار دارد که دستورات سطح بالا (Top-level statements) نوشته شده‌اند.
این کار قانونی است—به شرطی که دستورات سطح بالا قبل از تعریف کلاس بیایند—و در برنامه‌های کوچک آزمایشی، کاملاً پذیرفته‌شده است.
اما در برنامه‌های بزرگ‌تر، رویکرد استاندارد این است که تعریف کلاس را در یک فایل جداگانه قرار دهیم؛ مثلاً در UnitConverter.cs.</p>
<h4>اعضای یک نوع (Members of a Type) 🧩</h4>
<p>یک نوع (Type) شامل دو دسته عضو است:</p>
<p>1️⃣ اعضای داده‌ای (Data Members) → داده‌ها را نگهداری می‌کنند.</p>
<p>2️⃣ اعضای تابعی (Function Members) → عملیات و رفتار مرتبط با داده‌ها را انجام می‌دهند.</p>
<p>در مثال UnitConverter:</p>
<p>🔹 عضو داده‌ای → فیلدی به نام ratio که نسبت تبدیل را ذخیره می‌کند.</p>
<p>🔹 اعضای تابعی → متد Convert و سازنده‌ی (Constructor) کلاس UnitConverter.</p>
<h4>تقارن بین انواع از پیش تعریف‌شده و انواع سفارشی ⚖️</h4>
<p>یکی از ویژگی‌های زیبا در C# این است که انواع از پیش تعریف‌شده (مثل int) و انواع سفارشی (مثل UnitConverter) از نظر ساختار، تفاوت کمی دارند:</p>
<p>🔹 نوع int → یک نقشه (Blueprint) برای اعداد صحیح است. داده ذخیره می‌کند (۳۲ بیت) و توابعی مثل ToString برای کار با آن دارد.</p>
<p>🔹 نوع UnitConverter → یک نقشه برای تبدیل واحدها است. داده‌ای (نسبت تبدیل) را نگهداری می‌کند و توابعی برای استفاده از آن دارد.</p>
<h4>سازنده‌ها و نمونه‌سازی (Constructors &amp; Instantiation) 🏗️</h4>
<p>🔹 ایجاد داده‌ها با نمونه‌سازی (Instantiation) انجام می‌شود.</p>
<p>🔹 انواع از پیش تعریف‌شده را می‌توان با یک لیترال ایجاد کرد، مثل:</p>
<pre><code class="language-csharp">&quot;Hello world&quot;
</code></pre>
<p>🔹 برای ایجاد نمونه از یک نوع سفارشی باید از عملگر new استفاده کنیم:</p>
<pre><code class="language-csharp">UnitConverter feetToInchesConverter = new UnitConverter(12);
</code></pre>
<p>🔹 بعد از اجرای new، سازنده‌ی آن نوع فراخوانی می‌شود تا داده‌ها مقداردهی اولیه شوند.</p>
<p><strong>تعریف یک سازنده 🛠️</strong></p>
<p>یک سازنده درست مثل یک متد نوشته می‌شود، با این تفاوت که:</p>
<p>🔹 نام آن دقیقا همان نام نوع است.</p>
<p>🔹 نوع بازگشتی ندارد.</p>
<p>مثال:</p>
<pre><code class="language-csharp">public UnitConverter(int unitRatio) 
{
    ratio = unitRatio;
}
</code></pre>
<h3>🆚 اعضای نمونه (Instance) در برابر اعضای ایستا (Static)</h3>
<p>اعضای داده‌ای و اعضای تابعی که روی نمونه‌ای از یک نوع (Type) عمل می‌کنند، «اعضای نمونه» (Instance Members) نام دارند.
مثلاً متد Convert در کلاس UnitConverter و متد ToString در نوع int نمونه‌هایی از اعضای نمونه هستند.
به‌طور پیش‌فرض، اعضا در سی‌شارپ «نمونه‌ای» هستند.</p>
<p>در مقابل، اعضای داده‌ای و تابعی که روی نمونه خاصی از نوع عمل نمی‌کنند، می‌توانند با کلمه کلیدی static علامت‌گذاری شوند.
برای دسترسی به یک عضو ایستا از بیرونِ نوع، به جای یک نمونه، نام خودِ نوع را مشخص می‌کنیم.
مثلاً متد WriteLine در کلاس Console یک عضو ایستا است، بنابراین آن را این‌طور فراخوانی می‌کنیم:</p>
<pre><code class="language-csharp">Console.WriteLine();
</code></pre>
<p>و نه این‌طور:</p>
<pre><code class="language-csharp">new Console().WriteLine();
</code></pre>
<p>📌 کلاس Console در واقع به‌عنوان یک کلاس ایستا (Static Class) تعریف شده است. این یعنی تمام اعضای آن ایستا هستند و شما هرگز نمی‌توانید نمونه‌ای از Console بسازید.</p>
<p><strong>📍 مثال — تفاوت عضو نمونه و ایستا</strong></p>
<p>در کد زیر، فیلد نمونه‌ای Name به یک نمونه خاص از کلاس Panda مربوط می‌شود،
در حالی که فیلد ایستای Population به مجموع همه نمونه‌های Panda ارتباط دارد:</p>
<pre><code class="language-csharp">Panda p1 = new Panda(&quot;Pan Dee&quot;);
Panda p2 = new Panda(&quot;Pan Dah&quot;);

Console.WriteLine(p1.Name);      // Pan Dee
Console.WriteLine(p2.Name);      // Pan Dah
Console.WriteLine(Panda.Population); // 2

public class Panda
{
    public string Name;             // 🐼 فیلد نمونه‌ای
    public static int Population;   // 🌍 فیلد ایستا

    public Panda(string n)          // 🔹 سازنده (Constructor)
    {
        Name = n;                   // مقداردهی فیلد نمونه‌ای
        Population = Population + 1; // افزایش فیلد ایستا
    }
}
</code></pre>
<p>📌 اگر بخواهید p1.Population یا Panda.Name را ارزیابی کنید،
کامپایلر یک خطای زمان کامپایل (Compile-time Error) تولید خواهد کرد.</p>
<h4>🔑 کلیدواژه public</h4>
<p>کلیدواژه public اعضای یک کلاس را برای دسترسی توسط سایر کلاس‌ها قابل مشاهده می‌کند.
در این مثال، اگر فیلد Name در کلاس Panda با public علامت‌گذاری نشده بود، به‌صورت خصوصی (private) در نظر گرفته می‌شد و امکان دسترسی به آن از خارج کلاس وجود نداشت.</p>
<p>علامت‌گذاری یک عضو به‌صورت public، روشی است که یک نوع (type) این پیام را منتقل می‌کند:</p>
<p>«اینجا چیزهایی است که می‌خواهم بقیه‌ی انواع ببینند — بقیه‌اش جزئیات داخلی و شخصی خودم است.»</p>
<p>در اصطلاحات برنامه‌نویسی شیءگرا (OOP)، می‌گوییم اعضای عمومی (public members)، اعضای خصوصی (private members) کلاس را کپسوله‌سازی (encapsulate) می‌کنند.</p>
<h4>📦 تعریف فضای نام (Namespace)</h4>
<p>به‌خصوص در برنامه‌های بزرگ، منطقی است که انواع (Types) را در قالب فضای نام (namespace)‌ها سازمان‌دهی کنیم.
مثال: تعریف کلاس Panda درون فضای نامی به نام Animals 👇</p>
<pre><code class="language-csharp">using System;
using Animals;

Panda p = new Panda(&quot;Pan Dee&quot;);
Console.WriteLine(p.Name);

namespace Animals
{
    public class Panda
    {
        ...
    }
}
</code></pre>
<p>در این مثال، ما فضای نام Animals را وارد (import) کردیم تا بتوانیم در کدهای سطح بالا (Top-level statements) به انواع داخل آن بدون پیشوند کامل دسترسی داشته باشیم.</p>
<p>بدون این وارد کردن، مجبور بودیم به این شکل بنویسیم:</p>
<pre><code class="language-csharp">Animals.Panda p = new Animals.Panda(&quot;Pan Dee&quot;);
</code></pre>
<p>📖 یادداشت: ما مبحث فضای نام‌ها را به‌طور کامل در انتهای این فصل بررسی می‌کنیم (بخش Namespaces در صفحه ۹۵).</p>
<h4>📌 تعریف متد Main</h4>
<p>تا اینجای کار، تمام مثال‌های ما از دستورات سطح بالا (Top-Level Statements) استفاده کرده‌اند؛ این قابلیت از نسخه C# 9 معرفی شد.</p>
<p>🔹 بدون استفاده از دستورات سطح بالا، یک برنامه‌ی ساده‌ی کنسول یا ویندوز به این شکل نوشته می‌شود:</p>
<pre><code class="language-csharp">using System;

class Program
{
    static void Main()   // نقطه شروع برنامه
    {
        int x = 12 * 30;
        Console.WriteLine(x);
    }
}
</code></pre>
<p>💡 در نبود دستورات سطح بالا، زبان C# به دنبال یک متد ایستا (static) به نام Main می‌گردد که نقطه‌ی شروع برنامه محسوب می‌شود.</p>
<p>🔹 متد Main می‌تواند در هر کلاسی تعریف شود (اما فقط یک متد Main می‌تواند وجود داشته باشد).</p>
<p>🔹 این متد می‌تواند به‌صورت اختیاری به جای void یک عدد صحیح (int) برگرداند تا نتیجه‌ای به محیط اجرای برنامه (Execution Environment) ارسال کند. معمولاً یک مقدار غیر صفر نشان‌دهنده‌ی وقوع خطاست.</p>
<p>🔹 همچنین متد Main می‌تواند به صورت اختیاری یک آرایه از رشته‌ها (string[]) به‌عنوان پارامتر بگیرد که شامل آرگومان‌هایی است که به فایل اجرایی پاس داده شده‌اند.</p>
<p>📌 مثال:</p>
<pre><code class="language-csharp">static int Main (string[] args) { ... }
</code></pre>
<p><strong>📚 نکته: آرایه‌ها در C#</strong></p>
<p>آرایه (مثل string[]) مجموعه‌ای ثابت از عناصر یک نوع خاص را نشان می‌دهد.
برای تعریف آرایه، براکت مربع ([]) را بعد از نوع داده قرار می‌دهیم.
(آرایه‌ها به طور کامل در بخش &quot;آرایه‌ها&quot; در صفحه 61 توضیح داده می‌شوند.)</p>
<p>💡 همچنین متد Main می‌تواند با کلمه‌ی کلیدی async تعریف شود و مقدار Task یا Task<int> برگرداند تا از برنامه‌نویسی غیرهمزمان (Asynchronous Programming) پشتیبانی کند. این موضوع را در فصل 14 بررسی می‌کنیم.</p>
<h3>🏷 دستورات سطح بالا (Top-Level Statements)</h3>
<p>دستورات سطح بالا که در C# 9 معرفی شدند، به شما اجازه می‌دهند بدون نیاز به نوشتن متد Main استاتیک و یک کلاس حاوی آن، برنامه را شروع کنید.
یک فایل شامل دستورات سطح بالا از سه بخش تشکیل می‌شود که به همین ترتیب می‌آیند:</p>
<p>1️⃣ (اختیاری) — دستورهای using</p>
<p>2️⃣ یک‌سری دستورات که می‌توانند با تعریف متدها مخلوط شوند (اختیاری)</p>
<p>3️⃣ (اختیاری) — اعلان نوع‌ها و فضای‌نام‌ها (Types &amp; Namespaces)</p>
<p>📌 مثال:</p>
<pre><code class="language-csharp">using System;                           // بخش ۱
Console.WriteLine(&quot;Hello, world&quot;);      // بخش ۲
void SomeMethod1() { ... }              // بخش ۲
Console.WriteLine(&quot;Hello again!&quot;);      // بخش ۲
void SomeMethod2() { ... }              // بخش ۲
class SomeClass { ... }                 // بخش ۳
namespace SomeNamespace { ... }         // بخش ۳
</code></pre>
<p>💡 چون CLR (ماشین مجازی دات‌نت) به طور مستقیم از دستورات سطح بالا پشتیبانی نمی‌کند، کامپایلر کد شما را به شکلی مشابه زیر ترجمه می‌کند:</p>
<pre><code class="language-csharp">using System;                           // بخش ۱
static class Program$   // نام خاص تولیدشده توسط کامپایلر
{
    static void Main$(string[] args)    // نام خاص تولیدشده توسط کامپایلر
    {
        Console.WriteLine(&quot;Hello, world&quot;);  // بخش ۲
        void SomeMethod1() { ... }          // بخش ۲
        Console.WriteLine(&quot;Hello again!&quot;);  // بخش ۲
        void SomeMethod2() { ... }          // بخش ۲
    }
}
class SomeClass { ... }                     // بخش ۳
namespace SomeNamespace { ... }             // بخش ۳
</code></pre>
<p>🔍 نکته مهم این است که تمام بخش ۲ درون متد Main قرار می‌گیرد.
به این معنا که SomeMethod1 و SomeMethod2 در عمل متدهای محلی هستند.
ما اثرات کامل این موضوع را در بخش متدهای محلی (صفحه ۱۰۶) بررسی می‌کنیم. مهم‌ترین نکته این است که متدهای محلی (مگر اینکه به صورت static تعریف شوند) می‌توانند به متغیرهای تعریف‌شده در همان متد دسترسی داشته باشند:</p>
<pre><code class="language-csharp">int x = 3;
LocalMethod();
void LocalMethod() { Console.WriteLine(x); }  // می‌توانیم به x دسترسی داشته باشیم
</code></pre>
<p>⚠️ نتیجه دیگر این است که متدهای سطح بالا را نمی‌توان از کلاس‌ها یا نوع‌های دیگر فراخوانی کرد.</p>
<p>📌 ویژگی‌های دیگر:</p>
<p>🔹 متد سطح بالا می‌تواند به صورت اختیاری یک مقدار عدد صحیح (int) به فراخواننده برگرداند.</p>
<p>🔹 همچنین می‌تواند به یک متغیر جادویی به نام args (از نوع string[]) دسترسی داشته باشد که شامل آرگومان‌های خط فرمانی است که توسط فراخواننده ارسال شده‌اند.</p>
<p>❗ از آنجایی که یک برنامه فقط می‌تواند یک نقطه ورود (Entry Point) داشته باشد، در هر پروژه C# حداکثر می‌توان یک فایل با دستورات سطح بالا داشت.</p>
<h3>انواع و تبدیل‌ها (Types and Conversions)</h3>
<p>زبان C# می‌تواند بین نمونه‌های انواع (Types) سازگار، تبدیل انجام دهد. هر تبدیل همیشه یک مقدار جدید را از یک مقدار موجود ایجاد می‌کند.</p>
<p>تبدیل‌ها می‌توانند ضمنی (Implicit) یا صریح (Explicit) باشند:</p>
<p>🔹 تبدیل ضمنی به‌طور خودکار انجام می‌شود.</p>
<p>🔹 تبدیل صریح نیاز به عملیات Cast دارد.</p>
<p>در مثال زیر:</p>
<p>🔹 یک int به‌صورت ضمنی به long (که دو برابر ظرفیت بیتی int را دارد) تبدیل می‌شود.</p>
<p>🔹 یک int به‌صورت صریح به short (که نصف ظرفیت بیتی int را دارد) Cast می‌شود:</p>
<pre><code class="language-csharp">int x = 12345;       // int یک عدد صحیح ۳۲ بیتی است
long y = x;          // تبدیل ضمنی به عدد صحیح ۶۴ بیتی
short z = (short)x;  // تبدیل صریح به عدد صحیح ۱۶ بیتی
</code></pre>
<p>✅ تبدیل ضمنی زمانی مجاز است که هر دو شرط زیر برقرار باشند:</p>
<p>1️⃣ کامپایلر بتواند تضمین کند که تبدیل همیشه موفق خواهد شد.</p>
<p>2️⃣ هیچ اطلاعاتی در فرآیند تبدیل از دست نرود.</p>
<p>⚠ تبدیل صریح زمانی لازم است که یکی از شرایط زیر برقرار باشد:</p>
<p>1️⃣ کامپایلر نتواند تضمین کند که تبدیل همیشه موفق خواهد شد.</p>
<p>2️⃣ ممکن است اطلاعات در فرآیند تبدیل از دست برود.</p>
<p>📌 اگر کامپایلر تشخیص دهد که یک تبدیل همیشه شکست خواهد خورد، هر دو نوع تبدیل (ضمنی و صریح) ممنوع می‌شوند.
همچنین، تبدیل‌های مربوط به جنریک‌ها (Generics) هم ممکن است در شرایط خاص شکست بخورند (بخش Type Parameters and Conversions در صفحه 166 توضیح داده شده است).</p>
<p>🔹 تبدیل‌های عددی که در بالا دیدیم، در خود زبان به‌صورت داخلی پشتیبانی می‌شوند.</p>
<p>🔹 سی شارپ همچنین از موارد زیر پشتیبانی می‌کند:</p>
<p>🔹 تبدیل‌های ارجاعی (Reference Conversions)</p>
<p>🔹 تبدیل‌های Boxing (در فصل ۳ توضیح داده شده)</p>
<p>🔹 تبدیل‌های سفارشی (Custom Conversions) (بخش Operator Overloading در صفحه 256)</p>
<p>⚠ در تبدیل‌های سفارشی، کامپایلر قوانین بالا را اجرا نمی‌کند، بنابراین اگر نوع‌ها به‌درستی طراحی نشده باشند، می‌توانند رفتار غیرمنتظره داشته باشند.</p>
<h3>انواع مقدار (Value Types) در مقابل انواع مرجع (Reference Types)</h3>
<p>تمام انواع (Type)‌های C# در یکی از دسته‌بندی‌های زیر قرار می‌گیرند:</p>
<p>🔹 انواع مقدار (Value Types)</p>
<p>🔹 انواع مرجع (Reference Types)</p>
<p>🔹 پارامترهای نوع کلی (Generic Type Parameters)</p>
<p>🔹 انواع اشاره‌گر (Pointer Types)</p>
<p>در این بخش، ما فقط به انواع مقدار و انواع مرجع می‌پردازیم.
پارامترهای نوع کلی را در بخش &quot;Generics&quot; (صفحه 159) و انواع اشاره‌گر را در بخش &quot;Unsafe Code and Pointers&quot; (صفحه 263) بررسی خواهیم کرد.</p>
<h4>انواع مقدار</h4>
<p>محتوای یک متغیر یا ثابت از نوع مقدار، فقط خودِ مقدار است.
به‌عنوان مثال، محتوای یک متغیر int (که نوع مقداری از پیش تعریف‌شده است) صرفاً ۳۲ بیت داده می‌باشد.</p>
<p>شما می‌توانید یک نوع مقدار سفارشی را با کلیدواژه‌ی struct تعریف کنید:</p>
<pre><code class="language-csharp">public struct Point { public int X; public int Y; }
</code></pre>
<p>یا به شکل خلاصه‌تر:</p>
<pre><code class="language-csharp">public struct Point { public int X, Y; }
</code></pre>
<p>📌 شکل ۲-۱. نمونه‌ای از یک نوع مقداری در حافظه</p>
<div align="center">
<p><img src="../../../../assets/image/02/Figure-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>وقتی یک نمونه از نوع مقداری را به متغیری دیگر انتساب می‌دهید، کل داده کپی می‌شود، نه فقط یک اشاره‌گر. مثال:</p>
<pre><code class="language-csharp">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // 📄 انتساب باعث ایجاد یک کپی از p1 می‌شود

Console.WriteLine(p1.X);   // 🔢 خروجی: 7
Console.WriteLine(p2.X);   // 🔢 خروجی: 7

p1.X = 9;                  // ✏️ تغییر مقدار X در p1

Console.WriteLine(p1.X);   // 🔢 خروجی: 9
Console.WriteLine(p2.X);   // 🔢 خروجی: 7
</code></pre>
<p>💡 همانطور که می‌بینید، تغییر در متغیر p1 بعد از کپی شدن، هیچ تاثیری روی p2 ندارد. این ویژگی، تفاوت اصلی انواع مقداری با انواع ارجاعی است.</p>
<p>📌 شکل ۲-۲ نشان می‌دهد که <code>p1</code> و <code>p2</code> فضای ذخیره‌سازی مستقلی دارند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 یعنی هر کدام در حافظه جداگانه نگهداری می‌شوند و تغییر یکی روی دیگری اثری ندارد.</p>
<h3>انواع ارجاعی (Reference Types) 🧭</h3>
<p>یک نوع ارجاعی از یک نوع مقداری پیچیده‌تر است، زیرا از دو بخش تشکیل شده است: یک شیء (Object) و ارجاع (Reference) به آن شیء.
محتوای یک متغیر یا ثابت از نوع ارجاعی، در واقع یک ارجاع به شیئی است که مقدار را در خود نگه می‌دارد.</p>
<p>در اینجا همان نوع Point که در مثال قبلی داشتیم، این بار به جای ساختار (struct) به صورت کلاس (class) نوشته شده است (مطابق شکل 2-3):</p>
<pre><code class="language-csharp">public class Point { public int X, Y; }
</code></pre>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-3.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 نکته مهم: وقتی یک متغیر از نوع ارجاعی را مقداردهی می‌کنیم، ارجاع (آدرس شیء) کپی می‌شود، نه خود شیء.
این موضوع باعث می‌شود چندین متغیر بتوانند به یک شیء واحد اشاره کنند — چیزی که در انواع مقداری به طور معمول امکان‌پذیر نیست.</p>
<p>اگر همان مثال قبلی را تکرار کنیم اما این بار Point یک کلاس باشد، تغییر در p1 روی p2 نیز اثر می‌گذارد:</p>
<pre><code class="language-c#">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // کپی شدن ارجاع p1
Console.WriteLine(p1.X);   // خروجی: 7
Console.WriteLine(p2.X);   // خروجی: 7

p1.X = 9;                  // تغییر مقدار p1.X
Console.WriteLine(p1.X);   // خروجی: 9
Console.WriteLine(p2.X);   // خروجی: 9

</code></pre>
<p>💡 نتیجه: در انواع ارجاعی، همه متغیرهایی که به یک شیء اشاره می‌کنند، در واقع یک نسخه مشترک از داده‌ها را می‌بینند.</p>
<p>📌 شکل ۲-۴ نشان می‌دهد که <code>p1</code> و <code>p2</code> دو ارجاع هستند که به یک شیء مشترک اشاره می‌کنند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-4.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 در نتیجه تغییر یکی، روی دیگری هم تأثیر دارد.</p>
<h3>Null</h3>
<p>یک مرجع (reference) می‌تواند به مقدار ثابت (literal) null نسبت داده شود، که نشان می‌دهد این مرجع به هیچ شیءی اشاره نمی‌کند:</p>
<pre><code class="language-csharp">Point p = null;
Console.WriteLine(p == null);   // True

// خط زیر باعث ایجاد خطای زمان اجرا می‌شود
// (یک استثنای NullReferenceException پرتاب می‌شود):
Console.WriteLine(p.X);

class Point { ... }
</code></pre>
<p>در بخش &quot;نوع‌های مرجع قابل تهی&quot; (صفحه 215)، یک قابلیت در C# توضیح داده شده است که به کاهش خطاهای اتفاقی NullReferenceException کمک می‌کند.</p>
<p>در مقابل، یک نوع مقداری (value type) معمولاً نمی‌تواند مقدار null داشته باشد:</p>
<pre><code class="language-csharp">Point p = null;  // خطای زمان کامپایل
int x = null;    // خطای زمان کامپایل

struct Point { ... }
</code></pre>
<p>C# یک ساختار به نام نوع‌های مقداری قابل تهی (nullable value types) نیز دارد که برای نمایش مقدار null در نوع‌های مقداری استفاده می‌شود. برای اطلاعات بیشتر به بخش &quot;نوع‌های مقداری قابل تهی&quot; (صفحه 210) مراجعه کنید.</p>
<h4>سربار حافظه (Storage overhead)</h4>
<p>نمونه‌های نوع مقداری دقیقاً به اندازه‌ای از حافظه اشغال می‌کنند که برای ذخیره فیلدهایشان لازم است. در این مثال، ساختار Point دقیقاً 8 بایت حافظه می‌گیرد:</p>
<pre><code class="language-csharp">struct Point
{
    int x;  // 4 بایت
    int y;  // 4 بایت
}
</code></pre>
<p>از نظر فنی، CLR فیلدها را در آدرسی قرار می‌دهد که مضربی از اندازه فیلد باشد (حداکثر تا 8 بایت).
به همین دلیل، ساختار زیر در واقع 16 بایت حافظه مصرف می‌کند (7 بایت بعد از فیلد اول «هدر» می‌رود):</p>
<pre><code class="language-csharp">struct A
{
    byte b;
    long l;
}
</code></pre>
<p>می‌توان این رفتار را با اعمال ویژگی StructLayout تغییر داد (به بخش &quot;نگاشت یک struct به حافظه unmanaged&quot; در صفحه 997 مراجعه کنید).</p>
<p>نوع‌های مرجعی نیاز به تخصیص جداگانه حافظه برای مرجع و شیء دارند.
شیء به اندازه فیلدهایش حافظه مصرف می‌کند به اضافه سربار مدیریتی اضافی.
میزان دقیق این سربار وابسته به پیاده‌سازی داخلی زمان‌اجرای .NET است، اما حداقل 8 بایت است که برای ذخیره کلیدی به نوع شیء، و همچنین اطلاعات موقتی مانند وضعیت قفل برای چندنخی و یک فلگ برای مشخص کردن اینکه آیا شیء توسط garbage collector از جابجایی قفل شده یا خیر، استفاده می‌شود.</p>
<p>هر مرجع به یک شیء، بسته به اینکه .NET روی پلتفرم 32بیتی یا 64بیتی اجرا شود، به ترتیب 4 یا 8 بایت اضافی نیاز دارد.</p>
<h3>Predefined Type Taxonomy</h3>
<p>Predefined Types در C# به شرح زیر هستند:</p>
<ul>
<li>
<p>Value Types</p>
<ul>
<li>
<p>Numeric</p>
<p>Signed integer (sbyte, short, int, long)</p>
<p>Unsigned integer (byte, ushort, uint, ulong)</p>
<p>Real number (float, double, decimal)</p>
</li>
<li>
<p>Logical (bool)</p>
</li>
<li>
<p>Character (char)</p>
</li>
</ul>
</li>
<li>
<p>Reference Types</p>
<ul>
<li>
<p>String (string)</p>
</li>
<li>
<p>Object (object)</p>
</li>
</ul>
</li>
</ul>
<p>Predefined Types در C# در واقع Alias برای .NET Types در Namespace System هستند. تنها یک تفاوت Syntactic بین این دو دستور وجود دارد:</p>
<pre><code class="language-C#">
int i = 5;
System.Int32 i = 5;
</code></pre>
<p>در دات‌نت، مجموعه‌ای از انواع مقداری (Value Types) که به‌جز decimal هستند، به‌عنوان انواع اولیه (Primitive Types) شناخته می‌شوند. 🧩</p>
<p>به آن‌ها «اولیه» گفته می‌شود چون به‌طور مستقیم از طریق دستورالعمل‌های موجود در کد کامپایل‌شده پشتیبانی می‌شوند، و این معمولاً به معنی پشتیبانی مستقیم در پردازنده‌ی سخت‌افزاری است. 💻⚡</p>
<p>برای مثال:</p>
<pre><code class="language-csharp">// نمایش زیرساختی (نمایش هگزادسیمال)
int i = 7;        // 0x7
bool b = true;    // 0x1
char c = 'A';     // 0x41
float f = 0.5f;   // استفاده از کدگذاری IEEE برای اعداد اعشاری شناور
</code></pre>
<p>همچنین، انواع System.IntPtr و System.UIntPtr نیز جزو انواع اولیه محسوب می‌شوند. (به فصل ۲۴ مراجعه کنید) 📖</p>
<p>Numeric Types</p>
<p>C# دارای Predefined Numeric Types است که در Table 2-1 نشان داده شده‌اند.</p>
<p>Table 2-1. Predefined numeric types in C#</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
از بین انواع عدد صحیح (Integral Types)، نوع‌های int و long در زبان C# و در زمان اجرای برنامه (Runtime) جایگاه ویژه‌ای دارند و بیشترین استفاده را دارند. سایر انواع عدد صحیح معمولاً زمانی استفاده می‌شوند که یا نیاز به سازگاری و تعامل با سیستم‌ها و کتابخانه‌های دیگر (Interoperability) وجود دارد یا بهینه‌سازی در مصرف حافظه اهمیت دارد.
نوع‌های عدد صحیح با اندازه بومی سیستم یعنی nint و nuint بیشتر هنگام کار با اشاره‌گرها (Pointers) مفید هستند که توضیح آن‌ها در فصل بعدی خواهد آمد (بخش «اعداد صحیح با اندازه بومی» در صفحه 266).
<p>از بین انواع اعداد حقیقی (Real Number Types)، دو نوع float و double که به آن‌ها انواع شناور (Floating-Point Types) گفته می‌شود، معمولاً در محاسبات علمی و گرافیکی استفاده می‌شوند.
نوع decimal بیشتر در محاسبات مالی و اقتصادی به کار می‌رود، چون محاسبات آن دقیق بر پایه مبنای ۱۰ بوده و دقت بالایی دارد.</p>
<p>علاوه بر این، ‌**.NET** چند نوع عددی تخصصی نیز ارائه می‌دهد، از جمله:</p>
<ul>
<li>
<p>Int128 و UInt128 برای اعداد صحیح علامت‌دار و بدون علامت ۱۲۸ بیتی</p>
</li>
<li>
<p>BigInteger برای اعداد صحیح بسیار بزرگ (بدون محدودیت اندازه)</p>
</li>
<li>
<p>Half برای اعداد اعشاری ۱۶ بیتی (نقطه شناور)</p>
</li>
</ul>
<p>نوع Half عمدتاً برای تعامل با پردازنده‌های کارت گرافیک استفاده می‌شود و اغلب پشتیبانی سخت‌افزاری مستقیم در CPUها ندارد، به همین دلیل float و double برای استفاده عمومی انتخاب‌های بهتری هستند.</p>
<h3>اعداد ثابت (Numeric Literals)</h3>
<p>اعداد ثابت از نوع صحیح (Integral-type literals) می‌توانند از نمادگذاری ده‌دهی (decimal) یا شانزده‌شانزدهی (hexadecimal) استفاده کنند؛ حالت شانزده‌شانزدهی با پیشوند 0x مشخص می‌شود.
برای مثال:</p>
<pre><code class="language-csharp">int x = 127;
long y = 0x7F;
</code></pre>
<p>شما می‌توانید برای خواناتر کردن یک عدد ثابت، در هرجای آن یک خط زیرین (underscore) قرار دهید:</p>
<pre><code class="language-csharp">int million = 1_000_000;
</code></pre>
<p>همچنین می‌توانید اعداد را به صورت دودویی (binary) با پیشوند 0b بنویسید:</p>
<pre><code class="language-csharp">var b = 0b1010_1011_1100_1101_1110_1111;
</code></pre>
<p>اعداد ثابت اعشاری (Real literals) می‌توانند از نمادگذاری ده‌دهی و/یا نمادگذاری نمایی (exponential notation) استفاده کنند:</p>
<pre><code class="language-csharp">double d = 1.5;
double million = 1E06;
</code></pre>
<h4>نتیجه‌گیری نوع عدد ثابت (Numeric literal type inference)</h4>
<p>به طور پیش‌فرض، کامپایلر نوع یک عدد ثابت را یا double یا یکی از انواع صحیح در نظر می‌گیرد:</p>
<ul>
<li>
<p>اگر عدد شامل نقطه اعشار یا نماد نمایی E باشد، نوع آن double خواهد بود.</p>
</li>
<li>
<p>در غیر این صورت، نوع عدد اولین نوع در لیست زیر خواهد بود که بتواند مقدار آن را در خود جای دهد:
int → uint → long → ulong</p>
</li>
</ul>
<p>برای مثال:</p>
<pre><code class="language-csharp">Console.WriteLine(       1.0.GetType());   // Double  (double)
Console.WriteLine(      1E06.GetType());   // Double  (double)
Console.WriteLine(         1.GetType());   // Int32   (int)
Console.WriteLine(0xF0000000.GetType());   // UInt32  (uint)
Console.WriteLine(0x100000000.GetType());  // Int64   (long)
</code></pre>
<p>نکته: از نظر فنی، decimal نیز یک نوع اعشاری (floating-point type) محسوب می‌شود، اما در مشخصات زبان C# به این صورت معرفی نشده است.</p>
<h3>پسوندهای عددی (Numeric Suffixes) 🔤</h3>
<p>پسوندهای عددی به‌طور صریح نوع یک مقدار ثابت (literal) را مشخص می‌کنند. این پسوندها می‌توانند با حروف کوچک یا بزرگ نوشته شوند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
📌 نکته:
پسوندهای U و L به ندرت لازم می‌شوند، چون نوع‌های uint، long و ulong معمولاً یا به‌طور خودکار حدس زده می‌شوند (inferred) یا می‌توانند به‌طور ضمنی (implicitly) از int تبدیل شوند:
<pre><code class="language-csharp">long i = 5; // تبدیل ضمنی بدون از دست دادن داده از int به long
</code></pre>
<p>💡 پسوند D از نظر فنی اضافی است، چون هر عددی که یک نقطه اعشار داشته باشد به‌طور پیش‌فرض به عنوان double در نظر گرفته می‌شود. حتی می‌توانید با افزودن یک نقطه اعشار این کار را انجام دهید:</p>
<pre><code class="language-csharp">double x = 4.0;
</code></pre>
<p><strong>⭐ پسوندهای F و M</strong> بیشترین کاربرد را دارند و باید همیشه وقتی نوع float یا decimal را مشخص می‌کنید، استفاده شوند.</p>
<p>🔹 بدون پسوند F، کد زیر کامپایل نمی‌شود، چون 4.5 به‌طور پیش‌فرض از نوع double است و تبدیل ضمنی به float وجود ندارد:</p>
<pre><code class="language-csharp">float f = 4.5F;
</code></pre>
<p>🔹 همین اصل برای decimal هم صدق می‌کند:</p>
<pre><code class="language-csharp">decimal d = -1.23M; // بدون M کامپایل نمی‌شود
</code></pre>
<p>📖 در بخش بعدی، به‌طور کامل مفهوم تبدیل‌های عددی (numeric conversions) را توضیح خواهیم داد.</p>
<h3>تبدیل‌های عددی (Numeric Conversions)</h3>
<h4>تبدیل بین نوع‌های صحیح (Integral Types)</h4>
<p>تبدیل نوع‌های صحیح به‌صورت ضمنی (implicit) انجام می‌شود، زمانی که نوع مقصد بتواند تمام مقادیر ممکن نوع مبدأ را نمایش دهد. در غیر این صورت، یک تبدیل صریح (explicit) لازم است؛ برای مثال:</p>
<pre><code class="language-csharp">int x = 12345;       // int یک عدد صحیح 32 بیتی است
long y = x;          // تبدیل ضمنی به نوع صحیح 64 بیتی
short z = (short)x;  // تبدیل صریح به نوع صحیح 16 بیتی
</code></pre>
<h4>تبدیل بین نوع‌های اعشاری شناور (Floating-Point Types)</h4>
<p>یک مقدار float می‌تواند به‌صورت ضمنی به یک double تبدیل شود، چون double قادر است همه مقادیر ممکن یک float را نمایش دهد.
برعکس این تبدیل باید به‌صورت صریح انجام شود.</p>
<h4>تبدیل بین نوع‌های اعشاری شناور و صحیح (Floating-Point ↔ Integral Types)</h4>
<p>همه نوع‌های صحیح می‌توانند به‌صورت ضمنی به همه نوع‌های اعشاری شناور تبدیل شوند:</p>
<pre><code class="language-csharp">int i = 1;
float f = i;
</code></pre>
<p>اما برعکس این تبدیل باید صریح باشد:</p>
<pre><code class="language-csharp">int i2 = (int)f;
</code></pre>
<p>هنگامی که یک عدد اعشاری شناور را به یک نوع صحیح تبدیل می‌کنید، هر بخش کسری (fractional portion) حذف می‌شود و هیچ گرد شدنی (rounding) انجام نمی‌شود.
کلاس ایستای System.Convert متدهایی فراهم می‌کند که هنگام تبدیل بین نوع‌های عددی مختلف، عملیات گرد کردن را انجام می‌دهند (به فصل ۶ مراجعه کنید).</p>
<h4>دقت (Precision) در تبدیل اعداد بزرگ</h4>
<p>تبدیل ضمنی یک نوع صحیح بزرگ به یک نوع اعشاری شناور، مقدار کلی (magnitude) را حفظ می‌کند اما گاهی ممکن است دقت (precision) از دست برود.
این به این دلیل است که نوع‌های اعشاری شناور همیشه بازه عددی (magnitude) بیشتری نسبت به نوع‌های صحیح دارند، اما ممکن است دقت کمتری داشته باشند.</p>
<p>بازنویسی مثال با یک عدد بزرگ:</p>
<pre><code class="language-csharp">int i1 = 100000001;
float f = i1;          // مقدار کلی حفظ شده، اما دقت از دست رفته
int i2 = (int)f;       // خروجی: 100000000
</code></pre>
<h4>تبدیل‌های Decimal</h4>
<p>همه نوع‌های صحیح را می‌توان به‌صورت ضمنی به نوع decimal تبدیل کرد، زیرا decimal می‌تواند همه مقادیر ممکن نوع‌های صحیح C# را نمایش دهد.
تمام تبدیل‌های عددی دیگر به/از نوع decimal باید به‌صورت صریح انجام شوند، زیرا این تبدیل‌ها می‌توانند باعث شوند مقدار خارج از محدوده (out of range) شود یا دقت آن از دست برود.</p>
<h3>عملگرهای حسابی (Arithmetic Operators) 🔢</h3>
<p>عملگرهای حسابی در C# برای همه نوع‌های عددی به جز نوع‌های صحیح 8 و 16 بیتی تعریف شده‌اند:</p>
<p>عملگر توضیح</p>
<ul>
<li>➕ جمع (Addition)</li>
</ul>
<ul>
<li>➖ تفریق (Subtraction)</li>
</ul>
<ul>
<li>✖️ ضرب (Multiplication)
/ ➗ تقسیم (Division)
% باقیمانده بعد از تقسیم (Remainder)</li>
</ul>
<h3>عملگرهای افزایش و کاهش (Increment &amp; Decrement Operators) ⬆️⬇️</h3>
<p>عملگر ++ مقدار متغیر را ۱ واحد افزایش و عملگر -- مقدار را ۱ واحد کاهش می‌دهد.
این عملگرها می‌توانند قبل یا بعد از متغیر بیایند:</p>
<pre><code class="language-csharp">int x = 0, y = 0;
Console.WriteLine(x++); // خروجی: 0  → سپس x می‌شود 1
Console.WriteLine(++y); // خروجی: 1  → y قبل از چاپ افزایش می‌یابد
</code></pre>
<p>📌 نکته: قبل گذاشتن (++y) یعنی اول تغییر، بعد استفاده.
بعد گذاشتن (y++) یعنی اول استفاده، بعد تغییر.</p>
<h3>عملیات ویژه روی نوع‌های صحیح (Specialized Operations on Integral Types) 🧮</h3>
<p>نوع‌های صحیح شامل:
int, uint, long, ulong, short, ushort, byte, sbyte</p>
<h4>تقسیم (Division) ➗</h4>
<ul>
<li>در نوع‌های صحیح، نتیجه تقسیم همیشه بخش اعشاری را حذف می‌کند (گرد کردن به صفر).</li>
</ul>
<ul>
<li>
<p>تقسیم بر ۰ در زمان اجرا (runtime) باعث خطا (DivideByZeroException) می‌شود.</p>
</li>
<li>
<p>تقسیم بر ثابت یا مقدار صفر در زمان کامپایل (compile-time) خطا می‌دهد.</p>
</li>
</ul>
<pre><code class="language-csharp">int a = 2 / 3; // خروجی: 0
int b = 0;
int c = 5 / b; // خطای DivideByZeroException
</code></pre>
<h4>سرریز (Overflow) ⚠️</h4>
<p>در عملیات عددی روی نوع‌های صحیح، اگر مقدار از محدوده نوع داده فراتر برود، به‌طور پیش‌فرض خطایی رخ نمی‌دهد، بلکه مقدار دور می‌زند (wraparound).</p>
<pre><code class="language-csharp">int a = int.MinValue;
a--;
Console.WriteLine(a == int.MaxValue); // True
</code></pre>
<h4>بررسی سرریز با checked ✅</h4>
<p>اگر بخواهید در صورت سرریز خطا (OverflowException) دریافت کنید، از checked استفاده کنید. این دستور روی عملگرهای:
++, --, +, -, *, / و تبدیل‌های صریح بین نوع‌های صحیح اثر دارد.</p>
<pre><code class="language-csharp">int a = 1000000;
int b = 1000000;
int c = checked(a * b); // بررسی فقط همین عبارت
</code></pre>
<p>یا می‌توانید یک بلوک کامل را بررسی کنید:</p>
<pre><code class="language-csharp">checked
{
    c = a * b; // همه عبارات این بلوک بررسی می‌شوند
}
</code></pre>
<p>📌 نکات مهم:</p>
<ul>
<li>
<p>روی double و float بی‌اثر است (این نوع‌ها در سرریز مقدار &quot;بی‌نهایت&quot; می‌گیرند).</p>
</li>
<li>
<p>روی decimal همیشه بررسی انجام می‌شود.</p>
</li>
<li>
<p>می‌توانید در تنظیمات پروژه (Advanced Build Settings) حالت checked را به‌طور پیش‌فرض فعال کنید.</p>
</li>
<li>
<p>اگر checked پیش‌فرض فعال باشد، با unchecked می‌توان بررسی را غیرفعال کرد:</p>
</li>
</ul>
<pre><code class="language-csharp">int x = int.MaxValue;
int y = unchecked(x + 1); // خطا نمی‌دهد
</code></pre>
<h3>بررسی سرریز (Overflow) برای عبارت‌های ثابت 📏💥</h3>
<p>فارغ از این‌که تنظیم «checked» در پروژه فعال باشد یا نه، تمام عبارت‌هایی که در زمان کامپایل ارزیابی می‌شوند، همیشه از نظر سرریز بررسی می‌شوند—مگر این‌که از عملگر unchecked استفاده کنید:</p>
<pre><code class="language-csharp">int x = int.MaxValue + 1;               // ❌ خطای زمان کامپایل
int y = unchecked(int.MaxValue + 1);    // ✅ بدون خطا
</code></pre>
<p>🔍 نکته:
در حالت اول، چون محاسبه در زمان کامپایل انجام می‌شود و مقدار فراتر از int.MaxValue می‌رود، کامپایلر جلوی اجرای آن را می‌گیرد. اما با unchecked به کامپایلر می‌گویید که بررسی سرریز را انجام ندهد و اجازه دهد عملیات بدون خطا انجام شود—even اگر نتیجه wrap-around شود.</p>
<h3>Bitwise Operators</h3>
<p>C# از Bitwise Operators زیر پشتیبانی می‌کند:</p>
<p><img src="../../../assets/image/02/Table-2-3.png" alt="Conventions-UsedThis-Book"></p>
<p>عملگر شیفت به راست &gt;&gt; و تفاوتش با &gt;&gt;&gt; ⚙️</p>
<p>وقتی عملگر شیفت به راست (&gt;&gt;) روی اعداد صحیح علامت‌دار (signed integers) اعمال می‌شود، بیت پرارزش (بیت علامت) را تکرار می‌کند.
اما عملگر شیفت به راست بدون علامت (&gt;&gt;&gt;) این کار را انجام نمی‌دهد و همیشه بیت‌های خالی را با صفر پر می‌کند.</p>
<p>📌 مثال ساده:</p>
<pre><code class="language-csharp">int a = -8;     // در باینری: 11111111 11111111 11111111 11111000
int b = a &gt;&gt; 2; // تکرار بیت علامت: 11111111 11111111 11111111 11111110
int c = a &gt;&gt;&gt; 2;// بدون تکرار بیت علامت: 00111111 11111111 11111111 11111110
</code></pre>
<p>علاوه بر این عملگرها، عملیات بیتی پیشرفته‌تری از طریق کلاس BitOperations در فضای نام System.Numerics ارائه شده است
(نگاه کنید به بخش “BitOperations” در صفحه 340 📖).</p>
<h3>🔢 انواع عدد صحیح ۸ و ۱۶ بیتی</h3>
<p>انواع عدد صحیح ۸ و ۱۶ بیتی شامل byte، sbyte، short و ushort هستند.
این نوع‌ها عملگرهای حسابی مخصوص به خود را ندارند، بنابراین #C به‌طور ضمنی آن‌ها را در صورت نیاز به انواع بزرگ‌تر تبدیل می‌کند.</p>
<p>این موضوع می‌تواند باعث خطای زمان کامپایل شود وقتی بخواهید نتیجه عملیات را دوباره به یک نوع کوچک اختصاص دهید:</p>
<pre><code class="language-csharp">short x = 1, y = 1;
short z = x + y;   // ❌ خطای زمان کامپایل
</code></pre>
<p>در این مثال، x و y به‌طور ضمنی به نوع int تبدیل می‌شوند تا عمل جمع انجام شود.
این یعنی نتیجه نیز یک int خواهد بود که نمی‌تواند به‌طور ضمنی به short تبدیل شود (چون احتمال از دست رفتن داده وجود دارد).</p>
<p>برای رفع خطا باید تبدیل (Cast) صریح انجام دهید:</p>
<pre><code class="language-csharp">short z = (short)(x + y);  // ✅ صحیح
</code></pre>
<h3>🌊 مقادیر خاص float و double</h3>
<p>برخلاف انواع عدد صحیح، انواع اعشاری (float و double) مقادیری دارند که برخی عملیات‌ها آن‌ها را به‌طور ویژه پردازش می‌کنند. این مقادیر خاص عبارتند از:</p>
<ul>
<li>
<p>NaN (عدد نامعتبر یا Not a Number) 🌀</p>
</li>
<li>
<p>+∞ (مثبت بی‌نهایت) ♾️</p>
</li>
<li>
<p>−∞ (منفی بی‌نهایت) ♾️</p>
</li>
<li>
<p>−0 (منفی صفر)</p>
</li>
</ul>
<p>کلاس‌های float و double ثابت‌هایی برای NaN، +∞ و −∞ دارند، همچنین مقادیر دیگری مثل MaxValue، MinValue و Epsilon نیز موجود است.</p>
<p>مثال:</p>
<pre><code class="language-csharp">Console.WriteLine(double.NegativeInfinity); // -Infinity
</code></pre>
<p>Constants که special values را برای double و float نشان می‌دهند، به شرح زیر هستند:</p>
<p><img src="../../../assets/image/02/Table-2-4.png" alt="Conventions-UsedThis-Book"></p>
<p>تقسیم یک عدد ناصفر بر صفر منجر به یک مقدار بی‌نهایت می‌شود:</p>
<pre><code class="language-csharp">Console.WriteLine ( 1.0 /  0.0);                  //  Infinity
Console.WriteLine (−1.0 /  0.0);                  // -Infinity
Console.WriteLine ( 1.0 / −0.0);                  // -Infinity
Console.WriteLine (−1.0 / −0.0);                  //  Infinity
</code></pre>
<p>تقسیم صفر بر صفر، یا کم کردن بی‌نهایت از بی‌نهایت، منجر به یک مقدار NaN می‌شود:</p>
<pre><code class="language-csharp">Console.WriteLine ( 0.0 /  0.0);                  //  NaN
Console.WriteLine ((1.0 /  0.0) − (1.0 / 0.0));   //  NaN
</code></pre>
<p>وقتی از عملگر == استفاده می‌کنید، یک مقدار NaN هرگز برابر با مقدار دیگری نیست، حتی اگر آن مقدار NaN دیگری باشد:</p>
<pre><code class="language-csharp">Console.WriteLine (0.0 / 0.0 == double.NaN);    // False
</code></pre>
<p>برای بررسی اینکه آیا یک مقدار NaN است، باید از متد float.IsNaN یا double.IsNaN استفاده کنید:</p>
<pre><code class="language-csharp">Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True
</code></pre>
<p>با این حال، هنگام استفاده از object.Equals، دو مقدار NaN برابر در نظر گرفته می‌شوند:</p>
<pre><code class="language-csharp">Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));   // True
</code></pre>
<p>مقادیر NaN گاهی برای نمایش مقادیر خاص مفید هستند.
در Windows Presentation Foundation (WPF)، مقدار double.NaN نمایانگر یک اندازه‌گیری با مقدار «خودکار» (Automatic) است.
راه دیگر برای نمایش چنین مقداری، استفاده از یک نوع تهی‌پذیر (nullable type) است (فصل ۴)؛
و یا استفاده از یک ساختار سفارشی (custom struct) که یک نوع عددی را در خود نگه داشته و یک فیلد اضافی به آن اضافه می‌کند (فصل ۳).</p>
<p>نوع‌های float و double از مشخصات قالب IEEE 754 پیروی می‌کنند که تقریباً توسط تمام پردازنده‌ها به صورت بومی پشتیبانی می‌شود.
می‌توانید اطلاعات دقیق‌تر درباره رفتار این نوع‌ها را در <a href="http://www.ieee.org">http://www.ieee.org</a> پیدا کنید.</p>
<h3>🔍 مقایسه‌ی double و decimal</h3>
<p>🔹 double برای محاسبات علمی مفید است (مانند محاسبه‌ی مختصات فضایی 🛰️).
🔹 decimal برای محاسبات مالی 💰 و مقادیری که ساخته‌شده‌اند و نه نتیجه‌ی اندازه‌گیری‌های دنیای واقعی، مناسب است.</p>
<p>📌 در اینجا خلاصه‌ای از تفاوت‌ها آورده شده است.</p>
<p><img src="../../../assets/image/02/Table-2-5.png" alt="Conventions-UsedThis-Book"></p>
<h3>خطاهای گرد کردن اعداد حقیقی 🧮</h3>
<p>نوع داده‌های float و double به‌صورت داخلی اعداد را در مبنای ۲ ذخیره می‌کنند.
به همین دلیل، فقط اعدادی که در مبنای ۲ قابل بیان باشند، دقیق نمایش داده می‌شوند.</p>
<p>در عمل، این یعنی بیشتر عددهای اعشاری که ما به‌صورت مبنای ۱۰ می‌نویسیم، دقیق ذخیره نمی‌شوند.
مثلاً:</p>
<pre><code class="language-csharp">float x = 0.1f;  // دقیقاً 0.1 نیست
Console.WriteLine (x + x + x + x + x + x + x + x + x + x);
// خروجی: 1.0000001
</code></pre>
<p>به همین دلیل، float و double برای محاسبات مالی انتخاب خوبی نیستند.
در مقابل، نوع داده‌ی decimal در مبنای ۱۰ کار می‌کند و می‌تواند اعدادی را که در مبنای ۱۰ قابل بیان هستند، دقیق ذخیره کند (همچنین مقسوم‌علیه‌های آن یعنی مبنای ۲ و ۵ را هم).</p>
<p>چون عددهای اعشاری که ما می‌نویسیم در مبنای ۱۰ هستند، decimal می‌تواند عددهایی مثل 0.1 را دقیق نمایش دهد.</p>
<p>با این حال، حتی double و decimal هم نمی‌توانند عددهای کسری‌ای را که در مبنای ۱۰ نمایش دوره‌ای دارند، دقیق ذخیره کنند:</p>
<pre><code class="language-csharp">decimal m = 1M / 6M;     // 0.1666666666666666666666666667M
double  d = 1.0 / 6.0;   // 0.16666666666666666
</code></pre>
<p>این موضوع باعث ایجاد خطاهای تجمعی در گرد کردن می‌شود:</p>
<pre><code class="language-csharp">decimal notQuiteWholeM = m+m+m+m+m+m;  // 1.0000000000000000000000000002M
double  notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989
</code></pre>
<p>که می‌تواند باعث شکست در عملیات مقایسه و برابری شود:</p>
<pre><code class="language-csharp">Console.WriteLine (notQuiteWholeM == 1M);   // False
Console.WriteLine (notQuiteWholeD &lt; 1.0);   // True
</code></pre>
<h3>نوع بولی و عملگرها (Boolean Type and Operators)</h3>
<p>نوع bool در زبان C# (که نام مستعار نوع System.Boolean است) یک مقدار منطقی را نشان می‌دهد که می‌تواند مقدار ثابت true یا false داشته باشد.</p>
<p>اگرچه یک مقدار بولی از نظر تئوری فقط به یک بیت حافظه نیاز دارد، اما در زمان اجرا (runtime) یک بایت کامل حافظه استفاده می‌شود، چون این کوچک‌ترین واحدی است که پردازنده و زمان اجرا می‌توانند به شکل کارآمد با آن کار کنند.</p>
<p>برای جلوگیری از هدر رفت حافظه در مواقعی مثل آرایه‌های بزرگ از مقادیر بولی، دات‌نت کلاسی به نام BitArray در فضای نام System.Collections ارائه می‌دهد که طوری طراحی شده است که برای هر مقدار بولی فقط یک بیت استفاده کند.</p>
<h4>تبدیل‌های نوع بولی (bool Conversions)</h4>
<p>هیچ نوع تبدیلی (casting) بین bool و انواع عددی (numeric types) وجود ندارد؛ یعنی شما نمی‌توانید یک عدد را مستقیم به bool تبدیل کنید یا برعکس.</p>
<h4>عملگرهای برابری و مقایسه (Equality and Comparison Operators)</h4>
<p>عملگرهای == و != برای بررسی برابری و نابرابری همه نوع‌ها به کار می‌روند و همیشه یک مقدار بولی برمی‌گردانند.</p>
<p>برای انواع مقداری (Value Types) مثل int، مفهوم برابری معمولاً ساده است:</p>
<pre><code class="language-csharp">int x = 1;
int y = 2;
int z = 1;

Console.WriteLine(x == y); // False
Console.WriteLine(x == z); // True
</code></pre>
<p>📌 نکته: در تئوری می‌توان این عملگرها را overload کرد تا نوعی غیر از bool برگردانند (فصل 4)، ولی در عمل تقریباً هرگز این کار انجام نمی‌شود.</p>
<h4>برابری در انواع ارجاعی (Reference Types)</h4>
<p>برای انواع ارجاعی، برابری به طور پیش‌فرض بر اساس آدرس مرجع بررسی می‌شود، نه مقدار واقعی شیء:</p>
<pre><code class="language-csharp">Dude d1 = new Dude(&quot;John&quot;);
Dude d2 = new Dude(&quot;John&quot;);
Console.WriteLine(d1 == d2); // False

Dude d3 = d1;
Console.WriteLine(d1 == d3); // True

public class Dude
{
    public string Name;
    public Dude(string n) { Name = n; }
}
</code></pre>
<p><strong>نکات تکمیلی</strong></p>
<ul>
<li>
<p>عملگرهای ==، !=، &lt;، &gt;، &gt;= و &lt;= روی همه انواع عددی کار می‌کنند.</p>
</li>
<li>
<p>ولی باید هنگام استفاده با اعداد اعشاری (real numbers) دقت کنید، چون خطاهای گرد کردن (rounding errors) می‌تواند نتایج مقایسه را تحت تأثیر قرار دهد (همان‌طور که در بخش «خطاهای گرد کردن اعداد حقیقی» صفحه 54 دیدیم).</p>
</li>
<li>
<p>این عملگرها همچنین روی مقادیر enum هم کار می‌کنند، چون مقادیر آن‌ها بر اساس نوع عددی زیرین‌شان مقایسه می‌شود (توضیح کامل در بخش «Enums» صفحه 154).</p>
</li>
<li>
<p>جزئیات بیشتر در مورد این عملگرها در فصل‌های «Operator Overloading» صفحه 256، «Equality Comparison» صفحه 344 و «Order Comparison» صفحه 355 آمده است.</p>
</li>
</ul>
<h4>عملگرهای شرطی (Conditional Operators)</h4>
<p>عملگرهای &amp;&amp; و || برای بررسی شرایط و (and) و یا (or) استفاده می‌شوند. این عملگرها معمولاً همراه با عملگر ! که بیانگر not (نقیض) است، به کار می‌روند.</p>
<p>در مثال زیر، متد UseUmbrella مقدار true برمی‌گرداند اگر هوا بارانی یا آفتابی باشد (برای محافظت از باران یا آفتاب)، البته به شرطی که هم‌زمان باد هم نوزد (چون چتر در باد بی‌فایده است):</p>
<pre><code class="language-csharp">static bool UseUmbrella (bool rainy, bool sunny, bool windy)
{
    return !windy &amp;&amp; (rainy || sunny);
}
</code></pre>
<p>عملگرهای &amp;&amp; و || ارزیابی کوتاه‌مدت (short-circuit evaluation) انجام می‌دهند؛ یعنی وقتی ممکن باشد، از ادامه ارزیابی جلوگیری می‌کنند.</p>
<p>در مثال بالا، اگر windy برابر true باشد، عبارت (rainy || sunny) حتی ارزیابی هم نمی‌شود.</p>
<p>این ویژگی بسیار مهم است، چون اجازه می‌دهد کدهایی مانند نمونه زیر بدون ایجاد NullReferenceException اجرا شوند:</p>
<p>csharp
Copy
Edit
if (sb != null &amp;&amp; sb.Length &gt; 0) ...
<strong>عملگرهای &amp; و |</strong></p>
<p>عملگرهای &amp; و | هم برای بررسی شرایط و و یا به کار می‌روند:</p>
<pre><code class="language-csharp">return !windy &amp; (rainy | sunny);
</code></pre>
<p>تفاوتشان با &amp;&amp; و || این است که ارزیابی کوتاه‌مدت انجام نمی‌دهند. به همین دلیل، به‌ندرت به جای عملگرهای شرطی اصلی استفاده می‌شوند.</p>
<p>برخلاف زبان‌های C و ++C، وقتی عملگرهای &amp; و | روی عبارت‌های bool به کار می‌روند، مقایسه‌های منطقی (Boolean comparisons) انجام می‌دهند و عملیات بیتی (bitwise) تنها زمانی اتفاق می‌افتد که روی اعداد اعمال شوند.</p>
<h5>عملگر شرطی سه‌تایی (Ternary Operator)</h5>
<p>عملگر شرطی (که معمولاً به آن عملگر سه‌تایی می‌گویند، چون تنها عملگری است که سه عملوند می‌گیرد) به شکل زیر است:</p>
<pre><code class="language-less">q ? a : b
</code></pre>
<p>اگر شرط q برابر true باشد، عبارت a ارزیابی می‌شود؛ در غیر این صورت، عبارت b ارزیابی می‌شود:</p>
<pre><code class="language-csharp">static int Max (int a, int b)
{
    return (a &gt; b) ? a : b;
}
</code></pre>
<p>این عملگر در عبارات LINQ (فصل ۸) به‌خصوص کاربرد زیادی دارد. ✅</p>
<h3>رشته‌ها و کاراکترها 📝</h3>
<p>نوع داده char در #C (که نام مستعار System.Char است) یک کاراکتر یونیکد را نمایش می‌دهد و ۲ بایت (با استاندارد UTF-16) فضا اشغال می‌کند.
یک مقدار کاراکتر به‌صورت تک‌نقل‌قول نوشته می‌شود:</p>
<pre><code class="language-csharp">char c = 'A';       // کاراکتر ساده
</code></pre>
<p>کاراکترهای ویژه یا همان Escape Sequences کاراکترهایی هستند که نمی‌توان آن‌ها را به‌طور مستقیم نوشت یا تفسیر کرد.
برای نوشتن این کاراکترها، یک بک‌اسلش () به‌علاوه‌ی یک حرف با معنی خاص استفاده می‌شود.
مثال:</p>
<pre><code class="language-csharp">char newLine = '\n';   // خط جدید
char backSlash = '\\'; // بک‌اسلش
</code></pre>
<p>📌 جدول ۲-۲ کاراکترهای Escape Sequence را نشان می‌دهد.
Table 2-2 escape sequence characters را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-6.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-6-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>دستورات \u یا \x این امکان را می‌دهند که هر کاراکتر یونیکد را با استفاده از کد هگزادسیمال چهاررقمی مشخص کنید:</p>
<pre><code class="language-csharp">char copyrightSymbol = '\u00A9';
char omegaSymbol     = '\u03A9';
char newLine         = '\u000A';
</code></pre>
<h4>تبدیل‌های کاراکتر 🔄</h4>
<p>یک تبدیل ضمنی (Implicit Conversion) از نوع char به یک نوع عددی، در صورتی انجام می‌شود که نوع عددی بتواند یک مقدار unsigned short را در خود جای دهد.
برای سایر انواع عددی، یک تبدیل صریح (Explicit Conversion) لازم است.</p>
<h4>📝 رشته‌ها (Strings) و نوع string</h4>
<p>در C#، نوع داده‌ی string (که در واقع نام مستعار System.String است و به‌طور کامل در فصل ۶ توضیح داده می‌شود) نمایانگر یک دنباله‌ی غیرقابل تغییر (Immutable) از کاراکترهای یونیکد است.</p>
<ol>
<li>ایجاد رشته
برای تعریف یک رشته، از دابل کوتیشن (&quot; &quot;) استفاده می‌کنیم:</li>
</ol>
<pre><code class="language-csharp">string a = &quot;Heat&quot;;
</code></pre>
<ol start="2">
<li>نوع مرجع (Reference Type) با رفتار مقایسه‌ی مقداری
نوع string از نوع مرجع است، اما عملگرهای مقایسه (== و !=) مثل نوع‌های مقداری رفتار می‌کنند:</li>
</ol>
<pre><code class="language-csharp">string a = &quot;test&quot;;
string b = &quot;test&quot;;
Console.Write(a == b);  // خروجی: True
</code></pre>
<p>این یعنی مقایسه، مقدار رشته را بررسی می‌کند نه محل ذخیره‌سازی در حافظه.</p>
<ol start="3">
<li>استفاده از سکانس‌های فرار (Escape Sequences)
همان سکانس‌های فرار که برای char معتبر بودند، در string هم کار می‌کنند:</li>
</ol>
<pre><code class="language-csharp">string a = &quot;Here's a tab:\t&quot;;
</code></pre>
<ol start="4">
<li>مشکل بک‌اسلش و راه‌حل آن
به‌دلیل استفاده از بک‌اسلش \ در سکانس‌های فرار، برای نوشتن یک بک‌اسلش واقعی باید آن را دو بار بنویسید:</li>
</ol>
<pre><code class="language-csharp">string a1 = &quot;\\\\server\\fileshare\\helloworld.cs&quot;;
</code></pre>
<ol start="5">
<li>رشته‌های حرف‌به‌حرف (Verbatim Strings)
برای راحت‌تر نوشتن رشته‌ها، می‌توانیم از پیشوند @ استفاده کنیم که:</li>
</ol>
<p>سکانس‌های فرار را نادیده می‌گیرد</p>
<p>امکان نوشتن رشته‌ها در چند خط را می‌دهد</p>
<p>مثال:</p>
<pre><code class="language-csharp">string a2 = @&quot;\\server\fileshare\helloworld.cs&quot;;
</code></pre>
<p>همچنین:</p>
<pre><code class="language-csharp">string escaped  = &quot;First Line\r\nSecond Line&quot;;
string verbatim = @&quot;First Line
Second Line&quot;;

Console.WriteLine(escaped == verbatim); // True (اگر ویرایشگر از CR-LF استفاده کند)
</code></pre>
<ol start="6">
<li>قرار دادن کوتیشن دوتایی داخل رشته‌ی حرف‌به‌حرف
برای گذاشتن &quot; داخل یک رشته‌ی verbatim، باید آن را دو بار بنویسید:</li>
</ol>
<pre><code class="language-csharp">string xml = @&quot;&lt;customer id=&quot;&quot;123&quot;&quot;&gt;&lt;/customer&gt;&quot;;
</code></pre>
<h4>🔹 لیترال‌های رشته‌ای خام (Raw String Literals) در #C 11</h4>
<p>اگر یک رشته را در سه یا بیشتر علامت نقل‌قول دوتایی (&quot;&quot;&quot;) قرار دهید، یک رشته‌ی خام ایجاد می‌شود. رشته‌های خام می‌توانند تقریباً هر دنباله‌ای از کاراکترها را شامل شوند، بدون نیاز به فرار دادن (escaping) یا دوبل‌کردن کاراکترها:</p>
<pre><code class="language-csharp">string raw = &quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;;
</code></pre>
<p>رشته‌های خام نوشتن متن‌هایی مثل JSON، XML و HTML را بسیار راحت می‌کنند، همچنین برای عبارات منظم (Regex) و کد منبع هم مفید هستند.</p>
<p>اگر لازم باشد که سه یا بیشتر علامت نقل‌قول دوتایی در خود رشته داشته باشید، کافیست رشته را با چهار یا بیشتر علامت نقل‌قول دوتایی بپیچید:</p>
<pre><code class="language-csharp">string raw = &quot;&quot;&quot;&quot;The &quot;&quot;&quot; sequence denotes raw string literals.&quot;&quot;&quot;&quot;;
</code></pre>
<p><strong>📜 رشته‌های خام چندخطی</strong></p>
<p>رشته‌های خام چندخطی قوانین خاصی دارند. برای مثال، می‌توان رشته‌ی &quot;Line 1\r\nLine 2&quot; را اینگونه نوشت:</p>
<pre><code class="language-csharp">string multiLineRaw = &quot;&quot;&quot;
  Line 1
  Line 2
&quot;&quot;&quot;;
</code></pre>
<p>🔹 توجه کنید: علامت‌های شروع (&quot;&quot;&quot;) و پایان (&quot;&quot;&quot;) باید در خطوط جداگانه از محتوای رشته باشند.</p>
<p>همچنین:</p>
<ul>
<li>
<p>فضای خالی (Whitespace) بعد از علامت شروع &quot;&quot;&quot; (در همان خط) نادیده گرفته می‌شود.</p>
</li>
<li>
<p>فضای خالی قبل از علامت پایان &quot;&quot;&quot; (در همان خط) به‌عنوان تورفتگی مشترک (common indentation) در نظر گرفته شده و از همه‌ی خطوط رشته حذف می‌شود. این کار باعث می‌شود تورفتگی کد منبع برای خوانایی حفظ شود، اما بخشی از رشته نشود.</p>
</li>
</ul>
<p>📌 نمونه‌ی دیگر</p>
<pre><code class="language-csharp">if (true)
    Console.WriteLine(&quot;&quot;&quot;
        {
          &quot;Name&quot; : &quot;Joe&quot;
        }
    &quot;&quot;&quot;);
</code></pre>
<p>📤 خروجی:</p>
<pre><code class="language-json">{
  &quot;Name&quot; : &quot;Joe&quot;
}
</code></pre>
<p>⚠️ اگر در یک رشته‌ی خام چندخطی، هر خط تورفتگی مشترک مشخص‌شده در علامت پایان را نداشته باشد، کامپایلر خطا می‌دهد.</p>
<p>💡 رشته‌های خام می‌توانند قابل درون‌گذاری (Interpolated) هم باشند، البته با قوانین خاصی که در بخش «درون‌گذاری رشته» توضیح داده شده است.</p>
<h4>الحاق رشته‌ها (String Concatenation)</h4>
<p>عملگر + می‌تواند دو رشته را به هم متصل کند:</p>
<pre><code class="language-csharp">string s = &quot;a&quot; + &quot;b&quot;;
</code></pre>
<p>اگر یکی از عملوندها رشته نباشد، متد ToString روی آن فراخوانی می‌شود:</p>
<pre><code class="language-csharp">string s = &quot;a&quot; + 5;  // خروجی: a5
</code></pre>
<p>استفاده مکرر از + برای ساخت یک رشته طولانی غیر بهینه است. راه‌حل بهتر استفاده از کلاس System.Text.StringBuilder است (که در فصل ۶ توضیح داده می‌شود).</p>
<h4>درون‌گذاری رشته‌ها (String Interpolation)</h4>
<p>اگر یک رشته با علامت $ شروع شود، به آن رشته درون‌گذاری‌شده می‌گویند. این رشته‌ها می‌توانند شامل عبارات C# درون {} باشند:</p>
<pre><code class="language-csharp">int x = 4;
Console.Write ($&quot;A square has {x} sides&quot;);

// خروجی: A square has 4 sides
</code></pre>
<p>هر عبارت معتبر C# از هر نوع داده‌ای می‌تواند درون {} قرار گیرد و C# آن را با استفاده از ToString یا معادل آن به رشته تبدیل می‌کند.</p>
<p>قالب‌دهی درون رشته
می‌توان بعد از عبارت، یک علامت : و رشته قالب (Format String) نوشت:</p>
<pre><code class="language-csharp">string s = $&quot;255 in hex is {byte.MaxValue:X2}&quot;;  
// X2 = نمایش هگزادسیمال دو رقمی
// خروجی: 255 in hex is FF
</code></pre>
<p>اگر لازم باشد از : در جای دیگری استفاده کنید (مثل عملگر شرطی سه‌تایی ?:)، باید کل عبارت را داخل پرانتز بگذارید:</p>
<pre><code class="language-csharp">bool b = true;
Console.WriteLine ($&quot;The answer in binary is {(b ? 1 : 0)}&quot;);
</code></pre>
<p><strong>قابلیت‌های جدید C# در رشته‌های درون‌گذاری‌شده</strong></p>
<ul>
<li>از C# 10: رشته‌های درون‌گذاری‌شده می‌توانند const باشند، به شرطی که تمام مقادیر درون‌گذاری نیز ثابت باشند:</li>
</ul>
<pre><code class="language-csharp">const string greeting = &quot;Hello&quot;;
const string message = $&quot;{greeting}, world&quot;;
</code></pre>
<ul>
<li>از C# 11: رشته‌های درون‌گذاری‌شده می‌توانند چندخطی باشند (چه معمولی، چه verbatim):</li>
</ul>
<pre><code class="language-csharp">string s = $&quot;this interpolation spans {1 + 1} lines&quot;;
</code></pre>
<ul>
<li>رشته‌های خام (Raw String Literals) نیز می‌توانند درون‌گذاری شوند:</li>
</ul>
<pre><code class="language-csharp">string s = $&quot;&quot;&quot;The date and time is {DateTime.Now}&quot;&quot;&quot;;
</code></pre>
<p><strong>قرار دادن آکولاد به‌صورت ثابت در رشته درون‌گذاری‌شده</strong></p>
<ul>
<li>
<p>در رشته‌های معمولی و verbatim: کاراکتر آکولاد ({ یا }) را دوبار بنویسید.</p>
</li>
<li>
<p>در رشته‌های خام: با تکرار علامت $ در ابتدای رشته، طول توالی آکولاد تغییر می‌کند.</p>
</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">Console.WriteLine ($$&quot;&quot;&quot;{ &quot;TimeStamp&quot;: &quot;&quot; }&quot;&quot;&quot;);
// خروجی: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }
</code></pre>
<p>این روش باعث می‌شود بتوانید متن را مستقیماً کپی و در رشته خام قرار دهید، بدون نیاز به تغییر آکولادها.</p>
<h4>مقایسه‌ی رشته‌ها (String comparisons)</h4>
<p>برای انجام مقایسه برابری رشته‌ها، می‌توانید از عملگر == (یا یکی از متدهای Equals کلاس string) استفاده کنید.
برای مقایسه‌ی ترتیب، باید از متد CompareTo رشته استفاده کنید؛ عملگرهای &lt; و &gt; در این زمینه پشتیبانی نمی‌شوند. ما جزئیات مربوط به برابری و مقایسه‌ی ترتیب را در بخش «Comparing Strings» در صفحه ۲۹۷ توضیح داده‌ایم.</p>
<h3>رشته‌های UTF-8</h3>
<p>از نسخه‌ی C# 11، می‌توانید با استفاده از پسوند u8 رشته‌هایی ایجاد کنید که به جای UTF-16 در UTF-8 رمزگذاری شده‌اند.
این ویژگی برای سناریوهای پیشرفته، مانند مدیریت سطح پایین متن JSON در بخش‌هایی که عملکرد (Performance) بسیار مهم است، طراحی شده است:</p>
<pre><code class="language-csharp">ReadOnlySpan&lt;byte&gt; utf8 = &quot;ab→cd&quot;u8;  // علامت فلش ۳ بایت مصرف می‌کند
Console.WriteLine(utf8.Length);       // خروجی: 7
</code></pre>
<p>نوع زیرین آن ReadOnlySpan<byte> است که در فصل ۲۳ بررسی خواهیم کرد.
برای تبدیل آن به آرایه، می‌توانید متد ToArray() را فراخوانی کنید.</p>
<h3>آرایه‌ها (Arrays)</h3>
<p>آرایه یک تعداد ثابت از متغیرها (که به آن‌ها عنصر یا element گفته می‌شود) از یک نوع مشخص را نشان می‌دهد. عناصر یک آرایه همیشه به صورت پشت‌سرهم در یک بلوک پیوسته از حافظه ذخیره می‌شوند، که این باعث دسترسی بسیار کارآمد به آن‌ها می‌شود.</p>
<p>آرایه با قرار دادن کروشه ([]) بعد از نوع عنصر تعریف می‌شود:</p>
<pre><code class="language-csharp">char[] vowels = new char[5];    // تعریف یک آرایه ۵ کاراکتری
</code></pre>
<p>کروشه‌ها همچنین برای اندیس‌دهی (indexing) استفاده می‌شوند تا به یک عنصر مشخص بر اساس موقعیتش دسترسی پیدا کنیم:</p>
<pre><code class="language-csharp">vowels[0] = 'a';
vowels[1] = 'e';
vowels[2] = 'i';
vowels[3] = 'o';
vowels[4] = 'u';

Console.WriteLine(vowels[1]);   // e
</code></pre>
<p>در اینجا خروجی e چاپ می‌شود، چون اندیس‌های آرایه از ۰ شروع می‌شوند.</p>
<p>می‌توانید از حلقه for برای پیمایش (iterate) تمام عناصر یک آرایه استفاده کنید. کد زیر متغیر i را از ۰ تا ۴ پیمایش می‌کند:</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; vowels.Length; i++)
    Console.Write(vowels[i]);   // خروجی: aeiou
</code></pre>
<p>ویژگی (property)‌ Length در یک آرایه، تعداد عناصر آن را برمی‌گرداند. بعد از ایجاد یک آرایه، طول آن قابل تغییر نیست.
فضای نام (namespace) System.Collections و زیرمجموعه‌های آن، ساختارهای داده پیشرفته‌تری مانند آرایه‌های با اندازه پویا (dynamic arrays) و دیکشنری‌ها را ارائه می‌کنند.</p>
<p>یک عبارت مقداردهی اولیه (initialization expression) به شما این امکان را می‌دهد که آرایه را در یک مرحله تعریف و پر کنید:</p>
<pre><code class="language-csharp">char[] vowels = new char[] { 'a', 'e', 'i', 'o', 'u' };
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre><code class="language-csharp">char[] vowels = { 'a', 'e', 'i', 'o', 'u' };
</code></pre>
<p>از C# 12 می‌توانید به جای آکولاد {} از کروشه [] استفاده کنید:</p>
<pre><code class="language-csharp">char[] vowels = ['a', 'e', 'i', 'o', 'u'];
</code></pre>
<p>به این روش عبارت مجموعه‌ای (Collection Expression) گفته می‌شود و مزیت آن این است که هنگام ارسال آرایه به متدها نیز کاربرد دارد:</p>
<pre><code class="language-csharp">Foo(['a', 'e', 'i', 'o', 'u']);

void Foo(char[] letters) { ... }
</code></pre>
<p>عبارت‌های مجموعه‌ای همچنین با سایر نوع‌های مجموعه‌ای مثل لیست‌ها (lists) و مجموعه‌ها (sets) نیز کار می‌کنند — بخش &quot;Collection Initializers and Collection Expressions&quot; در صفحه 205 را ببینید.</p>
<p>تمام آرایه‌ها از کلاس System.Array ارث‌بری می‌کنند که سرویس‌های مشترکی برای تمام آرایه‌ها ارائه می‌دهد. این قابلیت‌ها شامل متدهایی برای گرفتن یا تنظیم عناصر صرف‌نظر از نوع آرایه هستند. توضیحات کامل‌تر در بخش &quot;The Array Class&quot; در صفحه 377 آمده است.</p>
<h4>مقداردهی پیش‌فرض به عناصر (Default Element Initialization)</h4>
<p>هنگام ایجاد یک آرایه، همیشه تمام عناصر آن به مقادیر پیش‌فرض (default values) مقداردهی اولیه می‌شوند. مقدار پیش‌فرض یک نوع، حاصل صفر کردن بیتی (bitwise zeroing) حافظه است.</p>
<p>به عنوان مثال، در نظر بگیرید که یک آرایه از اعداد صحیح (int) ایجاد می‌کنیم. از آنجایی که int یک نوع مقداری (value type) است، این کار باعث تخصیص ۱۰۰۰ عدد صحیح در یک بلوک پیوسته از حافظه می‌شود. مقدار پیش‌فرض برای هر عنصر صفر خواهد بود:</p>
<pre><code class="language-csharp">int[] a = new int[1000];
Console.Write(a[123]); // خروجی: 0
</code></pre>
<h5>انواع مقداری در برابر انواع ارجاعی (Value Types vs Reference Types)</h5>
<p>اینکه نوع عنصر یک آرایه مقداری باشد یا ارجاعی، تأثیر مهمی بر عملکرد برنامه دارد.</p>
<p>اگر نوع عنصر یک نوع مقداری باشد، هر مقدار مستقیماً به عنوان بخشی از آرایه تخصیص داده می‌شود، مانند مثال زیر:</p>
<pre><code class="language-csharp">Point[] a = new Point[1000];
int x = a[500].X; // خروجی: 0

public struct Point { public int X, Y; }
</code></pre>
<p>اما اگر Point یک کلاس بود، ایجاد آرایه تنها باعث ایجاد ۱۰۰۰ ارجاع null می‌شد:</p>
<pre><code class="language-csharp">Point[] a = new Point[1000];
int x = a[500].X; // خطای زمان اجرا: NullReferenceException

public class Point { public int X, Y; }
</code></pre>
<p>برای جلوگیری از این خطا، باید بعد از ایجاد آرایه، به‌طور صریح ۱۰۰۰ شیء Point ایجاد و به عناصر نسبت دهیم:</p>
<pre><code class="language-csharp">Point[] a = new Point[1000];
for (int i = 0; i &lt; a.Length; i++) // تکرار از 0 تا 999
    a[i] = new Point(); // مقداردهی عنصر i با یک Point جدید
</code></pre>
<p>توجه: خود آرایه، همیشه یک شیء از نوع ارجاعی است، صرف‌نظر از اینکه نوع عناصر آن مقداری باشد یا ارجاعی.
به عنوان مثال، دستور زیر معتبر است:</p>
<pre><code class="language-csharp">int[] a = null;
</code></pre>
<h3>ایندکس‌ها (Indices) و بازه‌ها (Ranges) 🔢📏</h3>
<p>ایندکس‌ها و بازه‌ها (که در نسخه‌ی C# 8 معرفی شدند) کار با عناصر یا بخش‌هایی از یک آرایه را ساده‌تر می‌کنند.</p>
<p>ایندکس‌ها و بازه‌ها همچنین با انواع CLR مانند Span<T> و ReadOnlySpan<T> نیز کار می‌کنند (به فصل ۲۳ مراجعه کنید 📖).
شما حتی می‌توانید انواع دلخواه خودتان را هم طوری طراحی کنید که با ایندکس‌ها و بازه‌ها کار کنند؛ برای این کار باید یک ایندکسر (Indexer) از نوع Index یا Range تعریف کنید (بخش &quot;Indexers&quot; در صفحه ۱۱۸ را ببینید).</p>
<h4>ایندکس‌ها (Indices)</h4>
<p>ایندکس‌ها این امکان را می‌دهند که به عناصر یک آرایه نسبت به انتهای آن ارجاع دهید، با استفاده از عملگر ^.</p>
<ul>
<li>
<p>^1 به آخرین عنصر اشاره می‌کند.</p>
</li>
<li>
<p>^2 به عنصر ماقبل آخر اشاره می‌کند.</p>
</li>
<li>
<p>و همین‌طور ادامه پیدا می‌کند.</p>
</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels[^1];   // 'u'
char secondToLast = vowels[^2];   // 'o'
</code></pre>
<p>نکته: مقدار ^0 برابر با طول آرایه است، بنابراین vowels[^0] باعث ایجاد خطا می‌شود. ⚠️</p>
<p>زبان C# ایندکس‌ها را با کمک نوع Index پیاده‌سازی می‌کند، بنابراین می‌توانید کد زیر را هم بنویسید:</p>
<pre><code class="language-csharp">Index first = 0;
Index last = ^1;
char firstElement = vowels[first];   // 'a'
char lastElement  = vowels[last];    // 'u'
</code></pre>
<h4>بازه‌ها (Ranges)</h4>
<p>بازه‌ها به شما امکان می‌دهند با استفاده از عملگر .. یک آرایه را برش بزنید:</p>
<pre><code>char[] firstTwo  = vowels[..2];   // 'a', 'e'
char[] lastThree = vowels[2..];   // 'i', 'o', 'u'
char[] middleOne = vowels[2..3];  // 'i'
</code></pre>
<p>عدد دوم در بازه انحصاری است، یعنی ..2 عناصری را برمی‌گرداند که قبل از vowels[2] قرار دارند.</p>
<p>همچنین می‌توانید در بازه‌ها از نماد ^ استفاده کنید. مثال زیر دو کاراکتر آخر را برمی‌گرداند:</p>
<pre><code class="language-csharp">char[] lastTwo = vowels[^2..];   // 'o', 'u'
</code></pre>
<p>زبان C# بازه‌ها را با کمک نوع Range پیاده‌سازی می‌کند، بنابراین کد زیر هم ممکن است:</p>
<pre><code class="language-csharp">Range firstTwoRange = 0..2;
char[] firstTwo = vowels[firstTwoRange];   // 'a', 'e'
</code></pre>
<h3>آرایه‌های چندبعدی Multidimensional Arrays 🧮</h3>
<p>آرایه‌های چندبعدی در زبان #C به دو نوع اصلی تقسیم می‌شوند: آرایه‌های مستطیلی و آرایه‌های دندانه‌دار (Jagged).</p>
<p>آرایه‌های مستطیلی یک بلوک n-بعدی از حافظه را نمایش می‌دهند.</p>
<p>آرایه‌های دندانه‌دار در واقع آرایه‌ای از آرایه‌ها هستند.</p>
<h4>📏 آرایه‌های مستطیلی (Rectangular Arrays)</h4>
<p>آرایه‌های مستطیلی با استفاده از ویرگول ( , ) بین هر بُعد تعریف می‌شوند. مثال زیر یک آرایه دو‌بعدی 3×3 ایجاد می‌کند:</p>
<pre><code class="language-c#">int[,] matrix = new int[3,3];
</code></pre>
<p>متد GetLength طول یک بُعد خاص از آرایه را برمی‌گرداند (شماره‌گذاری از 0 شروع می‌شود):</p>
<pre><code class="language-c#">for (int i = 0; i &lt; matrix.GetLength(0); i++)
    for (int j = 0; j &lt; matrix.GetLength(1); j++)
        matrix[i,j] = i * 3 + j;
</code></pre>
<p>همچنین می‌توان آرایه مستطیلی را به‌طور مستقیم با مقادیر مشخص مقداردهی اولیه کرد:</p>
<pre><code class="language-c#">int[,] matrix = new int[,]
{
    {0,1,2},
    {3,4,5},
    {6,7,8}
};
</code></pre>
<h4>🪢 آرایه‌های دندانه‌دار (Jagged Arrays)</h4>
<p>آرایه‌های دندانه‌دار با استفاده از براکت‌های متوالی [ ] برای نمایش هر بُعد تعریف می‌شوند. مثال زیر یک آرایه دو‌بعدی دندانه‌دار با بُعد بیرونی 3 ایجاد می‌کند:</p>
<pre><code class="language-c#">int[][] matrix = new int[3][];
</code></pre>
<p>نکته: این تعریف new int[3][] است، نه new int[][3].
اریک لیپرت (Eric Lippert) مقاله بسیار خوبی درباره دلیل این موضوع نوشته است.</p>
<p>در این نوع آرایه، اندازه بُعد داخلی در زمان تعریف مشخص نمی‌شود، زیرا هر آرایه داخلی می‌تواند طول متفاوتی داشته باشد. در ابتدا هر آرایه داخلی به‌طور پیش‌فرض مقدار null می‌گیرد (نه یک آرایه خالی). بنابراین باید به صورت دستی آرایه داخلی را ایجاد کنید:</p>
<pre><code class="language-c#">for (int i = 0; i &lt; matrix.Length; i++)
{
    matrix[i] = new int[3];   // ایجاد آرایه داخلی
    for (int j = 0; j &lt; matrix[i].Length; j++)
        matrix[i][j] = i * 3 + j;
}
</code></pre>
<p>همچنین می‌توان یک آرایه دندانه‌دار را به‌طور مستقیم مقداردهی اولیه کرد:</p>
<pre><code class="language-c#">int[][] matrix = new int[][]
{
    new int[] {0,1,2},
    new int[] {3,4,5},
    new int[] {6,7,8,9}
};
</code></pre>
<h3>📝 مقداردهی ساده‌شده به آرایه‌ها (Simplified Array Initialization Expressions)</h3>
<p>در #C دو روش برای کوتاه‌کردن عبارات مقداردهی اولیه به آرایه‌ها وجود دارد.</p>
<p><strong>1️⃣ حذف new و نوع داده</strong></p>
<p>در این روش، می‌توانیم عملگر new و مشخصه نوع داده را حذف کنیم:</p>
<pre><code class="language-c#">char[] vowels = {'a','e','i','o','u'};

int[,] rectangularMatrix =
{
    {0,1,2},
    {3,4,5},
    {6,7,8}
};

int[][] jaggedMatrix =
{
    new int[] {0,1,2},
    new int[] {3,4,5},
    new int[] {6,7,8,9}
};
</code></pre>
<p>💡 نکته: از نسخه C# 12 به بعد، برای آرایه‌های یک‌بعدی می‌توانید از براکت مربع [] به‌جای آکولاد {} استفاده کنید.</p>
<p><strong>2️⃣ استفاده از کلیدواژه var</strong></p>
<p>کلمه کلیدی var به کامپایلر می‌گوید که نوع متغیر را به صورت ضمنی تشخیص دهد:</p>
<pre><code>var i = 3;         // i به‌صورت ضمنی int است
var s = &quot;sausage&quot;; // s به‌صورت ضمنی string است
</code></pre>
<p>برای آرایه‌ها هم می‌توانیم از این قابلیت استفاده کنیم و حتی یک گام جلوتر برویم: با حذف نوع داده بعد از new، کامپایلر نوع آرایه را تشخیص می‌دهد:</p>
<pre><code>var vowels = new[] {'a','e','i','o','u'}; // نوع char[] است
</code></pre>
<p><strong>🧮 اعمال در آرایه‌های چندبعدی</strong></p>
<pre><code class="language-c#">var rectMatrix = new[,]
{
    {0,1,2},
    {3,4,5},
    {6,7,8}
}; // نوع int[,]

var jaggedMat = new int[][]
{
    new[] {0,1,2},
    new[] {3,4,5},
    new[] {6,7,8,9}
}; // نوع int[][]
</code></pre>
<p><strong>⚠️ محدودیت‌ها</strong></p>
<p>برای این که این روش کار کند:</p>
<ul>
<li>
<p>تمام عناصر باید به‌طور ضمنی قابل تبدیل به یک نوع داده واحد باشند.</p>
</li>
<li>
<p>حداقل یک عنصر باید دقیقاً از آن نوع باشد.</p>
</li>
<li>
<p>باید تنها یک نوع بهترین انتخاب وجود داشته باشد.</p>
</li>
</ul>
<p>مثال:</p>
<pre><code class="language-c#">var x = new[] {1, 10000000000}; // همه به long قابل تبدیل‌اند
</code></pre>
<h3>🛡 بررسی محدوده آرایه‌ها (Bounds Checking)</h3>
<p>در #C، تمام دسترسی‌ها به عناصر آرایه‌ها توسط زمان اجرا (runtime) بررسی می‌شود.
اگر از یک ایندکس نامعتبر استفاده کنید، استثنای IndexOutOfRangeException پرتاب می‌شود:</p>
<pre><code class="language-c#">int[] arr = new int[3];
arr[3] = 1; // IndexOutOfRangeException رخ می‌دهد
</code></pre>
<p>🔍 بررسی محدوده آرایه‌ها برای ایمنی نوع داده (type safety) ضروری است و همچنین کار اشکال‌زدایی (debugging) را ساده‌تر می‌کند.</p>
<p><strong>⚡ تأثیر بر کارایی</strong></p>
<p>به‌طور کلی، کاهش کارایی ناشی از این بررسی‌ها بسیار جزئی است.
کامپایلر JIT (Just-In-Time) می‌تواند بهینه‌سازی‌هایی انجام دهد؛ مثلاً قبل از ورود به یک حلقه، تشخیص دهد که تمام ایندکس‌ها ایمن هستند و به این ترتیب، نیاز به بررسی در هر تکرار حلقه را حذف کند.</p>
<p><strong>🚫 کد Unsafe</strong></p>
<p>همچنین، زبان #C قابلیت کد ناایمن (unsafe code) را فراهم کرده که می‌تواند این بررسی‌ها را به‌طور صریح دور بزند.
(برای جزئیات بیشتر، بخش &quot;Unsafe Code and Pointers&quot; در صفحه 263 را ببینید.)</p>
<h3>🗃 متغیرها و پارامترها (Variables and Parameters)</h3>
<p>یک متغیر (variable) نمایانگر یک مکان ذخیره‌سازی است که مقدار آن قابل تغییر است.
متغیر می‌تواند یکی از انواع زیر باشد:</p>
<ul>
<li>
<p>متغیر محلی (local variable)</p>
</li>
<li>
<p>پارامتر (parameter) — که می‌تواند به شکل value، یا با کلیدواژه‌های ref، out، یا in باشد</p>
</li>
<li>
<p>فیلد (field) — چه نمونه‌ای (instance) و چه ایستا (static)</p>
</li>
<li>
<p>عنصر آرایه (array element)</p>
</li>
</ul>
<h4>🏛 پشته و هیپ (The Stack and the Heap)</h4>
<p>در #C، متغیرها در یکی از دو مکان اصلی حافظه ذخیره می‌شوند:</p>
<ol>
<li>
<p>پشته (stack)</p>
</li>
<li>
<p>هیپ (heap)</p>
</li>
</ol>
<p>هرکدام از این مکان‌ها قوانین و چرخه عمر (lifetime) متفاوتی دارند.</p>
<h5>📦 پشته (Stack)</h5>
<p>پشته یک بخش از حافظه است که برای ذخیره متغیرهای محلی و پارامترها استفاده می‌شود.
پشته به‌صورت منطقی رشد و کوچک می‌شود؛ یعنی وقتی یک متد یا تابع وارد می‌شود، فضا اضافه می‌شود و وقتی از آن خارج می‌شویم، آن فضا آزاد می‌گردد.</p>
<p>🔹 به مثال زیر توجه کنید:
(برای جلوگیری از حواس‌پرتی، بررسی ورودی‌ها را نادیده گرفته‌ایم)</p>
<pre><code class="language-c#">static int Factorial(int x)
{
    if (x == 0) return 1;
    return x * Factorial(x - 1);
}
</code></pre>
<p>این متد بازگشتی (recursive) است، یعنی خودش را صدا می‌زند.</p>
<p>هر بار که این متد اجرا می‌شود:</p>
<ul>
<li>
<p>یک مقدار int جدید روی پشته اختصاص داده می‌شود.</p>
</li>
<li>
<p>و هر بار که متد پایان می‌یابد، آن مقدار از پشته آزاد می‌شود.</p>
</li>
</ul>
<h5>🗄 هیپ (Heap)</h5>
<p>هیپ بخشی از حافظه است که در آن اشیاء (objects) یا همان نمونه‌های نوع مرجع (reference-type instances) ذخیره می‌شوند.</p>
<p>هر زمان که یک شیء جدید ایجاد می‌شود:</p>
<ol>
<li>
<p>فضای آن روی هیپ اختصاص داده می‌شود.</p>
</li>
<li>
<p>یک مرجع (reference) به آن شیء برگردانده می‌شود.</p>
</li>
</ol>
<p><strong>♻ جمع‌آوری زباله (Garbage Collection)</strong></p>
<p>در طول اجرای برنامه، هیپ کم‌کم با ایجاد اشیاء جدید پر می‌شود.
زمان اجرا (runtime) یک مکانیزم به نام جمع‌آورندهٔ زباله (garbage collector - GC) دارد که به‌طور دوره‌ای اشیاء بلااستفاده را از هیپ آزاد می‌کند تا برنامه با مشکل کمبود حافظه مواجه نشود.</p>
<p>یک شیء زمانی واجد شرایط پاک شدن است که دیگر هیچ مرجعی از سوی داده‌های زنده (alive) به آن وجود نداشته باشد.</p>
<p>🔍 مثال</p>
<pre><code class="language-c#">using System;
using System.Text;

StringBuilder ref1 = new StringBuilder(&quot;object1&quot;);
Console.WriteLine(ref1);
// شیء StringBuilder که توسط ref1 ارجاع داده شده، اکنون واجد شرایط GC است.

StringBuilder ref2 = new StringBuilder(&quot;object2&quot;);
StringBuilder ref3 = ref2;
// شیء StringBuilder که توسط ref2 ارجاع داده شده، هنوز واجد شرایط GC نیست
// چون ref3 همچنان به آن اشاره می‌کند.

Console.WriteLine(ref3); // خروجی: object2
</code></pre>
<p>در این مثال:</p>
<ul>
<li>
<p>ابتدا یک شیء از نوع StringBuilder ایجاد می‌کنیم که توسط متغیر ref1 ارجاع داده شده است.
بعد از خط Console.WriteLine(ref1)، دیگر چیزی به آن شیء ارجاع نمی‌دهد، پس می‌تواند توسط GC جمع‌آوری شود.</p>
</li>
<li>
<p>سپس یک شیء دیگر به نام ref2 ایجاد کرده و مرجع آن را در ref3 ذخیره می‌کنیم.
حتی اگر ref2 دیگر استفاده نشود، وجود ref3 باعث می‌شود شیء همچنان زنده بماند.</p>
</li>
</ul>
<p><strong>📌 نکات مهم دربارهٔ هیپ:</strong></p>
<ul>
<li>
<p>نمونه‌های نوع مقداری (value-type instances) و مراجع اشیاء در همان جایی ذخیره می‌شوند که متغیرشان تعریف شده است.
اگر نمونهٔ نوع مقداری به‌عنوان یک فیلد درون یک نوع کلاس یا به‌عنوان یک عنصر آرایه تعریف شود، روی هیپ ذخیره می‌شود.</p>
</li>
<li>
<p>در C#، برخلاف C++، شما نمی‌توانید یک شیء را به‌صورت دستی حذف کنید.
شیء بدون مرجع در نهایت توسط جمع‌آورندهٔ زباله پاک می‌شود.</p>
</li>
<li>
<p>هیپ همچنین فیلدهای ایستا (static fields) را ذخیره می‌کند.
برخلاف اشیاء معمولی روی هیپ که می‌توانند جمع‌آوری شوند، این فیلدها تا پایان اجرای فرآیند زنده می‌مانند.</p>
</li>
</ul>
<h3>✅ انتساب قطعی (Definite Assignment)</h3>
<p>در زبان C# یک قانون به نام انتساب قطعی وجود دارد.
به زبان ساده، این قانون تضمین می‌کند که (خارج از حالت‌های unsafe یا interop) شما نمی‌توانید به‌طور تصادفی به حافظهٔ مقداردهی‌نشده دسترسی پیدا کنید.</p>
<p><strong>📌 سه نتیجهٔ اصلی این قانون:</strong></p>
<ol>
<li>
<p>متغیرهای محلی (Local Variables) باید قبل از خواندن یک مقدار به آن‌ها اختصاص داده شود.</p>
</li>
<li>
<p>پارامترهای متد (Function Arguments) باید هنگام فراخوانی متد ارسال شوند (مگر این که به‌عنوان اختیاری مشخص شده باشند – بخش Optional Parameters صفحه 74).</p>
</li>
<li>
<p>تمام متغیرهای دیگر (مثل فیلدها و عناصر آرایه) به‌طور خودکار توسط زمان اجرا (runtime) مقداردهی اولیه می‌شوند.</p>
</li>
</ol>
<p><strong>🛑 مثال خطای زمان کامپایل</strong></p>
<pre><code class="language-c#">int x;
Console.WriteLine(x); // خطا در زمان کامپایل: متغیر مقداردهی نشده
</code></pre>
<p>اینجا x یک متغیر محلی است و چون قبل از استفاده مقداری به آن نداده‌ایم، کامپایلر خطا می‌دهد.</p>
<p><strong>🗄 مقداردهی پیش‌فرض برای آرایه‌ها</strong></p>
<p>عناصر آرایه‌ها به‌صورت پیش‌فرض با مقدار پیش‌فرض نوعشان (default value) مقداردهی می‌شوند:</p>
<pre><code class="language-c#">int[] ints = new int[2];
Console.WriteLine(ints[0]); // خروجی: 0
</code></pre>
<p>در اینجا، نوع int پیش‌فرضش 0 است، پس تمام خانه‌های آرایه به این مقدار مقداردهی می‌شوند.</p>
<p><strong>🏷 مقداردهی پیش‌فرض برای فیلدها</strong></p>
<p>فیلدها (چه ایستا و چه نمونه‌ای) به‌طور خودکار با مقدار پیش‌فرضشان مقداردهی می‌شوند:</p>
<pre><code class="language-c#">Console.WriteLine(Test.X); // خروجی: 0

class Test
{
    public static int X; // به‌طور پیش‌فرض 0
}
</code></pre>
<h3>🎯 مقادیر پیش‌فرض (Default Values)</h3>
<p>تمام نمونه‌های نوع داده‌ها یک مقدار پیش‌فرض دارند.
برای نوع‌های از پیش تعریف‌شده (predefined types)، مقدار پیش‌فرض نتیجهٔ صفر شدن بیت به بیت حافظه است:</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-7.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
می‌توانی مقدار پیش‌فرض هر نوع داده‌ای را با استفاده از کلیدواژه‌ی default به دست بیاوری:
<pre><code class="language-c#">Console.WriteLine(default(decimal));   // 0
</code></pre>
<p>در صورتی که نوع داده قابل استنباط باشد، می‌توانی نوع را هم نیاوری:</p>
<pre><code class="language-c#">decimal d = default;
</code></pre>
<p>مقدار پیش‌فرض در نوع‌های سفارشی از نوع value (یعنی struct) همان مقدار پیش‌فرض هر فیلد تعریف‌شده در آن نوع است. ✅</p>
<h3>Parameters پارامترها</h3>
<p>یک متد می‌تواند یک دنباله از پارامترها داشته باشد. پارامترها مجموعه‌ای از آرگومان‌ها را تعریف می‌کنند که باید برای آن متد فراهم شوند.</p>
<p>در مثال زیر، متد Foo یک پارامتر به نام p از نوع int دارد:</p>
<pre><code class="language-c#">Foo(8);                        // 8 یک آرگومان است
static void Foo(int p) {...}   // p یک پارامتر است
</code></pre>
<p>می‌توانی نحوه‌ی ارسال پارامترها را با استفاده از مقداردهنده‌های ref، in و out کنترل کنی. 🔄</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-8.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h5>عبور آرگومان‌ها به صورت مقدار (Passing arguments by value)</h5>
<p>به طور پیش‌فرض، در C# آرگومان‌ها به صورت مقدار (by value) ارسال می‌شوند، که رایج‌ترین حالت است. ✨</p>
<p>این یعنی وقتی مقداری به متد داده می‌شود، یک کپی از آن مقدار ساخته شده و به متد داده می‌شود:</p>
<pre><code class="language-c#">int x = 8;
Foo(x);                    // یک کپی از x ساخته می‌شود
Console.WriteLine(x);      // x همچنان 8 خواهد بود

static void Foo(int p)
{
    p = p + 1;             // مقدار p یک واحد افزایش می‌یابد
    Console.WriteLine(p);  // مقدار p نمایش داده می‌شود
}
</code></pre>
<p>اینجا تغییر مقدار p هیچ اثری روی x ندارد، چون p و x در مکان‌های متفاوتی از حافظه ذخیره شده‌اند. 🧩</p>
<p>🔹 حالا اگر آرگومان از نوع مرجع (reference type) باشد، ماجرا کمی فرق می‌کند:
در این حالت، هنگام ارسال آرگومان، خود شیء کپی نمی‌شود، بلکه مرجع (آدرس حافظه) شیء کپی می‌شود.</p>
<pre><code class="language-c#">StringBuilder sb = new StringBuilder();
Foo(sb);
Console.WriteLine(sb.ToString());    // خروجی: test

static void Foo(StringBuilder fooSB)
{
    fooSB.Append(&quot;test&quot;);
    fooSB = null;
}
</code></pre>
<p>اینجا هم sb و هم fooSB هر دو به یک شیء مشترک از نوع StringBuilder اشاره می‌کنند.
به همین دلیل، وقتی در متد Foo عبارت &quot;test&quot; اضافه می‌کنیم، تغییر روی شیء اصلی (sb) هم اعمال می‌شود.</p>
<p>اما زمانی که در Foo مقدار fooSB = null; انجام می‌دهیم، فقط کپی مرجع را تغییر می‌دهیم و شیء اصلی (sb) همچنان به همان StringBuilder اشاره می‌کند.</p>
<p>(البته اگر fooSB با کلیدواژه‌ی ref تعریف و فراخوانی شده بود، تغییر آن به null باعث می‌شد که sb هم null شود.) ⚡</p>
<h5>کلیدواژه‌ی ref</h5>
<p>برای اینکه یک آرگومان به‌صورت مرجع (by reference) به متد داده شود، در C# از کلیدواژه‌ی ref استفاده می‌کنیم. 🔗</p>
<p>در این حالت، پارامتر متد و متغیر اصلی، هر دو به یک مکان حافظه اشاره می‌کنند:</p>
<pre><code class="language-c#">int x = 8;
Foo(ref x);               // از Foo می‌خواهیم مستقیماً روی x کار کند
Console.WriteLine(x);     // خروجی: 9

static void Foo(ref int p)
{
    p = p + 1;            // مقدار p یک واحد زیاد می‌شود
    Console.WriteLine(p); // نمایش مقدار p
}
</code></pre>
<p>✅ در اینجا وقتی p تغییر می‌کند، مقدار x هم تغییر می‌کند.
توجه کن که کلیدواژه‌ی ref هم در تعریف متد و هم در هنگام فراخوانی باید ذکر شود؛ این کار باعث می‌شود خیلی واضح باشد که آرگومان با مرجعش ارسال شده است.</p>
<p>📌 استفاده‌ی مهم ref در پیاده‌سازی متدهایی مثل جابجایی (Swap) است:</p>
<pre><code class="language-c#">string x = &quot;Penn&quot;;
string y = &quot;Teller&quot;;

Swap(ref x, ref y);

Console.WriteLine(x);   // خروجی: Teller
Console.WriteLine(y);   // خروجی: Penn

static void Swap(ref string a, ref string b)
{
    string temp = a;
    a = b;
    b = temp;
}
</code></pre>
<h5>کلیدواژه‌ی out</h5>
<p>پارامترها می‌توانند چه به‌صورت مقدار (by value) و چه به‌صورت مرجع (by reference) ارسال شوند،
اما کلیدواژه‌ی out یک تفاوت ظریف با ref دارد: ✨</p>
<ol>
<li>
<p>✅ مقدار متغیر قبل از ورود به متد لازم نیست مقداردهی شود.</p>
</li>
<li>
<p>✅ اما قبل از خروج از متد حتماً باید مقداردهی شود.</p>
</li>
</ol>
<p>📌 این ویژگی معمولاً برای برگرداندن چند مقدار از یک متد استفاده می‌شود:</p>
<pre><code class="language-c#">string a, b;
Split(&quot;Stevie Ray Vaughn&quot;, out a, out b);

Console.WriteLine(a);   // خروجی: Stevie Ray
Console.WriteLine(b);   // خروجی: Vaughn

void Split(string name, out string firstNames, out string lastName)
{
    int i = name.LastIndexOf(' ');
    firstNames = name.Substring(0, i);
    lastName = name.Substring(i + 1);
}
</code></pre>
<p>اینجا پارامترهای firstNames و lastName با کلیدواژه‌ی out ارسال شده‌اند.
این یعنی متد Split باید حتماً قبل از پایان اجرا به هر دو مقدار اختصاص دهد.</p>
<p>📍 نکته‌ی مهم: درست مثل ref، یک پارامتر out هم به‌صورت مرجع (by reference) ارسال می‌شود.
پس تغییرش درون متد، روی متغیر اصلی بیرون از متد هم اثر می‌گذارد.</p>
<h5>متغیرهای out و Discards</h5>
<p>گاهی اوقات وقتی متدی پارامترهای out دارد، می‌توانیم متغیرها را همان لحظه (on the fly) در زمان فراخوانی متد تعریف کنیم. 🎯</p>
<p>به جای این:</p>
<pre><code class="language-c#">string a, b;
Split(&quot;Stevie Ray Vaughan&quot;, out a, out b);
</code></pre>
<p>می‌توانیم مستقیم بنویسیم:</p>
<pre><code class="language-c#">Split(&quot;Stevie Ray Vaughan&quot;, out string a, out string b);
</code></pre>
<p><strong>Discards (نادیده گرفتن مقادیر)</strong></p>
<p>اگر متدی چندین پارامتر out داشته باشد، ولی به همه‌ی خروجی‌ها نیاز نداشته باشیم، می‌توانیم بعضی را نادیده بگیریم.
این کار با علامت _ انجام می‌شود:</p>
<pre><code class="language-c#">Split(&quot;Stevie Ray Vaughan&quot;, out string a, out _); // پارامتر دوم نادیده گرفته می‌شود
Console.WriteLine(a);   // خروجی: Stevie Ray
</code></pre>
<p>✅ علامت _ در اینجا نقش یک متغیر خاص به نام discard را دارد.
می‌توان چندین بار از آن در یک فراخوانی استفاده کرد:</p>
<pre><code class="language-c#">SomeBigMethod(out _, out _, out _, out int x, out _, out _, out _);
</code></pre>
<p>اینجا فقط پارامتر چهارم (x) را نگه داشته‌ایم و بقیه را نادیده گرفته‌ایم.</p>
<p><strong>⚠️ یک نکته‌ی مهم:</strong></p>
<p>به‌خاطر سازگاری با نسخه‌های قدیمی‌تر C#، اگر در همان محدوده‌ی کد واقعاً متغیری با نام _ تعریف کرده باشید، آن دیگر discard محسوب نمی‌شود.</p>
<p>مثال:</p>
<pre><code class="language-c#">string _;
Split(&quot;Stevie Ray Vaughan&quot;, out string a, out _);
Console.WriteLine(_);   // خروجی: Vaughan
</code></pre>
<p>اینجا چون _ به عنوان متغیر واقعی تعریف شده، مقدار پارامتر دوم (Vaughan) در آن ریخته می‌شود.</p>
<h5>پیامدهای ارسال پارامتر به‌صورت مرجع (by reference)</h5>
<p>وقتی آرگومانی را با ref یا out ارسال می‌کنیم، در واقع یک آدرس (مرجع) به متد داده می‌شود،
نه یک کپی جداگانه. یعنی پارامتر متد و متغیر اصلی، هردو به یک مکان حافظه اشاره دارند.</p>
<p>مثال:</p>
<pre><code class="language-c#">class Test
{
    static int x;

    static void Main() 
    { 
        Foo(out x); 
    }

    static void Foo(out int y)
    {
        Console.WriteLine(x);  // خروجی: 0
        y = 1;                 // مقدار y تغییر داده می‌شود
        Console.WriteLine(x);  // خروجی: 1
    }
}
</code></pre>
<p>اینجا x و y در واقع به همان مکان حافظه اشاره می‌کنند.
وقتی y = 1 می‌شود، مقدار x هم همزمان تغییر می‌کند.</p>
<h5>🔹 پارامترهای in</h5>
<p>پارامتر in شبیه به پارامتر ref است، با این تفاوت مهم که:
👉 متد نمی‌تواند مقدار آن پارامتر را تغییر دهد.
اگر سعی کنیم داخل متد مقدارش را تغییر دهیم، ❌ خطای کامپایل خواهیم گرفت.</p>
<p><strong>📌 کاربرد اصلی in</strong></p>
<p>وقتی یک ساختار بزرگ (struct) را به متدی پاس می‌دهیم، به‌طور پیش‌فرض یک کپی کامل از آن ساخته می‌شود.
این کار می‌تواند هزینه‌ی زیادی برای حافظه و کارایی داشته باشد.</p>
<p>✅ استفاده از in باعث می‌شود:</p>
<ul>
<li>
<p>مقدار by reference پاس داده شود (بدون کپی اضافه).</p>
</li>
<li>
<p>ولی همچنان محافظت شود تا متد نتواند مقدار اصلی را تغییر دهد.</p>
</li>
</ul>
<p><strong>📍 اورلودینگ بر اساس in</strong></p>
<p>می‌توان یک متد را فقط بر اساس وجود in اورلود کرد:</p>
<pre><code class="language-c#">void Foo(SomeBigStruct a) { ... }
void Foo(in SomeBigStruct a) { ... }
</code></pre>
<p>حالا برای فراخوانی:</p>
<pre><code class="language-c#">SomeBigStruct x = ...;

Foo(x);     // فراخوانی متد اول (بدون in)
Foo(in x);  // فراخوانی متد دوم (با in)
</code></pre>
<p><strong>📍 زمانی که ابهامی وجود ندارد</strong></p>
<p>اگر فقط یک متد داشته باشیم که in استفاده می‌کند:</p>
<pre><code class="language-c#">void Bar(in SomeBigStruct a) { ... }
</code></pre>
<p>در این صورت، هنگام فراخوانی نوشتن in اختیاری است:</p>
<pre><code class="language-c#">Bar(x);     // اوکی ✔ (همان متد با in صدا زده می‌شود)
Bar(in x);  // اوکی ✔
</code></pre>
<p><strong>📌 نکته مهم</strong></p>
<p>این ویژگی بیشتر برای زمانی معنا دارد که SomeBigStruct یک struct بزرگ باشد (مثل یک struct با چندین فیلد یا داده‌ی حجیم).
چون در غیر این صورت استفاده از in خیلی تفاوتی ایجاد نمی‌کند.</p>
<h5>🔹 پارامترهای params</h5>
<p>کلمه کلیدی params به ما اجازه می‌دهد که یک متد را طوری تعریف کنیم که تعداد نامحدودی آرگومان از یک نوع خاص بپذیرد.</p>
<p>📌 شرایط:</p>
<ul>
<li>
<p>باید فقط روی آخرین پارامتر متد اعمال شود.</p>
</li>
<li>
<p>نوع آن باید آرایه تک‌بعدی باشد.</p>
</li>
</ul>
<p>📍 مثال</p>
<pre><code class="language-c#">int total = Sum(1, 2, 3, 4);
Console.WriteLine(total);   // خروجی: 10

int Sum(params int[] ints)
{
    int sum = 0;
    for (int i = 0; i &lt; ints.Length; i++)
        sum += ints[i];
    return sum;
}
</code></pre>
<p>🔸 در اینجا متد Sum هر تعداد عدد صحیح را می‌پذیرد و جمع آن‌ها را برمی‌گرداند.</p>
<p><strong>📌 معادل بدون params</strong></p>
<p>فراخوانی بالا در واقع معادل است با:</p>
<pre><code class="language-c#">int total = Sum(new int[] { 1, 2, 3, 4 });
</code></pre>
<p>یعنی کامپایلر به صورت خودکار یک آرایه می‌سازد.</p>
<p><strong>📍 حالت بدون آرگومان</strong></p>
<p>اگر هیچ آرگومانی داده نشود، یک آرایه خالی ساخته می‌شود:</p>
<pre><code class="language-c#">int total = Sum();   // آرایه‌ای با Length = 0
</code></pre>
<p><strong>🔹 پارامترهای اختیاری (Optional Parameters)</strong></p>
<p>در C#، متدها، سازنده‌ها و ایندکسرها می‌توانند پارامتر اختیاری داشته باشند.
یعنی در تعریف متد برای آن پارامتر یک مقدار پیش‌فرض مشخص می‌کنیم.</p>
<p>📍 مثال ساده</p>
<pre><code class="language-c#">void Foo(int x = 23) 
{ 
    Console.WriteLine(x); 
}

Foo();    // 23
</code></pre>
<p>✅ وقتی آرگومان را حذف کنیم، مقدار پیش‌فرض 23 پاس داده می‌شود.
در حقیقت، کامپایلر مقدار 23 را در کد کامپایل‌شده جایگزین می‌کند.</p>
<p>پس این دو فراخوانی معادل هستند:</p>
<pre><code class="language-c#">Foo();    // 23
Foo(23);  // 23
</code></pre>
<p><strong>📌 قوانین پارامترهای اختیاری</strong></p>
<ol>
<li>مقدار پیش‌فرض باید یک عبارت ثابت (constant expression)، سازنده بدون پارامتر یک نوع مقداری (مثل new DateTime())، یا یک عبارت default باشد.</li>
</ol>
<pre><code class="language-c#">void Bar(int x = 5, string s = &quot;Hello&quot;, DateTime d = default) { }
</code></pre>
<ol start="2">
<li>
<p>پارامترهای اختیاری نمی‌توانند با ref یا out علامت‌گذاری شوند. ❌</p>
</li>
<li>
<p>پارامترهای اجباری باید همیشه قبل از پارامترهای اختیاری بیایند.</p>
</li>
<li>
<p>استثنا: اگر params داشته باشیم، همیشه باید در آخر قرار بگیرد.</p>
</li>
</ol>
<p><strong>📍 مثال ترکیب پارامتر اجباری و اختیاری</strong></p>
<pre><code class="language-c#">void Foo(int x = 0, int y = 0) 
{ 
    Console.WriteLine(x + &quot;, &quot; + y); 
}

Foo(1);    // خروجی: 1, 0
Foo();     // خروجی: 0, 0
</code></pre>
<p><strong>📌 ترکیب با Named Arguments</strong></p>
<p>اگر بخواهیم مقدار پیش‌فرض x را نگه داریم ولی برای y مقدار مشخصی بفرستیم، می‌توانیم از named arguments استفاده کنیم:</p>
<pre><code class="language-c#">Foo(y: 5);   // خروجی: 0, 5
</code></pre>
<h5>آرگومان‌های نام‌گذاری‌شده (Named Arguments) 🎯</h5>
<p>به‌جای اینکه یک آرگومان را بر اساس موقعیتش مشخص کنید، می‌توانید آن را بر اساس نام پارامتر صدا بزنید:</p>
<pre><code class="language-c#">Foo (x: 1, y: 2);  // خروجی: 1, 2
void Foo (int x, int y) { Console.WriteLine (x + &quot;, &quot; + y); }
</code></pre>
<p>✅ آرگومان‌های نام‌گذاری‌شده می‌توانند به هر ترتیبی بیایند. فراخوانی‌های زیر کاملاً معادل هستند:</p>
<pre><code class="language-c#">Foo (x: 1, y: 2);
Foo (y: 2, x: 1);
</code></pre>
<p><strong>ترتیب ارزیابی (Evaluation Order) ⚡</strong></p>
<p>یک نکته‌ی ظریف این است که عبارت‌های آرگومان‌ها به ترتیبی که در محل فراخوانی نوشته شده‌اند، ارزیابی می‌شوند.</p>
<p>مثلاً کد زیر 0, 1 چاپ می‌کند:</p>
<pre><code class="language-c#">int a = 0;
Foo (y: ++a, x: --a);  // اول ++a اجرا می‌شود، بعد --a
</code></pre>
<p>البته نوشتن چنین کدی در عمل به‌هیچ‌وجه توصیه نمی‌شود! 🚫</p>
<p><strong>ترکیب آرگومان‌های نامی و موقعیتی 📝</strong></p>
<p>شما می‌توانید آرگومان‌های موقعیتی و نام‌گذاری‌شده را ترکیب کنید:</p>
<pre><code class="language-c#">Foo (1, y: 2);   // مجاز ✅
</code></pre>
<p>اما یک محدودیت وجود دارد:</p>
<ul>
<li>آرگومان‌های موقعیتی باید قبل از آرگومان‌های نامی بیایند، مگر اینکه دقیقاً در موقعیت درست قرار گیرند.</li>
</ul>
<p>مثلاً:</p>
<pre><code class="language-c#">Foo (x: 1, 2);   // مجاز ✅ (هر کدام در جای درستشان هستند)
Foo (y: 2, 1);   // خطای کامپایل ❌ (y در جای اول نیست)
</code></pre>
<p><strong>کاربرد عملی 💡</strong></p>
<p>آرگومان‌های نامی به‌ویژه زمانی مفید هستند که همراه با پارامترهای اختیاری (optional parameters) استفاده شوند.</p>
<p>مثلاً اگر متدی این‌طور تعریف شده باشد:</p>
<pre><code class="language-c#">void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }
</code></pre>
<p>می‌توانید فقط مقدار d را مشخص کنید:</p>
<pre><code class="language-c#">Bar (d: 3);
</code></pre>
<p>این ویژگی مخصوصاً هنگام کار با COM APIs (که در فصل ۲۴ توضیح داده می‌شوند) بسیار کاربردی است.</p>
<h3>🟢 Ref Locals</h3>
<p>یکی از ویژگی‌های کمتر شناخته‌شده‌ی #C (اضافه شده از نسخه‌ی 7) امکان استفاده از متغیرهای محلی ارجاعی (ref locals) و بازگشت ارجاعی (ref returns) است. این قابلیت‌ها بیشتر برای بهینه‌سازی‌های خاص (micro-optimizations) استفاده می‌شوند.</p>
<p>یک ref local متغیری است که به یک عنصر آرایه، فیلد یا متغیر محلی دیگر اشاره می‌کند.</p>
<pre><code class="language-c#">int[] numbers = { 0, 1, 2, 3, 4 };

// numRef یک اشاره‌گر به عنصر سوم آرایه است
ref int numRef = ref numbers[2];

numRef *= 10;

Console.WriteLine(numRef);      // 20
Console.WriteLine(numbers[2]);  // 20
</code></pre>
<p>✔ تغییر numRef باعث تغییر مستقیم روی numbers[2] شد.
❌ توجه: هدف یک ref local نمی‌تواند یک property باشد (به خاطر اینکه property در واقع یک متد است، نه یک متغیر ذخیره‌شده).</p>
<h3>🟢 Ref Returns</h3>
<p>گاهی می‌خواهیم متدی یک ارجاع به یک متغیر یا فیلد برگرداند، نه یک کپی از مقدار آن. این کار با ref return انجام می‌شود.</p>
<pre><code class="language-c#">class Program
{
    static string x = &quot;Old Value&quot;;

    static ref string GetX() =&gt; ref x;   // متد یک ارجاع برمی‌گرداند

    static void Main()
    {
        ref string xRef = ref GetX();    // نتیجه را در یک ref local می‌گیریم
        xRef = &quot;New Value&quot;;
        
        Console.WriteLine(x);  // خروجی: New Value
    }
}
</code></pre>
<p>🔹 اگر ref در سمت گیرنده استفاده نشود، یک کپی معمولی از مقدار برگردانده می‌شود:</p>
<pre><code class="language-c#">string localX = GetX();  // localX فقط یک مقدار معمولی است
</code></pre>
<p><strong>🟢 Ref Properties و Ref Indexers</strong></p>
<p>می‌توانیم یک property یا indexer را به‌صورت ref تعریف کنیم:</p>
<pre><code class="language-c#">static ref string Prop =&gt; ref x;

Prop = &quot;New Value&quot;;   // مجاز است، حتی بدون set accessor!
</code></pre>
<p>اما اگر بخواهیم تغییر مقدار جلوگیری شود، می‌توانیم از ref readonly استفاده کنیم:</p>
<pre><code class="language-c#">static ref readonly string Prop =&gt; ref x;
</code></pre>
<p>✔ این کار اجازه‌ی خواندن مستقیم بدون کپی‌برداری می‌دهد، اما جلوی تغییر مقدار را می‌گیرد.</p>
<p><strong>⚡ نکته‌ی مهم درباره‌ی Performance</strong></p>
<ul>
<li>
<p>در نوع‌های مرجع (مثل string)، سود زیادی از ref returns به‌دست نمی‌آید، چون فقط یک آدرس (۳۲ یا ۶۴ بیتی) کپی می‌شود.</p>
</li>
<li>
<p>اما در نوع‌های مقداری (structs)، به‌ویژه اگر بزرگ باشند و به‌صورت readonly struct تعریف شوند، استفاده از ref می‌تواند جلوی کپی‌های پرهزینه را بگیرد.</p>
</li>
</ul>
<p>❌ تعریف یک set accessor صریح روی property یا indexer که ref return دارد، غیرقانونی است.</p>
<h4>متغیرهای ضمنی (Implicitly Typed Locals) با var</h4>
<p>اغلب پیش می‌آید که متغیری را همزمان با تعریف، مقداردهی اولیه کنیم. اگر کامپایلر بتواند نوع متغیر را از روی عبارت مقداردهی تشخیص دهد، می‌توانیم به‌جای نام نوع، از کلمه کلیدی var استفاده کنیم:</p>
<pre><code class="language-c#">var x = &quot;hello&quot;;
var y = new System.Text.StringBuilder();
var z = (float)Math.PI;
</code></pre>
<p>این دقیقاً معادل کد زیر است:</p>
<pre><code class="language-c#">string x = &quot;hello&quot;;
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
</code></pre>
<p>✅ به همین دلیل، متغیرهای ضمنی همچنان استاتیک تایپ (دارای نوع مشخص در زمان کامپایل) هستند.</p>
<p>مثال خطا:</p>
<pre><code class="language-c#">var x = 5;       // نوع x، int است
x = &quot;hello&quot;;     // ❌ خطا در زمان کامپایل
</code></pre>
<p><strong>⚠️ نکته درباره‌ی خوانایی کد</strong></p>
<p>استفاده از var گاهی باعث می‌شود خوانایی کد پایین بیاید، به‌خصوص وقتی نوع متغیر از روی عبارت مقداردهی مشخص نیست:</p>
<pre><code class="language-c#">Random r = new Random();
var x = r.Next();   // 🤔 نوع x چیست؟ (int)
</code></pre>
<p>📌 در بعضی موارد مثل Anonymous Types (صفحه 220 کتاب)، استفاده از var اجباری است.</p>
<h4>عبارات new با نوع هدف (Target-Typed new Expressions) در #C 9</h4>
<p>ویژگی دیگری که برای کم کردن تکرار نوع معرفی شد، Target-Typed new Expressions است.</p>
<pre><code class="language-c#">System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new(&quot;Test&quot;);
</code></pre>
<p>این دقیقاً معادل است با:</p>
<pre><code class="language-c#">System.Text.StringBuilder sb1 = new System.Text.StringBuilder();
System.Text.StringBuilder sb2 = new System.Text.StringBuilder(&quot;Test&quot;);
</code></pre>
<p>اصل موضوع این است که اگر کامپایلر بتواند نوع شیء را بدون ابهام از روی زمینه (context) تشخیص دهد، دیگر نیاز نیست نوع را دوباره در سمت راست بنویسیم.</p>
<p><strong>📌 کاربردهای مهم Target-Typed new</strong></p>
<ol>
<li>مقداردهی فیلدها در سازنده‌ها</li>
</ol>
<pre><code class="language-c#">class Foo
{
    System.Text.StringBuilder sb;

    public Foo(string initialValue)
    {
        sb = new(initialValue);   // نوع از روی فیلد sb مشخص است
    }
}
</code></pre>
<ol start="2">
<li>ارسال مستقیم مقدار به متدها</li>
</ol>
<pre><code class="language-c#">MyMethod(new(&quot;test&quot;));

void MyMethod(System.Text.StringBuilder sb) { ... }
</code></pre>
<p>👉 به‌طور خلاصه:</p>
<ul>
<li>
<p>var → وقتی نوع از روی مقداردهی مشخص است، دیگر نیازی به نوشتن نام نوع ندارید.</p>
</li>
<li>
<p>target-typed new → وقتی کامپایلر نوع را از روی سمت چپ یا پارامتر متد می‌فهمد، دیگر نیاز نیست سمت راست بنویسید.</p>
</li>
</ul>
<h3>عبارت‌ها و عملگرها (Expressions and Operators)</h3>
<p>یک عبارت (expression) در اصل نشان‌دهنده‌ی یک مقدار است. ساده‌ترین نوع عبارت‌ها شامل ثابت‌ها (constants) و متغیرها (variables) هستند.
عبارت‌ها می‌توانند با استفاده از عملگرها (operators) تغییر داده شده یا ترکیب شوند.</p>
<p>🔹 یک عملگر (operator) یک یا چند عملوند (operand) را گرفته و یک عبارت جدید خروجی می‌دهد.</p>
<p>برای نمونه، این یک عبارت ثابت (constant expression) است:</p>
<pre><code>12
</code></pre>
<p>می‌توانیم از عملگر * برای ترکیب دو عملوند (یعنی دو مقدار ثابت 12 و 30) استفاده کنیم:</p>
<pre><code>12 * 30
</code></pre>
<p>همچنین می‌توانیم عبارت‌های پیچیده‌تر بسازیم؛ چون یک عملوند خودش می‌تواند یک عبارت باشد، مثل (12 * 30) در مثال زیر:</p>
<pre><code>1 + (12 * 30)
</code></pre>
<p>عملگرها در C# بر اساس تعداد عملوندها دسته‌بندی می‌شوند:</p>
<ul>
<li>
<p>یکانی (unary) → روی یک عملوند کار می‌کنند.</p>
</li>
<li>
<p>دوتایی (binary) → روی دو عملوند کار می‌کنند.</p>
</li>
<li>
<p>سه‌تایی (ternary) → روی سه عملوند کار می‌کنند.</p>
</li>
</ul>
<p>عملگرهای دوتایی همیشه از نشانه‌گذاری میانی (infix notation) استفاده می‌کنند؛ یعنی عملگر بین دو عملوند قرار می‌گیرد.</p>
<h4>عبارت‌های اصلی (Primary Expressions)</h4>
<p>عبارت‌های اصلی شامل عملگرهایی می‌شوند که جزو بخش‌های پایه‌ای زبان هستند.
مثال:</p>
<pre><code>Math.Log(1)
</code></pre>
<p>این عبارت شامل دو عبارت اصلی است:</p>
<p>عملگر . که یک جستجوی عضو (member lookup) انجام می‌دهد.</p>
<p>عملگر () که یک فراخوانی متد (method call) انجام می‌دهد.</p>
<h4>عبارت‌های void</h4>
<p>یک عبارت void عبارتی است که هیچ مقداری ندارد؛ مثلاً:</p>
<pre><code class="language-c#">Console.WriteLine(1)
</code></pre>
<p>چون مقداری ندارد، نمی‌توان از آن به‌عنوان عملوند در عبارات پیچیده‌تر استفاده کرد:</p>
<pre><code class="language-c#">1 + Console.WriteLine(1)   // خطای کامپایل
</code></pre>
<h4>عبارت‌های انتسابی (Assignment Expressions)</h4>
<p>یک عبارت انتسابی با عملگر = نتیجه‌ی یک عبارت را به یک متغیر اختصاص می‌دهد. مثال:</p>
<pre><code>x = x * 5
</code></pre>
<p>🔹 عبارت انتسابی یک عبارت void نیست؛ بلکه مقدار آن همان چیزی است که اختصاص داده شده.
پس می‌توان آن را درون یک عبارت دیگر به کار برد:</p>
<pre><code>y = 5 * (x = 2)   // مقداردهی همزمان به x و y
</code></pre>
<p>می‌توانید این سبک را برای مقداردهی همزمان چند متغیر استفاده کنید:</p>
<pre><code>a = b = c = d = 0
</code></pre>
<p>عملگرهای ترکیبی (Compound Assignment Operators)</p>
<p>این عملگرها میانبرهایی هستند که انتساب را با عملگر دیگری ترکیب می‌کنند:</p>
<pre><code class="language-c#">x *= 2    // معادل x = x * 2
x &lt;&lt;= 1   // معادل x = x &lt;&lt; 1
</code></pre>
<p>⚠️ یک استثنای ظریف اینجاست: برای eventها در C# عملگرهای += و -= رفتار خاصی دارند و در واقع به متدهای add و remove آن event نگاشت می‌شوند (فصل ۴ توضیح داده شده).</p>
<h4>تقدم و وابستگی عملگرها (Operator Precedence and Associativity)</h4>
<p>وقتی یک عبارت شامل چند عملگر باشد، ترتیب اجرای آن‌ها با دو قانون مشخص می‌شود:</p>
<p>تقدم (Precedence) → عملگرهایی با تقدم بالاتر زودتر اجرا می‌شوند.</p>
<p>وابستگی (Associativity) → اگر دو عملگر تقدم یکسانی داشته باشند، وابستگی تعیین می‌کند که از چپ به راست اجرا می‌شوند یا برعکس.</p>
<h5>تقدم (Precedence)</h5>
<p>مثال:</p>
<pre><code>1 + 2 * 3
</code></pre>
<p>اینجا عملگر * تقدم بیشتری دارد، پس ابتدا ضرب انجام می‌شود:</p>
<pre><code>1 + (2 * 3)
</code></pre>
<h4>وابستگی به چپ (Left-associative)</h4>
<p>بیشتر عملگرهای دوتایی (به‌جز =, =&gt;, و ??) چپ‌گرا هستند؛ یعنی از چپ به راست ارزیابی می‌شوند.</p>
<p>مثال:</p>
<pre><code>8 / 4 / 2
</code></pre>
<p>به این صورت اجرا می‌شود:</p>
<pre><code>(8 / 4) / 2   // نتیجه: 1
</code></pre>
<p>اما با پرانتز می‌توانید ترتیب واقعی اجرا را تغییر دهید:</p>
<pre><code>8 / (4 / 2)   // نتیجه: 4
</code></pre>
<h4>اپراتورهای راست‌همبند (Right-associative operators) ⚡</h4>
<p>در زبان #C، بعضی از اپراتورها به‌جای چپ‌همبندی، راست‌همبند هستند. یعنی وقتی چند بار پشت سر هم بیایند، از راست به چپ ارزیابی می‌شوند.</p>
<p>📌 این اپراتورها عبارت‌اند از:</p>
<ul>
<li>
<p>اپراتورهای انتساب (=, +=, -=, *=, …)</p>
</li>
<li>
<p>اپراتور lambda (=&gt;)</p>
</li>
<li>
<p>اپراتور null-coalescing (??)</p>
</li>
<li>
<p>اپراتور شرطی (?:)</p>
</li>
</ul>
<p>مثال: چندین انتساب</p>
<pre><code>x = y = 3;
</code></pre>
<p>✔️ ابتدا مقدار 3 به y نسبت داده می‌شود.
✔️ سپس نتیجه‌ی همان عبارت (که 3 است) به x نسبت داده می‌شود.</p>
<p>به همین دلیل، این نوع کد به‌درستی کامپایل می‌شود.</p>
<p>جدول اپراتورها  🧮</p>
<p>کتاب در ادامه یک جدول (Table 2-3) ارائه می‌دهد که تمام اپراتورهای C# را به‌ترتیب اولویت (precedence) نشان می‌دهد.</p>
<ul>
<li>
<p>اپراتورهایی که در یک دسته قرار می‌گیرند، اولویت یکسان دارند.</p>
</li>
<li>
<p>ترتیب دسته‌ها مشخص می‌کند کدام عملگرها زودتر اجرا می‌شوند.</p>
</li>
</ul>
<p>📖 نکته: در فصل “Operator Overloading” (صفحه 256) توضیح داده شده که کدام اپراتورها را می‌توان برای کلاس‌ها و ساختارهای خودتان بازتعریف (overload) کنید.</p>
<p>Table 2-3. C# operators (categories in order of precedence)</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-9.jpeg" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h3>اپراتورهای null  🟰</h3>
<p>زبان #C سه اپراتور پرکاربرد برای راحت‌تر کار کردن با مقادیر null دارد:</p>
<ol>
<li>
<p>اپراتور ادغام با null (??)</p>
</li>
<li>
<p>اپراتور انتساب ادغام با null (??=)</p>
</li>
<li>
<p>اپراتور شرطی null (Elvis) (?.)</p>
</li>
</ol>
<h4>اپراتور Null-Coalescing (??)</h4>
<p>این اپراتور می‌گوید:
👉 «اگر مقدار سمت چپ null نبود، همان را بده؛ در غیر این صورت مقدار سمت راست را بده.»</p>
<p>مثال:</p>
<pre><code class="language-c#">string s1 = null;
string s2 = s1 ?? &quot;nothing&quot;;   // s2 برابر می‌شود با &quot;nothing&quot;
</code></pre>
<p>📌 نکته: اگر سمت چپ غیر null باشد، سمت راست اصلاً اجرا نمی‌شود.</p>
<p>این اپراتور همچنین با انواع Nullable هم کار می‌کند (توضیح کامل در فصل &quot;Nullable Value Types&quot;).</p>
<h4>اپراتور Null-Coalescing Assignment (??=)</h4>
<p>(اضافه شده در C# 8)</p>
<p>این اپراتور می‌گوید:
👉 «اگر مقدار سمت چپ null بود، مقدار سمت راست را به آن انتساب بده.»</p>
<p>مثال:</p>
<pre><code class="language-c#">myVariable ??= someDefault;
</code></pre>
<p>معادل است با:</p>
<pre><code class="language-c#">if (myVariable == null) 
    myVariable = someDefault;
</code></pre>
<p>📌 این اپراتور مخصوصاً در پیاده‌سازی ویژگی‌های محاسبه‌ای تنبل (lazy evaluation) خیلی کاربردی است.</p>
<h4>اپراتور Null-Conditional (Elvis) (?.)</h4>
<p>این اپراتور (به خاطر شباهت به شکلک Elvis ?.) به شما اجازه می‌دهد مثل اپراتور نقطه (.) به اعضای یک شیء دسترسی پیدا کنید،
اما اگر شیء سمت چپ null باشد، به جای پرتاب خطای NullReferenceException، مقدار کل عبارت null می‌شود.</p>
<p>مثال:</p>
<pre><code class="language-c#">System.Text.StringBuilder sb = null;
string s = sb?.ToString();   // خطایی نمی‌دهد، s برابر null می‌شود
</code></pre>
<p>این معادل است با:</p>
<pre><code class="language-c#">string s = (sb == null ? null : sb.ToString());
</code></pre>
<p>📌 استفاده با ایندکسرها:</p>
<pre><code class="language-c#">string[] words = null;
string word = words?[1];   // word برابر null می‌شود
</code></pre>
<p>📌 کوتاه‌سازی (short-circuiting):</p>
<pre><code class="language-c#">System.Text.StringBuilder sb = null;
string s = sb?.ToString().ToUpper();   // باز هم s برابر null می‌شود، بدون خطا
</code></pre>
<p>🔹 تکرار Elvis فقط زمانی لازم است که هر بخش ممکن است null باشد:</p>
<pre><code>x?.y?.z
</code></pre>
<p>معادل است با:</p>
<pre><code class="language-c#">x == null ? null 
          : (x.y == null ? null : x.y.z)
</code></pre>
<p><strong>⚠️ خطا در استفاده با نوع غیرnullable</strong></p>
<pre><code class="language-c#">System.Text.StringBuilder sb = null;
int length = sb?.ToString().Length;   // ❌ خطا: int نمی‌تواند null باشد
</code></pre>
<p>✅ راه‌حل: استفاده از Nullable</p>
<pre><code class="language-c#">int? length = sb?.ToString().Length;  // درست: int? می‌تواند null باشد
</code></pre>
<p>📌 استفاده برای متدهای void</p>
<pre><code class="language-c#">someObject?.SomeVoidMethod();
</code></pre>
<p>اگر someObject مقدار null داشته باشد، این دستور هیچ کاری نمی‌کند (no-op).</p>
<p><strong>🌀 ترکیب با اپراتور Null-Coalescing</strong></p>
<p>خیلی وقت‌ها ترکیب این دو اپراتور کاربردی است:</p>
<pre><code class="language-c#">System.Text.StringBuilder sb = null;
string s = sb?.ToString() ?? &quot;nothing&quot;;   // s می‌شود &quot;nothing&quot;
</code></pre>
<h3>جملات (Statements)</h3>
<p>توابع (Functions) از جملات (statements) تشکیل می‌شوند که به ترتیب متنی که ظاهر شده‌اند، اجرا می‌شوند.
یک بلوک جمله (statement block) مجموعه‌ای از جملات است که بین آکولادها ({}) نوشته می‌شوند.</p>
<h4>جملات اعلان (Declaration Statements)</h4>
<p>یک اعلان متغیر (variable declaration) یک متغیر جدید معرفی می‌کند و در صورت نیاز می‌تواند آن را با یک عبارت مقداردهی اولیه کند.
شما می‌توانید چند متغیر از یک نوع را در یک لیست جداشده با ویرگول اعلان کنید:</p>
<pre><code class="language-c#">string someWord = &quot;rosebud&quot;;
int someNumber = 42;
bool rich = true, famous = false;
</code></pre>
<p>یک اعلان ثابت (constant declaration) شبیه به اعلان متغیر است، با این تفاوت که پس از تعریف دیگر قابل تغییر نیست و مقداردهی اولیه باید همان موقع اعلام صورت بگیرد (به بخش «ثابت‌ها (Constants)» در صفحه 104 مراجعه کنید):</p>
<pre><code class="language-c#">const double c = 2.99792458E08;
c += 10;   // خطای زمان کامپایل
</code></pre>
<h5>متغیرهای محلی (Local variables)</h5>
<p>دامنه (scope) یک متغیر یا ثابت محلی در کل بلوک جاری برقرار است.
شما نمی‌توانید متغیر دیگری با همان نام در همان بلوک یا بلوک‌های تو در تو اعلان کنید:</p>
<pre><code class="language-c#">int x;
{
    int y;
    int x;   // خطا - x قبلاً تعریف شده
}
{
    int y;   // مجاز - y در اینجا در دامنه نیست
}
Console.Write(y);  // خطا - y خارج از دامنه است
</code></pre>
<p>دامنه‌ی یک متغیر در هر دو جهت در سراسر بلوک کدی‌اش گسترش دارد.
این یعنی اگر در مثال بالا اعلان x را به پایین متد منتقل کنیم، باز همان خطا را خواهیم گرفت.
این موضوع در تضاد با زبان ++C است و کمی عجیب به نظر می‌رسد، چون شما نمی‌توانید قبل از تعریف یک متغیر یا ثابت به آن ارجاع دهید.</p>
<h4>جملات عبارت (Expression Statements)</h4>
<p>جملات عبارت، عبارت‌هایی هستند که به‌عنوان جمله نیز معتبر هستند.
یک جمله‌ی عبارت باید یا وضعیت (state) را تغییر دهد یا چیزی را فراخوانی کند که ممکن است وضعیت را تغییر دهد.</p>
<p>منظور از تغییر وضعیت همان تغییر دادن مقدار یک متغیر است.</p>
<p>انواع جملات عبارت عبارت‌اند از:</p>
<ul>
<li>
<p>عبارت‌های انتساب (assignment expressions) → شامل افزایش (++) و کاهش (--)</p>
</li>
<li>
<p>عبارت‌های فراخوانی متد (method call expressions) → چه متدهای void و چه غیر void</p>
</li>
<li>
<p>عبارت‌های نمونه‌سازی شیء (object instantiation expressions)</p>
</li>
</ul>
<p>مثال‌ها</p>
<pre><code class="language-c#">// جملات اعلان:
string s;
int x, y;
System.Text.StringBuilder sb;

// جملات عبارت:
x = 1 + 2;                 // عبارت انتساب
x++;                       // عبارت افزایش
y = Math.Max(x, 5);        // عبارت انتساب
Console.WriteLine(y);      // عبارت فراخوانی متد
sb = new StringBuilder();  // عبارت انتساب
new StringBuilder();       // عبارت نمونه‌سازی شیء
</code></pre>
<p>وقتی یک سازنده (constructor) یا متدی که مقداری برمی‌گرداند را فراخوانی می‌کنید، الزامی نیست از نتیجه‌ی آن استفاده کنید.
اما اگر سازنده یا متد هیچ تغییری در وضعیت ایجاد نکند، جمله‌ی حاصل کاملاً بی‌فایده خواهد بود:</p>
<pre><code class="language-c#">new StringBuilder();     // مجاز، اما بی‌فایده
new string('c', 3);      // مجاز، اما بی‌فایده
x.Equals(y);             // مجاز، اما بی‌فایده
</code></pre>
<h4>جملات انتخابی (Selection Statements)</h4>
<p>زبان C# مکانیزم‌های مختلفی برای کنترل شرطی جریان اجرای برنامه دارد:</p>
<ul>
<li>
<p>جملات انتخابی (if, switch)</p>
</li>
<li>
<p>عملگر شرطی (?:)</p>
</li>
<li>
<p>جملات حلقه (while, do-while, for, foreach)</p>
</li>
</ul>
<p>در این بخش، دو ساختار ساده‌تر یعنی دستور if و دستور switch توضیح داده می‌شوند.</p>
<p><strong>دستور if</strong></p>
<p>یک دستور if یک جمله را فقط در صورتی اجرا می‌کند که یک عبارت بولی (bool) مقدار true داشته باشد:</p>
<pre><code class="language-c#">if (5 &lt; 2 * 3)
    Console.WriteLine(&quot;true&quot;);   // true
</code></pre>
<p>جمله می‌تواند یک بلوک کدی هم باشد:</p>
<pre><code class="language-c#">if (5 &lt; 2 * 3)
{
    Console.WriteLine(&quot;true&quot;);
    Console.WriteLine(&quot;Let’s move on!&quot;);
}
</code></pre>
<p><strong>بخش else</strong></p>
<p>یک دستور if می‌تواند به صورت اختیاری دارای بخش else هم باشد:</p>
<pre><code class="language-c#">if (2 + 2 == 5)
    Console.WriteLine(&quot;Does not compute&quot;);
else
    Console.WriteLine(&quot;False&quot;);   // False
</code></pre>
<p>داخل بخش else می‌توان یک دستور if دیگر قرار داد:</p>
<pre><code class="language-c#">if (2 + 2 == 5)
    Console.WriteLine(&quot;Does not compute&quot;);
else
    if (2 + 2 == 4)
        Console.WriteLine(&quot;Computes&quot;);   // Computes
</code></pre>
<h4>تغییر جریان اجرا با آکولادها (Braces)</h4>
<p>بخش else همیشه به نزدیک‌ترین دستور if قبل از خودش تعلق دارد:</p>
<pre><code class="language-c#">if (true)
    if (false)
        Console.WriteLine();
    else
        Console.WriteLine(&quot;executes&quot;);
</code></pre>
<p>این دقیقاً معادل است با:</p>
<pre><code class="language-c#">if (true)
{
    if (false)
        Console.WriteLine();
    else
        Console.WriteLine(&quot;executes&quot;);
}
</code></pre>
<p>اما اگر جای آکولادها را تغییر دهیم، جریان اجرا عوض می‌شود:</p>
<pre><code class="language-c#">if (true)
{
    if (false)
        Console.WriteLine();
}
else
    Console.WriteLine(&quot;does not execute&quot;);
</code></pre>
<p><strong>چرا آکولادها مهم هستند؟</strong></p>
<p>استفاده از آکولادها باعث می‌شود قصد شما شفاف‌تر شود و خوانایی کد در ساختارهای تو در تو بهتر گردد—even اگر کامپایلر به آنها نیازی نداشته باشد.</p>
<p>یک استثنای مهم الگوی زیر است:</p>
<pre><code class="language-c#">void TellMeWhatICanDo(int age)
{
    if (age &gt;= 35)
        Console.WriteLine(&quot;You can be president!&quot;);
    else if (age &gt;= 21)
        Console.WriteLine(&quot;You can drink!&quot;);
    else if (age &gt;= 18)
        Console.WriteLine(&quot;You can vote!&quot;);
    else
        Console.WriteLine(&quot;You can wait!&quot;);
}
</code></pre>
<p>اینجا دستورهای if و else طوری پشت سر هم قرار گرفته‌اند که شبیه به دستور elseif در زبان‌های دیگر باشد (یا مثل دستور پیش‌پردازنده #elif در C#).
ویژوال استودیو این الگو را تشخیص می‌دهد و فرمت‌بندی خودکارش را مطابق همین حالت حفظ می‌کند.
با این حال، از نظر معنایی هر دستور if بعد از یک else در واقع داخل بخش else قبلی تو در تو است.</p>
<h4>دستور switch</h4>
<p>دستورهای switch به شما اجازه می‌دهند جریان اجرای برنامه را بر اساس مجموعه‌ای از مقادیر ممکن که یک متغیر می‌تواند داشته باشد، شاخه‌بندی کنید.
کدهایی که از switch استفاده می‌کنند معمولاً خواناتر و تمیزتر از استفاده از چندین دستور if پشت سر هم هستند، چون عبارت فقط یک بار ارزیابی می‌شود.</p>
<p>مثال ساده</p>
<pre><code class="language-c#">void ShowCard(int cardNumber)
{
    switch (cardNumber)
    {
        case 13:
            Console.WriteLine(&quot;King&quot;);
            break;
        case 12:
            Console.WriteLine(&quot;Queen&quot;);
            break;
        case 11:
            Console.WriteLine(&quot;Jack&quot;);
            break;
        case -1:                       // کارت Joker معادل -1
            goto case 12;              // در این بازی Joker معادل Queen حساب می‌شود
        default:                       // اجرا می‌شود برای هر مقدار دیگری
            Console.WriteLine(cardNumber);
            break;
    }
}
</code></pre>
<p>🔹 در این مثال، از رایج‌ترین حالت استفاده شده است: سوئیچ روی مقادیر ثابت.
وقتی یک مقدار ثابت (constant) مشخص می‌کنید، نوع آن باید یکی از موارد زیر باشد:</p>
<ul>
<li>
<p>انواع عددی داخلی (int, byte, long, …)</p>
</li>
<li>
<p>bool</p>
</li>
<li>
<p>char</p>
</li>
<li>
<p>string</p>
</li>
<li>
<p>enum</p>
</li>
</ul>
<p><strong>پایان هر case</strong></p>
<p>در انتهای هر بخش case باید صراحتاً مشخص کنید که اجرای برنامه به کجا برود (مگر اینکه کد شما به حلقه بی‌نهایت ختم شود).
گزینه‌ها عبارت‌اند از:</p>
<ul>
<li>
<p>break → پرش به انتهای دستور switch</p>
</li>
<li>
<p>goto case x → پرش به بخش یک case دیگر</p>
</li>
<li>
<p>goto default → پرش به بخش default</p>
</li>
<li>
<p>سایر دستورات پرش مثل: return، throw، continue یا goto label</p>
</li>
</ul>
<p><strong>اجرای یک کد مشترک برای چند مقدار</strong></p>
<p>اگر بیش از یک مقدار باید همان کد را اجرا کند، می‌توانید آنها را پشت سر هم بنویسید:</p>
<pre><code class="language-c#">switch (cardNumber)
{
    case 13:
    case 12:
    case 11:
        Console.WriteLine(&quot;Face card&quot;);
        break;
    default:
        Console.WriteLine(&quot;Plain card&quot;);
        break;
}
</code></pre>
<p>در اینجا برای مقادیر 13، 12 و 11 همان کد مشترک اجرا می‌شود.</p>
<p>✅ این قابلیت یکی از ویژگی‌های مهم دستور switch است که باعث می‌شود کد شما خیلی خواناتر و تمیزتر از چندین if-else پشت سر هم باشد.</p>
<h4>سوئیچ روی نوع داده (Switching on Types)</h4>
<p>سوئیچ روی نوع داده یک حالت خاص از سوئیچ روی الگو (pattern matching) است.
از نسخه‌های جدیدتر C#، الگوهای بیشتری معرفی شده‌اند (برای توضیح کامل به بخش Patterns در صفحه 238 مراجعه کنید).</p>
<p>مثال: سوئیچ روی نوع داده</p>
<pre><code class="language-c#">TellMeTheType(12);
TellMeTheType(&quot;hello&quot;);
TellMeTheType(true);

void TellMeTheType(object x)   // object می‌تواند هر نوع داده‌ای را بپذیرد
{
    switch (x)
    {
        case int i:
            Console.WriteLine(&quot;It's an int!&quot;);
            Console.WriteLine($&quot;The square of {i} is {i * i}&quot;);
            break;
        case string s:
            Console.WriteLine(&quot;It's a string&quot;);
            Console.WriteLine($&quot;The length of {s} is {s.Length}&quot;);
            break;
        case DateTime:
            Console.WriteLine(&quot;It's a DateTime&quot;);
            break;
        default:
            Console.WriteLine(&quot;I don't know what x is&quot;);
            break;
    }
}
</code></pre>
<p>🔹 نوع object این امکان را می‌دهد که پارامتر هر نوع داده‌ای را بپذیرد.
(این موضوع در بخش‌های Inheritance صفحه 126 و The object Type صفحه 138 توضیح داده می‌شود.)</p>
<p>در هر بخش case:</p>
<ul>
<li>
<p>یک نوع داده مشخص می‌کنید.</p>
</li>
<li>
<p>اگر تطبیق برقرار شود، مقدار متغیر به یک متغیر الگو (pattern variable) اختصاص داده می‌شود.</p>
</li>
</ul>
<p>برخلاف مقادیر ثابت، اینجا هیچ محدودیتی برای نوع داده وجود ندارد.</p>
<p><strong>شرط‌گذاری روی case با when</strong></p>
<p>می‌توانید یک شرط اضافه کنید:</p>
<pre><code class="language-c#">switch (x)
{
    case bool b when b == true:
        Console.WriteLine(&quot;True!&quot;);
        break;
    case bool b:
        Console.WriteLine(&quot;False!&quot;);
        break;
}
</code></pre>
<p>🔸 توجه: ترتیب caseها در سوئیچ روی نوع اهمیت دارد (برخلاف ثابت‌ها).
اگر ترتیب را برعکس کنید، کد حتی کامپایل نمی‌شود چون بخش دوم غیرقابل دسترسی (unreachable) خواهد شد.
استثنا: بخش default که همیشه در آخر اجرا می‌شود (مهم نیست کجا نوشته شده باشد).</p>
<p><strong>چندین case روی هم (Stacking Cases)</strong></p>
<p>می‌توانید چند نوع داده را پشت سر هم قرار دهید تا یک کد مشترک اجرا شود:</p>
<pre><code class="language-c#">switch (x)
{
    case float f when f &gt; 1000:
    case double d when d &gt; 1000:
    case decimal m when m &gt; 1000:
        Console.WriteLine(&quot;We can refer to x here but not f or d or m&quot;);
        break;
}
</code></pre>
<p>🔹 در اینجا متغیرهای f، d و m فقط داخل شرط‌های when در دسترس هستند.
وقتی به Console.WriteLine می‌رسیم، چون معلوم نیست کدام یک از این متغیرها مقدار گرفته، همه آنها خارج از محدوده (out of scope) محسوب می‌شوند.</p>
<p><strong>ترکیب ثابت‌ها و الگوها</strong></p>
<p>شما می‌توانید مقادیر ثابت و الگوها (patterns) را در یک دستور switch ترکیب کنید.
همچنین می‌توانید روی مقدار null هم سوئیچ کنید:</p>
<pre><code class="language-c#">case null:
    Console.WriteLine(&quot;Nothing here&quot;);
    break;
</code></pre>
<p>✅ پس در نسخه‌های جدید C#، switch فقط محدود به مقادیر ثابت نیست،
بلکه می‌تواند بر اساس نوع داده، مقدار null، یا حتی الگوهای پیچیده‌تر تصمیم بگیرد.</p>
<h4>عبارت‌های Switch (Switch Expressions)</h4>
<p>از C# 8 به بعد، می‌توان از switch در قالب یک عبارت (expression) هم استفاده کرد.
برخلاف حالت عادی که switch یک بلوک دستور (statement block) است، اینجا مقدار بازمی‌گرداند و می‌تواند مستقیماً در انتساب‌ها یا پرس‌وجوهای LINQ به‌کار برود.</p>
<p><strong>مثال ساده</strong></p>
<p>فرض کنید متغیر cardNumber از نوع int است:</p>
<pre><code class="language-c#">string cardName = cardNumber switch
{
    13 =&gt; &quot;King&quot;,
    12 =&gt; &quot;Queen&quot;,
    11 =&gt; &quot;Jack&quot;,
    _  =&gt; &quot;Pip card&quot;   // معادل 'default'
};
</code></pre>
<p>🔹 نکات مهم:</p>
<ul>
<li>
<p>کلمه کلیدی switch بعد از نام متغیر می‌آید.</p>
</li>
<li>
<p>هر بخش case در قالب یک عبارت نوشته می‌شود و با کاما جدا می‌شود (نه break;).</p>
</li>
<li>
<p>بخش _ نقش default را دارد.</p>
</li>
<li>
<p>اگر _ (یا هر حالت پیش‌فرض دیگری) حذف شود و تطبیق انجام نشود → یک استثنا (exception) پرتاب می‌شود.</p>
</li>
</ul>
<p><strong>مزایا</strong></p>
<ul>
<li>
<p>کوتاه‌تر و خواناتر از switch معمولی.</p>
</li>
<li>
<p>قابل استفاده در عبارت‌های LINQ و جاهایی که نیاز به یک مقدار بازگشتی دارید.</p>
</li>
</ul>
<p><strong>سوئیچ روی چند مقدار (Tuple Pattern)</strong></p>
<p>می‌توانید روی بیش از یک مقدار همزمان سوئیچ کنید:</p>
<pre><code class="language-c#">int cardNumber = 12;
string suite = &quot;spades&quot;;

string cardName = (cardNumber, suite) switch
{
    (13, &quot;spades&quot;) =&gt; &quot;King of spades&quot;,
    (13, &quot;clubs&quot;)  =&gt; &quot;King of clubs&quot;,
    (12, &quot;spades&quot;) =&gt; &quot;Queen of spades&quot;,
    _              =&gt; &quot;Some other card&quot;
};
</code></pre>
<p>🔹 در اینجا (cardNumber, suite) یک تاپل (tuple) است و هر case هم یک الگوی تاپل مشخص می‌کند.</p>
<p><strong>جمع‌بندی</strong></p>
<p>✅ Switch Expressions یک نسخه ساده‌تر و قدرتمندتر از switch هستند که:</p>
<ul>
<li>
<p>از C# 8 معرفی شدند.</p>
</li>
<li>
<p>می‌توانند روی یک مقدار یا چند مقدار (تاپل) عمل کنند.</p>
</li>
<li>
<p>به‌طور مستقیم مقدار بازمی‌گردانند.</p>
</li>
<li>
<p>از الگوها (patterns) پشتیبانی می‌کنند.</p>
</li>
</ul>
<h4>دستورهای تکرار (Iteration Statements)</h4>
<p>در زبان C#، می‌توان یک بلوک از دستورات را به‌طور تکراری اجرا کرد.
این کار با استفاده از چهار نوع حلقه (loop) امکان‌پذیر است:</p>
<ul>
<li>
<p>while</p>
</li>
<li>
<p>do-while</p>
</li>
<li>
<p>for</p>
</li>
<li>
<p>foreach</p>
</li>
</ul>
<p><strong>🔹 حلقه while</strong></p>
<p>حلقه while یک بلوک کد را تا زمانی که شرط بولی برقرار باشد تکرار می‌کند.
در این حالت، شرط قبل از اجرای بدنه بررسی می‌شود.</p>
<p>مثال:</p>
<pre><code class="language-c#">int i = 0;
while (i &lt; 3)
{
    Console.Write(i);
    i++;
}
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>012
</code></pre>
<p>✅ توضیح:</p>
<p>ابتدا مقدار i بررسی می‌شود.</p>
<p>تا زمانی که i &lt; 3 باشد، بدنه حلقه اجرا می‌شود.</p>
<p>در هر بار اجرا، i++ مقدار را یکی افزایش می‌دهد.</p>
<h5>حلقه do-while</h5>
<p>حلقه do-while تقریباً شبیه به while است، اما با یک تفاوت مهم:</p>
<p>شرط بعد از اجرای بدنه بررسی می‌شود.</p>
<p>بنابراین بدنه حداقل یک بار اجرا خواهد شد، حتی اگر شرط در ابتدا نادرست باشد.</p>
<p>مثال:</p>
<pre><code class="language-c#">int i = 0;
do
{
    Console.WriteLine(i);
    i++;
}
while (i &lt; 3);
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>0
1
2
</code></pre>
<p>✅ تفاوت کلیدی:</p>
<ul>
<li>
<p>در while، اگر شرط از همان ابتدا نادرست باشد، هیچ‌وقت بدنه اجرا نمی‌شود.</p>
</li>
<li>
<p>در do-while، بدنه حداقل یک بار اجرا می‌شود، حتی اگر شرط از ابتدا نادرست باشد.</p>
</li>
</ul>
<h6>🔹 حلقه for</h6>
<p>حلقه for شبیه به while است، با این تفاوت که بخش‌های مقداردهی اولیه، شرط و به‌روزرسانی متغیر در یک خط قرار می‌گیرند.</p>
<p>ساختار کلی:</p>
<pre><code class="language-c#">for (initialization-clause; condition-clause; iteration-clause)
    statement-or-statement-block;
</code></pre>
<ul>
<li>
<p>initialization-clause → قبل از شروع حلقه اجرا می‌شود؛ معمولاً برای مقداردهی متغیر شمارنده.</p>
</li>
<li>
<p>condition-clause → یک عبارت بولی است که شرط ادامه‌ی حلقه را مشخص می‌کند.</p>
</li>
<li>
<p>iteration-clause → بعد از هر بار اجرای بدنه حلقه اجرا می‌شود؛ معمولاً برای به‌روزرسانی شمارنده.</p>
</li>
</ul>
<p>مثال ساده:</p>
<pre><code class="language-c#">for (int i = 0; i &lt; 3; i++)
    Console.WriteLine(i);
</code></pre>
<p>🔸 خروجی:</p>
<p>0
1
2</p>
<p><strong>مثال محاسبه‌ی دنباله فیبوناچی (۱۰ عدد اول):</strong></p>
<pre><code class="language-c#">for (int i = 0, prevFib = 1, curFib = 1; i &lt; 10; i++)
{
    Console.WriteLine(prevFib);
    int newFib = prevFib + curFib;
    prevFib = curFib; 
    curFib = newFib;
}
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>1
1
2
3
5
8
13
21
34
55
</code></pre>
<p><strong>حلقه‌ی بی‌نهایت با for</strong></p>
<p>در حلقه‌ی for، هر سه بخش (init, condition, iteration) می‌توانند حذف شوند.
این باعث می‌شود یک حلقه بی‌نهایت ساخته شود:</p>
<pre><code class="language-c#">for (;;)
    Console.WriteLine(&quot;interrupt me&quot;);
</code></pre>
<p>(مشابه با while (true))</p>
<h6>حلقه foreach</h6>
<p>حلقه‌ی foreach برای پیمایش روی عناصر یک شیء قابل شمارش (Enumerable) استفاده می‌شود.
بسیاری از مجموعه‌ها در .NET مثل آرایه‌ها، لیست‌ها و حتی رشته‌ها (string) قابل شمارش هستند.</p>
<p>مثال پیمایش روی کاراکترهای یک رشته:</p>
<pre><code class="language-c#">foreach (char c in &quot;beer&quot;)   // c متغیر تکرار است
    Console.WriteLine(c);
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>b
e
e
r
</code></pre>
<p>✅ نکته: foreach به شما کمک می‌کند بدون نیاز به شمارنده (i) روی عناصر مجموعه حرکت کنید.</p>
<h4>🚀 دستورات پرش (Jump Statements)</h4>
<p>در زبان C# چند دستور وجود دارد که باعث تغییر ناگهانی جریان اجرای برنامه می‌شوند. این‌ها به نام jump statements شناخته می‌شوند و شامل موارد زیر هستند:</p>
<ul>
<li>
<p>break</p>
</li>
<li>
<p>continue</p>
</li>
<li>
<p>goto</p>
</li>
<li>
<p>return</p>
</li>
<li>
<p>throw</p>
</li>
</ul>
<p><strong>⚖️ قوانین مهم پرش‌ها در کنار بلوک‌های try/finally</strong></p>
<p>اگر از داخل یک بلوک try پرش (jump) انجام شود، قبل از رسیدن به مقصد، بلوک finally همیشه اجرا می‌شود.</p>
<p>پرش از داخل finally به بیرون ممنوع است (مگر با استفاده از throw).</p>
<h5>دستور break</h5>
<p>🔸 break اجرای بدنه‌ی یک حلقه (for, while, do-while, foreach) یا یک switch را متوقف کرده و جریان برنامه را به اولین خط بعد از آن منتقل می‌کند.</p>
<p>مثال:</p>
<pre><code class="language-c#">int x = 0;
while (true)
{
    if (x++ &gt; 5)
        break;   // خروج از حلقه
}
Console.WriteLine(&quot;بعد از break&quot;);
</code></pre>
<p>📌 وقتی شرط برقرار شود، حلقه متوقف شده و اجرای برنامه از خط بعد از حلقه ادامه پیدا می‌کند.</p>
<h5>دستور continue</h5>
<p>🔸 continue باعث می‌شود اجرای باقی‌مانده‌ی کد در همان تکرار جاری از حلقه متوقف شود و بلافاصله به سراغ تکرار بعدی حلقه برود.</p>
<p>مثال: پرش از روی اعداد زوج</p>
<pre><code class="language-c#">for (int i = 0; i &lt; 10; i++)
{
    if ((i % 2) == 0)   // اگر عدد زوج بود
        continue;       // برو سراغ تکرار بعدی

    Console.Write(i + &quot; &quot;);
}
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>1 3 5 7 9
</code></pre>
<p>📌 اینجا همه‌ی اعداد زوج نادیده گرفته می‌شوند و فقط اعداد فرد چاپ می‌شوند.</p>
<h5>دستور goto</h5>
<p>🔸 دستور goto باعث می‌شود اجرای برنامه به یک برچسب (label) منتقل شود.</p>
<p>📌 فرمت کلی:</p>
<pre><code class="language-c#">goto statement-label;
</code></pre>
<p>یا در switch‎:</p>
<pre><code class="language-c#">goto case case-constant;   // فقط برای مقادیر ثابت
</code></pre>
<p>🔸 برچسب یک نام در بلوک کد است که با علامت : تعریف می‌شود.</p>
<p>مثال: شبیه‌سازی یک حلقه با goto</p>
<pre><code class="language-c#">int i = 1;
startLoop:
if (i &lt;= 5)
{
    Console.Write(i + &quot; &quot;);
    i++;
    goto startLoop;   // پرش به برچسب
}
</code></pre>
<p>🔸 خروجی:</p>
<pre><code>1 2 3 4 5
</code></pre>
<p>📌 اینجا عملاً رفتاری مثل یک for ساخته‌ایم، ولی به روش قدیمی و کمتر خوانا.</p>
<p>⚠️ نکته: استفاده از goto معمولاً توصیه نمی‌شود چون باعث سخت‌خوانی کد می‌شود، مگر در شرایط خاص (مثل خروج از چند حلقه تو در تو یا پرش در switch).</p>
<h5>دستور return</h5>
<p>🔸 دستور return باعث می‌شود اجرای متد متوقف شده و کنترل به متدی که آن را صدا زده بازگردد.</p>
<p>اگر متد مقداری برنگرداند (void)، فقط return; کافی است.</p>
<p>اگر متد مقدار برمی‌گرداند (مثل int یا decimal)، باید مقدار مناسب برگردانده شود.</p>
<p>مثال:</p>
<pre><code class="language-c#">decimal AsPercentage(decimal d)
{
    decimal p = d * 100m;
    return p;   // بازگشت همراه با مقدار
}
</code></pre>
<p>📌 این متد یک عدد را گرفته و درصد آن را برمی‌گرداند.</p>
<p>⚠️ return می‌تواند در هر جای متد نوشته شود (به‌جز داخل finally).</p>
<h5>دستور throw</h5>
<p>🔸 دستور throw برای پرتاب یک Exception (استثنا/خطا) استفاده می‌شود. این کار اجرای عادی برنامه را متوقف کرده و کنترل را به مکان مدیریت خطا (معمولاً یک بلوک try/catch) منتقل می‌کند.</p>
<p>مثال:</p>
<pre><code class="language-c#">if (w == null)
    throw new ArgumentNullException(&quot;w cannot be null&quot;);
</code></pre>
<p>📌 اگر متغیر w مقدار null داشته باشد، یک استثنا پرتاب می‌شود تا به برنامه‌نویس یا کاربر اعلام کند خطایی رخ داده است.</p>
<h4>دستورات متفرقه ✨</h4>
<p>دستور using یک نحو (syntax) شیک و ساده برای فراخوانی متد Dispose روی اشیائی که رابط IDisposable را پیاده‌سازی کرده‌اند، درون یک بلوک finally فراهم می‌کند (بخش “try Statements and Exceptions” در صفحه 195 و “IDisposable, Dispose, and Close” در صفحه 581 را ببینید).</p>
<p>در زبان C#، کلمه‌ی کلیدی using بیش‌بارگذاری (overload) شده تا در زمینه‌های مختلف، معانی مستقلی داشته باشد. به طور مشخص، using directive با using statement متفاوت است.</p>
<p>دستور lock یک میان‌بر (shortcut) برای فراخوانی متدهای Enter و Exit از کلاس Monitor است (به فصل‌های 14 و 23 مراجعه کنید). 🔒</p>
<h3>فضای نام‌ها (Namespaces) 🗂️</h3>
<p>یک فضای نام (namespace) در واقع یک دامنه برای نام انواع (types) است. انواع معمولاً در قالب فضای نام‌های سلسله‌مراتبی (hierarchical) سازمان‌دهی می‌شوند تا پیدا کردن آن‌ها آسان‌تر باشد و از بروز تداخل جلوگیری شود.</p>
<p>برای نمونه، نوع (type) RSA که وظیفه‌ی مدیریت رمزنگاری کلید عمومی را بر عهده دارد، در فضای نام زیر تعریف شده است:</p>
<pre><code class="language-c#">System.Security.Cryptography
</code></pre>
<p>فضای نام، بخش جدایی‌ناپذیری از نام یک نوع به‌شمار می‌رود. کد زیر متد Create از نوع RSA را فراخوانی می‌کند:</p>
<pre><code class="language-c#">System.Security.Cryptography.RSA rsa =
    System.Security.Cryptography.RSA.Create();
</code></pre>
<p>فضاهای نام (namespaces) مستقل از assemblies هستند. اسمبلی‌ها همان فایل‌های .dll‌ای هستند که به عنوان واحدهای استقرار (deployment units) عمل می‌کنند (در فصل 17 توضیح داده شده است).
همچنین، فضاهای نام هیچ تأثیری بر روی سطح دسترسی اعضا (مانند public، internal، private و غیره) ندارند.</p>
<p>کلمه‌ی کلیدی namespace یک فضای نام برای انواع درون یک بلوک تعریف می‌کند؛ برای مثال:</p>
<pre><code class="language-c#">namespace Outer.Middle.Inner
{
    class Class1 {}
    class Class2 {}
}
</code></pre>
<p>نقطه‌ها (.) در نام فضای نام نشان‌دهنده‌ی سلسله‌مراتبی از فضاهای نام تو‌در‌تو هستند. کدی که در ادامه می‌آید، از نظر معنایی دقیقاً معادل نمونه‌ی قبلی است:</p>
<pre><code class="language-c#">namespace Outer
{
    namespace Middle
    {
        namespace Inner
        {
            class Class1 {}
            class Class2 {}
        }
    }
}
</code></pre>
<p>شما می‌توانید به یک نوع با نام کاملش (fully qualified name) اشاره کنید؛ نامی که شامل همه‌ی فضاهای نام از بیرونی‌ترین تا درونی‌ترین است. به عنوان مثال، می‌توانیم به Class1 در نمونه‌ی قبلی به صورت زیر ارجاع دهیم:</p>
<pre><code class="language-c#">Outer.Middle.Inner.Class1
</code></pre>
<p>انواعی که در هیچ فضای نامی تعریف نشده‌اند، در فضای نام global قرار می‌گیرند. فضای نام global همچنین شامل فضای نام‌های سطح بالا (top-level namespaces) مانند Outer در مثال ما هم می‌شود. 🌍</p>
<h4>فضای نام با محدوده فایل (File-Scoped Namespaces) 📄</h4>
<p>اغلب اوقات، می‌خواهید همه‌ی انواع (types) در یک فایل، در یک فضای نام تعریف شوند:</p>
<pre><code class="language-c#">namespace MyNamespace
{
    class Class1 {}
    class Class2 {}
}
</code></pre>
<p>از C# 10 به بعد، می‌توانید این کار را با استفاده از فضای نام با محدوده فایل (file-scoped namespace) انجام دهید:</p>
<pre><code class="language-c#">namespace MyNamespace;  // برای همه چیز در ادامه فایل اعمال می‌شود
class Class1 {}         // داخل MyNamespace
class Class2 {}         // داخل MyNamespace
</code></pre>
<p>استفاده از فضای نام با محدوده فایل باعث کاهش شلوغی کد و حذف یک سطح اضافی از تورفتگی (indentation) می‌شود. ✨</p>
<h4>دستور using 🧩</h4>
<p>دستور using یک فضای نام را وارد (import) می‌کند و به شما اجازه می‌دهد بدون استفاده از نام کامل (fully qualified name) به انواع آن فضای نام دسترسی داشته باشید.</p>
<p>مثال زیر فضای نام Outer.Middle.Inner که قبلاً تعریف شده بود را وارد می‌کند:</p>
<pre><code class="language-c#">using Outer.Middle.Inner;

Class1 c;  // نیازی به نام کامل نیست
</code></pre>
<p>قانوناً (و اغلب به صورت مطلوب) می‌توانید نام یک نوع را در فضای نام‌های مختلف دوباره تعریف کنید. اما معمولاً این کار تنها زمانی انجام می‌شود که احتمال کمی وجود داشته باشد که کسی بخواهد هر دو فضای نام را همزمان وارد کند.
یک مثال خوب کلاس TextBox است که هم در System.Windows.Controls (WPF) و هم در System.Windows.Forms (Windows Forms) تعریف شده است.</p>
<p>همچنین، یک دستور using می‌تواند درون یک فضای نام دیگر قرار گیرد تا محدوده‌ی دسترسی آن محدود شود. 🛡️</p>
<h4>دستور global using 🌐</h4>
<p>از C# 10 به بعد، اگر یک دستور using را با کلمه‌ی کلیدی global پیشوند کنید، این دستور برای تمام فایل‌های پروژه یا واحد کامپایل اعمال می‌شود:</p>
<pre><code class="language-c#">global using System;
global using System.Collections.Generic;
</code></pre>
<p>این کار به شما اجازه می‌دهد تا واردات رایج (common imports) را متمرکز کنید و از تکرار همان دستورات در هر فایل جلوگیری کنید.
توجه داشته باشید که دستورهای global using باید قبل از دستورهای معمولی (nonglobal) قرار بگیرند و نمی‌توانند داخل تعریف یک namespace بیایند. همچنین، می‌توان از global همراه با using static نیز استفاده کرد. ⚡</p>
<h5>واردات ضمنی global (Implicit global usings) 🔄</h5>
<p>از .NET 6، فایل‌های پروژه اجازه می‌دهند تا دستورهای global using به صورت ضمنی تعریف شوند. اگر عنصر ImplicitUsings در فایل پروژه روی true تنظیم شود (که برای پروژه‌های جدید پیش‌فرض است)، فضای نام‌های زیر به طور خودکار وارد می‌شوند:</p>
<pre><code class="language-c#">System

System.Collections.Generic

System.IO

System.Linq

System.Net.Http

System.Threading

System.Threading.Tasks
</code></pre>
<p>همچنین، بسته به نوع SDK پروژه (Web، Windows Forms، WPF و غیره)، فضای نام‌های اضافی نیز به طور خودکار وارد می‌شوند.</p>
<h4>دستور using static ⚙️</h4>
<p>دستور using static یک نوع (type) را وارد می‌کند، نه یک namespace. پس از آن، تمام اعضای static آن نوع بدون نیاز به نوشتن نام نوع، قابل استفاده هستند.</p>
<p>مثال:</p>
<pre><code class="language-c#">using static System.Console;

WriteLine(&quot;Hello&quot;);  // نیازی به Console.WriteLine نیست
</code></pre>
<p>دستور using static همه‌ی اعضای static قابل دسترسی نوع، شامل فیلدها، ویژگی‌ها (properties) و انواع تو در تو (nested types) را وارد می‌کند (فصل 3).
همچنین می‌توان این دستور را روی enumها نیز اعمال کرد، که در این صورت اعضای آن‌ها وارد می‌شوند.</p>
<p>مثال:</p>
<pre><code class="language-c#">using static System.Windows.Visibility;

var textBox = new TextBox { Visibility = Hidden };  // به جای Visibility.Hidden
</code></pre>
<p>اگر بین چندین واردات static ابهام ایجاد شود، کامپایلر C# به اندازه کافی هوشمند نیست تا نوع صحیح را از زمینه استنتاج کند و خطا ایجاد می‌کند. ⚠️</p>
<h3>قواعد درون یک فضای نام (Rules Within a Namespace) 📚</h3>
<h4>محدوده‌ی نام‌ها (Name Scoping) 🏷️</h4>
<p>نام‌هایی که در فضای نام‌های بیرونی تعریف شده‌اند، می‌توانند بدون نیاز به نام کامل در فضای نام‌های درونی استفاده شوند.
در مثال زیر، Class1 نیازی به نام کامل ندارد و می‌توان مستقیماً در Inner استفاده کرد:</p>
<pre><code class="language-c#">namespace Outer
{
    class Class1 {}

    namespace Inner
    {
        class Class2 : Class1 {}  // Class1 از Outer استفاده می‌شود
    }
}
</code></pre>
<p>اگر بخواهید به نوعی در شاخه‌ی دیگری از سلسله‌مراتب فضای نام خود ارجاع دهید، می‌توانید از نام نیمه‌کامل (partially qualified name) استفاده کنید.
مثال زیر، SalesReport را بر اساس Common.ReportBase تعریف می‌کند:</p>
<pre><code class="language-c#">namespace MyTradingCompany
{
    namespace Common
    {
        class ReportBase {}
    }

    namespace ManagementReporting
    {
        class SalesReport : Common.ReportBase {}
    }
}
</code></pre>
<h5>مخفی شدن نام‌ها (Name Hiding) 🕵️‍♂️</h5>
<p>اگر نام یک نوع در هر دو فضای نام درونی و بیرونی ظاهر شود، نام درونی برنده است و استفاده می‌شود.
برای ارجاع به نوع در فضای نام بیرونی، باید نام کامل آن را مشخص کنید:</p>
<pre><code class="language-c#">namespace Outer
{
    class Foo { }

    namespace Inner
    {
        class Foo { }

        class Test
        {
            Foo f1;         // = Outer.Inner.Foo
            Outer.Foo f2;   // = Outer.Foo
        }
    }
}
</code></pre>
<p>تمام نام‌های انواع در زمان کامپایل به نام کامل (fully qualified name) تبدیل می‌شوند.
کد Intermediate Language (IL) هیچ نام ناکامل یا نیمه‌کامل ندارد و همه چیز به صورت کامل مشخص است. ⚡</p>
<h4>تکرار فضای نام‌ها (Repeated Namespaces) 🔁</h4>
<p>می‌توانید یک اعلامیه‌ی فضای نام را تکرار کنید، تا زمانی که نام‌های انواع (types) داخل آن‌ها با هم تداخل نداشته باشند:</p>
<pre><code class="language-c#">namespace Outer.Middle.Inner
{
    class Class1 {}
}

namespace Outer.Middle.Inner
{
    class Class2 {}
}
</code></pre>
<p>حتی می‌توان مثال بالا را به دو فایل جداگانه تقسیم کرد، به طوری که هر کلاس بتواند در یک assembly متفاوت کامپایل شود.</p>
<p>فایل منبع 1:</p>
<pre><code class="language-c#">namespace Outer.Middle.Inner
{
    class Class1 {}
}
</code></pre>
<p>فایل منبع 2:</p>
<pre><code class="language-c#">namespace Outer.Middle.Inner
{
    class Class2 {}
}
</code></pre>
<h4>دستور using تو در تو (Nested Using Directives) 📦</h4>
<p>می‌توانید یک دستور using را درون یک فضای نام قرار دهید. این کار به شما اجازه می‌دهد تا دامنه‌ی استفاده از دستور using را محدود به همان فضای نام کنید.
در مثال زیر، Class1 در یک محدوده قابل مشاهده است ولی در محدوده‌ی دیگر نه:</p>
<pre><code class="language-c#">namespace N1
{
    class Class1 {}
}

namespace N2
{
    using N1;
    class Class2 : Class1 {}  // قابل مشاهده
}

namespace N2
{
    class Class3 : Class1 {}  // خطای زمان کامپایل
}
</code></pre>
<p>⚠️ نکته: اگر دستور using داخل یک فضای نام تعریف نشود، اعضای آن به همه‌ی فضای نام‌های بعدی در همان فایل قابل دسترسی خواهند بود، اما با تو در تو کردن آن، می‌توان کنترل دقیقی روی دامنه‌ی دید (scope) داشت.</p>
<h4>ایجاد نام مستعار برای انواع و فضای نام‌ها (Aliasing Types and Namespaces) 🎭</h4>
<p>گاهی اوقات وارد کردن یک فضای نام کامل می‌تواند باعث تداخل نام‌ها (type-name collision) شود.
به جای وارد کردن کل فضای نام، می‌توانید فقط انواع خاص مورد نیاز خود را وارد کرده و برای هر نوع یک نام مستعار (alias) تعریف کنید:</p>
<pre><code class="language-c#">using PropertyInfo2 = System.Reflection.PropertyInfo;

class Program
{
    PropertyInfo2 p;
}
</code></pre>
<p>همچنین می‌توان کل یک فضای نام را به یک نام مستعار تبدیل کرد:</p>
<pre><code class="language-c#">using R = System.Reflection;

class Program
{
    R.PropertyInfo p;
}
</code></pre>
<h5>نام مستعار برای هر نوع (C# 12) ✨</h5>
<p>از C# 12 به بعد، دستور using می‌تواند برای هر نوعی نام مستعار تعریف کند، حتی برای آرایه‌ها:</p>
<pre><code class="language-c#">using NumberList = double[];

NumberList numbers = { 2.5, 3.5 };
</code></pre>
<p>همچنین می‌توان tupleها را نیز نام مستعار داد که در بخش “Aliasing Tuples (C# 12)” در صفحه 225 توضیح داده شده است.</p>
<h4>ویژگی‌های پیشرفته فضای نام (Advanced Namespace Features) 🛠️</h4>
<h5>Extern</h5>
<p>نام‌های مستعار extern به برنامه اجازه می‌دهند تا به دو نوع با نام کامل یکسان ارجاع دهد (یعنی هم نام فضای نام و هم نام نوع یکسان باشد). این سناریو نادر است و تنها زمانی رخ می‌دهد که دو نوع از اسمبلی‌های مختلف آمده باشند.</p>
<p>مثال:</p>
<p>Library 1، کامپایل شده به Widgets1.dll:</p>
<pre><code class="language-c#">namespace Widgets
{
    public class Widget {}
}
</code></pre>
<p>Library 2، کامپایل شده به Widgets2.dll:</p>
<pre><code class="language-c#">namespace Widgets
{
    public class Widget {}
}
</code></pre>
<p>برنامه‌ای که به هر دو اسمبلی ارجاع دارد:</p>
<pre><code class="language-c#">using Widgets;

Widget w = new Widget();  // خطا: نام Widget مبهم است
</code></pre>
<p>برای حل این ابهام، ابتدا فایل پروژه (.csproj) را تغییر داده و برای هر ارجاع یک نام مستعار منحصر به فرد اختصاص می‌دهیم:</p>
<pre><code class="language-c#">&lt;ItemGroup&gt;
    &lt;Reference Include=&quot;Widgets1&quot;&gt;
        &lt;Aliases&gt;W1&lt;/Aliases&gt;
    &lt;/Reference&gt;
    &lt;Reference Include=&quot;Widgets2&quot;&gt;
        &lt;Aliases&gt;W2&lt;/Aliases&gt;
    &lt;/Reference&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>سپس از دستور extern alias استفاده می‌کنیم:</p>
<pre><code class="language-c#">extern alias W1;
extern alias W2;

W1.Widgets.Widget w1 = new W1.Widgets.Widget();
W2.Widgets.Widget w2 = new W2.Widgets.Widget();
</code></pre>
<h5>مشخص کردن نام فضاها با نام مستعار (Namespace Alias Qualifiers) 🏷️</h5>
<p>همانطور که قبلاً گفتیم، نام‌ها در فضای نام‌های درونی، نام‌های فضای نام بیرونی را پنهان می‌کنند.
با این حال، گاهی حتی استفاده از نام کامل نوع هم مشکل را حل نمی‌کند.</p>
<p>مثال:</p>
<pre><code class="language-c#">namespace N
{
    class A
    {
        static void Main() =&gt; new A.B();  // کدام B؟
        public class B {}                  // نوع تو در تو
    }
}

namespace A
{
    class B {}
}
</code></pre>
<p>در این مثال، کامپایلر همیشه اولویت بالاتر را به نوع موجود در فضای نام جاری می‌دهد (در اینجا B تو در تو).</p>
<p>برای رفع این ابهام، می‌توان نام فضای نام را با یک مرجع مشخص تعیین کرد:</p>
<ul>
<li>
<p>فضای نام global — ریشه همه فضاهای نام (با کلیدواژه‌ی global)</p>
</li>
<li>
<p>مجموعه‌ی نام‌های مستعار extern</p>
</li>
</ul>
<p>نماد :: برای تعیین نام مستعار فضای نام (namespace alias qualification) استفاده می‌شود.</p>
<p>مثال با فضای نام global:</p>
<pre><code class="language-c#">namespace N
{
    class A
    {
        static void Main()
        {
            System.Console.WriteLine(new A.B());        // B تو در تو
            System.Console.WriteLine(new global::A.B()); // B در فضای نام A
        }

        public class B {}
    }
}

namespace A
{
    class B {}
}
</code></pre>
<p>مثال با نام مستعار extern (از بخش Extern در صفحه 100):</p>
<pre><code class="language-c#">extern alias W1;
extern alias W2;

W1::Widgets.Widget w1 = new W1::Widgets.Widget();
W2::Widgets.Widget w2 = new W2::Widgets.Widget();
</code></pre>
<p>⚠️ استفاده از نام مستعار و :: کمک می‌کند ابهام بین انواع مشابه در فضاهای نام مختلف برطرف شود.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
