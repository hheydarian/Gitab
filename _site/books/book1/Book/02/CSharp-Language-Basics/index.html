<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>کتاب لایف</title>
  <link rel="stylesheet" href="/styles/main.css"/>
  <link rel="stylesheet" href="/icone/css/all.min.css">


</head>
<!-- Font Awesome JS -->
<script src="/icone/js/all.min.js" defer></script>


<body class="rtl-site">
  <header>
    <h2>کتاب لایف</h2>
  </header>

  <main class="markdown-body">
    <h2>📝مبانی زبان #C</h2>
<p>در این فصل، مبانی پایه‌ای زبان سی‌شارپ را معرفی می‌کنیم.
تقریباً تمامی لیست‌های کد ارائه‌شده در این کتاب، به صورت نمونه‌های تعاملی در <strong>LINQPad</strong> قابل دسترسی هستند. کار کردن با این نمونه‌ها در کنار مطالعهٔ کتاب، روند یادگیری را تسریع می‌کند، چرا که می‌توانید کدها را ویرایش کرده و بلافاصله نتایج را مشاهده کنید بدون نیاز به تنظیم پروژه‌ها یا Solutionها در ویژوال استودیو.</p>
<p>برای دانلود نمونه‌ها، در <strong>LINQPad</strong> روی تب Samples کلیک کنید، سپس گزینهٔ &quot;<code>Download more samples</code>&quot; را انتخاب نمایید. <strong>LINQPad</strong> رایگان است — برای دریافت به آدرس زیر مراجعه کنید:
<strong><a href="http://www.linqpad.net">http://www.linqpad.net</a></strong></p>
<h2>اولین برنامه سی‌شارپ</h2>
<p>برنامه زیر عدد ۱۲ را در ۳۰ ضرب کرده و نتیجه (۳۶۰) را روی صفحه نمایش می‌دهد. علامت <code>//</code> نشان‌دهنده توضیحات (کامنت) است:</p>
<pre><code class="language-C#">int x = 12 * 30;                  // عبارت ۱  
System.Console.WriteLine(x);      // عبارت ۲
</code></pre>
<p>برنامه ما از دو عبارت تشکیل شده است. عبارات در سی‌شارپ به ترتیب اجرا شده و با سمیکولن (<code>;</code>) پایان می‌یابند.</p>
<p>عبارت اول حاصل ضرب 12 * 30 را محاسبه کرده و نتیجه را در متغیری به نام x از نوع <code>int</code> (عدد صحیح ۳۲ بیتی) ذخیره می‌کند.</p>
<p>عبارت دوم متد <code>WriteLine</code> را از کلاس <code>Console</code> (تعریف‌شده در فضای نام <code>System</code>) فراخوانی می‌کند که مقدار x را در پنجره خروجی نمایش می‌دهد.</p>
<p>توضیح مفاهیم کلیدی
متد (Method): یک تابع که وظیفه خاصی را انجام می‌دهد (مثل WriteLine).</p>
<p>کلاس (Class): بلوک سازنده شیءگرایی که شامل متدها و داده‌هاست (مثل Console).</p>
<p>فضای نام (<strong>Namespace</strong>): راهی برای سازماندهی انواع (<code>Types</code>) در سطوح بالاتر. بسیاری از کلاس‌های پرکاربرد (مثل <code>Console</code>) در فضای نام <code>System</code> قرار دارند.
مثال:</p>
<pre><code class="language-C#">System.Text برای کار با متن.

System.IO برای عملیات ورودی/خروجی.
</code></pre>
<p>بهینه‌سازی کد با <strong>using</strong>
برای جلوگیری از تکرار <code>System.Console</code> می‌توان از دستور <code>using</code> استفاده کرد:</p>
<pre><code class="language-C#">using System;  // وارد کردن فضای نام System  
Console.WriteLine(x);  // دیگر نیازی به نوشتن System. نیست  
</code></pre>
<p>استفاده مجدد از کد با متدها
می‌توان با تعریف متدهای سطح بالا (مثل تبدیل فوت به اینچ) کد را بهینه‌تر کرد:</p>
<pre><code class="language-C#">Console.WriteLine(FeetToInches(30));  // خروجی: 360  
Console.WriteLine(FeetToInches(100)); // خروجی: 1200  

int FeetToInches(int feet)  
{  
    int inches = feet * 12;  
    return inches;  
}  
</code></pre>
<p>بلوک عبارت: مجموعه‌ای از دستورات داخل آکولاد {}.</p>
<p>پارامتر ورودی و خروجی: متد FeetToInches یک پارامتر (feet) و مقدار بازگشتی (inches) دارد.</p>
<p>متدهای بدون ورودی/خروجی
اگر متدی ورودی نداشته باشد، از پرانتز خالی استفاده می‌کنیم.</p>
<p>اگر خروجی نداشته باشد، از void استفاده می‌شود:</p>
<pre><code class="language-C#">SayHello();  

void SayHello()  
{  
    Console.WriteLine(&quot;Hello, world&quot;);  
}
</code></pre>
<p>انواع توابع در سی‌شارپ
متدها (مثل FeetToInches).</p>
<p>عملگرها (مثل * برای ضرب).</p>
<p>سایر موارد: سازنده‌ها (Constructors)، ویژگی‌ها (Properties)، رویدادها (Events)، ایندکسرها (Indexers) و فاینالایزرها (Finalizers).</p>
<h3>کامپایل</h3>
<p>کامپایلر سی‌شارپ کد منبع (مجموعه‌ای از فایل‌ها با پسوند .cs) را به یک اَسمبلی (assembly) کامپایل می‌کند. یک اَسمبلی، واحد بسته‌بندی و استقرار در .NET است. یک اَسمبلی می‌تواند یک برنامه یا یک کتابخانه باشد. یک برنامه کنسول یا ویندوز معمولی دارای یک نقطه ورود است، در حالی که یک کتابخانه اینگونه نیست. هدف یک کتابخانه این است که توسط یک برنامه یا توسط کتابخانه‌های دیگر فراخوانی (ارجاع) شود. خود .NET مجموعه‌ای از کتابخانه‌ها (و همچنین یک محیط زمان اجرا) است.</p>
<p>هر یک از برنامه‌های بخش قبلی مستقیماً با مجموعه‌ای از دستورات (به نام دستورات سطح بالا) آغاز شدند. وجود دستورات سطح بالا به طور ضمنی یک نقطه ورود برای یک برنامه کنسول یا ویندوز ایجاد می‌کند. (بدون دستورات سطح بالا، متد Main نقطه ورود یک برنامه را نشان می‌دهد—به &quot;انواع سفارشی&quot; در صفحه ۳۷ مراجعه کنید.)</p>
<p>برخلاف .NET Framework، اَسمبلی‌های .NET 8 هرگز پسوند .exe ندارند. فایل .exe که پس از ساخت یک برنامه .NET 8 می‌بینید، یک لودر بومی (native loader) مخصوص پلتفرم است که مسئول راه‌اندازی اسمبلی .dll برنامه شما می‌باشد.</p>
<p>.NET 8 همچنین به شما اجازه می‌دهد یک استقرار مستقل (self-contained deployment) ایجاد کنید که شامل لودر، اسمبلی‌های شما، و بخش‌های مورد نیاز از زمان اجرای .NET باشد—همه در یک فایل .exe واحد. .NET 8 همچنین امکان کامپایل پیش از موعد (AOT) را فراهم می‌کند، که در آن فایل اجرایی حاوی کد بومی از پیش کامپایل شده برای راه‌اندازی سریع‌تر و کاهش مصرف حافظه است.</p>
<p>ابزار dotnet (در ویندوز dotnet.exe) به شما کمک می‌کند کدهای منبع و باینری‌های .NET را از طریق خط فرمان مدیریت کنید. می‌توانید از آن برای ساخت و اجرای برنامه خود استفاده کنید، به عنوان جایگزینی برای استفاده از یک محیط توسعه یکپارچه (IDE) مانند ویژوال استودیو یا ویژوال استودیو کد.</p>
<p>می‌توانید ابزار dotnet را یا با نصب .NET 8 SDK یا با نصب ویژوال استودیو به دست آورید. مکان پیش‌فرض آن در ویندوز ‎%ProgramFiles%\dotnet و در اوبونتو لینوکس ‎/usr/bin/dotnet است.
برای کامپایل یک برنامه، ابزار dotnet به یک فایل پروژه و همچنین یک یا چند فایل سی‌شارپ نیاز دارد. دستور زیر یک پروژه کنسول جدید را راه‌اندازی می‌کند (ساختار پایه آن را ایجاد می‌کند):</p>
<pre><code class="language-c#">
dotnet new Console -n MyFirstProgram
</code></pre>
<p>این دستور یک زیرپوشه به نام MyFirstProgram ایجاد می‌کند که شامل یک فایل پروژه به نام MyFirstProgram.csproj و یک فایل سی‌شارپ به نام Program.cs است که عبارت &quot;Hello world.&quot; را چاپ می‌کند.</p>
<p>برای ساخت و اجرای برنامه خود، دستور زیر را از پوشه MyFirstProgram اجرا کنید:</p>
<pre><code class="language-c#">
dotnet run MyFirstProgram
</code></pre>
<p>یا، اگر فقط می‌خواهید بدون اجرا بسازید:</p>
<pre><code class="language-c#">
dotnet build MyFirstProgram.csproj
</code></pre>
<p>خروجی اسمبلی در یک زیردایرکتوری تحت bindebug نوشته خواهد شد. ما در فصل 17 به تفصیل درباره اسمبلی‌ها توضیح می‌دهیم.</p>
<h2>Syntax</h2>
<p>نحو سی‌شارپ از نحو زبان‌های C و C++ الهام گرفته شده است. در این بخش، ما عناصر نحو سی‌شارپ را با استفاده از برنامه زیر توضیح می‌دهیم:</p>
<pre><code class="language-C#">
using System;
int x = 12 * 30;
Console.WriteLine (x);
</code></pre>
<h3>شناسه‌ها و کلمات کلیدی</h3>
<p>شناسه‌ها (Identifiers) نام‌هایی هستند که برنامه‌نویسان برای کلاس‌ها، متدها، متغیرها و غیره انتخاب می‌کنند. در برنامه مثال ما، شناسه‌ها به ترتیب ظاهر شدنشان عبارتند از:</p>
<pre><code class="language-System"></code></pre>
<p>یک شناسه باید یک کلمه کامل باشد که اساساً از کاراکترهای یونیکد تشکیل شده و با یک حرف یا زیرخط شروع می‌شود. شناسه‌های سی‌شارپ به حروف حساس هستند (case sensitive). طبق قرارداد، پارامترها، متغیرهای محلی، و فیلدهای خصوصی باید به کمل کِیس (camel case) باشند (مثلاً myVariable)، و سایر شناسه‌ها باید به پاسکال کِیس (Pascal case) باشند (مثلاً MyMethod).</p>
<p>کلمات کلیدی (Keywords) نام‌هایی هستند که برای کامپایلر معنای خاصی دارند. در برنامه مثال ما دو کلمه کلیدی وجود دارد: using و int.</p>
<p>بیشتر کلمات کلیدی رزرو شده هستند، به این معنی که نمی‌توانید از آن‌ها به عنوان شناسه استفاده کنید. در اینجا لیست کامل کلمات کلیدی رزرو شده سی‌شارپ آمده است:</p>
<pre><code class="language-abstract">as          double      public        sealed
base        else        readonly      short
bool        enum        record        sizeof
break       event       ref           stackalloc
byte        explicit    return        static
case        extern      float         string
catch       false       for           struct
char        finally     foreach       switch
checked     fixed       goto          this
class       if          throw         true
const       implicit    try           typeof
continue    in          uint          ulong
decimal     int         unchecked     unsafe
default     interface   ushort        using
delegate    internal    virtual       void
            is          volatile      while
            lock
            long
            namespace
            new
            null
            object
            operator
            out
            override
            params
            private
</code></pre>
<p>اگر واقعاً می‌خواهید از شناسه‌ای استفاده کنید که با یک کلمه کلیدی رزرو شده تداخل دارد، می‌توانید با استفاده از پیشوند @ این کار را انجام دهید. برای مثال:</p>
<pre><code class="language-C#">
int using = 123;      // غیرقانونی
int @using = 123;     // قانونی
</code></pre>
<p>نماد @ بخشی از خود شناسه را تشکیل نمی‌دهد. بنابراین، @myVariable همان myVariable است.</p>
<h3>کلمات کلیدی متنی</h3>
<p>برخی از کلمات کلیدی متنی (contextual) هستند، به این معنی که می‌توانید از آن‌ها به عنوان شناسه نیز استفاده کنید—بدون نماد @:</p>
<pre><code class="language-add">alias       dynamic     group         nuint       required    with
and         equals      init          on          select      when
ascending   file        into          or          set         where
async       from        join          orderby     unmanaged   yield
await       get         let           partial     value
by          managed     nameof
</code></pre>
<p>با کلمات کلیدی متنی، ابهام نمی‌تواند در متنی که در آن استفاده می‌شوند، ایجاد شود.</p>
<h3>ثابت‌ها، نشانه‌گذارها و عملگرها</h3>
<p>ثابت‌ها (Literals) قطعات داده اولیه‌ای هستند که به صورت لغوی در برنامه جاسازی شده‌اند. ثابت‌هایی که در برنامه مثال ما استفاده کردیم ۱۲ و ۳۰ هستند.</p>
<p>نشانه‌گذارها (Punctuators) به جداسازی ساختار برنامه کمک می‌کنند. یک مثال سمی‌کولن است که یک دستور را به پایان می‌رساند. دستورات می‌توانند چندین خط را در بر گیرند:</p>
<pre><code class="language-C#">
Console.WriteLine
  (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);
</code></pre>
<p>یک عملگر (Operator) عبارت‌ها را تبدیل و ترکیب می‌کند. بیشتر عملگرها در سی‌شارپ با یک نماد نشان داده می‌شوند، مانند عملگر ضرب، *. ما عملگرها را بعداً در این فصل با جزئیات بیشتری بحث خواهیم کرد. این‌ها عملگرهایی هستند که در برنامه مثال ما استفاده کردیم:</p>
<pre><code class="language-="></code></pre>
<p>یک نقطه، عضویت چیزی را (یا نقطه اعشار را در ثابت‌های عددی) نشان می‌دهد. پرانتزها هنگام اعلان یا فراخوانی یک متد استفاده می‌شوند؛ پرانتزهای خالی زمانی استفاده می‌شوند که متد هیچ آرگومانی را نمی‌پذیرد. (پرانتزها اهداف دیگری نیز دارند که بعداً در این فصل خواهید دید.) یک علامت مساوی عمل انتساب را انجام می‌دهد. (علامت مساوی دوبل، ==، مقایسه برابری را انجام می‌دهد، همانطور که بعداً خواهید دید.)</p>
<h3>Comments</h3>
<p>سی‌شارپ دو سبک مختلف مستندسازی کد منبع را ارائه می‌دهد: نظرات تک‌خطی و نظرات چندخطی. یک نظر تک‌خطی با دو اسلش رو به جلو آغاز می‌شود و تا پایان خط ادامه می‌یابد؛ برای مثال:</p>
<pre><code class="language-C#">
int x = 3;   // Comment about assigning 3 to x
</code></pre>
<p>یک نظر چندخطی با /<em>شروع شده و با</em>/ به پایان می‌رسد؛ برای مثال:</p>
<pre><code class="language-C#">
int x = 3;   /* This is a comment that
                spans two lines */
</code></pre>
<p>نظرات می‌توانند شامل تگ‌های مستندسازی XML باشند، که ما در &quot;مستندسازی XML&quot; در صفحه ۲۷۲ توضیح می‌دهیم.</p>
<h2>مبانی Types</h2>
<p>یک Type، طرح کلی (blueprint) برای یک value را تعریف می‌کند. در این مثال، ما از دو Literals از نوع int با مقادیر ۱۲ و ۳۰ استفاده می‌کنیم. همچنین یک variable از نوع int با نام x اعلان می‌کنیم:</p>
<pre><code class="language-C#">
int x = 12 * 30;
Console.WriteLine (x);
</code></pre>
<p>از آنجایی که بیشتر لیست‌های کد در این کتاب به Types از Namespace System نیاز دارند، از این پس &quot;using System&quot; را حذف خواهیم کرد، مگر اینکه مفهومی مرتبط با Namespaces را نشان دهیم.</p>
<p>یک variable نشان‌دهنده یک مکان ذخیره‌سازی است که می‌تواند در طول زمان حاوی مقادیر مختلفی باشد. در مقابل، یک Constant همیشه همان value را نمایش می‌دهد (در ادامه بیشتر در مورد آن صحبت خواهیم کرد):</p>
<pre><code class="language-C#">
const int y = 360;
</code></pre>
<p>تمام Values در C#، Instances یک Type هستند. معنای یک value و مجموعه مقادیر ممکن که یک variable می‌تواند داشته باشد، توسط Type آن تعیین می‌شود.</p>
<h3>نمونه‌های Predefined Type</h3>
<p>Predefined Types انواعی هستند که به طور خاص توسط Compiler پشتیبانی می‌شوند. Type int یک Predefined Type برای نمایش مجموعه اعداد صحیح است که در ۳۲ بیت حافظه جای می‌گیرند، از
2
31</p>
<ul>
<li>تا
2
31</li>
</ul>
<p>-1، و Type پیش‌فرض برای Literals عددی در این محدوده است. می‌توانید با Instances از Type int توابعی مانند عملیات حسابی را به صورت زیر انجام دهید:</p>
<pre><code class="language-C#">
int x = 12 * 30;
</code></pre>
<p>یک Predefined Type دیگر C#، string است. Type string یک توالی از Characterها را نمایش می‌دهد، مانند &quot;.NET&quot; یا <a href="http://oreilly.com">http://oreilly.com</a>. می‌توانید با فراخوانی توابع روی Strings با آن‌ها کار کنید، به صورت زیر:</p>
<pre><code class="language-C#">
string message = &quot;Hello world&quot;;
string upperMessage = message.ToUpper();
Console.WriteLine (upperMessage);               // HELLO WORLD
int x = 2022;
message = message + x.ToString();
Console.WriteLine (message);                    // Hello world2022
</code></pre>
<p>در این مثال، ما x.ToString() را فراخوانی کردیم تا یک نمایش رشته‌ای از عدد صحیح x به دست آوریم. می‌توانید ToString() را روی یک variable از تقریباً هر Type فراخوانی کنید.</p>
<p>Type Predefined bool دقیقاً دو value ممکن دارد: true و false. Type bool معمولاً با یک if statement برای شاخه‌بندی شرطی جریان اجرا استفاده می‌شود:</p>
<pre><code class="language-C#">
bool simpleVar = false;
if (simpleVar)
  Console.WriteLine (&quot;This will not print&quot;);
int x = 5000;
bool lessThanAMile = x &lt; 5280;
if (lessThanAMile)
  Console.WriteLine (&quot;This will print&quot;);
</code></pre>
<h3>Custom Types</h3>
<p>در C#، Predefined Types (که به آن‌ها Built-in Types نیز گفته می‌شود) با یک C# Keyword شناخته می‌شوند. Namespace System در .NET حاوی بسیاری از Types مهم است که توسط C# Predefined نیستند (مثلاً DateTime).</p>
<p>همانطور که می‌توانیم Methodهای خودمان را بنویسیم، می‌توانیم Types خودمان را نیز بنویسیم. در مثال بعدی، ما یک Custom Type به نام UnitConverter تعریف می‌کنیم—یک Class که به عنوان طرح کلی برای تبدیل واحدها عمل می‌کند:</p>
<pre><code class="language-C#">
UnitConverter feetToInchesConverter = new UnitConverter (12);
UnitConverter milesToFeetConverter  = new UnitConverter (5280);
Console.WriteLine (feetToInchesConverter.Convert(30));    // 360
Console.WriteLine (feetToInchesConverter.Convert(100));   // 1200
Console.WriteLine (feetToInchesConverter.Convert(
                   milesToFeetConverter.Convert(1)));     // 63360
public class UnitConverter
{
 int ratio;                              // Field
 public UnitConverter (int unitRatio)    // Constructor
 {
 ratio = unitRatio;
 } 
public int Convert (int unit)           // Method
{
 return unit * ratio;
 } 
}
</code></pre>
<p>در این مثال، تعریف Class ما در همان فایل دستورات سطح بالای ما ظاهر می‌شود. این قانونی است—تا زمانی که دستورات سطح بالا ابتدا ظاهر شوند—و هنگام نوشتن برنامه‌های آزمایشی کوچک قابل قبول است. در برنامه‌های بزرگ‌تر، رویکرد استاندارد این است که تعریف Class را در یک فایل جداگانه مانند UnitConverter.cs قرار دهیم.</p>
<h3>اعضای یک نوع (Members of a type)</h3>
<p>یک نوع (Type) شامل اعضای داده‌ای (data members) و اعضای تابعی (function members) است.
عضو داده‌ای کلاس UnitConverter فیلدی به نام ratio است.
اعضای تابعی آن نیز شامل متد Convert و سازنده‌ی (constructor) کلاس UnitConverter می‌باشند.</p>
<h3>تقارن بین نوع‌های از پیش تعریف‌شده و نوع‌های سفارشی</h3>
<p>(Symmetry of predefined types and custom types)</p>
<p>یکی از جنبه‌های زیبای #C این است که بین نوع‌های از پیش تعریف‌شده (مثل int) و نوع‌هایی که خودمان تعریف می‌کنیم (custom types) تفاوت چندانی وجود ندارد.</p>
<p>برای مثال، نوع int به عنوان یک الگو برای عددهای صحیح عمل می‌کند.
این نوع داده ذخیره می‌کند — یعنی ۳۲ بیت اطلاعات — و اعضای تابعی دارد که از این داده استفاده می‌کنند، مانند متد ToString.</p>
<p>به‌طور مشابه، نوع سفارشی UnitConverter که خودمان تعریف کردیم، الگوی تبدیل واحد است.
این نوع هم داده‌ای نگه می‌دارد — نسبت یا همان ratio — و اعضای تابعی‌ای دارد که از این داده استفاده می‌کنند.</p>
<h3>سازنده‌ها و ایجاد نمونه (Constructors and instantiation)</h3>
<p>داده‌ها از طریق ایجاد نمونه‌ای از یک نوع (instantiating a type) ساخته می‌شوند.</p>
<p>نوع‌های از پیش تعریف‌شده را می‌توان تنها با استفاده از لیترال‌ها (literals) ایجاد کرد؛ مانند 12 یا &quot;Hello world&quot;.</p>
<p>اما برای ایجاد نمونه‌ای از یک نوع سفارشی، باید از عملگر new استفاده کنیم.
مثلاً این دستور یک نمونه از کلاس UnitConverter ایجاد می‌کند:</p>
<pre><code class="language-c#">UnitConverter feetToInchesConverter = new UnitConverter(12);
</code></pre>
<p>بلافاصله بعد از اینکه new یک شیء را ایجاد کرد، سازنده‌ی آن شیء فراخوانی می‌شود تا مقداردهی اولیه انجام شود.</p>
<p>سازنده‌ها مشابه متدها تعریف می‌شوند، با این تفاوت که نام متد همان نام کلاس است و نوع بازگشتی (return type) ندارد:</p>
<pre><code class="language-c#">public UnitConverter(int unitRatio) {
    ratio = unitRatio;
}
</code></pre>
<h3>اعضای نمونه‌ای در برابر اعضای ایستا</h3>
<p>(Instance versus static members)</p>
<p>اعضای داده‌ای و تابعی که روی یک نمونه از نوع عمل می‌کنند، اعضای نمونه‌ای (instance members) نامیده می‌شوند.</p>
<p>برای مثال، متد Convert در کلاس UnitConverter و متد ToString در int اعضای نمونه‌ای هستند.
به‌طور پیش‌فرض، تمام اعضا، نمونه‌ای هستند.</p>
<p>اما اگر عضوهایی وجود داشته باشند که مستقیماً به نمونه‌ای نیاز نداشته باشند، می‌توان آن‌ها را به عنوان static (ایستا) علامت‌گذاری کرد.</p>
<p>برای استفاده از عضو ایستا از بیرون، باید نام نوع را مشخص کنیم نه نام نمونه.</p>
<p>مثال: متد WriteLine در کلاس Console یک متد ایستا است، بنابراین آن را این‌گونه صدا می‌زنیم:</p>
<pre><code class="language-c#">Console.WriteLine();
</code></pre>
<p>نه به صورت:</p>
<pre><code class="language-c#">new Console().WriteLine(); // نادرست
</code></pre>
<p>در واقع، کلاس Console به‌طور کامل به‌صورت static تعریف شده است.
یعنی تمام اعضای آن ایستا هستند و شما هرگز نمی‌توانید یک شیء از Console بسازید.</p>
<p>مثال از تفاوت عضو نمونه‌ای و ایستا:
در کد زیر، فیلد Name مربوط به نمونه خاصی از پاندا است،
در حالی که فیلد Population مربوط به تمام پاندای ساخته‌شده است:</p>
<pre><code class="language-c#">Panda p1 = new Panda(&quot;Pan Dee&quot;);
Panda p2 = new Panda(&quot;Pan Dah&quot;);

Console.WriteLine(p1.Name);           // Pan Dee
Console.WriteLine(p2.Name);           // Pan Dah
Console.WriteLine(Panda.Population);  // 2
</code></pre>
<p>کلاس Panda به صورت زیر تعریف شده:</p>
<pre><code class="language-c#">public class Panda
{
    public string Name;             // فیلد نمونه‌ای
    public static int Population;   // فیلد ایستا (مشترک بین همه)

    public Panda(string n)          // سازنده
    {
        Name = n;
        Population = Population + 1;
    }
}
</code></pre>
<p>اگر سعی کنیم p1.Population یا Panda.Name را فراخوانی کنیم، خطای زمان کامپایل خواهیم گرفت،
چون هر کدام فقط به شیوه خاص خود قابل دسترسی هستند.</p>
<h3>کلیدواژه‌ی public</h3>
<p>کلیدواژه‌ی public اعضا را برای سایر کلاس‌ها قابل مشاهده و دسترسی می‌کند.</p>
<p>اگر در کلاس Panda، فیلد Name را به صورت public تعریف نکنیم، به صورت پیش‌فرض private خواهد بود
و از بیرون کلاس قابل دسترسی نخواهد بود.</p>
<p>استفاده از public یعنی:</p>
<p>«من می‌خوام این عضو برای سایر کلاس‌ها قابل دیدن و استفاده باشه؛ باقی چیزها جزئیات داخلی خودمن.»</p>
<p>در مفاهیم شی‌ء‌گرایی (OOP) می‌گوییم اعضای public، اعضای private را کپسوله‌سازی (encapsulate) می‌کنند.</p>
<h3>تعریف فضای نام (Defining namespaces)</h3>
<p>در برنامه‌های بزرگ، منطقیه که کلاس‌ها رو داخل namespace‌های مشخص قرار بدیم.</p>
<p>مثال:</p>
<pre><code class="language-c#">using System;
using Animals;

Panda p = new Panda(&quot;Pan Dee&quot;);
Console.WriteLine(p.Name);

namespace Animals
{
    public class Panda
    {
        ...
    }
}
</code></pre>
<p>در اینجا، ما فضای نام Animals رو وارد کردیم، تا نیازی به استفاده کامل از اسم نباشه.</p>
<p>اگه اون using رو نمی‌نوشتیم، باید این‌طور می‌نوشتیم:</p>
<pre><code class="language-c#">Animals.Panda p = new Animals.Panda(&quot;Pan Dee&quot;);
</code></pre>
<p>در ادامه‌ی فصل، بحث فضای نام به‌صورت کامل در صفحه ۹۵ بررسی می‌شه.</p>
<h3>تعریف متد Main</h3>
<p>(Defining a Main method)</p>
<p>تا اینجای کار، تمام مثال‌های ما از دستورات سطح بالا (top-level statements) استفاده می‌کردند —
ویژگی‌ای که در C# 9 معرفی شد.</p>
<p>اما بدون استفاده از دستورات سطح بالا، ساختار یک برنامه ساده کنسولی یا ویندوزی به این صورت خواهد بود:</p>
<pre><code class="language-c#">using System;

class Program
{
    static void Main()   // نقطه ورود برنامه
    {
        int x = 12 * 30;
        Console.WriteLine(x);
    }
}
</code></pre>
<p>در صورت نبود دستورات سطح بالا، کامپایلر #C به دنبال یک متد ایستا به نام Main می‌گردد
که نقش نقطه‌ی ورود (entry point) برنامه را ایفا می‌کند.</p>
<p>این متد Main می‌تواند در هر کلاسی تعریف شود، اما فقط یک Main در برنامه مجاز است.</p>
<p>برگشت مقدار از Main (اختیاری)
متد Main می‌تواند به‌جای void، یک عدد صحیح (int) برگرداند.
این عدد می‌تواند به محیط اجرایی برگردانده شود تا وضعیت اجرای برنامه مشخص شود:</p>
<p>اگر مقدار بازگشتی 0 باشد، یعنی اجرا موفق بوده؛</p>
<p>اگر مقدار بازگشتی غیراز صفر باشد، معمولاً نشان‌دهنده‌ی یک خطا است.</p>
<p>دریافت آرگومان‌های خط فرمان (Command Line Arguments)
متد Main می‌تواند آرایه‌ای از رشته‌ها (string[]) به عنوان ورودی بگیرد.
این آرایه، شامل آرگومان‌هایی است که هنگام اجرای فایل اجرایی به برنامه پاس داده شده‌اند.</p>
<p>مثال:</p>
<pre><code class="language-c#">static int Main(string[] args)
{
    // استفاده از args[0] و غیره
}
</code></pre>
<h4>توضیحی درباره‌ی آرایه‌ها</h4>
<p>یک آرایه (Array) مثل string[] نشان‌دهنده‌ی تعدادی مقدار از یک نوع خاص است.
برای تعریف آرایه، از علامت براکت [] بعد از نوع داده استفاده می‌کنیم.</p>
<p>آرایه‌ها به طور کامل در بخش &quot;آرایه‌ها&quot; در صفحه ۶۱ توضیح داده می‌شوند.</p>
<h4>پشتیبانی از برنامه‌نویسی ناهمگام (Async Main)</h4>
<p>متد Main همچنین می‌تواند به صورت async (ناهمگام) تعریف شود
و مقدار بازگشتی آن می‌تواند از نوع Task یا Task&lt; int &gt; باشد.</p>
<p>این قابلیت، به برنامه‌نویسی ناهمگام (asynchronous programming) کمک می‌کند
و به‌طور کامل در فصل ۱۴ بررسی خواهد شد.</p>
<h3>دستورات سطح بالا (Top-Level Statements)</h3>
<p>دستورات سطح بالا (که در #C نسخه ۹ معرفی شدند) به شما اجازه می‌دهند تا از نوشتن متد Main به صورت ایستا و کلاس نگهدارنده‌ی آن صرف‌نظر کنید.
یک فایل که از دستورات سطح بالا استفاده می‌کند، شامل سه بخش به ترتیب زیر است:</p>
<p>(اختیاری) دستورات using</p>
<p>مجموعه‌ای از دستورات که می‌تواند شامل تعریف متدها نیز باشد (اختیاری)</p>
<p>(اختیاری) تعریف نوع‌ها و فضای نام‌ها</p>
<p>مثال:</p>
<pre><code class="language-c#">using System;                           // بخش ۱
Console.WriteLine(&quot;Hello, world&quot;);      // بخش ۲
void SomeMethod1() { ... }              // بخش ۲
Console.WriteLine(&quot;Hello again!&quot;);      // بخش ۲
void SomeMethod2() { ... }              // بخش ۲
class SomeClass { ... }                 // بخش ۳
namespace SomeNamespace { ... }         // بخش ۳
</code></pre>
<p>از آنجا که CLR (Common Language Runtime) به‌طور صریح از دستورات سطح بالا پشتیبانی نمی‌کند،
کامپایلر کد شما را به چیزی مانند زیر ترجمه می‌کند:</p>
<pre><code class="language-c#">using System;                           // بخش ۱

static class Program$   // نام ویژه‌ای که توسط کامپایلر تولید شده
{
    static void Main$ (string[] args)   // نام تولیدشده توسط کامپایلر
    {
        Console.WriteLine(&quot;Hello, world&quot;);     // بخش ۲
        void SomeMethod1() { ... }             // بخش ۲
        Console.WriteLine(&quot;Hello again!&quot;);     // بخش ۲
        void SomeMethod2() { ... }             // بخش ۲
    }
}

class SomeClass { ... }                 // بخش ۳
namespace SomeNamespace { ... }         // بخش ۳
</code></pre>
<p>توجه کنید که تمام محتوای بخش ۲ درون متد Main قرار می‌گیرد.
این یعنی SomeMethod1 و SomeMethod2 به‌عنوان متدهای محلی (local methods) عمل می‌کنند.</p>
<p>ما در بخش «متدهای محلی» در صفحه ۱۰۶ به‌طور کامل در مورد این موضوع صحبت خواهیم کرد.
مهم‌ترین نکته این است که متدهای محلی (مگر اینکه به صورت static تعریف شده باشند)
می‌توانند به متغیرهایی که درون متد احاطه‌کننده تعریف شده‌اند، دسترسی داشته باشند:</p>
<pre><code class="language-c#">int x = 3;
LocalMethod();
void LocalMethod() { Console.WriteLine(x); }   // می‌توانیم به x دسترسی داشته باشیم
</code></pre>
<p>یک نتیجه دیگر این است که متدهای سطح بالا قابل دسترسی از سایر کلاس‌ها یا نوع‌ها نیستند.</p>
<p>دستورات سطح بالا می‌توانند به‌صورت اختیاری یک مقدار عدد صحیح (int) به فراخواننده بازگردانند
و به یک متغیر خاص از نوع string[] به نام args دسترسی داشته باشند،
که معادل آرگومان‌های خط فرمانی است که توسط فراخواننده به برنامه داده شده‌اند.</p>
<p>از آنجا که فقط یک نقطه ورود برای برنامه می‌تواند وجود داشته باشد،
در یک پروژه #C حداکثر فقط یک فایل می‌تواند شامل دستورات سطح بالا باشد.</p>
<h3>نوع‌ها و تبدیل‌ها</h3>
<p>(Types and Conversions)</p>
<p>زبان C# می‌تواند بین نمونه‌هایی از نوع‌های سازگار، تبدیل انجام دهد.
هر تبدیل، همیشه یک مقدار جدید از روی یک مقدار موجود می‌سازد.</p>
<p>تبدیل‌ها می‌توانند ضمنی (implicit) یا صریح (explicit) باشند:</p>
<p>تبدیل ضمنی به صورت خودکار انجام می‌شود.</p>
<p>تبدیل صریح نیاز به عملگر تبدیل (cast) دارد.</p>
<p>در مثال زیر، ما به‌طور ضمنی یک int را به long (که دو برابر ظرفیت بیتی دارد) تبدیل می‌کنیم،
و سپس به‌طور صریح یک int را به short (که نصف ظرفیت بیتی دارد) تبدیل می‌کنیم:</p>
<pre><code class="language-c#">int x = 12345;       // int یک عدد صحیح ۳۲ بیتی است
long y = x;          // تبدیل ضمنی به عدد صحیح ۶۴ بیتی
short z = (short)x;  // تبدیل صریح به عدد صحیح ۱۶ بیتی
</code></pre>
<p>تبدیل‌های ضمنی در صورتی مجاز هستند که هر دو شرط زیر برقرار باشد:</p>
<p>کامپایلر می‌تواند تضمین کند که تبدیل همیشه موفق خواهد بود.</p>
<p>هیچ اطلاعاتی در طول تبدیل از دست نمی‌رود.¹</p>
<p>در مقابل، تبدیل‌های صریح زمانی مورد نیاز هستند که یکی از شرایط زیر وجود داشته باشد:</p>
<p>کامپایلر نمی‌تواند تضمین کند که تبدیل همیشه موفق خواهد بود.</p>
<p>ممکن است اطلاعاتی در طول تبدیل از دست برود.</p>
<p>اگر کامپایلر تشخیص دهد که یک تبدیل همیشه شکست می‌خورد،
هر دو نوع تبدیل (ضمنی و صریح) ممنوع خواهند بود.</p>
<p>تبدیل‌هایی که شامل نوع‌های generic هستند هم ممکن است تحت شرایط خاصی شکست بخورند
— به بخش «Type Parameters and Conversions» در صفحه ۱۶۶ مراجعه کنید.</p>
<p>تبدیل‌های عددی که در بالا دیدیم، به‌صورت ذاتی در زبان C# تعریف شده‌اند.
C# همچنین از موارد زیر پشتیبانی می‌کند:</p>
<p>تبدیل ارجاعی (reference conversions)</p>
<p>تبدیل باکسینگ (boxing conversions)
(در فصل ۳ توضیح داده می‌شوند)</p>
<p>و همچنین تبدیل‌های سفارشی (custom conversions)
(در بخش «Operator Overloading» در صفحه ۲۵۶ توضیح داده شده)</p>
<p>کامپایلر، قوانین بالا را برای تبدیل‌های سفارشی تضمین نمی‌کند؛
پس ممکن است نوع‌هایی که بد طراحی شده‌اند، رفتار غیرمنتظره‌ای داشته باشند.</p>
<p>¹ یک نکته‌ی جزئی: مقادیر long بسیار بزرگ، هنگام تبدیل به double، ممکن است کمی دقت (precision) را از دست بدهند.</p>
<h3>نوع‌های مقداری در برابر نوع‌های ارجاعی</h3>
<p>(Value Types Versus Reference Types)</p>
<p>تمام نوع‌های C# در یکی از دسته‌های زیر قرار می‌گیرند:</p>
<p>نوع‌های مقداری (Value types)</p>
<p>نوع‌های ارجاعی (Reference types)</p>
<p>پارامترهای نوعی (Generic type parameters)</p>
<p>نوع‌های اشاره‌گر (Pointer types)</p>
<p>در این بخش، ما درباره‌ی نوع‌های مقداری و نوع‌های ارجاعی صحبت می‌کنیم.</p>
<p>پارامترهای نوعی در بخش «Generics» در صفحه ۱۵۹
و نوع‌های اشاره‌گر در بخش «Unsafe Code and Pointers» در صفحه ۲۶۳ پوشش داده می‌شوند.</p>
<p>نوع‌های مقداری شامل بیشتر نوع‌های داخلی هستند؛
به‌ویژه:</p>
<p>تمام نوع‌های عددی</p>
<p>نوع char</p>
<p>نوع bool</p>
<p>و همچنین نوع‌های سفارشی مانند struct و enum</p>
<p>نوع‌های ارجاعی شامل موارد زیر می‌شوند:</p>
<p>تمام کلاس‌ها (class)</p>
<p>آرایه‌ها (array)</p>
<p>نماینده‌ها (delegate)</p>
<p>رابط‌ها (interface)
(شامل نوع string که به صورت داخلی تعریف شده نیز می‌شود)</p>
<p>تفاوت اصلی بین نوع‌های مقداری و ارجاعی، نحوه‌ی مدیریت آن‌ها در حافظه است.</p>
<h3>نوع‌های مقداری (Value Types)</h3>
<p>محتوای یک متغیر یا ثابت از نوع مقداری، صرفاً یک مقدار است.
برای مثال، محتوای نوع int (که یکی از نوع‌های داخلی مقداری است)،
فقط شامل ۳۲ بیت داده است.</p>
<p>می‌توانی یک نوع مقداری سفارشی را با استفاده از کلیدواژه‌ی struct تعریف کنی
(به شکل زیر که در شکل ۲-۱ نمایش داده شده):</p>
<pre><code class="language-c#">public struct Point { public int X; public int Y; }
</code></pre>
<p>یا به‌شکل مختصرتر:</p>
<pre><code class="language-c#">public struct Point { public int X, Y; }
</code></pre>
<p>📌 شکل ۲-۱. نمونه‌ای از یک نوع مقداری در حافظه</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>وقتی یک نمونه از نوع مقداری را به متغیر دیگری اختصاص می‌دهی (<code>assign</code>)،
تمام مقدار آن کپی می‌شود. برای مثال:</p>
<pre><code class="language-C#">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // انتساب باعث کپی کامل می‌شود

Console.WriteLine(p1.X);   // 7
Console.WriteLine(p2.X);   // 7

p1.X = 9;                  // تغییر مقدار p1.X

Console.WriteLine(p1.X);   // 9
Console.WriteLine(p2.X);   // 7
</code></pre>
<p>📌 شکل ۲-۲ نشان می‌دهد که <code>p1</code> و <code>p2</code> فضای ذخیره‌سازی مستقلی دارند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 یعنی هر کدام در حافظه جداگانه نگهداری می‌شوند و تغییر یکی روی دیگری اثری ندارد.</p>
<h3>نوع‌های ارجاعی (Reference Types)</h3>
<p>یک نوع ارجاعی از نوع‌های مقداری پیچیده‌تر است و از دو بخش تشکیل شده:</p>
<p>یک شیء (<code>object</code>)</p>
<p>و یک ارجاع (<code>reference</code>) به آن شیء</p>
<p>محتوای یک متغیر یا ثابت از نوع ارجاعی، ارجاعی به یک شیء است که آن مقدار را در خود دارد.</p>
<p>در اینجا، نوع <code>Point</code> را که قبلاً به‌صورت <code>struct</code> داشتیم، این بار به‌صورت <code>class</code> بازنویسی می‌کنیم:
(در شکل ۲-۳ نشان داده شده)</p>
<pre><code class="language-c#">public class Point { public int X, Y; }
</code></pre>
<p>📌 شکل ۲-۳. نمونه‌ای از نوع ارجاعی در حافظه</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-3.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>زمانی که یک متغیر از نوع ارجاعی را به متغیر دیگری اختصاص می‌دهیم،
فقط ارجاع کپی می‌شود، نه خود شیء.</p>
<p>این موضوع باعث می‌شود که چندین متغیر به یک شیء واحد اشاره کنند —
چیزی که در نوع‌های مقداری امکان‌پذیر نیست.</p>
<p>اگر همان مثال قبلی را با <code>Point</code> به‌صورت <code>class</code> اجرا کنیم، عملیات روی <code>p1</code> روی <code>p2</code> نیز اثر می‌گذارد:</p>
<pre><code class="language-c#">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // کپی شدن ارجاع (نه شیء)

Console.WriteLine(p1.X);   // 7
Console.WriteLine(p2.X);   // 7

p1.X = 9;                  // تغییر مقدار X از طریق p1

Console.WriteLine(p1.X);   // 9
Console.WriteLine(p2.X);   // 9
</code></pre>
<p>📌 شکل ۲-۴ نشان می‌دهد که <code>p1</code> و <code>p2</code> دو ارجاع هستند که به یک شیء مشترک اشاره می‌کنند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-4.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 در نتیجه تغییر یکی، روی دیگری هم تأثیر دارد.</p>
<h3>Null</h3>
<p>یک <code>Reference</code> را می‌توان با <code>Literal null</code> مقداردهی کرد، که نشان می‌دهد <code>Reference</code> به هیچ شیء(<code>Object</code>) اشاره نمی‌کند:</p>
<pre><code class="language-C#">
Point p = null;
Console.WriteLine (p == null);   // True
// The following line generates a runtime error
// (a NullReferenceException is thrown):
Console.WriteLine (p.X);
class Point {...}
</code></pre>
<p>در &quot;<strong>Nullable Reference Types</strong>&quot; در صفحه ۲۱۵، ما ویژگی‌ای از <strong>C#</strong> را شرح می‌دهیم که به کاهش خطاهای تصادفی <code>NullReferenceException</code> کمک می‌کند.</p>
<p>در مقابل، یک Value Type به طور معمول نمی‌تواند مقدار null داشته باشد:</p>
<pre><code class="language-C#">
Point p = null;  // Compile-time error
int x = null;    // Compile-time error
struct Point {...}
</code></pre>
<p>C# همچنین ساختاری به نام <code>Nullable Value Types</code> برای نمایش nullهای Value Type دارد. برای اطلاعات بیشتر، به &quot;<code>Nullable Value Types</code>&quot; در صفحه ۲۱۰ مراجعه کنید.</p>
<h3>Storage Overhead</h3>
<p><code>Instances</code> انواع <code>Value Type</code> دقیقاً حافظه مورد نیاز برای ذخیره <code>Fields</code> خود را اشغال می‌کنند. در این مثال، <code>Point،</code> ۸ بایت حافظه می‌گیرد:</p>
<pre><code class="language-C#">
struct Point
{
  int x;  // 4 bytes
  int y;  // 4 bytes
}
</code></pre>
<p>از نظر فنی، <strong>CLR Fields</strong> را در <code>Type</code> در آدرسی قرار می‌دهد که مضربی از اندازه <code>Fields</code> است (حداکثر ۸ بایت). بنابراین، مثال زیر در واقع ۱۶ بایت حافظه مصرف می‌کند (با ۷ بایت پس از Field اول &quot;تلف شده&quot;):</p>
<pre><code class="language-C#">
struct A { byte b; long l; }
</code></pre>
<p>می‌توانید این رفتار را با اعمال Attribute StructLayout نادیده بگیرید (به &quot;Mapping a Struct to Unmanaged Memory&quot; در صفحه ۹۹۷ مراجعه کنید).</p>
<p>Reference Types نیاز به تخصیص‌های جداگانه حافظه برای Reference و Object دارند. Object به اندازه Fields خود به علاوه سربار اداری اضافی، بایت مصرف می‌کند. سربار دقیقاً به طور ذاتی برای پیاده‌سازی .NET runtime خصوصی است، اما حداقل، این سربار ۸ بایت است، که برای ذخیره یک کلید به Type Object و همچنین اطلاعات موقت مانند وضعیت Lock آن برای Multithreading و یک پرچم برای نشان دادن اینکه آیا از حرکت توسط Garbage Collector ثابت شده است، استفاده می‌شود. هر Reference به یک Object به ۴ یا ۸ بایت اضافی نیاز دارد، بسته به اینکه .NET runtime روی پلتفرم ۳۲ یا ۶۴ بیتی در حال اجرا باشد.</p>
<h3>Predefined Type Taxonomy</h3>
<p>Predefined Types در C# به شرح زیر هستند:</p>
<ul>
<li>
<p>Value Types</p>
<ul>
<li>
<p>Numeric</p>
<p>Signed integer (sbyte, short, int, long)</p>
<p>Unsigned integer (byte, ushort, uint, ulong)</p>
<p>Real number (float, double, decimal)</p>
</li>
<li>
<p>Logical (bool)</p>
</li>
<li>
<p>Character (char)</p>
</li>
</ul>
</li>
<li>
<p>Reference Types</p>
<ul>
<li>
<p>String (string)</p>
</li>
<li>
<p>Object (object)</p>
</li>
</ul>
</li>
</ul>
<p>Predefined Types در C# در واقع Alias برای .NET Types در Namespace System هستند. تنها یک تفاوت Syntactic بین این دو دستور وجود دارد:</p>
<pre><code class="language-C#">
int i = 5;
System.Int32 i = 5;
</code></pre>
<p>مجموعه Predefined Value Types به استثنای decimal به عنوان Primitive Types در CLR شناخته می‌شوند. Primitive Types به این دلیل نام‌گذاری شده‌اند که مستقیماً از طریق Instructions در کد Compile شده پشتیبانی می‌شوند، و این معمولاً به پشتیبانی مستقیم در Processor زیربنایی ترجمه می‌شود؛ برای مثال:</p>
<pre><code class="language-C#">
                   // Underlying hexadecimal representation
int i = 7;         // 0x7
bool b = true;     // 0x1
char c = 'A';      // 0x41
float f = 0.5f;    // uses IEEE floating-point encoding
</code></pre>
<p>Types System.IntPtr و System.UIntPtr نیز Primitive هستند (به Chapter 24 مراجعه کنید).</p>
<p>Numeric Types</p>
<p>C# دارای Predefined Numeric Types است که در Table 2-1 نشان داده شده‌اند.</p>
<p>Table 2-1. Predefined numeric types in C#</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
از بین Integral Types، int و long، First-class Citizens محسوب می‌شوند و مورد توجه C# و Runtime هستند. سایر Integral Types معمولاً برای Interoperability یا زمانی که کارایی فضا (space efficiency) در اولویت است، استفاده می‌شوند. Native-sized Integer Types یعنی nint و nuint، بیشتر در کار با Pointers مفید هستند، بنابراین این‌ها را در یک Chapter بعدی توضیح خواهیم داد (به "Native-Sized Integers" در صفحه ۲۶۶ مراجعه کنید).
<p>از بین Real Number Types، float و double را Floating-Point Types2 می‌نامند و معمولاً برای محاسبات علمی و گرافیکی استفاده می‌شوند. Type decimal معمولاً برای محاسبات مالی به کار می‌رود، که در آن‌ها محاسبات با دقت Base-10 و دقت بالا مورد نیاز است.</p>
<p>.NET این لیست را با چندین Specialized Numeric Type تکمیل می‌کند، از جمله Int128 و UInt128 برای ۱۲۸-bit Signed و Unsigned Integers، BigInteger برای Integers با اندازه‌های دلخواه بزرگ، و Half برای ۱۶-bit Floating Point Numbers. Half عمدتاً برای Interoperability با Processors کارت گرافیک در نظر گرفته شده است و در بیشتر CPUs پشتیبانی Native ندارد، که float و double را به گزینه‌های بهتری برای استفاده عمومی تبدیل می‌کند.</p>
<h3>Numeric Literals</h3>
<p>Literals از نوع Integral می‌توانند از Decimal یا Hexadecimal Notation استفاده کنند؛ Hexadecimal با پیشوند 0x نشان داده می‌شود. برای مثال:</p>
<pre><code class="language-C#">
int x = 127;
long y = 0x7F;
</code></pre>
<p>می‌توانید یک Underscore را در هر کجای یک Numeric Literal قرار دهید تا خواناتر شود:</p>
<pre><code class="language-C#">
int million = 1_000_000;
</code></pre>
<p>می‌توانید اعداد را به صورت Binary با پیشوند 0b مشخص کنید:</p>
<pre><code class="language-C#">
var b = 0b1010_1011_1100_1101_1110_1111;
Real Literals می‌توانند از Decimal و/یا Exponential Notation استفاده کنند:
</code></pre>
<pre><code class="language-C#">
double d = 1.5;
double million = 1E06;
</code></pre>
<h3>Numeric Literal Type Inference</h3>
<p>به طور پیش‌فرض، Compiler یک Numeric Literal را به صورت double یا یک Integral Type استنباط می‌کند:</p>
<ul>
<li>
<p>اگر Literal شامل یک Decimal Point یا نماد Exponential (E) باشد، یک double است.</p>
</li>
<li>
<p>در غیر این صورت، Type Literal اولین Type در این لیست است که می‌تواند Value Literal را در خود جای دهد: int, uint, long, و ulong.</p>
</li>
</ul>
<p>برای مثال:</p>
<p>از نظر فنی، decimal نیز یک Floating-Point Type است، اگرچه در Specification زبان C# به این نام از آن یاد نمی‌شود.</p>
<pre><code class="language-C#">
Console.WriteLine (        1.0.GetType());  // Double  (double)
Console.WriteLine (       1E06.GetType());  // Double  (double)
Console.WriteLine (          1.GetType());  // Int32   (int)
Console.WriteLine ( 0xF0000000.GetType());  // UInt32  (uint)
Console.WriteLine (0x100000000.GetType());  // Int64   (long)
</code></pre>
<h3>پسوندهای Numeric</h3>
<p>Numeric Suffixes به طور صریح Type یک Literal را تعریف می‌کنند. Suffixes می‌توانند حروف کوچک یا بزرگ باشند، و به شرح زیر هستند:</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
پسوندهای U و L به ندرت ضروری هستند، زیرا Types uint، long و ulong تقریباً همیشه می‌توانند از int استنباط شوند یا به طور Implicit به آن تبدیل شوند:
<pre><code class="language-C#">
long i = 5;     // Implicit lossless conversion from int literal to long
</code></pre>
<p>پسوند D از نظر فنی اضافی است، زیرا تمام Literals دارای Decimal Point به صورت double استنباط می‌شوند. و شما همیشه می‌توانید یک Decimal Point به یک Numeric Literal اضافه کنید:</p>
<pre><code class="language-C#">
double x = 4.0;
</code></pre>
<p>پسوندهای F و M مفیدترین هستند و همیشه باید هنگام مشخص کردن Literals از نوع float یا decimal اعمال شوند. بدون پسوند F، خط زیر کامپایل نمی‌شود، زیرا 4.5 به عنوان Type double استنباط می‌شود، که هیچ Implicit Conversion به float ندارد:</p>
<pre><code class="language-C#">
float f = 4.5F;
</code></pre>
<p>همین اصل برای یک decimal Literal نیز صادق است:</p>
<pre><code class="language-C#">
decimal d = -1.23M;     // Will not compile without the M suffix.
</code></pre>
<p>ما Semantics مربوط به Numeric Conversions را با جزئیات در بخش بعدی شرح می‌دهیم.</p>
<h2>Numeric Conversions</h2>
<h3>تبدیل بین Integral Types</h3>
<p>Integral Type Conversions زمانی Implicit هستند که Type مقصد بتواند هر Value ممکن از Type منبع را نمایش دهد. در غیر این صورت، یک Explicit Conversion مورد نیاز است؛ برای مثال:</p>
<pre><code class="language-C#">
int x = 12345;       // int is a 32-bit integer
long y = x;          // Implicit conversion to 64-bit integral type
short z = (short)x;  // Explicit conversion to 16-bit integral type
</code></pre>
<h3>تبدیل بین Floating-Point Types</h3>
<p>یک float می‌تواند به طور Implicit به یک double تبدیل شود، با توجه به اینکه یک double می‌تواند هر Value ممکن از یک float را نمایش دهد. تبدیل معکوس باید Explicit باشد.</p>
<h3>تبدیل بین Floating-Point و Integral Types</h3>
<p>تمام Integral Types می‌توانند به طور Implicit به تمام Floating-Point Types تبدیل شوند:</p>
<pre><code class="language-C#">
int i = 1;
float f = i;
</code></pre>
<p>تبدیل معکوس باید Explicit باشد:</p>
<pre><code class="language-C#">int i2 = (int)f;
</code></pre>
<p>هنگامی که از یک Floating-Point Number به یک Integral Type Cast می‌کنید، هر بخش کسری Truncated می‌شود؛ هیچ Rounding انجام نمی‌شود. Static Class System.Convert متدهایی را فراهم می‌کند که هنگام تبدیل بین انواع Numeric مختلف Rounding را انجام می‌دهند (به Chapter 6 مراجعه کنید).</p>
<p>تبدیل Implicit یک Integral Type بزرگ به یک Floating-Point Type، Magnitude را حفظ می‌کند اما گاهی اوقات می‌تواند Precision را از دست بدهد. این به این دلیل است که Floating-Point Types همیشه Magnitude بیشتری نسبت به Integral Types دارند اما می‌توانند Precision کمتری داشته باشند. بازنویسی مثال ما با یک عدد بزرگ‌تر این را نشان می‌دهد:</p>
<pre><code class="language-C#">
int i1 = 100000001;
float f = i1;          // Magnitude preserved, precision lost
int i2 = (int)f;       // 100000000
</code></pre>
<h3>تبدیل‌های Decimal</h3>
<p>تمام Integral Types می‌توانند به طور Implicit به Type decimal تبدیل شوند، با توجه به اینکه یک decimal می‌تواند هر C# Integral-Type Value ممکن را نمایش دهد. تمام Numeric Conversions دیگر به و از یک Type decimal باید Explicit باشند، زیرا آن‌ها امکان خارج از محدوده بودن Value یا از دست رفتن Precision را معرفی می‌کنند.</p>
<h2>Arithmetic Operators</h2>
<p>Arithmetic Operators (+, -, *, /, %) برای تمام Numeric Types به جز Integral Types 8 و 16 بیتی تعریف شده‌اند:</p>
<ul>
<li>
<p>Addition</p>
</li>
<li>
<p>Subtraction</p>
</li>
<li>
<p>Multiplication</p>
</li>
</ul>
<p>/ Division</p>
<p>% Remainder after division</p>
<h2>Increment و Decrement Operators</h2>
<p>Increment و Decrement Operators (به ترتیب ++، --) Numeric Types را به اندازه ۱ واحد افزایش و کاهش می‌دهند. Operator می‌تواند هم بعد و هم قبل از Variable قرار گیرد، بسته به اینکه Value آن را قبل یا بعد از Increment/Decrement می‌خواهید؛ برای مثال:</p>
<pre><code class="language-C#">
int x = 0, y = 0;
Console.WriteLine (x++);   // Outputs 0; x is now 1
Console.WriteLine (++y);   // Outputs 1; y is now 1
</code></pre>
<h2>عملیات تخصصی بر روی Integral Types</h2>
<p>Integral Types عبارتند از int، uint، long، ulong، short، ushort، byte و sbyte.</p>
<h3>Division</h3>
<p>عملیات Division بر روی Integral Types همیشه Remainder را حذف می‌کنند (به سمت صفر Round می‌کنند). تقسیم بر یک Variable که Value آن صفر است، یک Runtime Error (DivideByZeroException) ایجاد می‌کند:</p>
<pre><code class="language-C#">
int a = 2 / 3;      // 0
int b = 0;
int c = 5 / b;      // throws DivideByZeroException
</code></pre>
<p>تقسیم بر Literal یا Constant 0 یک Compile-Time Error ایجاد می‌کند.</p>
<h3>Overflow</h3>
<p>در Runtime، عملیات Arithmetic بر روی Integral Types می‌توانند Overflow کنند. به طور پیش‌فرض، این اتفاق به طور Silent رخ می‌دهد—هیچ Exceptionی پرتاب نمی‌شود، و نتیجه رفتار &quot;wraparound&quot; را نشان می‌دهد، گویی که محاسبه بر روی یک Integer Type بزرگ‌تر انجام شده و Bitهای Significant اضافی دور ریخته شده‌اند. برای مثال، کاهش حداقل Value ممکن int منجر به حداکثر Value ممکن int می‌شود:</p>
<pre><code class="language-C#">
int a = int.MinValue;
a--;
Console.WriteLine (a == int.MaxValue); // True
</code></pre>
<h3>Overflow Check Operators</h3>
<p>Operator checked به Runtime دستور می‌دهد که به جای Overflow Silent، یک OverflowException ایجاد کند، زمانی که یک Integral-Type Expression یا Statement از محدودیت‌های Arithmetic آن Type فراتر رود. Operator checked بر Expressions با ++، --، +، - (Binary و Unary)، *، /، و Explicit Conversion Operators بین Integral Types تأثیر می‌گذارد. بررسی Overflow هزینه Performance کمی دارد.</p>
<p>Operator checked بر Types double و float (که به Values &quot;Infinite&quot; خاص Overflow می‌کنند، همانطور که به زودی خواهید دید) و بر Type decimal (که همیشه checked است) تأثیری ندارد.</p>
<p>می‌توانید checked را هم در اطراف یک Expression و هم در اطراف یک Statement Block استفاده کنید:</p>
<pre><code class="language-C#">
int a = 1000000;
int b = 1000000;
int c = checked (a * b);      // Checks just the expression.
checked                           // Checks all expressions
{                                      // in statement block
 ...                                
  c = a * b;
  ...
}
</code></pre>
<p>.
می‌توانید بررسی Arithmetic Overflow را به طور پیش‌فرض برای تمام Expressions در یک برنامه با انتخاب گزینه &quot;checked&quot; در سطح Project (در Visual Studio، به Advanced Build Settings بروید) فعال کنید. اگر سپس نیاز به غیرفعال کردن بررسی Overflow فقط برای Expressions یا Statements خاصی دارید، می‌توانید این کار را با Operator unchecked انجام دهید. برای مثال، کد زیر Exception پرتاب نخواهد کرد—حتی اگر گزینه &quot;checked&quot; Project انتخاب شده باشد:</p>
<pre><code class="language-C#">
int x = int.MaxValue;
int y = unchecked (x + 1);
unchecked { int z = x + 1; }
</code></pre>
<h3>بررسی Overflow برای Constant Expressions</h3>
<p>صرف‌نظر از تنظیمات &quot;checked&quot; در Project، Expressions که در Compile Time ارزیابی می‌شوند، همیشه Overflow-checked هستند—مگر اینکه از Operator unchecked استفاده کنید:</p>
<pre><code class="language-C#">
int x = int.MaxValue + 1;               // Compile-time error
int y = unchecked (int.MaxValue + 1);   // No errors
Bitwise Operators
</code></pre>
<h3>Bitwise Operators</h3>
<p>C# از Bitwise Operators زیر پشتیبانی می‌کند:</p>
<p><img src="../../../assets/image/02/Table-2-3.png" alt="Conventions-UsedThis-Book"></p>
<p>عملگر shift-right (&gt;&gt;) هنگام کار با signed integers، high-order bit را تکرار می‌کند، در حالی که عملگر unsigned shift-right (&gt;&gt;&gt;) این کار را نمی‌کند.</p>
<p>عملیات bitwise اضافی از طریق یک class به نام BitOperations در namespace System.Numerics در دسترس هستند (برای جزئیات بیشتر به &quot;BitOperations&quot; در صفحه ۳۴۰ مراجعه کنید).</p>
<h3>۸  و ۱۶-Bit Integral Types</h3>
<p>Integral Types هشت و شانزده بیتی عبارتند از byte, sbyte, short, و ushort. این types فاقد arithmetic operators خود هستند، بنابراین C# به صورت implicitly آن‌ها را در صورت نیاز به types بزرگتر تبدیل می‌کند. این می‌تواند هنگام تلاش برای انتساب نتیجه به یک integral type کوچک، منجر به compile-time error شود:</p>
<pre><code class="language-C#">
short x = 1, y = 1;
short z = x + y;          // Compile-time error
</code></pre>
<p>در این حالت، x و y به صورت implicitly به int تبدیل می‌شوند تا عملیات addition انجام شود. این بدان معناست که نتیجه نیز یک int است، که نمی‌تواند به صورت implicitly به short cast شود (زیرا می‌تواند باعث از دست رفتن data شود). برای اینکه این کد compile شود، باید یک explicit cast اضافه کنید:</p>
<pre><code class="language-C#">
short z = (short) (x + y);   // OK
</code></pre>
<h3>Special Float و Double Values</h3>
<p>برخلاف integral types، floating-point types دارای values هستند که برخی عملیات با آن‌ها به صورت ویژه رفتار می‌کنند. این special values عبارتند از NaN (Not a Number)، +∞، −∞ و −0. Classهای float و double دارای constants برای NaN، +∞ و −∞، و همچنین values دیگر (MaxValue, MinValue, و Epsilon) هستند؛ برای مثال:</p>
<pre><code class="language-C#">
Console.WriteLine (double.NegativeInfinity);   // -Infinity
</code></pre>
<p>Constants که special values را برای double و float نشان می‌دهند، به شرح زیر هستند:</p>
<p><img src="../../../assets/image/02/Table-2-4.png" alt="Conventions-UsedThis-Book"></p>
<p>تقسیم یک عدد ناصفر بر صفر، منجر به یک value بی‌نهایت می‌شود:</p>
<pre><code class="language-C#">
Console.WriteLine ( 1.0 /  0.0);                  //  Infinity
Console.WriteLine (−1.0 /  0.0);                  // -Infinity
Console.WriteLine ( 1.0 / −0.0);                  // -Infinity
Console.WriteLine (−1.0 / −0.0);                  //  Infinity
</code></pre>
<p>تقسیم صفر بر صفر، یا تفریق بی‌نهایت از بی‌نهایت، منجر به یک NaN می‌شود:</p>
<pre><code class="language-C#">
Console.WriteLine ( 0.0 /  0.0);                  //  NaN
Console.WriteLine ((1.0 /  0.0) − (1.0 / 0.0));   //  NaN
C# Language Basics
</code></pre>
<p>هنگام استفاده از ==، یک NaN value هرگز با value دیگری برابر نیست، حتی یک NaN value دیگر:</p>
<pre><code class="language-C#">
Console.WriteLine (0.0 / 0.0 == double.NaN);    // False
</code></pre>
<p>برای آزمایش اینکه آیا یک value برابر با NaN است، باید از متد float.IsNaN یا double.IsNaN استفاده کنید:</p>
<pre><code class="language-C#">
Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True
</code></pre>
<p>با این حال، هنگام استفاده از object.Equals، دو NaN value برابر هستند:</p>
<pre><code class="language-C#">
Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));   // True
</code></pre>
<p>NaNها گاهی اوقات برای نمایش special values مفید هستند. در Windows Presentation Foundation (WPF)، double.NaN یک اندازه‌گیری را نشان می‌دهد که value آن &quot;خودکار&quot; است. راه دیگری برای نمایش چنین valueای با یک nullable type (Chapter 4) است؛ راه دیگر با یک custom struct است که یک numeric type را wrap می‌کند و یک field اضافی اضافه می‌کند (Chapter 3).</p>
<p>float و double از specification IEEE 754 format types پیروی می‌کنند که به صورت natively توسط تقریباً تمام processors پشتیبانی می‌شود. اطلاعات دقیق در مورد رفتار این types را می‌توانید در <a href="http://www.ieee.org">http://www.ieee.org</a> بیابید.</p>
<h3>double در مقابل decimal</h3>
<p>double برای محاسبات علمی (مانند محاسبه spatial coordinates) مفید است. decimal برای محاسبات مالی و valuesی مفید است که تولید می‌شوند، نه نتیجه اندازه‌گیری‌های دنیای واقعی. در اینجا خلاصه‌ای از تفاوت‌ها آورده شده است.</p>
<p><img src="../../../assets/image/02/Table-2-5.png" alt="Conventions-UsedThis-Book"></p>
<h2>خطاهای Rounding اعداد حقیقی</h2>
<p>float و double به صورت داخلی اعداد را در base 2 نمایش می‌دهند. به همین دلیل، تنها اعدادی که در base 2 قابل بیان هستند، به طور دقیق نمایش داده می‌شوند. در عمل، این بدان معناست که بیشتر literals با جزء کسری (که در base 10 هستند) به طور دقیق نمایش داده نخواهند شد؛ برای مثال:</p>
<pre><code class="language-C#">
float x = 0.1f;  // Not quite 0.1
Console.WriteLine (x + x + x + x + x + x + x + x + x + x);    // 1.0000001
</code></pre>
<p>به همین دلیل float و double برای محاسبات مالی مناسب نیستند. در مقابل، decimal در base 10 کار می‌کند و بنابراین می‌تواند اعدادی که در base 10 قابل بیان هستند (و همچنین عوامل آن، base 2 و base 5) را به طور دقیق نمایش دهد. از آنجایی که real literals در base 10 هستند، decimal می‌تواند اعدادی مانند 0.1 را به طور دقیق نمایش دهد. با این حال، نه double و نه decimal نمی‌توانند یک عدد کسری را که نمایش base 10 آن تکرار شونده است، به طور دقیق نمایش دهند:</p>
<pre><code class="language-C#">
decimal m = 1M / 6M;               // 0.1666666666666666666666666667M
double  d = 1.0 / 6.0;             // 0.16666666666666666
</code></pre>
<p>این منجر به خطاهای rounding انباشته می‌شود:</p>
<pre><code class="language-C#">
decimal notQuiteWholeM = m+m+m+m+m+m;  // 1.0000000000000000000000000002M
double  notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989
</code></pre>
<p>که عملیات equality و comparison را مختل می‌کند:</p>
<pre><code class="language-C#">
Console.WriteLine (notQuiteWholeM == 1M);   // False
Console.WriteLine (notQuiteWholeD &lt; 1.0);   // True
</code></pre>
<h2>Boolean Type و Operators</h2>
<p>bool type در C# (که System.Boolean type را alias می‌کند) یک logical value است که می‌تواند literal true یا false را به خود بگیرد.</p>
<p>اگرچه یک Boolean value فقط به یک bit فضای ذخیره‌سازی نیاز دارد، اما runtime از یک byte حافظه استفاده خواهد کرد زیرا این حداقل قطعه‌ای است که runtime و processor می‌توانند به طور کارآمد با آن کار کنند. برای جلوگیری از ناکارآمدی فضا در مورد arrays، .NET یک BitArray class در namespace System.Collections فراهم می‌کند که برای استفاده تنها یک bit در هر Boolean value طراحی شده است.</p>
<h2>bool Conversions</h2>
<p>هیچ casting conversionsای را نمی‌توان از bool type به numeric types، یا بالعکس انجام داد.</p>
<h2>Equality و Comparison Operators</h2>
<p>== و != برای equality و inequality هر typeی را آزمایش می‌کنند اما همیشه یک bool value برمی‌گردانند.3 Value types معمولاً مفهوم بسیار ساده‌ای از equality دارند:</p>
<pre><code class="language-C#">
int x = 1;
int y = 2;
int z = 1;
Console.WriteLine (x == y);         // False
Console.WriteLine (x == z);         // True
</code></pre>
<p>برای reference types، equality، به طور پیش‌فرض، بر اساس reference است، نه بر اساس actual value underlying object (اطلاعات بیشتر در Chapter 6):</p>
<pre><code class="language-C#">
Dude d1 = new Dude (&quot;John&quot;);
Dude d2 = new Dude (&quot;John&quot;);
Console.WriteLine (d1 == d2);       // False
Dude d3 = d1;
Console.WriteLine (d1 == d3);       // True
public class Dude
{
  public string Name;
  public Dude (string n) { Name = n; }
}
</code></pre>
<p>Equality و comparison operators، ==, !=, &lt;, &gt;, &gt;=, و &lt;=، برای تمام numeric types کار می‌کنند، اما باید با احتیاط با real numbers از آن‌ها استفاده کنید (همانطور که در &quot;Real Number Rounding Errors&quot; در صفحه ۵۴ دیدیم). Comparison operators همچنین بر روی enum type members با مقایسه underlying integral-type values آن‌ها کار می‌کنند. ما این را در &quot;Enums&quot; در صفحه ۱۵۴ توضیح می‌دهیم.</p>
<p>ما equality و comparison operators را با جزئیات بیشتر در &quot;Operator Overloading&quot; در صفحه ۲۵۶، و در &quot;Equality Comparison&quot; در صفحه ۳۴۴ و &quot;Order Comparison&quot; در صفحه ۳۵۵ توضیح می‌دهیم.</p>
<h2>Conditional Operators</h2>
<p>Operators &amp;&amp; و || شرایط and و or را آزمایش می‌کنند. آن‌ها اغلب در ترکیب با operator ! که not را بیان می‌کند، استفاده می‌شوند. در مثال زیر، method UseUmbrella در صورتی true را برمی‌گرداند که بارانی یا آفتابی باشد (برای محافظت از ما در برابر باران یا خورشید)، به شرطی که windy هم نباشد (چترها در باد بی‌فایده‌اند):</p>
<pre><code class="language-C#">
static bool UseUmbrella (bool rainy, bool sunny, bool windy)
{
  return !windy &amp;&amp; (rainy || sunny);
}
</code></pre>
<p>Operators &amp;&amp; و || در صورت امکان، evaluation را short-circuit می‌کنند. در مثال قبلی، اگر windy باشد، expression (rainy || sunny) حتی evaluated نمی‌شود.</p>
<p>Short-circuiting در اجازه دادن به expressions مانند موارد زیر برای اجرا بدون پرتاب NullReferenceException ضروری است:</p>
<pre><code class="language-C#">
if (sb != null &amp;&amp; sb.Length &gt; 0) ...
Operators &amp; و | نیز شرایط and و or را آزمایش می‌کنند:
</code></pre>
<pre><code class="language-C#">
return !windy &amp; (rainy | sunny);
</code></pre>
<p>تفاوت این است که آن‌ها short-circuit نمی‌کنند. به همین دلیل، به ندرت به جای conditional operators استفاده می‌شوند.</p>
<p>برخلاف C و C++، operators &amp; و | هنگامی که بر bool expressions اعمال می‌شوند، مقایسات Boolean (غیر short-circuiting) را انجام می‌دهند. Operators &amp; و | عملیات bitwise را فقط هنگامی که بر اعداد اعمال می‌شوند، انجام می‌دهند.</p>
<h2>Conditional operator (Ternary operator)</h2>
<p>Conditional operator (که بیشتر به آن Ternary operator گفته می‌شود، زیرا تنها operatorی است که سه operand می‌گیرد) به شکل q ? a : b; است؛ بنابراین، اگر condition q true باشد، a evaluated می‌شود؛ در غیر این صورت b evaluated می‌شود:</p>
<pre><code class="language-C#">
static int Max (int a, int b)
{
  return (a &gt; b) ? a : b;
}
</code></pre>
<p>Conditional operator به ویژه در Language-Integrated Query (LINQ) expressions (Chapter 8) مفید است.</p>
<h2>Strings و Characters</h2>
<p>char type در C# (که System.Char type را alias می‌کند) یک Unicode character را نمایش می‌دهد و ۲ byte (UTF-16) فضا اشغال می‌کند. یک char literal در داخل single quotes مشخص می‌شود:</p>
<pre><code class="language-C#">
char c = 'A';       // Simple character
</code></pre>
<p>Escape sequences charactersی را بیان می‌کنند که نمی‌توانند به صورت literally بیان یا تفسیر شوند. یک escape sequence شامل یک backslash است که به دنبال آن یک character با معنای خاص می‌آید؛ برای مثال:</p>
<pre><code class="language-C#">
char newLine = '\n';
char backSlash = '\\';
</code></pre>
<p>Table 2-2 escape sequence characters را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-6.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-6-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>escape sequence \u (یا \x) به شما اجازه می‌دهد تا هر Unicode character را از طریق four-digit hexadecimal code آن مشخص کنید:</p>
<pre><code class="language-C#">
char copyrightSymbol = '\u00A9';
char omegaSymbol     = '\u03A9';
char newLine         = '\u000A';
</code></pre>
<h2>Char Conversions</h2>
<p>یک implicit conversion از یک char به یک numeric type برای numeric typesی کار می‌کند که می‌توانند یک unsigned short را در خود جای دهند. برای سایر numeric types، یک explicit conversion مورد نیاز است.</p>
<h2>String Type</h2>
<p>string type در C# (که System.String type را alias می‌کند و در Chapter 6 به تفصیل پوشش داده شده است) یک immutable (unmodifiable) sequence از Unicode characters را نمایش می‌دهد. یک string literal در داخل double quotes مشخص می‌شود:</p>
<pre><code class="language-C#">
string a = &quot;Heat&quot;;
</code></pre>
<p>string یک reference type است تا یک value type. با این حال، equality operators آن از value-type semantics پیروی می‌کنند:</p>
<pre><code class="language-C#">
string a = &quot;test&quot;;
string b = &quot;test&quot;;
Console.Write (a == b);  // True
</code></pre>
<p>escape sequences که برای char literals معتبر هستند، در داخل strings نیز کار می‌کنند:</p>
<pre><code class="language-C#">
string a = &quot;Here's a tab:\t&quot;;
</code></pre>
<p>هزینه این کار این است که هر زمان که به یک literal backslash نیاز دارید، باید آن را دو بار بنویسید:</p>
<pre><code class="language-C#">
string a1 = &quot;\\\\server\\fileshare\\helloworld.cs&quot;;
</code></pre>
<p>برای جلوگیری از این مشکل، C# verbatim string literals را مجاز می‌داند. یک verbatim string literal با @ پیشوند می‌گیرد و از escape sequences پشتیبانی نمی‌کند. verbatim string زیر با مورد قبلی یکسان است:</p>
<pre><code class="language-C#">
string a2 = @&quot;\\server\fileshare\helloworld.cs&quot;;
</code></pre>
<p>یک verbatim string literal می‌تواند چندین خط را نیز شامل شود:</p>
<pre><code class="language-C#">
string escaped  = &quot;First Line\r\nSecond Line&quot;;
string verbatim = @&quot;First Line
 Second Line&quot;;
// True if your text editor uses CR-LF line separators:
Console.WriteLine (escaped == verbatim);
</code></pre>
<p>می‌توانید double-quote character را در یک verbatim literal با نوشتن آن دو بار وارد کنید:</p>
<pre><code class="language-C#">
string xml = @&quot;&lt;customer id=&quot;&quot;123&quot;&quot;&gt;&lt;/customer&gt;&quot;;
</code></pre>
<h2>Raw string literals (C# 11)</h2>
<p>Wrapping یک string در سه یا بیشتر quote characters (&quot;&quot;&quot;) یک raw string literal ایجاد می‌کند. Raw string literals می‌توانند تقریباً هر character sequenceای را بدون escaping یا doubling up شامل شوند:</p>
<pre><code class="language-C#">
 string raw = &quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;;
</code></pre>
<p>Raw string literals نمایش JSON, XML, و HTML literals، و همچنین regular expressions و source code را آسان می‌کنند. اگر نیاز دارید سه (یا بیشتر) quote characters را در خود string وارد کنید، می‌توانید این کار را با wrapping string در چهار (یا بیشتر) quote characters انجام دهید:</p>
<pre><code class="language-C#">
string raw = &quot;&quot;&quot;&quot;The &quot;&quot;&quot; sequence denotes raw string literals.&quot;&quot;&quot;&quot;;
Multiline raw string literals تابع قوانین ویژه‌ای هستند. می‌توانیم string &quot;Line 1\r\nLine 2&quot; را به صورت زیر نمایش دهیم:
</code></pre>
<pre><code class="language-C#">
string multiLineRaw = &quot;&quot;&quot;
  Line 1
  Line 2
&quot;&quot;&quot;;
</code></pre>
<p>توجه داشته باشید که opening و closing quotes باید در خطوط جداگانه با string content باشند. علاوه بر این:</p>
<ul>
<li>
<p>Whitespace پس از opening &quot;&quot;&quot; (در همان خط) نادیده گرفته می‌شود.</p>
</li>
<li>
<p>Whitespace قبل از closing &quot;&quot;&quot; (در همان خط) به عنوان common indentation در نظر گرفته می‌شود و از هر خط در string حذف می‌شود. این به شما اجازه می‌دهد تا indentation را برای خوانایی source-code وارد کنید بدون اینکه آن indentation بخشی از string شود.</p>
</li>
</ul>
<p>در اینجا یک مثال دیگر برای نشان دادن قوانین multiline raw string literal آورده شده است:</p>
<pre><code class="language-C#">
if (true)
  Console.WriteLine (&quot;&quot;&quot;
    {
      &quot;Name&quot; : &quot;Joe&quot;
    }
    &quot;&quot;&quot;);
Output به شرح زیر است:

{
  &quot;Name&quot; : &quot;Joe&quot;
}
</code></pre>
<p>Compiler یک error ایجاد خواهد کرد اگر هر خط در یک multiline raw string literal با common indentation مشخص شده توسط closing quotes پیشوند نداشته باشد.</p>
<p>Raw string literals می‌توانند interpolated شوند، تابع قوانین ویژه‌ای که در &quot;String interpolation&quot; در صفحه ۶۰ توضیح داده شده‌اند.</p>
<h3>String concatenation</h3>
<p>Operator + دو string را concatenate می‌کند:</p>
<pre><code class="language-C#">
string s = &quot;a&quot; + &quot;b&quot;;
</code></pre>
<p>یکی از operands ممکن است یک nonstring value باشد، در این صورت ToString روی آن value فراخوانی می‌شود:</p>
<pre><code class="language-C#">
string s = &quot;a&quot; + 5;  // a5
</code></pre>
<p>استفاده مکرر از operator + برای ساخت یک string ناکارآمد است: یک راه حل بهتر استفاده از System.Text.StringBuilder type است (که در Chapter 6 توضیح داده شده است).</p>
<h3>String interpolation</h3>
<p>یک string که با character $ پیشوند می‌گیرد، interpolated string نامیده می‌شود. Interpolated strings می‌توانند expressions محصور شده در braces را شامل شوند:</p>
<pre><code class="language-C#">
int x = 4;
Console.Write ($&quot;A square has {x} sides&quot;);  // Prints: A square has 4 sides
</code></pre>
<p>هر valid C# expression از هر typeی می‌تواند در داخل braces ظاهر شود، و C# expression را با فراخوانی ToString method آن یا معادل آن به یک string تبدیل خواهد کرد. می‌توانید formatting را با appending expression با یک colon و یک format string تغییر دهید (format strings در &quot;String.Format and composite format strings&quot; در صفحه ۲۹۶ توضیح داده شده‌اند):</p>
<pre><code class="language-C#">
string s = $&quot;255 in hex is {byte.MaxValue:X2}&quot;;  // X2 = 2-digit hexadecimal
// Evaluates to &quot;255 in hex is FF&quot;
</code></pre>
<p>اگر نیاز به استفاده از colon برای هدف دیگری دارید (مانند ternary conditional operator، که بعداً آن را پوشش خواهیم داد)، باید کل expression را در parentheses wrap کنید:</p>
<pre><code class="language-C#">
bool b = true;
Console.WriteLine ($&quot;The answer in binary is {(b ? 1 : 0)}&quot;);
</code></pre>
<p>از C# 10، interpolated strings می‌توانند constants باشند، تا زمانی که interpolated values constants باشند:</p>
<pre><code class="language-C#">
const string greeting = &quot;Hello&quot;;
const string message = $&quot;{greeting}, world&quot;;
</code></pre>
<p>از C# 11، interpolated strings مجاز به شامل شدن در چندین خط هستند (چه standard و چه verbatim):</p>
<pre><code class="language-C#">
string s = $&quot;this interpolation spans {1 +
1} lines&quot;;
</code></pre>
<p>Raw string literals (از C# 11) نیز می‌توانند interpolated شوند:</p>
<pre><code class="language-C#">
string s = $&quot;&quot;&quot;The date and time is {DateTime.Now}&quot;&quot;&quot;;
</code></pre>
<p>برای وارد کردن یک brace literal در یک interpolated string:</p>
<ul>
<li>
<p>با standard و verbatim string literals، brace character مورد نظر را تکرار کنید.</p>
</li>
<li>
<p>با raw string literals، interpolation sequence را با تکرار $ prefix تغییر دهید.</p>
</li>
</ul>
<p>استفاده از دو (یا بیشتر) character $ در یک raw string literal prefix interpolation sequence را از یک brace به دو (یا بیشتر) braces تغییر می‌دهد:</p>
<pre><code class="language-C#">
Console.WriteLine ($$&quot;&quot;&quot;{ &quot;TimeStamp&quot;: &quot;&quot; }&quot;&quot;&quot;);
// Output: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }
</code></pre>
<p>این قابلیت copy-and-paste کردن text به یک raw string literal را بدون نیاز به تغییر string حفظ می‌کند.</p>
<h3>String comparisons</h3>
<p>برای انجام equality comparisons با strings، می‌توانید از operator == (یا یکی از string’s Equals methods) استفاده کنید. برای order comparison، باید از string’s CompareTo method استفاده کنید؛ operators &lt; و &gt; پشتیبانی نمی‌شوند. ما equality و order comparison را با جزئیات در &quot;Comparing Strings&quot; در صفحه ۲۹۷ توضیح می‌دهیم.</p>
<h2>UTF-8 Strings</h2>
<p>از C# 11، می‌توانید از u8 suffix برای ایجاد string literals encoded شده در UTF-8 به جای UTF-16 استفاده کنید. این ویژگی برای scenarios پیشرفته مانند low-level handling JSON text در performance hotspots در نظر گرفته شده است:</p>
<pre><code class="language-C#">
ReadOnlySpan&lt;byte&gt; utf8 = &quot;ab→cd&quot;u8;  // Arrow symbol consumes 3 bytes
Console.WriteLine (utf8.Length);      // 7
</code></pre>
<p>underlying type ReadOnlySpan<T> است، که در Chapter 23 آن را پوشش می‌دهیم. می‌توانید این را با فراخوانی ToArray() method به یک array تبدیل کنید.</p>
<h2>Arrays</h2>
<p>یک array، تعداد ثابتی از variables (که elements نامیده می‌شوند) از یک type خاص را نمایش می‌دهد. Elements در یک array همیشه در یک contiguous block of memory ذخیره می‌شوند که دسترسی بسیار کارآمدی را فراهم می‌کند.</p>
<p>یک array با square brackets پس از element type مشخص می‌شود:</p>
<pre><code class="language-C#">
char[] vowels = new char[5];    // Declare an array of 5 characters
</code></pre>
<p>Square brackets همچنین array را index می‌کنند و به یک element خاص بر اساس موقعیت دسترسی پیدا می‌کنند:</p>
<pre><code class="language-C#">
vowels[0] = 'a';
vowels[1] = 'e';
vowels[2] = 'i';
vowels[3] = 'o';
vowels[4] = 'u';
Console.WriteLine (vowels[1]);      // e
</code></pre>
<p>این &quot;e&quot; را چاپ می‌کند زیرا array indexes از ۰ شروع می‌شوند. می‌توانید از یک for loop statement برای iterate کردن از طریق هر element در array استفاده کنید. for loop در این مثال integer i را از ۰ تا ۴ cycle می‌کند:</p>
<pre><code class="language-C#">
for (int i = 0; i &lt; vowels.Length; i++)
 Console.Write (vowels[i]);            // aeiou
</code></pre>
<p>Length property یک array، تعداد elements در array را برمی‌گرداند. پس از ایجاد یک array، نمی‌توانید طول آن را تغییر دهید. System.Collection namespace و subnamespaces، ساختارهای داده‌ای سطح بالاتر، مانند dynamically sized arrays و dictionaries را فراهم می‌کنند.</p>
<p>یک array initialization expression به شما امکان می‌دهد یک array را در یک مرحله اعلان و پر کنید:</p>
<pre><code class="language-C#">
char[] vowels = new char[] {'a','e','i','o','u'};
</code></pre>
<p>یا به سادگی:</p>
<pre><code class="language-C#">
char[] vowels = {'a','e','i','o','u'};
</code></pre>
<p>از C# 12، می‌توانید به جای curly braces از square brackets استفاده کنید:</p>
<pre><code class="language-C#">
char[] vowels = ['a','e','i','o','u'];
</code></pre>
<p>این یک collection expression نامیده می‌شود و مزیت کار کردن هنگام فراخوانی methods را نیز دارد:</p>
<p>C#</p>
<pre><code>Foo (['a','e','i','o','u']);
void Foo (char[] letters) { ... }
</code></pre>
<p>Collection expressions با سایر collection types مانند lists و sets نیز کار می‌کنند—به &quot;Collection Initializers and Collection Expressions&quot; در صفحه ۲۰۵ مراجعه کنید.</p>
<p>تمام arrays از System.Array class ارث می‌برند و خدمات مشترک را برای تمام arrays فراهم می‌کنند. این members شامل methodsی برای دریافت و تنظیم elements صرف‌نظر از array type هستند. ما آن‌ها را در &quot;The Array Class&quot; در صفحه ۳۷۷ توضیح می‌دهیم.</p>
<h3>Default Element Initialization</h3>
<p>ایجاد یک array همیشه elements را با default values پیش‌تنظیم می‌کند. Default value برای یک type نتیجه bitwise zeroing memory است. برای مثال، ایجاد یک array از integers را در نظر بگیرید. از آنجایی که int یک value type است، این ۱۰۰۰ integers را در یک contiguous block of memory اختصاص می‌دهد. Default value برای هر element 0 خواهد بود:</p>
<pre><code class="language-C#">
int[] a = new int[1000];
Console.Write (a[123]);            // 0
</code></pre>
<h4>Value types در مقابل Reference types</h4>
<p>اینکه آیا element type یک array یک value type است یا یک reference type، پیامدهای performance مهمی دارد. هنگامی که element type یک value type است، هر element value به عنوان بخشی از array اختصاص داده می‌شود، همانطور که در اینجا نشان داده شده است:</p>
<pre><code class="language-C#">
Point[] a = new Point[1000];
int x = a[500].X;                  // 0
public struct Point { public int X, Y; }
</code></pre>
<p>اگر Point یک class بود، ایجاد array صرفاً ۱۰۰۰ null references را اختصاص می‌داد:</p>
<pre><code class="language-C#">
Point[] a = new Point[1000];
int x = a[500].X;                  // Runtime error, NullReferenceException
public class Point { public int X, Y; }
</code></pre>
<p>برای جلوگیری از این error، باید به طور explicitly ۱۰۰۰ Points را پس از instantiating array instantiate کنیم:</p>
<pre><code class="language-C#">
Point[] a = new Point[1000];
for (int i = 0; i &lt; a.Length; i++) // Iterate i from 0 to 999
  a[i] = new Point();             // Set array element i with new point
</code></pre>
<p>خود array همیشه یک reference type object است، صرف‌نظر از element type. برای مثال، موارد زیر قانونی است:</p>
<pre><code class="language-C#">
int[] a = null;
</code></pre>
<h3>Indices و Ranges</h3>
<p>Indices و ranges (معرفی شده در C# 8) کار با elements یا بخش‌هایی از یک array را ساده می‌کنند.</p>
<p>Indices</p>
<p>Indices و ranges همچنین با CLR types Span و ReadOnlySpan کار می‌کنند (به Chapter 23 مراجعه کنید).</p>
<p>همچنین می‌توانید types خود را با indices و ranges کار کنید، با تعریف یک indexer از type Index یا Range (به &quot;Indexers&quot; در صفحه ۱۱۸ مراجعه کنید).</p>
<p>Indices به شما امکان می‌دهند تا elements را نسبت به انتهای یک array، با operator ^ ارجاع دهید. ^1 به آخرین element، ^2 به element ماقبل آخر، و غیره اشاره دارد:</p>
<pre><code class="language-C#">
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [^1];   // 'u'
char secondToLast = vowels [^2];   // 'o'
</code></pre>
<p>(^0 برابر با طول array است، بنابراین vowels[^0] یک error ایجاد می‌کند.)</p>
<p>C# indices را با کمک Index type پیاده‌سازی می‌کند، بنابراین می‌توانید موارد زیر را نیز انجام دهید:</p>
<pre><code class="language-C#">
Index first = 0;
Index last = ^1;
char firstElement = vowels [first];   // 'a'
char lastElement = vowels [last];     // 'u'
</code></pre>
<h3>Ranges</h3>
<p>Ranges به شما امکان می‌دهند تا یک array را با استفاده از operator .. &quot;slice&quot; کنید:</p>
<pre><code class="language-C#">
char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3];   // 'i'
</code></pre>
<p>عدد دوم در range exclusive است، بنابراین ..2 elements قبل از vowels[2] را برمی‌گرداند.</p>
<p>می‌توانید از نماد ^ در ranges نیز استفاده کنید. موارد زیر دو character آخر را برمی‌گرداند:</p>
<p>C#</p>
<pre><code>char[] lastTwo = vowels [^2..];     // 'o', 'u'
</code></pre>
<p>C# ranges را با کمک Range type پیاده‌سازی می‌کند، بنابراین می‌توانید موارد زیر را نیز انجام دهید:</p>
<pre><code class="language-C#">
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'
</code></pre>
<h3>Multidimensional Arrays</h3>
<p>Multidimensional arrays در دو نوع ارائه می‌شوند: rectangular و jagged. Rectangular arrays یک n-dimensional block of memory را نمایش می‌دهند، و jagged arrays arrays از arrays هستند.</p>
<h3>Rectangular arrays</h3>
<p>Rectangular arrays با استفاده از commas برای جداسازی هر dimension اعلان می‌شوند. موارد زیر یک rectangular two-dimensional array را اعلان می‌کند که dimensions آن ۳ در ۳ است:</p>
<pre><code class="language-C#">
int[,] matrix = new int[3,3];
</code></pre>
<p>GetLength method یک array، طول یک dimension مشخص را برمی‌گرداند (شروع از ۰):</p>
<pre><code class="language-C#">
for (int i = 0; i &lt; matrix.GetLength(0); i++)
  for (int j = 0; j &lt; matrix.GetLength(1); j++)
    matrix[i,j] = i * 3 + j;
</code></pre>
<p>می‌توانید یک rectangular array را با explicit values مقداردهی کنید. کد زیر یک array مشابه مثال قبلی ایجاد می‌کند:</p>
<pre><code class="language-C#">
int[,] matrix = new int[,]
 {
  {0,1,2},
  {3,4,5},
  {6,7,8}
 };
</code></pre>
<h4>Jagged arrays</h4>
<p>Jagged arrays با استفاده از square brackets متوالی برای نمایش هر dimension اعلان می‌شوند. در اینجا مثالی از اعلان یک jagged two-dimensional array آورده شده است که outermost dimension آن ۳ است:</p>
<pre><code class="language-C#">
int[][] matrix = new int[3][];
</code></pre>
<p>جالب اینجاست که این new int[3][] است و نه new int[][3].
اریک لیپرت (Eric Lippert) مقاله فوق‌العاده‌ای در مورد دلیل این موضوع نوشته است.</p>
<p>Inner dimensions در اعلان مشخص نمی‌شوند زیرا، برخلاف یک rectangular array، هر inner array می‌تواند طول دلخواهی داشته باشد. هر inner array به طور implicitly به null مقداردهی اولیه می‌شود تا یک empty array. شما باید هر inner array را به صورت دستی ایجاد کنید:</p>
<pre><code class="language-C#">
for (int i = 0; i &lt; matrix.Length; i++)
{
  matrix[i] = new int[3];                    // Create inner array
  for (int j = 0; j &lt; matrix[i].Length; j++)
    matrix[i][j] = i * 3 + j;
}
</code></pre>
<p>می‌توانید یک jagged array را با explicit values مقداردهی اولیه کنید. کد زیر یک array مشابه مثال قبلی با یک element اضافی در انتها ایجاد می‌کند:</p>
<pre><code class="language-C#">
int[][] matrix = new int[][]
{
  new int[] {0,1,2},
  new int[] {3,4,5},
  new int[] {6,7,8,9}
};
</code></pre>
<h3>Simplified Array Initialization Expressions</h3>
<p>دو روش برای کوتاه‌تر کردن array initialization expressions وجود دارد. اولین روش حذف operator new و type qualifications است:</p>
<pre><code class="language-C#">
char[] vowels = {'a','e','i','o','u'};
int[,] rectangularMatrix =
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};
int[][] jaggedMatrix =
{
  new int[] {0,1,2},
  new int[] {3,4,5},
  new int[] {6,7,8,9}
};
</code></pre>
<p>(از C# 12، می‌توانید به جای braces با single-dimensional arrays از square brackets استفاده کنید.)</p>
<p>رویکرد دوم استفاده از keyword var است که به compiler دستور می‌دهد تا یک local variable را به طور implicitly type کند. در اینجا مثال‌های ساده‌ای آورده شده است:</p>
<pre><code class="language-C#">
var i = 3;           // i is implicitly of type int
var s = &quot;sausage&quot;;   // s is implicitly of type string
</code></pre>
<p>همین اصل را می‌توان در مورد arrays نیز اعمال کرد، با این تفاوت که می‌توان آن را یک مرحله فراتر برد. با حذف type qualifier پس از keyword new، compiler array type را استنباط می‌کند:</p>
<pre><code class="language-C#">
var vowels = new[] {'a','e','i','o','u'};   // Compiler infers char[]
</code></pre>
<p>در اینجا نحوه اعمال این بر روی multidimensional arrays آمده است:</p>
<pre><code class="language-C#">
var rectMatrix = new[,]        // rectMatrix is implicitly of type int[,]
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};
var jaggedMat = new int[][]    // jaggedMat is implicitly of type int[][]
{
  new[] {0,1,2},
  new[] {3,4,5},
  new[] {6,7,8,9}
};
</code></pre>
<p>برای اینکه این کار کند، تمام elements باید به طور implicitly به یک single type قابل تبدیل باشند (و حداقل یکی از elements باید از آن type باشد، و باید دقیقاً یک best type وجود داشته باشد)، همانطور که در مثال زیر:</p>
<pre><code class="language-C#">
var x = new[] {1,10000000000};   // all convertible to long
</code></pre>
<h3>Bounds Checking</h3>
<p>تمام array indexing توسط runtime bounds checked می‌شوند. اگر از یک invalid index استفاده کنید، یک IndexOutOfRangeException پرتاب می‌شود:</p>
<pre><code class="language-C#">
int[] arr = new int[3];
arr[3] = 1;               // IndexOutOfRangeException thrown
</code></pre>
<p>Array bounds checking برای type safety ضروری است و debugging را ساده می‌کند.</p>
<p>به طور کلی، performance hit ناشی از bounds checking جزئی است، و Just-In-Time (JIT) compiler می‌تواند optimizations را انجام دهد، مانند تعیین از قبل اینکه آیا تمام indexes قبل از ورود به یک loop ایمن خواهند بود یا خیر، در نتیجه از بررسی در هر iteration جلوگیری می‌کند. علاوه بر این، C# code &quot;unsafe&quot; را فراهم می‌کند که می‌تواند به طور explicitly bounds checking را دور بزند (به &quot;Unsafe Code and Pointers&quot; در صفحه ۲۶۳ مراجعه کنید).</p>
<h2>Variables و Parameters</h2>
<p>یک variable نشان‌دهنده یک مکان ذخیره‌سازی است که یک value قابل تغییر دارد. یک variable می‌تواند یک local variable، parameter (value، ref، یا out، یا in)، field (instance یا static)، یا array element باشد.</p>
<h3>The Stack و The Heap</h3>
<p>Stack و heap مکان‌هایی هستند که variables در آن‌ها قرار می‌گیرند. هر کدام semantics طول عمر بسیار متفاوتی دارند.</p>
<h4>Stack</h4>
<p>Stack یک block of memory برای ذخیره local variables و parameters است. Stack به صورت منطقی با ورود و خروج یک method یا function رشد و کوچک می‌شود. Method زیر را در نظر بگیرید (برای جلوگیری از حواس‌پرتی، بررسی input argument نادیده گرفته شده است):</p>
<pre><code class="language-C#">
static int Factorial (int x)
{
  if (x == 0) return 1;
  return x * Factorial (x-1);
}
</code></pre>
<p>این method recursive است، به این معنی که خودش را فراخوانی می‌کند. هر بار که method وارد می‌شود، یک int جدید در stack اختصاص داده می‌شود، و هر بار که method خارج می‌شود، int deallocated می‌شود.</p>
<h4>Heap</h4>
<p>Heap حافظه‌ای است که objects (یعنی reference-type instances) در آن قرار می‌گیرند. هر زمان که یک object جدید ایجاد می‌شود، در heap اختصاص داده می‌شود، و یک reference به آن object برگردانده می‌شود. در طول اجرای یک برنامه، heap با ایجاد objects جدید شروع به پر شدن می‌کند. Runtime دارای یک garbage collector است که به صورت دوره‌ای objects را از heap deallocate می‌کند، بنابراین برنامه شما با کمبود حافظه مواجه نمی‌شود. یک object به محض اینکه توسط چیزی که خود &quot;زنده&quot; است referenced نشود، واجد شرایط deallocation است.</p>
<p>در مثال زیر، ما با ایجاد یک StringBuilder object که توسط variable ref1 ارجاع شده است شروع می‌کنیم و سپس محتوای آن را می‌نویسیم. آن StringBuilder object بلافاصله واجد شرایط garbage collection است زیرا چیزی متعاقباً از آن استفاده نمی‌کند.</p>
<p>سپس، یک StringBuilder دیگر ایجاد می‌کنیم که توسط variable ref2 ارجاع شده و آن reference را به ref3 کپی می‌کنیم. حتی اگر ref2 پس از آن نقطه استفاده نشود، ref3 همان StringBuilder object را زنده نگه می‌دارد—اطمینان حاصل می‌کند که تا زمانی که ما استفاده از ref3 را تمام نکرده‌ایم، واجد شرایط collection نشود:</p>
<pre><code class="language-C#">
using System;
using System.Text;
StringBuilder ref1 = new StringBuilder (&quot;object1&quot;);
Console.WriteLine (ref1);
// The StringBuilder referenced by ref1 is now eligible for GC.
StringBuilder ref2 = new StringBuilder (&quot;object2&quot;);
StringBuilder ref3 = ref2;
// The StringBuilder referenced by ref2 is NOT yet eligible for GC.
Console.WriteLine (ref3);      // object2
</code></pre>
<p>Value-type instances (و object references) در هر کجا که variable اعلان شده است، زندگی می‌کنند. اگر instance به عنوان یک field در یک class type، یا به عنوان یک array element اعلان شده باشد، آن instance در heap زندگی می‌کند.</p>
<p>شما نمی‌توانید objects را به طور explicitly در C# حذف کنید، همانطور که در C++ می‌توانید. یک object بدون reference در نهایت توسط garbage collector جمع‌آوری می‌شود.</p>
<p>Heap همچنین static fields را ذخیره می‌کند. برخلاف objects که در heap اختصاص داده می‌شوند (و می‌توانند garbage-collected شوند)، اینها تا پایان process زنده می‌مانند.</p>
<h3>Definite Assignment</h3>
<p>C# یک definite assignment policy را اعمال می‌کند. در عمل، این بدان معناست که خارج از یک unsafe یا interop context، نمی‌توانید به طور تصادفی به uninitialized memory دسترسی پیدا کنید. Definite assignment سه پیامد دارد:</p>
<ul>
<li>
<p>Local variables باید قبل از خوانده شدن، یک value به آن‌ها اختصاص داده شود.</p>
</li>
<li>
<p>Function arguments باید هنگام فراخوانی یک method ارائه شوند (مگر اینکه به عنوان optional علامت‌گذاری شده باشند؛ به &quot;Optional parameters&quot; در صفحه ۷۴ مراجعه کنید).</p>
</li>
<li>
<p>تمام variables دیگر (مانند fields و array elements) به طور خودکار توسط runtime مقداردهی اولیه می‌شوند.</p>
</li>
</ul>
<p>برای مثال، کد زیر منجر به یک compile-time error می‌شود:</p>
<pre><code class="language-C#">
int x;
Console.WriteLine (x);        // Compile-time error
</code></pre>
<p>Fields و array elements به طور خودکار با default values برای type خود مقداردهی اولیه می‌شوند. کد زیر 0 را output می‌کند زیرا array elements به طور implicitly به default values خود اختصاص داده می‌شوند:</p>
<pre><code class="language-C#">
int[] ints = new int[2];
Console.WriteLine (ints[0]);    // 0
</code></pre>
<p>کد زیر 0 را output می‌کند، زیرا fields به طور implicitly یک default value به آن‌ها اختصاص داده می‌شود (چه instance و چه static):</p>
<pre><code class="language-C#">
Console.WriteLine (Test.X);   // 0
class Test { public static int X; }   // field
</code></pre>
<h3>Default Values</h3>
<p>تمام type instances دارای یک default value هستند. Default value برای predefined types نتیجه bitwise zeroing memory است:</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-7.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
می‌توانید default value برای هر type را از طریق keyword default به دست آورید:
<pre><code class="language-C#">
Console.WriteLine (default (decimal));   // 0
</code></pre>
<p>می‌توانید به صورت optionally type را حذف کنید، زمانی که قابل استنباط باشد:</p>
<pre><code class="language-C#">
decimal d = default;
</code></pre>
<p>Default value در یک custom value type (یعنی struct) همان default value برای هر field تعریف شده توسط custom type است.</p>
<h3>Parameters</h3>
<p>یک method ممکن است دارای یک sequence از parameters باشد. Parameters مجموعه‌ای از arguments را تعریف می‌کنند که باید برای آن method فراهم شوند. در مثال زیر، method Foo یک single parameter به نام p، از type int دارد:</p>
<pre><code class="language-C#">
Foo (8);                        // 8 is an argument
static void Foo (int p) {...}   // p is a parameter
</code></pre>
<p>می‌توانید نحوه پاس دادن parameters را با modifiers ref, in, و out کنترل کنید:</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-8.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h4>Passing arguments by value</h4>
<p>به طور پیش‌فرض، arguments در C# با value pass می‌شوند، که تاکنون رایج‌ترین حالت است. این بدان معناست که هنگام pass شدن به method، یک copy از value ایجاد می‌شود:</p>
<pre><code class="language-C#">
int x = 8;
Foo (x);                    // Make a copy of x
Console.WriteLine (x);      // x will still be 8
static void Foo (int p)
{
  p = p + 1;                // Increment p by 1
  Console.WriteLine (p);    // Write p to screen
}
</code></pre>
<p>اختصاص دادن یک new value به p، محتویات x را تغییر نمی‌دهد، زیرا p و x در مکان‌های memory متفاوتی قرار دارند.</p>
<p>Passing یک reference-type argument با value، reference را copy می‌کند اما object را copy نمی‌کند. در مثال زیر، Foo همان StringBuilder objectی را که ما instantiate کردیم (sb) می‌بیند اما یک independent reference به آن دارد. به عبارت دیگر، sb و fooSB variables جداگانه‌ای هستند که به همان StringBuilder object reference می‌کنند:</p>
<pre><code class="language-C#">
StringBuilder sb = new StringBuilder();
Foo (sb);
Console.WriteLine (sb.ToString());    // test
static void Foo (StringBuilder fooSB)
{
  fooSB.Append (&quot;test&quot;);
  fooSB = null;
}
</code></pre>
<p>از آنجایی که fooSB یک copy از یک reference است، setting آن به null باعث null شدن sb نمی‌شود. (اگرچه، اگر fooSB با modifier ref اعلان و فراخوانی شده بود، sb null می‌شد.)</p>
<h4>The ref modifier</h4>
<p>برای pass کردن با reference، C# parameter modifier ref را فراهم می‌کند. در مثال زیر، p و x به همان مکان‌های memory اشاره می‌کنند:</p>
<pre><code class="language-C#">
int x = 8;
Foo (ref  x);              // Ask Foo to deal directly with x
Console.WriteLine (x);     // x is now 9
static void Foo (ref int p)
{
  p = p + 1;               // Increment p by 1
  Console.WriteLine (p);   // Write p to screen
}
</code></pre>
<p>اکنون اختصاص دادن یک new value به p محتویات x را تغییر می‌دهد. توجه کنید که چگونه modifier ref هم هنگام نوشتن و هم هنگام فراخوانی method مورد نیاز است.4 این موضوع را بسیار واضح می‌کند که چه اتفاقی می‌افتد.</p>
<p>Modifier ref در پیاده‌سازی یک swap method ضروری است (در &quot;Generics&quot; در صفحه ۱۵۹، نشان می‌دهیم که چگونه یک swap method بنویسیم که با هر typeی کار کند):</p>
<pre><code class="language-C#">
string x = &quot;Penn&quot;;
string y = &quot;Teller&quot;;
Swap (ref x, ref y);
Console.WriteLine (x);   // Teller
Console.WriteLine (y);   // Penn
static void Swap (ref string a, ref string b)
{
  string temp = a;
  a = b;
  b = temp;
}
</code></pre>
<h4>The out modifier</h4>
<p>یک parameter را می‌توان با reference یا با value pass کرد، صرف‌نظر از اینکه parameter type یک reference type باشد یا یک value type.</p>
<p>یک out argument مانند یک ref argument است، با این تفاوت که:</p>
<ul>
<li>
<p>نیازی نیست قبل از ورود به function به آن assign شود.</p>
</li>
<li>
<p>باید قبل از خروج از function به آن assign شود.</p>
</li>
</ul>
<p>Modifier out معمولاً برای دریافت چندین return value از یک method استفاده می‌شود؛ برای مثال:</p>
<pre><code class="language-C#">
string a, b;
Split (&quot;Stevie Ray Vaughn&quot;, out a, out b);
Console.WriteLine (a);                      // Stevie Ray
Console.WriteLine (b);                      // Vaughn
void Split (string name, out string firstNames, out string lastName)
{
  int i = name.LastIndexOf (' ');
  firstNames = name.Substring (0, i);
  lastName = name.Substring (i + 1);
}
</code></pre>
<p>مانند یک ref parameter، یک out parameter با reference pass می‌شود.</p>
<h4>Out variables و discards</h4>
<p>می‌توانید variables را به صورت on the fly هنگام فراخوانی methods با out parameters اعلان کنید. می‌توانیم دو خط اول مثال قبلی خود را با این جایگزین کنیم:</p>
<pre><code class="language-C#">
Split (&quot;Stevie Ray Vaughan&quot;, out string a, out string b);
</code></pre>
<p>هنگام فراخوانی methods با چندین out parameters، گاهی اوقات علاقه‌ای به دریافت values از تمام parameters ندارید. در چنین مواردی، می‌توانید آنهایی که علاقه‌ای به آن‌ها ندارید را با استفاده از یک underscore &quot;discard&quot; کنید:</p>
<pre><code class="language-C#">
Split (&quot;Stevie Ray Vaughan&quot;, out string a, out _);   // Discard 2nd param
Console.WriteLine (a);
</code></pre>
<p>در این حالت، compiler underscore را به عنوان یک special symbol، به نام discard، در نظر می‌گیرد. می‌توانید چندین discard را در یک فراخوانی واحد وارد کنید. با فرض اینکه SomeBigMethod با هفت out parameters تعریف شده است، می‌توانیم همه به جز چهارمی را نادیده بگیریم، به صورت زیر:</p>
<pre><code class="language-C#">
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
</code></pre>
<p>برای backward compatibility، این language feature در صورتی که یک real underscore variable در scope باشد، تأثیری نخواهد داشت:</p>
<pre><code class="language-C#">
string _;
Split (&quot;Stevie Ray Vaughan&quot;, out string a, out _);
Console.WriteLine (_);     // Vaughan
</code></pre>
<h4>Implications of passing by reference</h4>
<p>هنگامی که یک argument را با reference pass می‌کنید، storage location یک existing variable را alias می‌کنید به جای اینکه یک new storage location ایجاد کنید. در مثال زیر، variables x و y به همان instance اشاره می‌کنند:</p>
<pre><code class="language-C#">
class Test
{
  static int x;
  static void Main() { Foo (out x); }
  static void Foo (out int y)
  {
    Console.WriteLine (x);                // x is 0
    y = 1;                                // Mutate y
    Console.WriteLine (x);                // x is 1
  }
}
</code></pre>
<h4>The in modifier</h4>
<p>یک in parameter مشابه یک ref parameter است با این تفاوت که value argument نمی‌تواند توسط method تغییر یابد (انجام این کار یک compile-time error ایجاد می‌کند). این modifier هنگامی که یک large value type به method pass می‌شود بسیار مفید است زیرا به compiler اجازه می‌دهد تا از overhead کپی کردن argument قبل از passing آن جلوگیری کند در حالی که original value را از تغییر محافظت می‌کند.</p>
<p>Overloading صرفاً بر اساس حضور in مجاز است:</p>
<pre><code class="language-C#">
void Foo (   SomeBigStruct a) { ... }
void Foo (in SomeBigStruct a) { ... }
</code></pre>
<p>برای فراخوانی second overload، caller باید از modifier in استفاده کند:</p>
<pre><code class="language-C#">
SomeBigStruct x = ...;
Foo (x);      // Calls the first overload
Foo (in x);   // Calls the second overload
</code></pre>
<p>هنگامی که ابهامی وجود ندارد:</p>
<pre><code class="language-C#">
void Bar (in SomeBigStruct a) { ... }
</code></pre>
<p>استفاده از modifier in برای caller اختیاری است:</p>
<pre><code class="language-C#">
Bar (x);     // OK (calls the 'in' overload)
Bar (in x);  // OK (calls the 'in' overload)
</code></pre>
<p>برای اینکه این مثال معنی‌دار باشد، SomeBigStruct به عنوان یک struct تعریف می‌شود (به &quot;Structs&quot; در صفحه ۱۴۲ مراجعه کنید).</p>
<h4>The params modifier</h4>
<p>Modifier params، اگر به آخرین parameter یک method اعمال شود، به method اجازه می‌دهد تا هر تعداد arguments از یک type خاص را بپذیرد. Parameter type باید به عنوان یک (single-dimensional) array اعلان شود، همانطور که در مثال زیر نشان داده شده است:</p>
<pre><code class="language-C#">
int total = Sum (1, 2, 3, 4);
Console.WriteLine (total);              // 10
// The call to Sum above is equivalent to:
int total2 = Sum (new int[] { 1, 2, 3, 4 });
int Sum (params int[] ints)
{
  int sum = 0;
  for (int i = 0; i &lt; ints.Length; i++)
    sum += ints [i];                       // Increase sum by ints[i]
  return sum;
}
</code></pre>
<p>اگر zero arguments در موقعیت params وجود داشته باشد، یک zero-length array ایجاد می‌شود. شما همچنین می‌توانید یک params argument را به عنوان یک ordinary array ارائه دهید. خط اول در مثال ما از نظر semantically با این یکسان است:</p>
<pre><code class="language-C#">
int total = Sum (new int[] { 1, 2, 3, 4 } );
</code></pre>
<h4>Optional parameters</h4>
<p>Methods, constructors, و indexers (Chapter 3) می‌توانند optional parameters را اعلان کنند. یک parameter optional است اگر یک default value را در اعلان خود مشخص کند:</p>
<pre><code class="language-C#">
void Foo (int x = 23) { Console.WriteLine (x); }
</code></pre>
<p>می‌توانید optional parameters را هنگام فراخوانی method حذف کنید:</p>
<pre><code class="language-C#">
Foo();     // 23
</code></pre>
<p>Default argument 23 در واقع به optional parameter x pass می‌شود—compiler value 23 را در compiled code در سمت calling bake می‌کند. فراخوانی قبلی Foo از نظر semantically با این یکسان است:</p>
<pre><code class="language-C#">
Foo (23);
</code></pre>
<p>زیرا compiler به سادگی default value یک optional parameter را در هر کجا که استفاده می‌شود جایگزین می‌کند.</p>
<p>اضافه کردن یک optional parameter به یک public method که از یک assembly دیگر فراخوانی می‌شود، نیاز به recompilation هر دو assemblies دارد—درست همانطور که گویی parameter اجباری بود.</p>
<p>Default value یک optional parameter باید توسط یک constant expression، یک parameterless constructor از یک value type، یا یک default expression مشخص شود. Optional parameters نمی‌توانند با ref یا out علامت‌گذاری شوند.</p>
<p>Mandatory parameters باید قبل از optional parameters در هر دو method declaration و method call (استثنا با params arguments است، که همیشه آخرین می‌آیند) قرار گیرند. در مثال زیر، explicit value 1 به x pass می‌شود، و default value 0 به y pass می‌شود:</p>
<pre><code class="language-C#">
Foo (1);    // 1, 0
void Foo (int x = 0, int y = 0) { Console.WriteLine (x + &quot;, &quot; + y); }
</code></pre>
<p>می‌توانید عکس آن را انجام دهید (یک default value به x و یک explicit value به y pass کنید) با ترکیب optional parameters با named arguments.</p>
<h4>Named arguments</h4>
<p>به جای شناسایی یک argument بر اساس موقعیت، می‌توانید یک argument را با نام شناسایی کنید:</p>
<pre><code class="language-C#">
Foo (x:1, y:2);  // 1, 2
void Foo (int x, int y) { Console.WriteLine (x + &quot;, &quot; + y); }
</code></pre>
<p>Named arguments می‌توانند به هر ترتیبی ظاهر شوند. فراخوانی‌های زیر به Foo از نظر semantically یکسان هستند:</p>
<pre><code class="language-C#">
Foo (x:1, y:2);
Foo (y:2, x:1);
</code></pre>
<p>یک تفاوت ظریف این است که argument expressions به ترتیبی که در calling site ظاهر می‌شوند، evaluated می‌شوند.</p>
<p>به طور کلی، این فقط در interdependent side-effecting expressions مانند زیر تفاوت ایجاد می‌کند که 0, 1 را می‌نویسد:</p>
<pre><code class="language-C#">
int a = 0;
Foo (y: ++a, x: --a);  // ++a is evaluated first
</code></pre>
<p>البته، شما تقریباً به طور قطع از نوشتن چنین codeی در عمل اجتناب خواهید کرد!</p>
<p>می‌توانید named و positional arguments را با هم ترکیب کنید:</p>
<pre><code class="language-C#">
Foo (1, y:2);
</code></pre>
<p>با این حال، یک محدودیت وجود دارد: positional arguments باید قبل از named arguments بیایند مگر اینکه در موقعیت صحیح استفاده شوند. بنابراین، می‌توانید Foo را اینگونه فراخوانی کنید:</p>
<pre><code class="language-C#">
Foo (x:1, 2);         // OK. Arguments in the declared positions
</code></pre>
<p>اما نه اینگونه:</p>
<pre><code class="language-C#">
Foo (y:2, 1);         // Compile-time error. y isn't in the first position
</code></pre>
<p>Named arguments به ویژه در ترکیب با optional parameters مفید هستند. برای مثال، method زیر را در نظر بگیرید:</p>
<pre><code class="language-C#">
void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }
</code></pre>
<p>می‌توانید این را فقط با ارائه یک value برای d فراخوانی کنید، به صورت زیر:</p>
<pre><code class="language-C#">
Bar (d:3);
</code></pre>
<p>این به ویژه هنگام فراخوانی COM APIs مفید است، که در Chapter 24 به تفصیل در مورد آنها بحث می‌کنیم.</p>
<h3>Ref Locals</h3>
<p>یکی از ویژگی‌های نسبتاً ناشناخته C# این است که می‌توانید یک local variable تعریف کنید که به یک element در یک array یا field در یک object reference می‌دهد (از C# 7):</p>
<pre><code class="language-C#">
int[] numbers = { 0, 1, 2, 3, 4 };
ref int numRef = ref numbers [2];
</code></pre>
<p>در این مثال، numRef یک reference به numbers[2] است. هنگامی که numRef را تغییر می‌دهیم، array element را تغییر می‌دهیم:</p>
<pre><code class="language-C#">
numRef *= 10;
Console.WriteLine (numRef);        // 20
Console.WriteLine (numbers [2]);   // 20
</code></pre>
<p>Target برای یکباید یک array element، field، یا local variable باشد؛ نمی‌تواند یک property (Chapter 3) باشد. Ref locals برای scenarios micro-optimization تخصصی در نظر گرفته شده‌اند و معمولاً در ترکیب با ref returns استفاده می‌شوند.</p>
<h3>Ref Returns</h3>
<p>Types Span و ReadOnlySpan که در Chapter 23 آن‌ها را توضیح می‌دهیم، از ref returns برای پیاده‌سازی یک indexer با کارایی بسیار بالا استفاده می‌کنند. خارج از چنین scenarios، ref returns معمولاً استفاده نمی‌شوند، و می‌توانید آن‌ها را یک feature micro-optimization در نظر بگیرید.</p>
<p>می‌توانید یکرا از یک method return کنید. این را ref return می‌نامند:</p>
<pre><code class="language-C#">
class Program
{
  static string x = &quot;Old Value&quot;;
  static ref string GetX() =&gt; ref x;    // This method returns a ref
  static void Main()
  {
    ref string xRef = ref GetX();       // Assign result to a ref local
    xRef = &quot;New Value&quot;;
    Console.WriteLine (x);              // New Value
  }
}
</code></pre>
<p>اگر modifier ref را در سمت calling حذف کنید، به returning یک ordinary value بازمی‌گردد:</p>
<pre><code class="language-C#">
string localX = GetX();  // Legal: localX is an ordinary non-ref variable.
</code></pre>
<p>همچنین می‌توانید از ref returns هنگام تعریف یک property یا indexer استفاده کنید:</p>
<pre><code class="language-C#">
static ref string Prop =&gt; ref x;
</code></pre>
<p>چنین propertyای به طور implicitly writable است، با وجود اینکه هیچ set accessorی وجود ندارد:</p>
<pre><code class="language-C#">
Prop = &quot;New Value&quot;;
</code></pre>
<p>می‌توانید از چنین تغییری با استفاده از ref readonly جلوگیری کنید:</p>
<pre><code class="language-C#">
static ref readonly string Prop =&gt; ref x;
</code></pre>
<p>Modifier ref readonly از تغییر جلوگیری می‌کند در حالی که همچنان performance gain returning by reference را فعال می‌کند. Gain در این مورد بسیار کوچک خواهد بود، زیرا x از type string (یک reference type) است: مهم نیست string چقدر طولانی باشد، تنها ناکارآمدی که می‌توانید امیدوار باشید از آن جلوگیری کنید، copying یک 32- یا 64-bit reference واحد است. Gains واقعی می‌توانند با custom value types رخ دهند (به &quot;Structs&quot; در صفحه ۱۴۲ مراجعه کنید)، اما فقط در صورتی که struct به عنوان readonly علامت‌گذاری شده باشد (در غیر این صورت، compiler یک defensive copy را انجام خواهد داد).</p>
<p>تلاش برای تعریف یک explicit set accessor در یک ref return property یا indexer غیرقانونی است.</p>
<h3>var—Implicitly Typed Local Variables</h3>
<p>اغلب اتفاق می‌افتد که یک variable را در یک مرحله اعلان و مقداردهی اولیه می‌کنید. اگر compiler قادر به استنباط type از initialization expression باشد، می‌توانید از keyword var به جای type declaration استفاده کنید؛ برای مثال:</p>
<pre><code class="language-C#">
var x = &quot;hello&quot;;
var y = new System.Text.StringBuilder();
var z = (float)Math.PI;
</code></pre>
<p>این دقیقاً معادل موارد زیر است:</p>
<pre><code class="language-C#">
string x = &quot;hello&quot;;
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
</code></pre>
<p>به دلیل این direct equivalence، implicitly typed variables statically typed هستند. برای مثال، موارد زیر یک compile-time error ایجاد می‌کند:</p>
<pre><code class="language-C#">
var x = 5;
x = &quot;hello&quot;;    // Compile-time error; x is of type int
</code></pre>
<p>var می‌تواند خوانایی code را کاهش دهد، زمانی که نمی‌توانید type را صرفاً با نگاه کردن به variable declaration استنباط کنید. برای مثال:</p>
<pre><code class="language-C#">
Random r = new Random();
var x = r.Next();
</code></pre>
<p>Type x چیست؟</p>
<p>در &quot;Anonymous Types&quot; در صفحه ۲۲۰، سناریویی را توضیح خواهیم داد که در آن استفاده از var اجباری است.</p>
<h3>Target-Typed new Expressions</h3>
<p>راه دیگری برای کاهش تکرار lexical، استفاده از target-typed new expressions است (از C# 9):</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new (&quot;Test&quot;);
</code></pre>
<p>این دقیقاً معادل موارد زیر است:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb1 = new System.Text.StringBuilder();
System.Text.StringBuilder sb2 = new System.Text.StringBuilder (&quot;Test&quot;);
</code></pre>
<p>اصل این است که می‌توانید new را بدون مشخص کردن type name فراخوانی کنید، اگر compiler بتواند آن را به طور غیرمبهم استنباط کند. Target-typed new expressions به ویژه زمانی مفید هستند که اعلان variable و مقداردهی اولیه در قسمت‌های مختلف code شما باشند. یک مثال رایج زمانی است که می‌خواهید یک field را در یک constructor مقداردهی اولیه کنید:</p>
<pre><code class="language-C#">
class Foo
{
 System.Text.StringBuilder sb;
  public Foo (string initialValue)
  {
    sb = new (initialValue);
  }
}
</code></pre>
<p>Target-typed new expressions در سناریوی زیر نیز مفید هستند:</p>
<pre><code class="language-C#">
MyMethod (new (&quot;test&quot;));
void MyMethod (System.Text.StringBuilder sb) { ... }
</code></pre>
<h2>Expressions و Operators</h2>
<p>یک expression اساساً یک value را نشان می‌دهد. ساده‌ترین انواع expressions، constants و variables هستند. Expressions را می‌توان با استفاده از operators تغییر داد و ترکیب کرد. یک operator یک یا چند input operand را می‌گیرد تا یک new expression را output کند.</p>
<p>در اینجا مثالی از یک constant expression آورده شده است:</p>
<p>12
می‌توانیم از operator * برای ترکیب دو operand (literal expressions 12 و 30) به صورت زیر استفاده کنیم:</p>
<p>12 <em>30
می‌توانیم expressions پیچیده بسازیم زیرا یک operand می‌تواند خود یک expression باشد، مانند operand (12</em> 30) در مثال زیر:</p>
<p>1 + (12 * 30)
Operators در C# را می‌توان به سه دسته unary, binary, یا ternary تقسیم کرد، بسته به تعداد operands که با آنها کار می‌کنند (یک، دو، یا سه). Binary operators همیشه از infix notation استفاده می‌کنند که در آن operator بین دو operand قرار می‌گیرد.</p>
<h3>Primary Expressions</h3>
<p>Primary expressions شامل expressionsی هستند که از operatorsی تشکیل شده‌اند که ذاتاً بخشی از ساختار اصلی زبان هستند. در اینجا یک مثال آورده شده است:</p>
<p>Math.Log (1)
این expression از دو primary expression تشکیل شده است. Expression اول یک member lookup را انجام می‌دهد (با operator .)، و expression دوم یک method call را انجام می‌دهد (با operator ()).</p>
<h3>Void Expressions</h3>
<p>یک void expression یک expression است که value ندارد، مانند این:</p>
<pre><code class="language-C#">
Console.WriteLine (1)
</code></pre>
<p>از آنجایی که value ندارد، نمی‌توانید از یک void expression به عنوان operand برای ساخت expressions پیچیده‌تر استفاده کنید:</p>
<pre><code class="language-C#">
1 + Console.WriteLine (1)      // Compile-time error
</code></pre>
<h3>Assignment Expressions</h3>
<p>یک assignment expression از operator = برای انتساب نتیجه یک expression دیگر به یک variable استفاده می‌کند؛ برای مثال:</p>
<p>x = x * 5
یک assignment expression یک void expression نیست—یک value از هر آنچه که assigned شده است دارد، و بنابراین می‌تواند در یک expression دیگر گنجانده شود. در مثال زیر، expression 2 را به x و 10 را به y assign می‌کند:</p>
<p>y = 5 * (x = 2)
می‌توانید از این سبک expression برای مقداردهی اولیه چندین value استفاده کنید:</p>
<p>a = b = c = d = 0
Compound assignment operators میانبرهای syntactic هستند که assignment را با یک operator دیگر ترکیب می‌کنند:</p>
<p>x <em>= 2    // equivalent to x = x</em> 2
x &lt;&lt;= 1   // equivalent to x = x &lt;&lt; 1
(یک استثنای ظریف برای این قانون در مورد events است، که در Chapter 4 توضیح می‌دهیم: operators += و -= در اینجا به طور ویژه رفتار می‌شوند و به add و remove accessors event نگاشت می‌شوند.)</p>
<h3>اولویت و ارتباط عملگرها (Operator Precedence and Associativity)</h3>
<p>وقتی یک عبارت شامل چندین عملگر باشد، اولویت (precedence) و ارتباط (associativity) ترتیب ارزیابی آن‌ها را مشخص می‌کنند. عملگرهایی با اولویت بالاتر قبل از عملگرهای با اولویت پایین‌تر اجرا می‌شوند. اگر عملگرها اولویت یکسانی داشته باشند، ارتباط عملگر ترتیب ارزیابی را تعیین می‌کند.</p>
<h4>اولویت (Precedence)</h4>
<p>عبارت زیر:</p>
<p>1 + 2 <em>3
به شکل زیر ارزیابی می‌شود، زیرا</em> اولویت بالاتری نسبت به + دارد:</p>
<p>1 + (2 * 3)
عملگرهای با ارتباط چپ‌به‌راست (Left-associative operators)
عملگرهای دوتایی (به جز عملگرهای انتساب، lambda و null-coalescing) از نوع left-associative هستند؛ به عبارت دیگر، آن‌ها از چپ به راست ارزیابی می‌شوند. برای مثال، عبارت زیر:</p>
<p>8 / 4 / 2
به شکل زیر ارزیابی می‌شود:</p>
<p>( 8 / 4 ) / 2    // 1</p>
<p>می‌توانید برای تغییر ترتیب واقعی ارزیابی، پرانتز اضافه کنید:</p>
<p>8 / ( 4 / 2 )    // 4</p>
<h4>عملگرهای با ارتباط راست‌به‌چپ (Right-associative operators)</h4>
<p>عملگرهای انتساب و همچنین عملگرهای lambda, null-coalescing و conditional از نوع right-associative هستند؛ به عبارت دیگر، آن‌ها از راست به چپ ارزیابی می‌شوند. Right associativity اجازه می‌دهد تا انتساب‌های چندگانه مانند زیر compile شوند:</p>
<p>C#</p>
<p>x = y = 3;
این ابتدا 3 را به y اختصاص می‌دهد و سپس نتیجه آن عبارت (3) را به x اختصاص می‌دهد.</p>
<h3>جدول عملگرها (Operator Table)</h3>
<p>Table 2-3 عملگرهای C# را به ترتیب اولویت فهرست می‌کند. عملگرهای در یک دسته‌بندی، اولویت یکسانی دارند.</p>
<p>عملگرهای user-overloadable را در &quot;Operator Overloading&quot; در صفحه ۲۵۶ توضیح می‌دهیم.</p>
<p>Table 2-3. C# operators (categories in order of precedence)</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-9.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-10-1.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-10-2.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-10-3.png" alt="Conventions-UsedThis-Book"> <br>
<img src="../../../assets/image/02/Table-2-10-4.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h2>Null Operators (عملگرهای Null)</h2>
<p>C# سه عملگر را برای سهولت کار با nullها فراهم می‌کند: null-coalescing operator, null-coalescing assignment operator, و null-conditional operator.</p>
<h3>Null-Coalescing Operator (عملگر همبسته‌ساز Null)</h3>
<p>عملگر ?? همان null-coalescing operator است. این عملگر می‌گوید: &quot;اگر operand سمت چپ non-null است، آن را به من بده؛ در غیر این صورت، یک value دیگر به من بده.&quot; برای مثال:</p>
<pre><code class="language-C#">
string s1 = null;
string s2 = s1 ?? &quot;nothing&quot;;   // s2 به &quot;nothing&quot; ارزیابی می‌شود
</code></pre>
<p>اگر lefthand expression non-null باشد، righthand expression هرگز evaluated نمی‌شود.</p>
<p>Null-coalescing operator با nullable value types نیز کار می‌کند (به &quot;Nullable Value Types&quot; در صفحه ۲۱۰ مراجعه کنید).</p>
<h3>Null-Coalescing Assignment Operator (عملگر انتساب همبسته‌ساز Null)</h3>
<p>عملگر ??= (معرفی شده در C# 8) همان null-coalescing assignment operator است. این عملگر می‌گوید: &quot;اگر operand سمت چپ null است، right operand را به left operand assign کن.&quot; موارد زیر را در نظر بگیرید:</p>
<pre><code class="language-C#">
myVariable ??= someDefault;
</code></pre>
<p>این معادل با موارد زیر است:</p>
<pre><code class="language-C#">
if (myVariable == null) myVariable = someDefault;
</code></pre>
<p>Operator ??= به ویژه در پیاده‌سازی lazily calculated properties مفید است. ما این موضوع را بعداً در &quot;Calculated Fields and Lazy Evaluation&quot; در صفحه ۲۳۳ پوشش خواهیم داد.</p>
<h3>Null-Conditional Operator (عملگر شرطی Null)</h3>
<p>عملگر ?. همان null-conditional یا &quot;Elvis&quot; operator است (نامگذاری شده پس از Elvis emoticon). این عملگر به شما اجازه می‌دهد تا methods را فراخوانی کرده و به members دسترسی پیدا کنید، دقیقاً مانند standard dot operator، با این تفاوت که اگر operand در سمت چپ null باشد، expression به جای پرتاب NullReferenceException به null ارزیابی می‌شود:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
string s = sb?.ToString();  // خطایی رخ نمی‌دهد؛ s به null ارزیابی می‌شود
</code></pre>
<p>خط آخر معادل با موارد زیر است:</p>
<pre><code class="language-C#">
string s = (sb == null ? null : sb.ToString());
</code></pre>
<p>Null-conditional expressions با indexers نیز کار می‌کنند:</p>
<pre><code class="language-C#">
string[] words = null;
string word = words?[1];   // word is null
</code></pre>
<p>هنگام برخورد با null، Elvis operator بقیه expression را short-circuits می‌کند. در مثال زیر، s به null ارزیابی می‌شود، حتی با وجود standard dot operator بین ToString() و ToUpper():</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
string s = sb?.ToString().ToUpper();   // s به null ارزیابی می‌شود بدون خطا
</code></pre>
<p>استفاده مکرر از Elvis تنها در صورتی ضروری است که operand بلافاصله سمت چپ آن ممکن است null باشد. عبارت زیر نسبت به x که null است و x.y که null است مقاوم است:</p>
<p>x?.y?.z
این معادل موارد زیر است (با این تفاوت که x.y فقط یک بار evaluated می‌شود):</p>
<pre><code class="language-C#">
x == null ? null 
          : (x.y == null ? null : x.y.z)
</code></pre>
<p>Final expression باید قادر به پذیرش null باشد. موارد زیر غیرقانونی است:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
int length = sb?.ToString().Length;   // غیرقانونی: int نمی‌تواند null باشد
</code></pre>
<p>ما می‌توانیم این مشکل را با استفاده از nullable value types برطرف کنیم (به &quot;Nullable Value Types&quot; در صفحه ۲۱۰ مراجعه کنید). اگر از قبل با nullable value types آشنا هستید، در اینجا یک پیش‌نمایش آورده شده است:</p>
<pre><code class="language-C#">
int? length = sb?.ToString().Length;   // OK: int? می‌تواند null باشد
</code></pre>
<p>همچنین می‌توانید از null-conditional operator برای فراخوانی یک void method استفاده کنید:</p>
<pre><code class="language-C#">
someObject?.SomeVoidMethod();
</code></pre>
<p>اگر someObject null باشد، این به یک &quot;no-operation&quot; تبدیل می‌شود به جای پرتاب NullReferenceException.</p>
<p>می‌توانید از null-conditional operator با type members رایج که در Chapter 3 توضیح می‌دهیم، از جمله methods, fields, properties, و indexers استفاده کنید. همچنین به خوبی با null-coalescing operator ترکیب می‌شود:</p>
<pre><code class="language-C#">
System.Text.StringBuilder sb = null;
string s = sb?.ToString() ?? &quot;nothing&quot;;   // s به &quot;nothing&quot; ارزیابی می‌شود
</code></pre>
<h2>Statements (عبارات)</h2>
<p>Functions شامل statementsی هستند که به صورت متوالی و به ترتیبی که در متن ظاهر می‌شوند، اجرا می‌گردند. یک statement block مجموعه‌ای از statements است که بین braces (توکن‌های {}) قرار می‌گیرد.</p>
<h3>Declaration Statements (عبارات اعلامی)</h3>
<p>یک variable declaration یک variable جدید را معرفی می‌کند، که به صورت optionally با یک expression مقداردهی اولیه می‌شود. می‌توانید چندین variable از یک type را در یک لیست جدا شده با comma اعلان کنید:</p>
<pre><code class="language-C#">
string someWord = &quot;rosebud&quot;;
int someNumber = 42;
bool rich = true, famous = false;
</code></pre>
<p>یک constant declaration مانند یک variable declaration است با این تفاوت که پس از اعلان نمی‌توان آن را تغییر داد، و مقداردهی اولیه باید همراه با اعلان انجام شود (به &quot;Constants&quot; در صفحه ۱۰۴ مراجعه کنید):</p>
<pre><code class="language-C#">
const double c = 2.99792458E08;
c += 10;                        // Compile-time Error
</code></pre>
<h4>Local variables (متغیرهای محلی)</h4>
<p>Scope یک local variable یا local constant در سراسر current block گسترش می‌یابد. نمی‌توانید یک local variable دیگر با همان نام را در current block یا در هر nested blockی اعلان کنید:</p>
<pre><code class="language-C#">
int x;
{
  int y;
  int x;            // Error - x already defined
}
{
  int y;            // OK - y not in scope
}
Console.Write (y);  // Error - y is out of scope
</code></pre>
<p>Scope یک variable در هر دو جهت در سراسر code block آن گسترش می‌یابد. این بدان معناست که اگر ما اعلان اولیه x را در این مثال به انتهای method منتقل کنیم، همان error را دریافت خواهیم کرد. این در تضاد با C++ است و تا حدودی عجیب است، با توجه به اینکه ارجاع به یک variable یا constant قبل از اعلان آن قانونی نیست.</p>
<h3>Expression Statements (عبارات بیانی)</h3>
<p>Expression statements expressionsی هستند که همچنین statements معتبری محسوب می‌شوند. یک expression statement باید یا state را تغییر دهد یا چیزی را فراخوانی کند که ممکن است state را تغییر دهد. Changing state اساساً به معنای تغییر یک variable است. در ادامه expression statements ممکن آورده شده‌اند:</p>
<ul>
<li>
<p>Assignment expressions (شامل increment و decrement expressions)</p>
</li>
<li>
<p>Method call expressions (هم void و هم nonvoid)</p>
</li>
<li>
<p>Object instantiation expressions</p>
</li>
</ul>
<p>در اینجا چند مثال آورده شده است:</p>
<pre><code class="language-C#">
// Declare variables with declaration statements:
string s;
int x, y;
System.Text.StringBuilder sb;

// Expression statements
x = 1 + 2;                 // Assignment expression
x++;                       // Increment expression
y = Math.Max (x, 5);       // Assignment expression
Console.WriteLine (y);     // Method call expression
sb = new StringBuilder();  // Assignment expression
new StringBuilder();       // Object instantiation expression
</code></pre>
<p>هنگامی که یک constructor یا یک method را فراخوانی می‌کنید که یک value را return می‌کند، مجبور به استفاده از نتیجه نیستید. با این حال، مگر اینکه constructor یا method state را تغییر دهد، statement کاملاً بی‌فایده است:</p>
<pre><code class="language-C#">
new StringBuilder();     // Legal, but useless
new string ('c', 3);     // Legal, but useless
x.Equals (y);            // Legal, but useless
</code></pre>
<h3>Selection Statements (عبارات انتخابی)</h3>
<p>C# دارای مکانیزم‌های زیر برای کنترل شرطی جریان اجرای برنامه است:</p>
<ul>
<li>
<p>Selection statements (if, switch)</p>
</li>
<li>
<p>Conditional operator (?:)</p>
</li>
<li>
<p>Loop statements (while, do-while, for, foreach)</p>
</li>
</ul>
<p>این بخش دو ساختار ساده‌تر را پوشش می‌دهد: if statement و switch statement.</p>
<h4>The if statement (عبارت if)</h4>
<p>یک if statement یک statement را اجرا می‌کند اگر یک bool expression true باشد:</p>
<pre><code class="language-C#">
if (5 &lt; 2 * 3)
 Console.WriteLine (&quot;true&quot;);       // true
</code></pre>
<p>Statement می‌تواند یک code block باشد:</p>
<pre><code class="language-C#">
if (5 &lt; 2 * 3)
{
  Console.WriteLine (&quot;true&quot;);
  Console.WriteLine (&quot;Let’s move on!&quot;);
}
</code></pre>
<h4>The else clause (بند else)</h4>
<p>یک if statement می‌تواند به صورت optionally شامل یک else clause باشد:</p>
<pre><code class="language-C#">
if (2 + 2 == 5)
 Console.WriteLine (&quot;Does not compute&quot;);
else
 Console.WriteLine (&quot;False&quot;);        // False
</code></pre>
<p>درون یک else clause، می‌توانید یک if statement دیگر را nest کنید:</p>
<pre><code class="language-C#">
if (2 + 2 == 5)
Console.WriteLine (&quot;Does not compute&quot;);
else
if (2 + 2 == 4)
Console.WriteLine (&quot;Computes&quot;);    // Computes
</code></pre>
<h3>تغییر جریان اجرا با Braces (آکولادها)</h3>
<p>یک else clause همیشه به if statement بلافاصله قبل از خود در statement block اعمال می‌شود:</p>
<pre><code class="language-C#">
if (true)
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine (&quot;executes&quot;);
</code></pre>
<p>این از نظر معنایی (semantically) دقیقاً معادل با موارد زیر است:</p>
<pre><code class="language-C#">
if (true)
{
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine (&quot;executes&quot;);
}
</code></pre>
<p>می‌توانیم با جابجایی braces، جریان اجرا را تغییر دهیم:</p>
<pre><code class="language-C#">
if (true)
{
  if (false)
    Console.WriteLine();
}
else
  Console.WriteLine (&quot;does not execute&quot;);
</code></pre>
<p>با braces، شما به صراحت قصد (intention) خود را بیان می‌کنید. این می‌تواند خوانایی nested if statements را بهبود بخشد—حتی زمانی که compiler آن را الزامی نمی‌داند. یک استثنای قابل توجه در مورد الگوی زیر است:</p>
<pre><code class="language-C#">
void TellMeWhatICanDo (int age)
{
  if (age &gt;= 35)
    Console.WriteLine (&quot;You can be president!&quot;);
  else if (age &gt;= 21)
    Console.WriteLine (&quot;You can drink!&quot;);
  else if (age &gt;= 18)
    Console.WriteLine (&quot;You can vote!&quot;);
  else
    Console.WriteLine (&quot;You can wait!&quot;);
}
</code></pre>
<p>در اینجا، if و else statements را به گونه‌ای چیده‌ایم که ساختار &quot;elseif&quot; سایر زبان‌ها (و C#’s #elif preprocessor directive) را تقلید کند. auto-formatting Visual Studio این الگو را تشخیص داده و indentation را حفظ می‌کند. با این حال، از نظر معنایی، هر if statement که به دنبال یک else statement می‌آید، از نظر کارکردی (functionally) درون else clause تو در تو (nested) قرار گرفته است.</p>
<h4>The switch statement (عبارت switch)</h4>
<p>switch statements به شما امکان می‌دهند اجرای برنامه را بر اساس مجموعه‌ای از possible values که یک variable ممکن است داشته باشد، شاخه بندی (branch) کنید. switch statements می‌توانند منجر به code تمیزتری نسبت به چندین if statement شوند، زیرا switch statements فقط یک بار نیاز به ارزیابی یک expression دارند:</p>
<pre><code class="language-C#">
void ShowCard (int cardNumber)
{
  switch (cardNumber)
  {
    case 13:
      Console.WriteLine (&quot;King&quot;);
      break;
    case 12:
      Console.WriteLine (&quot;Queen&quot;);
      break;
    case 11:
      Console.WriteLine (&quot;Jack&quot;);
      break;
    case -1:                         // Joker is -1
      goto case 12;                  // In this game joker counts as queen
    default:                         // Executes for any other cardNumber
      Console.WriteLine (cardNumber);
      break;
  }
}
</code></pre>
<p>این مثال رایج‌ترین سناریو را نشان می‌دهد، که سوئیچ کردن (switching) بر روی constants است. هنگامی که یک constant را مشخص می‌کنید، محدود به built-in numeric types و types bool, char, string, و enum هستید.</p>
<p>در انتهای هر case clause، باید به صراحت مشخص کنید که اجرای بعدی به کجا باید برود، با نوعی از jump statement (مگر اینکه code شما به یک infinite loop ختم شود). در اینجا گزینه‌ها آمده‌اند:</p>
<ul>
<li>
<p>break (به انتهای switch statement پرش می‌کند)</p>
</li>
<li>
<p>goto case x (به یک case clause دیگر پرش می‌کند)</p>
</li>
<li>
<p>goto default (به default clause پرش می‌کند)</p>
</li>
<li>
<p>هر jump statement دیگری—یعنی return, throw, continue, یا goto label</p>
</li>
</ul>
<p>هنگامی که بیش از یک value باید همان code را اجرا کند، می‌توانید common cases را به صورت متوالی لیست کنید:</p>
<pre><code class="language-C#">
switch (cardNumber)
{
  case 13:
  case 12:
  case 11:
    Console.WriteLine (&quot;Face card&quot;);
    break;
  default:
    Console.WriteLine (&quot;Plain card&quot;);
    break;
}
</code></pre>
<p>این ویژگی یک switch statement می‌تواند در تولید code تمیزتر نسبت به چندین if-else statements بسیار مهم باشد.</p>
<h4>Switching on types (سوئیچ کردن بر روی انواع)</h4>
<p>Switching on a type یک حالت خاص از switching on a pattern است.</p>
<p>تعدادی از patterns دیگر در نسخه‌های اخیر C# معرفی شده‌اند؛ برای بحث کامل به &quot;Patterns&quot; در صفحه ۲۳۸ مراجعه کنید.</p>
<p>همچنین می‌توانید بر روی types سوئیچ کنید (از C# 7):</p>
<pre><code class="language-C#">
TellMeTheType (12);
TellMeTheType (&quot;hello&quot;);
TellMeTheType (true);

void TellMeTheType (object x)   // object اجازه هر typeی را می‌دهد.
{
  switch (x)
  {
    case int i:
      Console.WriteLine (&quot;It's an int!&quot;);
      Console.WriteLine ($&quot;The square of {i} is {i * i}&quot;);
      break;
    case string s:
      Console.WriteLine (&quot;It's a string&quot;);
      Console.WriteLine ($&quot;The length of {s} is {s.Length}&quot;);
      break;
    case DateTime:
      Console.WriteLine (&quot;It's a DateTime&quot;);
      break;
    default:
      Console.WriteLine (&quot;I don't know what x is&quot;);
      break;
  }
}
</code></pre>
<p>(object type اجازه یک variable از هر type را می‌دهد؛ ما این را به طور کامل در &quot;Inheritance&quot; در صفحه ۱۲۶ و &quot;The object Type&quot; در صفحه ۱۳۸ بحث می‌کنیم.)</p>
<p>هر case clause یک type را برای مطابقت مشخص می‌کند، و یک variable را برای assign کردن typed value در صورت موفقیت match (متغیر &quot;pattern&quot;). برخلاف constants، هیچ محدودیتی در مورد typesی که می‌توانید استفاده کنید وجود ندارد.</p>
<p>می‌توانید یک case را با keyword when پیش‌بینی (predicate) کنید:</p>
<pre><code class="language-C#">
switch (x)
{
  case bool b when b == true:
    Console.WriteLine (&quot;True!&quot;);
    break;
  case bool b:
     // Fires only when b is true
    Console.WriteLine (&quot;False!&quot;);
    break;
}
</code></pre>
<p>ترتیب case clauses می‌تواند هنگام switching on type مهم باشد (برخلاف switching on constants). این مثال اگر دو case را معکوس می‌کردیم، نتیجه متفاوتی می‌داد (در واقع، حتی compile هم نمی‌شد، زیرا compiler تشخیص می‌داد که second case قابل دسترسی نیست). یک استثنا در این قانون default clause است، که همیشه در آخر اجرا می‌شود، صرف نظر از جایی که ظاهر می‌شود.</p>
<p>می‌توانید چندین case clause را روی هم پشته (stack) کنید. Console.WriteLine در کد زیر برای هر floating-point type بزرگتر از ۱۰۰۰ اجرا خواهد شد:</p>
<pre><code class="language-C#">
switch (x)
{
  case float f when f &gt; 1000:
  case double d when d &gt; 1000:
  case decimal m when m &gt; 1000:
    Console.WriteLine (&quot;We can refer to x here but not f or d or m&quot;);
    break;
}
</code></pre>
<p>در این مثال، compiler به ما اجازه می‌دهد pattern variables f, d, و m را فقط در when clauses مصرف کنیم. هنگامی که Console.WriteLine را فراخوانی می‌کنیم، مشخص نیست که کدام یک از آن سه variable مقداردهی خواهد شد، بنابراین compiler همه آنها را از scope خارج می‌کند.</p>
<p>می‌توانید constants و patterns را در یک switch statement ترکیب و تطبیق دهید. و همچنین می‌توانید بر روی null value سوئیچ کنید:</p>
<pre><code class="language-C#">
case null:
  Console.WriteLine (&quot;Nothing here&quot;);
  break;
</code></pre>
<h3>عبارات سوئیچ (Switch expressions)</h3>
<p>از C# 8 به بعد، شما می‌توانید از switch در قالب یک عبارت استفاده کنید. با فرض اینکه cardNumber از نوع int است، مثال زیر کاربرد آن را نشان می‌دهد:</p>
<pre><code class="language-C#">
string cardName = cardNumber switch
{
  13 =&gt; &quot;King&quot;,
  12 =&gt; &quot;Queen&quot;,
  11 =&gt; &quot;Jack&quot;,
  _ =&gt; &quot;Pip card&quot;   // معادل 'default'
};
</code></pre>
<p>توجه کنید که کلمه کلیدی switch پس از نام متغیر ظاهر می‌شود و case clauses (بندهای مورد) عبارت هستند (که با کاما خاتمه می‌یابند) نه دستور. عبارات سوئیچ فشرده‌تر از معادل‌های switch statement خود هستند و می‌توانید از آن‌ها در پرس‌وجوهای LINQ (فصل ۸) استفاده کنید.</p>
<p>اگر عبارت پیش‌فرض (_) را حذف کنید و سوئیچ نتواند تطابقی پیدا کند، یک استثنا پرتاب می‌شود.</p>
<p>شما همچنین می‌توانید روی چندین مقدار سوئیچ کنید (الگوی تاپل):</p>
<pre><code class="language-C#">
int cardNumber = 12;
string suite = &quot;spades&quot;;
string cardName = (cardNumber, suite) switch
{
  (13, &quot;spades&quot;) =&gt; &quot;King of spades&quot;,
  (13, &quot;clubs&quot;) =&gt; &quot;King of clubs&quot;,
  ...
};
</code></pre>
<p>گزینه‌های بسیار بیشتری از طریق استفاده از الگوها ممکن است (به &quot;Patterns&quot; در صفحه ۲۳۸ مراجعه کنید).</p>
<h3>دستورات تکرار (Iteration Statements)</h3>
<p>C# یک دنباله از دستورات را با استفاده از دستورات while، do-while، for و foreach به صورت مکرر اجرا می‌کند.</p>
<h4>حلقه‌های while و do-while</h4>
<p>حلقه‌های while به صورت مکرر بدنه کد را تا زمانی که یک عبارت bool درست باشد، اجرا می‌کنند. این عبارت قبل از اجرای بدنه حلقه تست می‌شود. برای مثال، کد زیر &quot;012&quot; را می‌نویسد:</p>
<pre><code class="language-C#">
int i = 0;
while (i &lt; 3)
{
  Console.Write (i);
  i++;
}
</code></pre>
<p>حلقه‌های do-while از نظر عملکردی تنها در این مورد با حلقه‌های while تفاوت دارند که عبارت را بعد از اجرای بلوک دستور تست می‌کنند (که تضمین می‌کند بلوک حداقل یک بار اجرا می‌شود). در اینجا مثال قبلی با حلقه do-while بازنویسی شده است:</p>
<pre><code class="language-C#">
int i = 0;
do
{
  Console.WriteLine (i);
  i++;
}
while (i &lt; 3);
</code></pre>
<h4>حلقه‌های for</h4>
<p>حلقه‌های for مانند حلقه‌های while هستند با بندهای خاصی برای مقداردهی اولیه و تکرار یک متغیر حلقه. یک حلقه for شامل سه بند به صورت زیر است:</p>
<pre><code class="language-C#">
for (initialization-clause; condition-clause; iteration-clause)
  statement-or-statement-block
</code></pre>
<p>در اینجا هر بند چه کاری انجام می‌دهد:</p>
<p>بند مقداردهی اولیه (Initialization clause): قبل از شروع حلقه اجرا می‌شود؛ برای مقداردهی اولیه یک یا چند متغیر تکرار استفاده می‌شود.</p>
<p>بند شرط (Condition clause): عبارت boolی که تا زمانی که درست باشد، بدنه را اجرا می‌کند.</p>
<p>بند تکرار (Iteration clause): پس از هر تکرار بلوک دستور اجرا می‌شود؛ معمولاً برای به‌روزرسانی متغیر تکرار استفاده می‌گردد.</p>
<p>برای مثال، کد زیر اعداد 0 تا 2 را چاپ می‌کند:</p>
<pre><code class="language-C#">
for (int i = 0; i &lt; 3; i++)
  Console.WriteLine (i);
</code></pre>
<p>کد زیر ۱۰ عدد اول فیبوناچی را چاپ می‌کند (که در آن هر عدد مجموع دو عدد قبلی است):</p>
<pre><code class="language-C#">
for (int i = 0, prevFib = 1, curFib = 1; i &lt; 10; i++)
{
  Console.WriteLine (prevFib);
  int newFib = prevFib + curFib;
  prevFib = curFib; curFib = newFib;
}
</code></pre>
<p>هر یک از سه بخش دستور for را می‌توان حذف کرد. شما می‌توانید یک حلقه بی‌نهایت مانند زیر پیاده‌سازی کنید (البته while(true) را می‌توان به جای آن استفاده کرد):</p>
<pre><code class="language-C#">
for (;;)
  Console.WriteLine (&quot;interrupt me&quot;);
</code></pre>
<h4>حلقه‌های foreach</h4>
<p>دستور foreach روی هر عنصر در یک شیء قابل شمارش (enumerable object) تکرار می‌کند. بیشتر انواع .NET که یک مجموعه یا لیست از عناصر را نشان می‌دهند، قابل شمارش هستند. برای مثال، هم یک آرایه و هم یک رشته قابل شمارش هستند. در اینجا مثالی از شمارش روی کاراکترهای یک رشته، از اولین کاراکتر تا آخرین آن آمده است:</p>
<pre><code class="language-C#">
foreach (char c in &quot;beer&quot;)   // c متغیر تکرار است
  Console.WriteLine (c);
</code></pre>
<p>خروجی به این صورت است:</p>
<p>b
e
e
r
ما اشیاء قابل شمارش را در &quot;Enumeration and Iterators&quot; در صفحه ۲۰۳ تعریف می‌کنیم.</p>
<h3>دستورات پرش (Jump Statements)</h3>
<p>دستورات پرش در C# عبارتند از break, continue, goto, return, و throw.</p>
<p>دستورات پرش از قوانین قابلیت اطمینان دستورات try پیروی می‌کنند (به &quot;try Statements and Exceptions&quot; در صفحه ۱۹۵ مراجعه کنید). این بدان معناست که:</p>
<ul>
<li>
<p>یک پرش از یک بلوک try همیشه بلوک finally مربوط به try را قبل از رسیدن به هدف پرش اجرا می‌کند.</p>
</li>
<li>
<p>یک پرش نمی‌تواند از داخل به خارج یک بلوک finally انجام شود (مگر از طریق throw).</p>
</li>
</ul>
<h4>دستور break</h4>
<p>دستور break اجرای بدنه یک تکرار یا دستور سوئیچ را به پایان می‌رساند:</p>
<pre><code class="language-C#">
int x = 0;
while (true)
{
  if (x++ &gt; 5)
    break;      // از حلقه خارج می‌شود
}

// اجرا بعد از break در اینجا ادامه می‌یابد
...
</code></pre>
<h3>دستور continue</h3>
<p>دستور continue از دستورات باقی‌مانده در یک حلقه صرف‌نظر می‌کند و یک شروع زودهنگام بر روی تکرار بعدی دارد. حلقه زیر اعداد زوج را رد می‌کند:</p>
<pre><code class="language-C#">
for (int i = 0; i &lt; 10; i++)
{
  if ((i % 2) == 0)       // اگر i زوج باشد،
    continue;             // با تکرار بعدی ادامه می‌دهد
  Console.Write (i + &quot; &quot;);
}
</code></pre>
<p>خروجی: 1 3 5 7 9</p>
<h3>دستور goto</h3>
<p>دستور goto اجرا را به یک برچسب دیگر در یک بلوک دستور منتقل می‌کند. فرم آن به صورت زیر است:</p>
<pre><code class="language-C#">
goto statement-label;
</code></pre>
<p>یا، زمانی که در یک دستور سوئیچ استفاده می‌شود:</p>
<pre><code class="language-C#">
goto case case-constant;    // (فقط با constants کار می‌کند، نه patterns)
</code></pre>
<p>یک برچسب (label) یک جایگزین در یک بلوک کد است که قبل از یک دستور قرار می‌گیرد، و با یک پسوند دو نقطه مشخص می‌شود. کد زیر اعداد ۱ تا ۵ را تکرار می‌کند، که تقلیدی از یک حلقه for است:</p>
<pre><code class="language-C#">
int i = 1;
startLoop:
if (i &lt;= 5)
{
  Console.Write (i + &quot; &quot;);
  i++;
  goto startLoop;
}
</code></pre>
<p>خروجی: 1 2 3 4 5</p>
<p>goto case case-constant اجرا را به یک case دیگر در یک بلوک switch منتقل می‌کند (به &quot;The switch statement&quot; در صفحه ۸۸ مراجعه کنید).</p>
<h4>دستور return</h4>
<p>دستور return از متد خارج می‌شود و اگر متد nonvoid باشد، باید یک عبارت از نوع بازگشتی متد را برگرداند:</p>
<pre><code class="language-C#">
decimal AsPercentage (decimal d)
{
  decimal p = d * 100m;
  return p;             // با مقدار به متد فراخواننده برمی‌گردد
}
</code></pre>
<p>یک دستور return می‌تواند در هر جایی در یک متد (به جز در یک بلوک finally) ظاهر شود، و می‌تواند بیش از یک بار استفاده شود.</p>
<h4>دستور throw</h4>
<p>دستور throw یک استثنا را پرتاب می‌کند تا نشان دهد خطایی رخ داده است (به &quot;try Statements and Exceptions&quot; در صفحه ۱۹۵ مراجعه کنید):</p>
<pre><code class="language-C#">
if (w == null)
  throw new ArgumentNullException (...);
</code></pre>
<h3>دستورات متفرقه (Miscellaneous Statements)</h3>
<p>دستور using: یک نحو زیبا برای فراخوانی Dispose بر روی اشیایی که IDisposable را پیاده‌سازی می‌کنند، در یک بلوک finally فراهم می‌کند (به &quot;try Statements and Exceptions&quot; در صفحه ۱۹۵ و &quot;IDisposable, Dispose, and Close&quot; در صفحه ۵۸۱ مراجعه کنید).</p>
<p>C# کلمه کلیدی using را برای داشتن معانی مستقل در زمینه‌های مختلف overload می‌کند. به طور خاص، دستورالعمل using با دستور using متفاوت است.</p>
<p>دستور lock: یک میانبر برای فراخوانی متدهای Enter و Exit از کلاس Monitor است (به فصل‌های ۱۴ و ۲۳ مراجعه کنید).</p>
<h2>فضاهای نام (Namespaces)</h2>
<p>یک فضای نام (namespace) یک دامنه برای نام‌گذاری انواع (type names) است. انواع معمولاً در فضاهای نام سلسله‌مراتبی سازماندهی می‌شوند، که پیدا کردن آن‌ها را آسان‌تر کرده و از تداخل نام‌ها جلوگیری می‌کند. برای مثال، نوع RSA که رمزگذاری کلید عمومی را مدیریت می‌کند، در فضای نام زیر تعریف شده است:</p>
<pre><code>System.Security.Cryptography
</code></pre>
<p>فضای نام بخش جدایی‌ناپذیری از نام یک نوع را تشکیل می‌دهد. کد زیر متد Create از RSA را فراخوانی می‌کند:</p>
<pre><code class="language-C#">
System.Security.Cryptography.RSA rsa =
 System.Security.Cryptography.RSA.Create();
</code></pre>
<p>فضاهای نام مستقل از Assemblies هستند، که فایل‌های dll. به عنوان واحدهای استقرار (deployment) عمل می‌کنند (در فصل ۱۷ توضیح داده شده‌اند). فضاهای نام همچنین هیچ تأثیری بر قابلیت مشاهده اعضا (member visibility)—public، internal، private و غیره—ندارند.</p>
<p>کلمه کلیدی namespace یک فضای نام را برای انواع درون آن بلوک تعریف می‌کند:</p>
<pre><code class="language-C#">
namespace Outer.Middle.Inner
{
  class Class1 {}
  class Class2 {}
}
</code></pre>
<p>نقطه‌ها در فضای نام نشان‌دهنده یک سلسله‌مراتب از فضاهای نام تو در تو هستند. کد زیر از نظر معنایی با مثال قبلی یکسان است:</p>
<pre><code class="language-C#">
namespace Outer
{
  namespace Middle
  {
    namespace Inner
    {
      class Class1 {}
      class Class2 {}
    }
  }
}
</code></pre>
<p>می‌توانید به یک نوع با نام کاملاً واجد شرایط (fully qualified name) آن ارجاع دهید، که شامل تمام فضاهای نام از بیرونی‌ترین تا درونی‌ترین است. برای مثال، می‌توانستیم به Class1 در مثال قبلی به صورت Outer.Middle.Inner.Class1 ارجاع دهیم.</p>
<p>انواعی که در هیچ فضای نامی تعریف نشده‌اند، گفته می‌شود که در فضای نام سراسری (global namespace) قرار دارند. فضای نام سراسری همچنین شامل فضاهای نام سطح بالا (top-level namespaces)، مانند Outer در مثال ما است.</p>
<h3>فضاهای نام محدود به فایل (File-Scoped Namespaces)</h3>
<p>اغلب می‌خواهید تمام انواع در یک فایل در یک فضای نام تعریف شوند:</p>
<pre><code class="language-C#">
namespace MyNamespace
{
  class Class1 {}
  class Class2 {}
}
</code></pre>
<p>از C# 10 به بعد، می‌توانید این کار را با یک فضای نام محدود به فایل انجام دهید:</p>
<pre><code class="language-C#">
namespace MyNamespace;  // اعمال می‌شود به هر چیزی که در فایل بعد از آن می‌آید.
class Class1 {}         // داخل MyNamespace
class Class2 {}         // داخل MyNamespace
</code></pre>
<p>فضاهای نام محدود به فایل از شلوغی کم می‌کنند و یک سطح غیرضروری از تورفتگی را از بین می‌برند.</p>
<h3>دستور using (The using Directive)</h3>
<p>دستور using یک فضای نام را وارد (import) می‌کند و به شما اجازه می‌دهد بدون نام‌های کاملاً واجد شرایط به انواع ارجاع دهید. کد زیر فضای نام Outer.Middle.Inner مثال قبلی را وارد می‌کند:</p>
<pre><code class="language-C#">
using Outer.Middle.Inner;
Class1 c;    // نیازی به نام کاملاً واجد شرایط نیست
</code></pre>
<p>تعریف نام‌های نوع یکسان در فضاهای نام مختلف قانونی (و اغلب مطلوب) است. با این حال، معمولاً این کار را تنها در صورتی انجام می‌دهید که بعید باشد یک مصرف‌کننده بخواهد هر دو فضای نام را به طور همزمان وارد کند. یک مثال خوب کلاس TextBox است که هم در System.Windows.Controls (WPF) و هم در System.Windows.Forms (Windows Forms) تعریف شده است.</p>
<p>یک دستور using می‌تواند درون یک فضای نام تو در تو قرار گیرد تا دامنه (scope) دستور را محدود کند.</p>
<h3>دستور global using</h3>
<p>از C# 10 به بعد، اگر پیشوند global را به یک دستور using اضافه کنید، آن دستور در تمام فایل‌های پروژه یا واحد کامپایل اعمال خواهد شد:</p>
<pre><code class="language-C#">
global using System;
global using System.Collection.Generic;
</code></pre>
<p>این به شما امکان می‌دهد واردات رایج را متمرکز کنید و از تکرار دستورات یکسان در هر فایل جلوگیری کنید.</p>
<p>دستورات global using باید قبل از دستورات غیرسراسری بیایند و نمی‌توانند درون اعلان‌های فضای نام ظاهر شوند. دستور global را می‌توان با using static نیز استفاده کرد.</p>
<h4>Implicit global usings</h4>
<p>از .NET 6، فایل‌های پروژه امکان استفاده از implicit global using directives را فراهم می‌کنند. اگر عنصر ImplicitUsings در فایل پروژه بر روی true تنظیم شود (که مقدار پیش‌فرض برای پروژه‌های جدید است)، فضاهای نام زیر به طور خودکار وارد می‌شوند:</p>
<pre><code class="language-System">
System.Collections.Generic

System.IO

System.Linq

System.Net.Http

System.Threading

System.Threading.Tasks
</code></pre>
<p>فضاهای نام اضافی بر اساس SDK پروژه (Web, Windows Forms, WPF و غیره) وارد می‌شوند.</p>
<h4>using static</h4>
<p>دستور using static به جای یک فضای نام، یک نوع (type) را وارد می‌کند. سپس تمام اعضای static آن نوع وارد شده می‌توانند بدون نیاز به ذکر نام نوع استفاده شوند. در مثال زیر، ما متد static WriteLine از کلاس Console را بدون نیاز به ارجاع به نوع آن فراخوانی می‌کنیم:</p>
<pre><code class="language-C#">
using static System.Console;
WriteLine (&quot;Hello&quot;);
</code></pre>
<p>دستور using static تمام اعضای static قابل دسترسی یک نوع را وارد می‌کند، شامل فیلدها (fields)، ویژگی‌ها (properties) و انواع تو در تو (nested types) (فصل ۳). شما همچنین می‌توانید این دستور را بر روی انواع enum (فصل ۳) اعمال کنید، که در این صورت اعضای آن‌ها وارد می‌شوند. بنابراین، اگر نوع enum زیر را وارد کنیم:</p>
<pre><code class="language-C#">
using static System.Windows.Visibility;
</code></pre>
<p>می‌توانیم به جای Visibility.Hidden از Hidden استفاده کنیم:</p>
<pre><code class="language-C#">
var textBox = new TextBox { Visibility = Hidden };   // سبک XAML
</code></pre>
<p>اگر بین چندین واردات static ابهامی ایجاد شود، کامپایلر C# به اندازه‌ای هوشمند نیست که نوع صحیح را از متن استنباط کند و یک خطا تولید خواهد کرد.</p>
<h3>قوانین در یک فضای نام (Rules Within a Namespace)</h3>
<h4>محدوده‌بندی نام (Name scoping)</h4>
<p>نام‌هایی که در فضاهای نام بیرونی‌تر تعریف شده‌اند، می‌توانند بدون واجد شرایط بودن (unqualified) در فضاهای نام درونی‌تر استفاده شوند. در این مثال، Class1 در داخل Inner نیازی به واجد شرایط بودن ندارد:</p>
<pre><code class="language-C#">
namespace Outer
{
  class Class1 {}
  namespace Inner
  {
    class Class2 : Class1  {}
  }
}
</code></pre>
<p>اگر می‌خواهید به یک نوع در یک شاخه متفاوت از سلسله‌مراتب فضای نام خود ارجاع دهید، می‌توانید از یک نام با شرایط جزئی (partially qualified name) استفاده کنید. در مثال زیر، ما SalesReport را بر اساس Common.ReportBase قرار می‌دهیم:</p>
<pre><code class="language-C#">
namespace MyTradingCompany
{
  namespace Common
  {
    class ReportBase {}
  }
  namespace ManagementReporting
  {
    class SalesReport : Common.ReportBase  {}
  }
}
</code></pre>
<h4>پنهان‌سازی نام (Name hiding)</h4>
<p>اگر یک نام نوع مشابه در یک فضای نام درونی و بیرونی ظاهر شود، نام درونی اولویت دارد. برای ارجاع به نوع در فضای نام بیرونی، باید نام آن را واجد شرایط کنید:</p>
<pre><code class="language-C#">
namespace Outer
{
  class Foo { }
  namespace Inner
  {
    class Foo { }
    class Test
    {
      Foo f1;         // = Outer.Inner.Foo
      Outer.Foo f2;   // = Outer.Foo
    }
  }
}
</code></pre>
<p>تمام نام‌های نوع در زمان کامپایل به نام‌های کاملاً واجد شرایط تبدیل می‌شوند. کد زبان میانی (Intermediate Language - IL) حاوی نام‌های غیرواجد شرایط یا با شرایط جزئی نیست.</p>
<h4>فضاهای نام تکراری (Repeated namespaces)</h4>
<p>می‌توانید یک اعلان فضای نام را تکرار کنید، به شرطی که نام‌های نوع درون فضاهای نام با هم تداخل نداشته باشند:</p>
<pre><code class="language-C#">
namespace Outer.Middle.Inner
{
  class Class1 {}
}
namespace Outer.Middle.Inner
{
  class Class2 {}
}
</code></pre>
<p>حتی می‌توانیم مثال را به دو فایل منبع تقسیم کنیم به طوری که بتوانیم هر کلاس را در یک assembly متفاوت کامپایل کنیم.</p>
<p>فایل منبع ۱:</p>
<pre><code class="language-C#">
namespace Outer.Middle.Inner
{
  class Class1 {}
}
فایل منبع ۲:

C#

namespace Outer.Middle.Inner
{
  class Class2 {}
}
</code></pre>
<h4>دستورات using تو در تو (Nested using directives)</h4>
<p>می‌توانید یک دستور using را درون یک فضای نام قرار دهید. این به شما امکان می‌دهد تا دامنه (scope) دستور using را در یک اعلان فضای نام محدود کنید. در مثال زیر، Class1 در یک محدوده قابل مشاهده است اما در دیگری خیر:</p>
<pre><code class="language-C#">
namespace N1
{
  class Class1 {}
}
namespace N2
{
  using N1;
  class Class2 : Class1 {}
}
namespace N2
{
  class Class3 : Class1 {}   // خطای زمان کامپایل
}
</code></pre>
<h3>نام مستعار برای انواع و فضاهای نام (Aliasing Types and Namespaces)</h3>
<p>وارد کردن یک فضای نام می‌تواند منجر به تداخل نام نوع (type-name collision) شود. به جای وارد کردن کل فضای نام، می‌توانید فقط انواع خاصی را که نیاز دارید وارد کنید و به هر نوع یک نام مستعار (alias) بدهید:</p>
<pre><code class="language-C#">
using PropertyInfo2 = System.Reflection.PropertyInfo;
class Program { PropertyInfo2 p; }
</code></pre>
<p>یک فضای نام کامل نیز می‌تواند به صورت زیر نام مستعار داشته باشد:</p>
<pre><code class="language-C#">
using R = System.Reflection;
class Program { R.PropertyInfo p; }
</code></pre>
<h4>نام مستعار برای هر نوع (Alias any type) (C# 12)</h4>
<p>از C# 12 به بعد، دستور using می‌تواند برای هر نوعی، از جمله آرایه‌ها، نام مستعار ایجاد کند:</p>
<pre><code class="language-C#">
using NumberList = double[];
NumberList numbers = { 2.5, 3.5 };
</code></pre>
<p>همچنین می‌توانید برای تاپل‌ها نیز نام مستعار ایجاد کنید (ما این موضوع را در &quot;Aliasing Tuples (C# 12)&quot; در صفحه ۲۲۵ پوشش می‌دهیم).</p>
<h3>ویژگی‌های پیشرفته فضای نام (Advanced Namespace Features)</h3>
<h4>Extern</h4>
<p>نام‌های مستعار Extern به برنامه شما اجازه می‌دهند تا به دو نوع با نام کاملاً واجد شرایط یکسان ارجاع دهد (یعنی نام فضای نام و نام نوع یکسان هستند). این یک سناریوی غیرمعمول است و تنها زمانی رخ می‌دهد که دو نوع از assemblyهای متفاوت آمده باشند.</p>
<p>مثال:</p>
<p>کتابخانه ۱، کامپایل شده به Widgets1.dll:</p>
<pre><code class="language-C#">
namespace Widgets
{
  public class Widget {}
}
</code></pre>
<p>کتابخانه ۲، کامپایل شده به Widgets2.dll:</p>
<pre><code class="language-C#">
namespace Widgets
{
  public class Widget {}
}
</code></pre>
<p>برنامه، که به Widgets1.dll و Widgets2.dll ارجاع می‌دهد:</p>
<pre><code class="language-C#">
using Widgets;
Widget w = new Widget(); // ابهام دارد
</code></pre>
<p>برنامه نمی‌تواند کامپایل شود زیرا Widget مبهم است. نام‌های مستعار Extern می‌توانند این ابهام را حل کنند. ابتدا باید فایل .csproj برنامه را اصلاح کرده و یک نام مستعار منحصر به فرد به هر ارجاع اختصاص دهید.</p>
<p>سپس باید از دستور extern alias استفاده کنید:</p>
<pre><code class="language-C#">
extern alias W1;
extern alias W2;
W1.Widgets.Widget w1 = new W1.Widgets.Widget();
W2.Widgets.Widget w2 = new W2.Widgets.Widget();
</code></pre>
<h4>واجد شرایط کردن نام مستعار فضای نام (Namespace alias qualifiers)</h4>
<p>همانطور که قبلاً اشاره کردیم، نام‌ها در فضاهای نام درونی، نام‌ها در فضاهای نام بیرونی را پنهان می‌کنند. با این حال، گاهی اوقات حتی استفاده از یک نام نوع کاملاً واجد شرایط نیز تداخل را حل نمی‌کند.</p>
<p>برای حل چنین تداخلاتی، می‌توان نام یک فضای نام را نسبت به یکی از موارد زیر واجد شرایط کرد:</p>
<p>فضای نام سراسری (global namespace) — ریشه همه فضاهای نام (با کلمه کلیدی global مشخص می‌شود).</p>
<p>مجموعه نام‌های مستعار extern.</p>
<p>توکن :: واجد شرایط کردن نام مستعار فضای نام را انجام می‌دهد. در این مثال، ما با استفاده از فضای نام سراسری واجد شرایط می‌کنیم:</p>
<pre><code class="language-C#">
namespace N
{
  class A
  {
    static void Main()
    {
      System.Console.WriteLine (new A.B());          // ارجاع به کلاس تو در توی B
      System.Console.WriteLine (new global::A.B());   // ارجاع به کلاس B در فضای نام A
    }
    public class B {}
  }
}
namespace A
{
  class B {}
}
</code></pre>
<p>در اینجا یک مثال از واجد شرایط کردن با یک نام مستعار آورده شده است (اقتباس شده از مثال &quot;Extern&quot;):</p>
<pre><code class="language-C#">
extern alias W1;
extern alias W2;
W1::Widgets.Widget w1 = new W1::Widgets.Widget();
W2::Widgets.Widget w2 = new W2::Widgets.Widget();
</code></pre>

  </main>

  <footer>
    <p>ساخته شده با ❤️ توسط برنامه نویسان برای برنامه نویسان</p>
  </footer>
</body>
</html>
