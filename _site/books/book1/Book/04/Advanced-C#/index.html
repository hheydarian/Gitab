<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل چهارم: سی شارپ پیشرفته</h1>
<p>در این فصل، به سراغ مباحث پیشرفته زبان C# می‌رویم که بر پایه مفاهیمی بنا شده‌اند که در فصل‌های 2 و 3 بررسی کردیم.
چهار بخش اول را باید به صورت پیوسته و پشت سر هم مطالعه کنید؛ اما بخش‌های باقی‌مانده را می‌توانید به هر ترتیبی بخوانید.</p>
<h3>Delegates (نمایندگان) 📨</h3>
<p>یک delegate یک شیء است که می‌داند چگونه یک متد را فراخوانی کند.</p>
<p>نوع delegate تعیین می‌کند که نمونه‌های delegate می‌توانند چه نوع متدهایی را فراخوانی کنند. به طور مشخص، یک delegate نوع بازگشتی متد و انواع پارامترهای متد را تعریف می‌کند.</p>
<p>مثال: تعریف یک نوع delegate به نام Transformer:</p>
<pre><code class="language-c#">delegate int Transformer(int x);
</code></pre>
<p>این delegate با هر متدی که بازگشتی از نوع int داشته باشد و یک پارامتر int بگیرد سازگار است. مثل این:</p>
<pre><code class="language-c#">int Square(int x) { return x * x; }
</code></pre>
<p>یا به صورت کوتاه‌تر (expression-bodied):</p>
<pre><code class="language-c#">int Square(int x) =&gt; x * x;
</code></pre>
<p><strong>ساختن و استفاده از یک delegate 🛠️</strong></p>
<p>اختصاص یک متد به یک متغیر delegate، باعث ایجاد یک نمونه delegate می‌شود:</p>
<pre><code class="language-c#">Transformer t = Square;
</code></pre>
<p>فراخوانی یک نمونه delegate دقیقاً مثل فراخوانی یک متد است:</p>
<pre><code class="language-c#">int answer = t(3);   // answer برابر با 9
</code></pre>
<p>مثال کامل:</p>
<pre><code class="language-c#">Transformer t = Square;   // ایجاد نمونه delegate
int result = t(3);        // فراخوانی delegate
Console.WriteLine(result); // خروجی: 9

int Square(int x) =&gt; x * x;

delegate int Transformer(int x);  // تعریف نوع delegate
</code></pre>
<p><strong>مفهوم اصلی delegate 🎯</strong></p>
<p>یک نمونه delegate واقعاً به عنوان نماینده‌ی caller عمل می‌کند:
caller (فراخواننده) delegate را فراخوانی می‌کند و سپس delegate، متد هدف را فراخوانی می‌کند.</p>
<p>این واسطه‌گری (indirection) باعث می‌شود که caller از متد هدف جدا و مستقل باشد.</p>
<p><strong>نکته‌های مهم ✅</strong></p>
<p>دستور:</p>
<pre><code>Transformer t = Square;
</code></pre>
<p>در واقع یک میان‌بُر (shorthand) برای این است:</p>
<pre><code class="language-c#">Transformer t = new Transformer(Square);
</code></pre>
<p>عبارت:</p>
<pre><code>t(3)
</code></pre>
<p>میان‌بُری است برای:</p>
<pre><code>t.Invoke(3)
</code></pre>
<p>از نظر فنی، وقتی به Square بدون پرانتز و آرگومان اشاره می‌کنیم، در حال مشخص کردن یک method group هستیم.
اگر متد overload شده باشد، کامپایلر C# بر اساس امضای delegate انتخاب می‌کند که کدام overload مناسب است.</p>
<p><strong>Delegate شبیه به Callback 📞</strong></p>
<p>یک delegate مشابه چیزی است که در اصطلاح عمومی callback نامیده می‌شود.
این مفهوم سازه‌هایی مثل function pointers در زبان C را نیز در بر می‌گیرد.</p>
<h3>نوشتن متدهای پلاگین با استفاده از Delegateها ✨</h3>
<p>یک متغیر از نوع delegate در زمان اجرا (runtime) به یک متد نسبت داده می‌شود. این ویژگی برای نوشتن متدهای پلاگین (plug-in methods) بسیار کاربردی است.</p>
<p>در مثال زیر، ما یک متد کمکی (utility method) به نام Transform داریم که یک عمل transform را روی هر عضو از یک آرایه‌ی عددی (integer array) اعمال می‌کند. این متد Transform یک پارامتر از نوع delegate دارد که می‌توانید برای مشخص کردن پلاگین transform از آن استفاده کنید:</p>
<pre><code class="language-c#">int[] values = { 1, 2, 3 };
Transform (values, Square);      // اتصال متد Square به Transform
foreach (int i in values)
  Console.Write (i + &quot;  &quot;);      // خروجی: 1   4   9

void Transform (int[] values, Transformer t)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = t (values[i]);
}

int Square (int x) =&gt; x * x;
int Cube (int x) =&gt; x * x * x;

delegate int Transformer (int x);
</code></pre>
<p>🔹 در اینجا اگر در خط دوم به‌جای Square از Cube استفاده کنیم، تبدیل روی اعداد به‌صورت مکعب (توان سوم) انجام می‌شود.</p>
<p>🔹 متد Transform یک higher-order function است، چون یک تابع (delegate) را به‌عنوان آرگومان می‌گیرد. (هر متدی که یک delegate را برگرداند نیز یک higher-order function محسوب می‌شود.)</p>
<h3>اهداف متد در Delegateها: Instance و Static ⚡</h3>
<p>یک متد هدف (target method) برای یک delegate می‌تواند محلی (local)، ایستا (static) یا نمونه‌ای (instance) باشد.</p>
<p>مثال یک متد static به‌عنوان هدف delegate:</p>
<pre><code class="language-c#">Transformer t = Test.Square;
Console.WriteLine (t(10));      // 100

class Test 
{ 
    public static int Square (int x) =&gt; x * x; 
}

delegate int Transformer (int x);
</code></pre>
<p>مثال یک متد instance به‌عنوان هدف delegate:</p>
<pre><code class="language-c#">Test test = new Test();
Transformer t = test.Square;
Console.WriteLine (t(10));      // 100

class Test 
{ 
    public int Square (int x) =&gt; x * x; 
}

delegate int Transformer (int x);
</code></pre>
<p>🔑 زمانی که یک متد instance به یک delegate اختصاص داده می‌شود، آن delegate فقط به خود متد اشاره نمی‌کند، بلکه نمونه‌ای از کلاس که متد به آن تعلق دارد را هم نگه‌داری می‌کند.</p>
<p><strong>خاصیت Target در کلاس System.Delegate 🎯</strong></p>
<p>کلاس System.Delegate یک ویژگی به نام Target دارد که این نمونه (instance) را نشان می‌دهد (و اگر delegate به یک متد static اشاره کند، مقدارش null خواهد بود).</p>
<p>مثال:</p>
<pre><code class="language-c#">MyReporter r = new MyReporter();
r.Prefix = &quot;%Complete: &quot;;

ProgressReporter p = r.ReportProgress;
p(99);                                 // %Complete: 99

Console.WriteLine (p.Target == r);     // True
Console.WriteLine (p.Method);          // Void ReportProgress(Int32)

r.Prefix = &quot;&quot;;
p(99);                                 // 99

public delegate void ProgressReporter (int percentComplete);

class MyReporter
{
  public string Prefix = &quot;&quot;;
  public void ReportProgress (int percentComplete)
    =&gt; Console.WriteLine (Prefix + percentComplete);
}
</code></pre>
<p>✅ چون نمونه (instance) در خاصیت Target ذخیره می‌شود، طول عمر آن حداقل به اندازه طول عمر delegate گسترش می‌یابد.</p>
<p>🔖 جمع‌بندی:</p>
<ul>
<li>
<p>Delegateها به ما اجازه می‌دهند که متدها را مثل متغیرها پاس بدهیم.</p>
</li>
<li>
<p>می‌توانند به متدهای static یا instance متصل شوند.</p>
</li>
<li>
<p>خاصیت Target تضمین می‌کند که نمونه مربوط به متد instance تا وقتی delegate زنده است، باقی بماند.</p>
</li>
</ul>
<p>💡 این مفهوم پایه‌ای در طراحی پلاگین‌ها، کال‌بک‌ها و برنامه‌نویسی شیءگراست.</p>
<h3>نمایندگان چندپخشی (Multicast Delegates) 🎯</h3>
<p>تمام نمونه‌های delegate در سی‌شارپ دارای قابلیت چندپخشی (multicast) هستند. این یعنی یک نمونه‌ی delegate می‌تواند نه فقط به یک متد، بلکه به یک لیست از متدها اشاره کند.</p>
<p>عملگرهای + و += برای ترکیب کردن نمونه‌های delegate استفاده می‌شوند:</p>
<pre><code class="language-c#">SomeDelegate d = SomeMethod1;
d += SomeMethod2;
</code></pre>
<p>خط آخر از نظر عملکرد دقیقاً معادل این است:</p>
<pre><code class="language-c#">d = d + SomeMethod2;
</code></pre>
<p>اکنون وقتی d فراخوانی شود، هم SomeMethod1 و هم SomeMethod2 اجرا می‌شوند.
✅ توجه داشته باشید که متدها به ترتیبی که اضافه شده‌اند فراخوانی می‌شوند.</p>
<p>عملگرهای - و -= هم برای حذف یک متد از لیست متدهای یک delegate استفاده می‌شوند:</p>
<pre><code>d -= SomeMethod1;
</code></pre>
<p>اکنون فراخوانی d باعث می‌شود فقط SomeMethod2 اجرا شود.</p>
<p>📌 نکته مهم:</p>
<ul>
<li>وقتی روی یک متغیر delegate که مقدارش null است، عمل + یا += انجام دهید، باز هم کار می‌کند و معادل این است که به آن مقدار جدید بدهید:</li>
</ul>
<pre><code class="language-c#">SomeDelegate d = null;
d += SomeMethod1;   // معادل با: d = SomeMethod1 وقتی d برابر null است
</code></pre>
<ul>
<li>به طور مشابه، اگر روی یک delegate که فقط یک متد را نگه داشته باشد عمل -= کنید، نتیجه‌اش معادل اختصاص مقدار null به آن متغیر خواهد بود.</li>
</ul>
<p>⚡ یک نکته مهم دیگر:
Delegates در سی‌شارپ immutable هستند. یعنی وقتی شما += یا -= را استفاده می‌کنید، در واقع یک نمونه‌ی جدید از delegate ساخته می‌شود و به متغیر موجود اختصاص داده می‌شود.</p>
<p>📢 اگر یک delegate چندپخشی (multicast delegate) دارای نوع بازگشتی غیر از void باشد، مقدار بازگشتی که شما دریافت می‌کنید مربوط به آخرین متدی است که اجرا شده است. متدهای قبلی همچنان اجرا می‌شوند، اما مقدار بازگشتی آن‌ها نادیده گرفته می‌شود.
(به همین دلیل، در بیشتر مواردی که از multicast delegate استفاده می‌شود، آن‌ها void برمی‌گردانند.)</p>
<p>🧩 تمام انواع delegate به طور ضمنی از System.MulticastDelegate ارث‌بری می‌کنند که خودش از System.Delegate ارث‌بری می‌کند.
کامپایلر سی‌شارپ تمام عملیات +، -، += و -= روی delegateها را به متدهای استاتیک Combine و Remove از کلاس System.Delegate تبدیل می‌کند.</p>
<h4>مثال Multicast Delegate 🛠️</h4>
<p>فرض کنید یک متدی نوشته‌اید که اجرای آن زمان زیادی می‌برد. این متد می‌تواند به طور منظم میزان پیشرفت کار را به فراخواننده گزارش دهد؛ این کار با فراخوانی یک delegate انجام می‌شود.</p>
<p>در مثال زیر، متد HardWork یک پارامتر از نوع delegate به نام ProgressReporter دریافت می‌کند و از آن برای نشان دادن پیشرفت استفاده می‌کند:</p>
<pre><code class="language-c#">public delegate void ProgressReporter(int percentComplete);

public class Util
{
    public static void HardWork(ProgressReporter p)
    {
        for (int i = 0; i &lt; 10; i++)
        {
            p(i * 10);                           // فراخوانی delegate
            System.Threading.Thread.Sleep(100);  // شبیه‌سازی کار سنگین
        }
    }
}
</code></pre>
<p>برای مانیتور کردن میزان پیشرفت، می‌توانیم یک نمونه‌ی Multicast Delegate به نام p بسازیم تا پیشرفت هم‌زمان توسط دو متد مستقل بررسی شود:</p>
<pre><code class="language-c#">ProgressReporter p = WriteProgressToConsole;
p += WriteProgressToFile;

Util.HardWork(p);

void WriteProgressToConsole(int percentComplete)
    =&gt; Console.WriteLine(percentComplete);

void WriteProgressToFile(int percentComplete)
    =&gt; System.IO.File.WriteAllText(&quot;progress.txt&quot;,
                                    percentComplete.ToString());
</code></pre>
<p>🔍 در اینجا چه اتفاقی می‌افتد؟</p>
<ol>
<li>
<p>ابتدا یک delegate از نوع ProgressReporter ساخته می‌شود و به متد WriteProgressToConsole اشاره می‌کند.</p>
</li>
<li>
<p>سپس با عملگر +=، متد WriteProgressToFile هم به آن اضافه می‌شود.
یعنی delegate p اکنون یک multicast delegate است.</p>
</li>
<li>
<p>هر بار که متد HardWork پیشرفت را گزارش می‌دهد (p(i * 10))، هر دو متد اجرا می‌شوند:</p>
</li>
</ol>
<ul>
<li>
<p>WriteProgressToConsole مقدار پیشرفت را روی کنسول چاپ می‌کند.</p>
</li>
<li>
<p>WriteProgressToFile مقدار پیشرفت را در یک فایل progress.txt ذخیره می‌کند.</p>
</li>
</ul>
<p>📊 نتیجه نهایی:</p>
<ul>
<li>
<p>شما همزمان در کنسول می‌بینید که پیشرفت کار چند درصد است.</p>
</li>
<li>
<p>یک فایل متنی هم دارید که همان اطلاعات را ذخیره می‌کند.</p>
</li>
</ul>
<h3>انواع Delegate عمومی (Generic Delegate Types) ⚡</h3>
<p>یک delegate می‌تواند شامل پارامترهای عمومی (Generic Type Parameters) باشد:</p>
<pre><code class="language-c#">public delegate T Transformer&lt;T&gt;(T arg);
</code></pre>
<p>با چنین تعریفی می‌توانیم یک متد ابزار عمومی (Utility Method) بنویسیم که روی هر نوع داده‌ای کار کند:</p>
<pre><code class="language-c#">int[] values = { 1, 2, 3 };
Util.Transform(values, Square);      // اتصال متد Square

foreach (int i in values)
    Console.Write(i + &quot;  &quot;);         // خروجی: 1   4   9

int Square(int x) =&gt; x * x;

public class Util
{
    public static void Transform&lt;T&gt;(T[] values, Transformer&lt;T&gt; t)
    {
        for (int i = 0; i &lt; values.Length; i++)
            values[i] = t(values[i]);
    }
}
</code></pre>
<h3>Delegates آماده: Func و Action ✅</h3>
<p>با معرفی generic delegates، این امکان فراهم شد که مجموعه‌ای کوچک از delegateها طراحی شوند که آن‌قدر عمومی و انعطاف‌پذیر باشند که برای متدهایی با هر نوع خروجی و هر تعداد (معقول) آرگومان قابل استفاده باشند.</p>
<p>این delegateها همان Func و Action هستند که در فضای نام System تعریف شده‌اند:</p>
<pre><code class="language-c#">delegate TResult Func&lt;out TResult&gt;();                
delegate TResult Func&lt;in T, out TResult&gt;(T arg);          
delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);
// ... ادامه دارد تا 16 پارامتر

delegate void Action();
delegate void Action&lt;in T&gt;(T arg);
delegate void Action&lt;in T1, in T2&gt;(T1 arg1, T2 arg2);
// ... ادامه دارد تا 16 پارامتر
</code></pre>
<p>📌 این‌ها بسیار عمومی و قدرتمند هستند.</p>
<p><strong>جایگزینی Transformer با Func 🔄</strong></p>
<p>در مثال قبلی، به جای تعریف delegate اختصاصی Transformer، می‌توانستیم از Func استفاده کنیم:</p>
<pre><code class="language-c#">public static void Transform&lt;T&gt;(T[] values, Func&lt;T, T&gt; transformer)
{
    for (int i = 0; i &lt; values.Length; i++)
        values[i] = transformer(values[i]);
}
</code></pre>
<p>در اینجا:</p>
<ul>
<li>
<p>Func&lt;T, T&gt; یعنی یک delegate که یک ورودی از نوع T می‌گیرد و خروجی هم از همان نوع T برمی‌گرداند.</p>
</li>
<li>
<p>دقیقاً همان چیزی است که قبلاً با Transformer<T> ساخته بودیم.</p>
</li>
</ul>
<p><strong>محدودیت‌ها 🚧</strong></p>
<p>تنها سناریوهای عملی که Func و Action پوشش نمی‌دهند، مواردی هستند که شامل پارامترهای ref/out یا pointer باشند.</p>
<p><strong>نکته تاریخی 🕰️</strong></p>
<p>زمانی که C# برای اولین بار معرفی شد، هنوز generics وجود نداشت. به همین دلیل، Func و Action هم وجود نداشتند.
به همین خاطر، بخش زیادی از کتابخانه‌ی .NET از delegateهای سفارشی استفاده می‌کند، نه از Func و Action.</p>
<h3>مقایسه Delegate‌ها و Interface‌ها ⚔️</h3>
<p>هر مسئله‌ای که با یک delegate حل می‌شود، می‌تواند با یک interface هم حل شود.</p>
<p>به‌عنوان مثال، می‌توانیم نمونه‌ی اولیه‌مان را با استفاده از یک interface به نام ITransformer بازنویسی کنیم، به جای اینکه از delegate استفاده کنیم:</p>
<pre><code class="language-c#">int[] values = { 1, 2, 3 };
Util.TransformAll(values, new Squarer());

foreach (int i in values)
    Console.WriteLine(i);

public interface ITransformer
{
    int Transform(int x);
}

public class Util
{
    public static void TransformAll(int[] values, ITransformer t)
    {
        for (int i = 0; i &lt; values.Length; i++)
            values[i] = t.Transform(values[i]);
    }
}

class Squarer : ITransformer
{
    public int Transform(int x) =&gt; x * x;
}
</code></pre>
<p>چه زمانی delegate انتخاب بهتری از interface است؟ ✅</p>
<p>طراحی با delegate ممکن است انتخاب بهتری باشد اگر یک یا چند مورد زیر برقرار باشند:</p>
<ul>
<li>
<p>🔹 interface فقط یک متد تعریف کرده باشد.</p>
</li>
<li>
<p>🔹 نیاز به multicast (اتصال چند متد به یک delegate) داشته باشیم.</p>
</li>
<li>
<p>🔹 یک subscriber مجبور باشد چند بار یک interface را پیاده‌سازی کند.</p>
</li>
</ul>
<p><strong>بررسی مثال 🔍</strong></p>
<p>در مثال ITransformer:</p>
<ul>
<li>
<p>ما نیازی به multicast نداریم.</p>
</li>
<li>
<p>اما interface فقط یک متد (Transform) تعریف کرده است.</p>
</li>
<li>
<p>از طرفی ممکن است بخواهیم چندین تبدیل مختلف (مثلاً مربع یا مکعب) را پیاده‌سازی کنیم.</p>
</li>
</ul>
<p>در چنین حالتی، اگر از interface استفاده کنیم، مجبور می‌شویم برای هر تبدیل یک کلاس جداگانه بسازیم، چون یک کلاس فقط یک بار می‌تواند ITransformer را پیاده‌سازی کند. این کار دست‌وپاگیر و تکراری می‌شود.</p>
<p>مثلاً:</p>
<pre><code class="language-c#">int[] values = { 1, 2, 3 };
Util.TransformAll(values, new Cuber());

foreach (int i in values)
    Console.WriteLine(i);

class Squarer : ITransformer
{
    public int Transform(int x) =&gt; x * x;
}

class Cuber : ITransformer
{
    public int Transform(int x) =&gt; x * x * x;
}
</code></pre>
<p>📌 نتیجه:</p>
<ul>
<li>
<p>با delegateها، پیاده‌سازی ساده‌تر و منعطف‌تر است (می‌توانیم به‌راحتی متدهای مختلفی مثل مربع یا مکعب را پاس بدهیم).</p>
</li>
<li>
<p>با interfaceها، مجبوریم برای هر عملگر یک کلاس جدید بسازیم.</p>
</li>
</ul>
<h3>سازگاری Delegate ها ⚖️</h3>
<h4>سازگاری نوع (Type Compatibility) 🏷️</h4>
<p>تمام نوع‌های delegate با هم ناسازگار هستند، حتی اگر امضا (signature) آن‌ها یکی باشد:</p>
<pre><code class="language-c#">D1 d1 = Method1;
D2 d2 = d1;   // ❌ خطای زمان کامپایل

void Method1() { }

delegate void D1();
delegate void D2();
</code></pre>
<p>🔹 اما این حالت مجاز است:</p>
<pre><code>D2 d2 = new D2(d1);   // ✅ درست
</code></pre>
<p><strong>مقایسه‌ی برابری (Equality) ✅</strong></p>
<p>دو نمونه‌ی delegate وقتی برابر محسوب می‌شوند که به یک متد یکسان اشاره کنند:</p>
<pre><code class="language-c#">D d1 = Method1;
D d2 = Method1;

Console.WriteLine(d1 == d2);   // True

void Method1() { }

delegate void D();
</code></pre>
<p>🔹 در مورد multicast delegate‌ها هم، برابری وقتی برقرار است که به همان متدها و به همان ترتیب اشاره کنند.</p>
<h4>سازگاری پارامتر (Parameter Compatibility) 🔄</h4>
<p>وقتی یک متد را فراخوانی می‌کنید، می‌توانید آرگومانی بدهید که از نوع خاص‌تر از پارامتر متد باشد. این رفتار معمولی polymorphism است.</p>
<p>به همین دلیل، یک delegate هم می‌تواند پارامترهایی خاص‌تر از متد هدف خود داشته باشد. این ویژگی را contravariance می‌نامند.</p>
<p>مثال:</p>
<pre><code class="language-c#">StringAction sa = new StringAction(ActOnObject);
sa(&quot;hello&quot;);

void ActOnObject(object o) =&gt; Console.WriteLine(o);   // خروجی: hello

delegate void StringAction(string s);
</code></pre>
<p>🔹 در اینجا StringAction یک متد را با پارامتر string فراخوانی می‌کند.
🔹 اما متدی که واقعا اجرا می‌شود (ActOnObject) پارامترش از نوع object است.
🔹 در این حالت، آرگومان string به‌طور خودکار تبدیل به object (upcast) می‌شود.</p>
<p><strong>3. ارتباط با الگوی استاندارد Event 🎯</strong></p>
<p>الگوی استاندارد event در C# طوری طراحی شده است که از contravariance استفاده کند.</p>
<ul>
<li>
<p>همه‌ی کلاس‌های رویداد از کلاس پایه‌ی مشترک EventArgs ارث‌بری می‌کنند.</p>
</li>
<li>
<p>بنابراین می‌توانید یک متد داشته باشید که توسط دو delegate مختلف فراخوانی شود:</p>
<ul>
<li>
<p>یکی رویداد MouseEventArgs پاس بدهد 🖱️</p>
</li>
<li>
<p>دیگری KeyEventArgs پاس بدهد ⌨️</p>
</li>
</ul>
</li>
</ul>
<p>این کار انعطاف‌پذیری بالایی در مدیریت رویدادها به شما می‌دهد.</p>
<p>📌 خلاصه:</p>
<ul>
<li>
<p>delegate type ها حتی با امضای یکسان هم ناسازگار هستند.</p>
</li>
<li>
<p>multicast delegateها برابرند اگر دقیقا همان متدها و ترتیب را داشته باشند.</p>
</li>
<li>
<p>contravariance اجازه می‌دهد متد هدف، پارامتر عام‌تر از delegate داشته باشد.</p>
</li>
<li>
<p>event pattern از همین ویژگی برای پشتیبانی از انواع مختلف رویدادها استفاده می‌کند.</p>
</li>
</ul>
<h4>سازگاری نوع بازگشتی در Delegateها (Return Type Compatibility) 🔄</h4>
<p>همان‌طور که وقتی یک متد را فراخوانی می‌کنید ممکن است نوعی خاص‌تر از چیزی که انتظار داشتید برگردد (رفتار معمولی polymorphism)؛ در مورد delegate‌ها هم همین موضوع صادق است.</p>
<p>یعنی متد هدف یک delegate می‌تواند نوع بازگشتی خاص‌تر از چیزی که delegate تعریف کرده داشته باشد.
این ویژگی را covariance می‌نامند.</p>
<p>مثال: Covariance در نوع بازگشتی 📝</p>
<pre><code class="language-c#">ObjectRetriever o = new ObjectRetriever(RetrieveString);
object result = o();
Console.WriteLine(result);   // hello

string RetrieveString() =&gt; &quot;hello&quot;;

delegate object ObjectRetriever();
</code></pre>
<p>🔹 اینجا ObjectRetriever انتظار دارد متدی که به آن متصل است، یک object برگرداند.
🔹 اما در واقعیت، متد RetrieveString یک string برمی‌گرداند.
🔹 چون string زیرکلاس object است، این مجاز است ✅.</p>
<p>📌 پس: نوع بازگشتی delegate ها covariant است.</p>
<h4>واریانس در Delegateهای جنریک ⚙️</h4>
<p>در فصل ۳ گفتیم که اینترفیس‌های جنریک می‌توانند از covariant و contravariant استفاده کنند.
این قابلیت برای delegate‌های جنریک هم وجود دارد.</p>
<p><strong>قوانین خوب برای تعریف delegate جنریک:</strong></p>
<p>اگر پارامتر نوع (Type Parameter) فقط در خروجی استفاده می‌شود → با out (covariant) علامت‌گذاری شود.</p>
<p>اگر پارامتر نوع فقط در ورودی استفاده می‌شود → با in (contravariant) علامت‌گذاری شود.</p>
<p><strong>مثال ۱: Covariance در جنریک‌ها (با Func) 📤</strong></p>
<p>در فضای نام System داریم:</p>
<pre><code class="language-c#">delegate TResult Func&lt;out TResult&gt;();
</code></pre>
<p>این باعث می‌شود بتوانیم بنویسیم:</p>
<pre><code class="language-c#">Func&lt;string&gt; x = () =&gt; &quot;Hello!&quot;;
Func&lt;object&gt; y = x;   // ✅ مجاز به خاطر covariance
</code></pre>
<p>🔹 یعنی می‌توانیم Func<string> را به Func<object> تبدیل کنیم چون string زیرکلاس object است.</p>
<p><strong>مثال ۲: Contravariance در جنریک‌ها (با Action) 📥</strong></p>
<p>باز هم در فضای نام System:</p>
<pre><code class="language-c#">delegate void Action&lt;in T&gt;(T arg);
</code></pre>
<p>این باعث می‌شود:</p>
<pre><code class="language-c#">Action&lt;object&gt; x = obj =&gt; Console.WriteLine(obj);
Action&lt;string&gt; y = x;   // ✅ مجاز به خاطر contravariance
</code></pre>
<p>🔹 یعنی می‌توانیم Action<object> را به Action<string> تبدیل کنیم چون متدی که انتظار دریافت object دارد، می‌تواند string هم بگیرد.</p>
<p>📌 خلاصه:</p>
<ul>
<li>
<p>نوع بازگشتی delegate می‌تواند خاص‌تر از نوع تعریف‌شده باشد → این covariance است.</p>
</li>
<li>
<p>در delegate جنریک:</p>
<ul>
<li>
<p>نوع خروجی (out) → covariant 📤</p>
</li>
<li>
<p>نوع ورودی (in) → contravariant 📥</p>
</li>
</ul>
</li>
</ul>
<p>این باعث می‌شود تبدیل‌ها بین delegateها به‌صورت طبیعی و بر اساس ارث‌بری انجام شوند.</p>
<h3>رویدادها (Events)</h3>
<p>هنگام استفاده از <strong>delegates</strong>، دو نقش معمولاً ظاهر می‌شوند: <strong>broadcaster</strong> و <strong>subscriber</strong>.</p>
<ul>
<li><strong>Broadcaster</strong> نوعی است که دارای یک فیلد delegate می‌باشد. این نوع تصمیم می‌گیرد که چه زمانی پیام را پخش کند، با <strong>invoke</strong> کردن delegate.</li>
<li><strong>Subscribers</strong> دریافت‌کنندگان هدف متد هستند. یک subscriber تصمیم می‌گیرد چه زمانی شروع به گوش دادن کند و چه زمانی آن را متوقف کند، با استفاده از عملگرهای <code>+=</code> و <code>-=</code> روی delegate مربوط به broadcaster. یک subscriber درباره دیگر subscribers اطلاعی ندارد و در عملکرد آن‌ها دخالتی نمی‌کند.</li>
</ul>
<h3>رویدادها در C# پیشرفته ⚡</h3>
<p>رویدادها یک ویژگی زبانی هستند که این الگو را رسمی می‌کنند. یک <strong>event</strong> یک ساختار است که تنها زیرمجموعه‌ای از قابلیت‌های delegate را که برای مدل <strong>broadcaster/subscriber</strong> لازم است، در معرض قرار می‌دهد. هدف اصلی رویدادها جلوگیری از دخالت subscribers در عملکرد یکدیگر است.</p>
<p>ساده‌ترین روش برای تعریف یک رویداد، استفاده از کلیدواژه <strong>event</strong> قبل از یک عضو delegate است:</p>
<pre><code class="language-csharp">// تعریف delegate
public delegate void PriceChangedHandler(decimal oldPrice, decimal newPrice);

public class Broadcaster
{
    // تعریف رویداد
    public event PriceChangedHandler PriceChanged;
}
</code></pre>
<p>کدی که داخل نوع <strong>Broadcaster</strong> قرار دارد، دسترسی کامل به <strong>PriceChanged</strong> دارد و می‌تواند آن را مانند یک delegate معمولی مدیریت کند. کدهای خارج از <strong>Broadcaster</strong> تنها می‌توانند عملیات <code>+=</code> و <code>-=</code> را روی رویداد <strong>PriceChanged</strong> انجام دهند.</p>
<p>✅ ادامه‌ی متن را ارسال کنید تا ترجمه بعدی را آماده کنم.</p>
<h3>چگونه رویدادها در درون کار می‌کنند؟ 🔍</h3>
<p>وقتی یک رویداد به شکل زیر تعریف می‌کنید:</p>
<pre><code class="language-csharp">public class Broadcaster
{
    public event PriceChangedHandler PriceChanged;
}
</code></pre>
<p>سه اتفاق در پشت صحنه رخ می‌دهد:</p>
<p>1️⃣ ابتدا، <strong>کامپایلر</strong> تعریف رویداد را به چیزی شبیه به کد زیر ترجمه می‌کند:</p>
<pre><code class="language-csharp">PriceChangedHandler priceChanged;   // delegate خصوصی

public event PriceChangedHandler PriceChanged
{
    add    { priceChanged += value; }
    remove { priceChanged -= value; }
}
</code></pre>
<p>کلیدواژه‌های <strong>add</strong> و <strong>remove</strong> نشان‌دهنده <strong>accessorهای رویداد صریح</strong> هستند—که عملکردی شبیه به <strong>accessorهای property</strong> دارند. بعداً درباره نحوه نوشتن این‌ها توضیح خواهیم داد.</p>
<p>2️⃣ دوم، کامپایلر داخل کلاس <strong>Broadcaster</strong> به دنبال ارجاعات به <strong>PriceChanged</strong> می‌گردد که عملیات دیگری غیر از <code>+=</code> یا <code>-=</code> انجام می‌دهند و آن‌ها را به فیلد delegate زیرین یعنی <strong>priceChanged</strong> هدایت می‌کند.</p>
<p>3️⃣ سوم، کامپایلر عملیات <code>+=</code> و <code>-=</code> روی رویداد را به فراخوانی <strong>add</strong> و <strong>remove</strong> accessorهای رویداد ترجمه می‌کند. جالب است بدانید که این کار باعث می‌شود رفتار <code>+=</code> و <code>-=</code> وقتی روی رویدادها اعمال می‌شوند، منحصربه‌فرد باشد: برخلاف سایر سناریوها، این‌ها تنها یک میانبر برای <code>+</code> و <code>-</code> به همراه انتساب نیستند.</p>
<p>مثالی را در نظر بگیرید 📈</p>
<p>کلاس <strong>Stock</strong> رویداد <strong>PriceChanged</strong> خود را هر بار که قیمت سهام تغییر می‌کند، فعال می‌کند:</p>
<pre><code class="language-csharp">public delegate void PriceChangedHandler(decimal oldPrice, decimal newPrice);

public class Stock
{
    string symbol;
    decimal price;
    public Stock(string symbol) =&gt; this.symbol = symbol;
    public event PriceChangedHandler PriceChanged;
    public decimal Price
    {
        get =&gt; price;
        set
        {
            if (price == value) return;   // خروج اگر چیزی تغییر نکرده
            decimal oldPrice = price;
            price = value;
            if (PriceChanged != null)      // اگر لیست فراخوانی خالی نیست
                PriceChanged(oldPrice, price); // رویداد فعال شود
        }
    }
}
</code></pre>
<p>اگر کلیدواژه <strong>event</strong> را حذف کنیم و <strong>PriceChanged</strong> به یک فیلد معمولی delegate تبدیل شود، باز هم مثال ما همان نتایج را خواهد داد. اما کلاس <strong>Stock</strong> کمتر مقاوم خواهد بود، زیرا subscribers می‌توانند با یکدیگر تداخل ایجاد کنند، مثلاً:</p>
<ul>
<li>جایگزین کردن دیگر subscribers با انتساب مجدد <strong>PriceChanged</strong> به جای استفاده از عملگر <code>+=</code>.</li>
<li>پاک کردن تمام subscribers با انتساب <strong>PriceChanged</strong> به <code>null</code>.</li>
<li>ارسال پیام به subscribers دیگر با invoke کردن delegate.</li>
</ul>
<h3>الگوی استاندارد رویدادها 🛠️</h3>
<p>در تقریباً همه مواردی که رویدادها در کتابخانه‌های .NET تعریف می‌شوند، تعریف آن‌ها مطابق یک الگوی استاندارد است تا یکپارچگی بین کدهای کتابخانه و کاربر حفظ شود. در مرکز این الگو، کلاس <strong>System.EventArgs</strong> قرار دارد؛ یک کلاس از پیش تعریف‌شده در .NET که هیچ عضوی ندارد (به جز فیلد استاتیک <strong>Empty</strong>). <strong>EventArgs</strong> کلاس پایه‌ای برای انتقال اطلاعات مربوط به یک رویداد است.</p>
<p>در مثال Stock ما، برای انتقال قیمت قدیمی و جدید هنگام فعال شدن رویداد <strong>PriceChanged</strong>، کلاس EventArgs را به صورت زیر subclass می‌کنیم:</p>
<pre><code class="language-csharp">public class PriceChangedEventArgs : System.EventArgs
{
    public readonly decimal LastPrice;
    public readonly decimal NewPrice;

    public PriceChangedEventArgs(decimal lastPrice, decimal newPrice)
    {
        LastPrice = lastPrice;
        NewPrice = newPrice;
    }
}
</code></pre>
<p>برای استفاده مجدد، subclass EventArgs معمولاً بر اساس اطلاعاتی که شامل می‌شود نامگذاری می‌شود، نه بر اساس رویدادی که برای آن استفاده می‌شود. داده‌ها معمولاً به صورت property یا فیلد فقط‌خواندنی ارائه می‌شوند.</p>
<h3>انتخاب یا تعریف delegate برای رویداد 🎯</h3>
<p>سه قاعده وجود دارد:</p>
<p>1️⃣ نوع بازگشتی باید <strong>void</strong> باشد.
2️⃣ دو آرگومان دریافت کند: آرگومان اول از نوع <strong>object</strong> و آرگومان دوم یک subclass از <strong>EventArgs</strong>. آرگومان اول نشان‌دهنده broadcaster و آرگومان دوم شامل اطلاعات اضافی برای انتقال است.
3️⃣ نام delegate باید با <strong>EventHandler</strong> پایان یابد.</p>
<p>.NET یک delegate عمومی به نام <strong>System.EventHandler&lt;&gt;</strong> برای کمک به این کار تعریف کرده است:</p>
<pre><code class="language-csharp">public delegate void EventHandler&lt;TEventArgs&gt;(object source, TEventArgs e);
</code></pre>
<p>قبل از وجود genericها در زبان (قبل از C# 2.0)، باید delegate سفارشی را به صورت زیر می‌نوشتیم:</p>
<pre><code class="language-csharp">public delegate void PriceChangedHandler(object sender, PriceChangedEventArgs e);
</code></pre>
<p>به دلایل تاریخی، بیشتر رویدادها در کتابخانه‌های .NET از این روش استفاده می‌کنند.</p>
<h3>تعریف رویداد با delegate انتخاب‌شده 🔧</h3>
<pre><code class="language-csharp">public class Stock
{
    ...
    public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;
}
</code></pre>
<h3>نوشتن متد محافظت‌شده و virtual برای فعال کردن رویداد</h3>
<p>نام این متد باید همان نام رویداد باشد، با پیشوند <strong>On</strong>، و یک آرگومان <strong>EventArgs</strong> دریافت کند:</p>
<pre><code class="language-csharp">public class Stock
{
    ...
    public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;

    protected virtual void OnPriceChanged(PriceChangedEventArgs e)
    {
        if (PriceChanged != null) PriceChanged(this, e);
    }
}
</code></pre>
<p>برای عملکرد مقاوم در سناریوهای چندنخی (multithreaded)، بهتر است delegate را قبل از تست و فراخوانی به یک متغیر موقت انتساب دهید:</p>
<pre><code class="language-csharp">var temp = PriceChanged;
if (temp != null) temp(this, e);
</code></pre>
<p>همچنین می‌توان با استفاده از <strong>null-conditional operator</strong> همان کار را بدون متغیر موقت انجام داد:</p>
<pre><code class="language-csharp">PriceChanged?.Invoke(this, e);
</code></pre>
<p>این روش هم <strong>thread-safe</strong> و هم مختصر است و بهترین روش عمومی برای فراخوانی رویدادها محسوب می‌شود.</p>
<h3>مثال کامل 💻</h3>
<pre><code class="language-csharp">using System;

Stock stock = new Stock(&quot;THPW&quot;);
stock.Price = 27.10M;

// ثبت برای رویداد PriceChanged
stock.PriceChanged += stock_PriceChanged;
stock.Price = 31.59M;

void stock_PriceChanged(object sender, PriceChangedEventArgs e)
{
    if ((e.NewPrice - e.LastPrice) / e.LastPrice &gt; 0.1M)
        Console.WriteLine(&quot;Alert, 10% stock price increase!&quot;);
}

public class PriceChangedEventArgs : EventArgs
{
    public readonly decimal LastPrice;
    public readonly decimal NewPrice;

    public PriceChangedEventArgs(decimal lastPrice, decimal newPrice)
    {
        LastPrice = lastPrice; NewPrice = newPrice;
    }
}

public class Stock
{
    string symbol;
    decimal price;
    public Stock(string symbol) =&gt; this.symbol = symbol;
    public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;

    protected virtual void OnPriceChanged(PriceChangedEventArgs e)
    {
        PriceChanged?.Invoke(this, e);
    }

    public decimal Price
    {
        get =&gt; price;
        set
        {
            if (price == value) return;
            decimal oldPrice = price;
            price = value;
            OnPriceChanged(new PriceChangedEventArgs(oldPrice, price));
        }
    }
}
</code></pre>
<h3>استفاده از EventHandler غیر عمومی</h3>
<p>وقتی رویداد نیاز به انتقال اطلاعات اضافی ندارد، می‌توان از <strong>EventHandler</strong> غیر generic استفاده کرد. در این مثال، کلاس <strong>Stock</strong> بازنویسی شده تا رویداد <strong>PriceChanged</strong> پس از تغییر قیمت فعال شود و تنها نیاز است بدانیم رویداد رخ داده است، بدون نیاز به اطلاعات اضافی. همچنین از <strong>EventArgs.Empty</strong> استفاده می‌کنیم تا از ایجاد غیرضروری یک نمونه EventArgs جلوگیری شود:</p>
<pre><code class="language-csharp">public class Stock
{
    string symbol;
    decimal price;

    public Stock(string symbol) { this.symbol = symbol; }
    public event EventHandler PriceChanged;

    protected virtual void OnPriceChanged(EventArgs e)
    {
        PriceChanged?.Invoke(this, e);
    }

    public decimal Price
    {
        get { return price; }
        set
        {
            if (price == value) return;
            price = value;
            OnPriceChanged(EventArgs.Empty);
        }
    }
}
</code></pre>
<p><strong>Accessorهای رویدادها 🔑</strong></p>
<p>Accessorهای یک رویداد، پیاده‌سازی‌های عملگرهای <code>+=</code> و <code>-=</code> آن هستند. به طور پیش‌فرض، این accessors به صورت ضمنی توسط کامپایلر پیاده‌سازی می‌شوند. به مثال زیر توجه کنید:</p>
<pre><code class="language-csharp">public event EventHandler PriceChanged;
</code></pre>
<p>کامپایلر این را به شکل زیر تبدیل می‌کند:</p>
<ul>
<li>یک فیلد delegate خصوصی</li>
<li>یک جفت تابع accessor عمومی برای رویداد (<strong>add_PriceChanged</strong> و <strong>remove_PriceChanged</strong>) که عملیات <code>+=</code> و <code>-=</code> را به فیلد delegate خصوصی هدایت می‌کنند</li>
</ul>
<p>شما می‌توانید این روند را با تعریف <strong>explicit event accessors</strong> به دست بگیرید. در اینجا پیاده‌سازی دستی رویداد <strong>PriceChanged</strong> از مثال قبلی آمده است:</p>
<pre><code class="language-csharp">private EventHandler priceChanged;   // تعریف یک delegate خصوصی
public event EventHandler PriceChanged
{
    add    { priceChanged += value; }
    remove { priceChanged -= value; }
}
</code></pre>
<p>این مثال از نظر عملکرد با پیاده‌سازی پیش‌فرض C# یکسان است (به جز اینکه C# همچنین ایمنی در برابر چندنخی را با الگوریتم lock-free compare-and-swap تضمین می‌کند). با تعریف دستی accessors، به C# می‌گوییم که منطق پیش‌فرض فیلد و accessor را تولید نکند.</p>
<p>با استفاده از explicit event accessors، می‌توان استراتژی‌های پیچیده‌تری برای ذخیره و دسترسی به delegate زیرین اعمال کرد. سه سناریو که این کاربرد دارد:</p>
<p>1️⃣ وقتی accessors تنها به عنوان واسطه برای کلاس دیگری هستند که رویداد را پخش می‌کند.
2️⃣ وقتی کلاس تعداد زیادی رویداد دارد اما اغلب تنها تعداد کمی subscriber وجود دارد، مثل کنترل‌های ویندوز. در این موارد بهتر است delegateهای subscribers را در یک <strong>dictionary</strong> ذخیره کنیم، زیرا dictionary حافظه کمتری نسبت به ده‌ها فیلد delegate خالی مصرف می‌کند.
3️⃣ هنگام پیاده‌سازی explicit یک interface که رویدادی را تعریف کرده است.</p>
<p>نمونه‌ای برای مورد سوم:</p>
<pre><code class="language-csharp">public interface IFoo { event EventHandler Ev; }

class Foo : IFoo
{
    private EventHandler ev;
    event EventHandler IFoo.Ev
    {
        add    { ev += value; }
        remove { ev -= value; }
    }
}
</code></pre>
<p>بخش‌های <strong>add</strong> و <strong>remove</strong> یک رویداد به متدهای <strong>add_XXX</strong> و <strong>remove_XXX</strong> کامپایل می‌شوند.</p>
<hr>
<p><strong>Modifierهای رویدادها ⚡</strong></p>
<p>مثل متدها، رویدادها می‌توانند <strong>virtual</strong>، <strong>overridden</strong>، <strong>abstract</strong> یا <strong>sealed</strong> باشند. همچنین می‌توانند <strong>static</strong> باشند:</p>
<pre><code class="language-csharp">public class Foo
{
    public static event EventHandler&lt;EventArgs&gt; StaticEvent;
    public virtual event EventHandler&lt;EventArgs&gt; VirtualEvent;
}
</code></pre>
<hr>
<p><strong>Lambda Expressions λ</strong></p>
<p>یک <strong>lambda expression</strong> متدی بدون نام است که به جای یک instance delegate نوشته می‌شود. کامپایلر بلافاصله آن را به یکی از موارد زیر تبدیل می‌کند:</p>
<ul>
<li>یک instance delegate</li>
<li>یا یک <strong>expression tree</strong> از نوع <code>Expression&lt;TDelegate&gt;</code> که کد داخل lambda را به صورت یک مدل شیء قابل پیمایش نمایش می‌دهد. این اجازه می‌دهد lambda بعداً در زمان اجرا تفسیر شود.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">Transformer sqr = x =&gt; x * x;
Console.WriteLine(sqr(3));   // خروجی: 9
delegate int Transformer(int i);
</code></pre>
<p>کامپایلر lambdaهای این نوع را با نوشتن یک متد خصوصی و انتقال کد expression به آن متد حل می‌کند.</p>
<p>فرم کلی یک lambda:</p>
<pre><code>(parameters) =&gt; expression-or-statement-block
</code></pre>
<p>اگر فقط یک پارامتر با نوع قابل استنتاج داشته باشیم، می‌توان پرانتزها را حذف کرد.</p>
<p>مثال:</p>
<pre><code class="language-csharp">x =&gt; x * x;
</code></pre>
<p>هر پارامتر lambda متناظر با پارامتر delegate است و نوع expression (که ممکن است <strong>void</strong> باشد) متناظر با نوع بازگشتی delegate است.</p>
<p>می‌توان expression را به صورت یک بلوک statement نیز نوشت:</p>
<pre><code class="language-csharp">x =&gt; { return x * x; };
</code></pre>
<p>اغلب lambdaها همراه با <strong>Func</strong> و <strong>Action</strong> استفاده می‌شوند:</p>
<pre><code class="language-csharp">Func&lt;int,int&gt; sqr = x =&gt; x * x;
</code></pre>
<p>مثال با دو پارامتر:</p>
<pre><code class="language-csharp">Func&lt;string,string,int&gt; totalLength = (s1, s2) =&gt; s1.Length + s2.Length;
int total = totalLength(&quot;hello&quot;, &quot;world&quot;);   // total = 10
</code></pre>
<p>اگر نیازی به استفاده از پارامترها نیست، می‌توان آن‌ها را با underscore دور انداخت (از C# 9):</p>
<pre><code class="language-csharp">Func&lt;string,string,int&gt; totalLength = (_,_) =&gt; ...
</code></pre>
<p>مثال بدون آرگومان:</p>
<pre><code class="language-csharp">Func&lt;string&gt; greeter = () =&gt; &quot;Hello, world&quot;;
</code></pre>
<p>از C# 10 به بعد، می‌توان از <strong>implicit typing</strong> برای lambda استفاده کرد:</p>
<pre><code class="language-csharp">var greeter = () =&gt; &quot;Hello, world&quot;;
</code></pre>
<h3>مشخص کردن صریح نوع پارامتر و نوع بازگشتی Lambda 🔧</h3>
<p>کامپایلر معمولاً می‌تواند نوع پارامترهای lambda را به صورت زمینه‌ای استنتاج کند. وقتی این امکان وجود نداشته باشد، باید نوع هر پارامتر را به صورت صریح مشخص کنید. به دو متد زیر توجه کنید:</p>
<pre><code class="language-csharp">void Foo&lt;T&gt;(T x) { }
void Bar&lt;T&gt;(Action&lt;T&gt; a) { }
</code></pre>
<p>کد زیر <strong>کامپایل نمی‌شود</strong>، زیرا کامپایلر نمی‌تواند نوع <code>x</code> را استنتاج کند:</p>
<pre><code class="language-csharp">Bar(x =&gt; Foo(x));   // نوع x چیست؟
</code></pre>
<p>می‌توان با مشخص کردن صریح نوع <code>x</code> مشکل را حل کرد:</p>
<pre><code class="language-csharp">Bar((int x) =&gt; Foo(x));
</code></pre>
<p>این مثال ساده را می‌توان به دو روش دیگر نیز اصلاح کرد:</p>
<pre><code class="language-csharp">Bar&lt;int&gt;(x =&gt; Foo(x));  // مشخص کردن type parameter برای Bar
Bar&lt;int&gt;(Foo);          // همانند بالا، با استفاده از method group
</code></pre>
<p>مثالی دیگر از استفاده explicit برای نوع پارامتر (C# 10):</p>
<pre><code class="language-csharp">var sqr = (int x) =&gt; x * x;
</code></pre>
<p>کامپایلر <code>sqr</code> را به نوع <code>Func&lt;int,int&gt;</code> استنتاج می‌کند. بدون مشخص کردن <code>int</code>، استنتاج نوع شکست می‌خورد: کامپایلر می‌داند که sqr باید از نوع <code>Func&lt;T,T&gt;</code> باشد، اما نمی‌داند T چیست.</p>
<p>از C# 10 به بعد می‌توان نوع بازگشتی lambda را نیز مشخص کرد:</p>
<pre><code class="language-csharp">var sqr = int (int x) =&gt; x;
</code></pre>
<p>مشخص کردن نوع بازگشتی می‌تواند عملکرد کامپایلر را در lambdaهای پیچیده و تو در تو بهبود دهد.</p>
<hr>
<h3>پارامترهای پیش‌فرض Lambda (C# 12) 🎯</h3>
<p>مانند متدهای معمولی که می‌توانند پارامتر اختیاری داشته باشند:</p>
<pre><code class="language-csharp">void Print(string message = &quot;&quot;) =&gt; Console.WriteLine(message);
</code></pre>
<p>lambdaها نیز می‌توانند پارامتر اختیاری داشته باشند:</p>
<pre><code class="language-csharp">var print = (string message = &quot;&quot;) =&gt; Console.WriteLine(message);
print(&quot;Hello&quot;);
print();
</code></pre>
<p>این ویژگی برای کتابخانه‌هایی مانند <strong>ASP.NET Minimal API</strong> مفید است.</p>
<hr>
<h3>دسترسی به متغیرهای خارجی (Outer Variables) 🌐</h3>
<p>یک lambda می‌تواند به هر متغیری که در محل تعریفش قابل دسترسی است، ارجاع دهد. این متغیرها <strong>outer variables</strong> نامیده می‌شوند و می‌توانند شامل متغیرهای محلی، پارامترها و فیلدها باشند:</p>
<pre><code class="language-csharp">int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;
Console.WriteLine(multiplier(3));   // خروجی: 6
</code></pre>
<p>متغیرهایی که توسط lambda ارجاع می‌شوند، <strong>captured variables</strong> نامیده می‌شوند. lambda که متغیرها را capture می‌کند، <strong>closure</strong> نامیده می‌شود.</p>
<p>متغیرهای capture شده هنگام فراخوانی delegate ارزیابی می‌شوند، نه هنگام capture شدن:</p>
<pre><code class="language-csharp">int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;
factor = 10;
Console.WriteLine(multiplier(3));  // خروجی: 30
</code></pre>
<p>lambdaها می‌توانند خودشان متغیرهای capture شده را به‌روزرسانی کنند:</p>
<pre><code class="language-csharp">int seed = 0;
Func&lt;int&gt; natural = () =&gt; seed++;
Console.WriteLine(natural());  // 0
Console.WriteLine(natural());  // 1
Console.WriteLine(seed);       // 2
</code></pre>
<p>متغیرهای capture شده طول عمرشان تا طول عمر delegate ادامه پیدا می‌کند. مثال:</p>
<pre><code class="language-csharp">static Func&lt;int&gt; Natural()
{
    int seed = 0;
    return () =&gt; seed++;  // برمی‌گرداند یک closure
}

static void Main()
{
    Func&lt;int&gt; natural = Natural();
    Console.WriteLine(natural()); // 0
    Console.WriteLine(natural()); // 1
}
</code></pre>
<p>اگر متغیر محلی را داخل خود lambda بسازیم، هر فراخوانی delegate یک متغیر جدید ایجاد می‌کند:</p>
<pre><code class="language-csharp">static Func&lt;int&gt; Natural()
{
    return () =&gt; { int seed = 0; return seed++; };
}

static void Main()
{
    Func&lt;int&gt; natural = Natural();
    Console.WriteLine(natural());  // 0
    Console.WriteLine(natural());  // 0
}
</code></pre>
<p>پیاده‌سازی capture داخلی با <strong>hoisting</strong> انجام می‌شود: متغیرهای capture شده به فیلدهای یک کلاس خصوصی منتقل می‌شوند و هنگام فراخوانی متد، کلاس ایجاد شده و به delegate وابسته می‌شود.</p>
<hr>
<h3>Lambdaهای استاتیک ⚡</h3>
<p>زمانی که lambda متغیرهای محلی، پارامترها، فیلدهای instance یا <strong>this</strong> را capture می‌کند، کامپایلر ممکن است کلاس خصوصی ایجاد کند تا ارجاع به داده‌ها ذخیره شود. این باعث مصرف حافظه می‌شود.</p>
<p>از C# 9 به بعد می‌توان با <strong>static</strong> کردن lambda، local function یا anonymous method، از capture شدن state جلوگیری کرد:</p>
<pre><code class="language-csharp">Func&lt;int, int&gt; multiplier = static n =&gt; n * 2;
</code></pre>
<p>اگر بعداً lambda بخواهد متغیری را capture کند، کامپایلر خطا می‌دهد:</p>
<pre><code class="language-csharp">int factor = 2;
Func&lt;int, int&gt; multiplier = static n =&gt; n * factor;  // کامپایل نمی‌شود
</code></pre>
<p>lambda بدون capture، یک instance delegate کش شده را مجدداً استفاده می‌کند و هزینه‌ای ندارد.</p>
<p>lambdaهای استاتیک هنوز می‌توانند به متغیرها و ثابت‌های static دسترسی داشته باشند. <strong>static</strong> تنها نقش بررسی دارد و تاثیری بر IL تولیدشده ندارد؛ بدون آن، کامپایلر در صورت نیاز closure تولید می‌کند، اما حتی آن زمان ترفندهایی برای کاهش هزینه دارد.</p>
<h3>گرفتن متغیرهای تکرار (Capturing iteration variables) 🔄</h3>
<p>وقتی در یک حلقه‌ی <code>for</code> متغیر تکرار (iteration variable) را <strong>Capture</strong> می‌کنید، زبان C# با آن طوری رفتار می‌کند که انگار <strong>بیرون از حلقه تعریف شده باشد</strong>. یعنی در هر تکرار، همان متغیر گرفته می‌شود. به همین دلیل برنامه‌ی زیر به‌جای نمایش <code>012</code>، مقدار <code>333</code> را چاپ می‌کند:</p>
<pre><code class="language-csharp">Action[] actions = new Action[3];
for (int i = 0; i &lt; 3; i++)
    actions[i] = () =&gt; Console.Write(i);

foreach (Action a in actions) a();     // 333
</code></pre>
<p>هر <strong>closure</strong> (بخش پررنگ شده) همان متغیر <code>i</code> را می‌گیرد. این منطقی است، چون <code>i</code> متغیری است که مقدارش بین تکرارهای حلقه باقی می‌ماند؛ حتی می‌توانید داخل بدنه‌ی حلقه، مقدار <code>i</code> را تغییر دهید. نتیجه این است که وقتی <strong>delegate</strong>ها بعداً فراخوانی می‌شوند، همگی مقدار <code>i</code> در لحظه‌ی فراخوانی را می‌بینند، یعنی <code>3</code>. برای درک بهتر، حلقه را این‌طور بازنویسی کنید:</p>
<pre><code class="language-csharp">Action[] actions = new Action[3];
int i = 0;
actions[0] = () =&gt; Console.Write(i);
i = 1;
actions[1] = () =&gt; Console.Write(i);
i = 2;
actions[2] = () =&gt; Console.Write(i);
i = 3;
foreach (Action a in actions) a();    // 333
</code></pre>
<p>راه‌حل برای نمایش <code>012</code> این است که متغیر تکرار را به یک <strong>متغیر محلی جدید</strong> که در همان محدوده‌ی حلقه قرار دارد، انتساب دهیم:</p>
<pre><code class="language-csharp">Action[] actions = new Action[3];
for (int i = 0; i &lt; 3; i++)
{
    int loopScopedi = i;
    actions[i] = () =&gt; Console.Write(loopScopedi);
}
foreach (Action a in actions) a();     // 012
</code></pre>
<p>چون در هر تکرار، یک متغیر جدید <code>loopScopedi</code> ساخته می‌شود، هر <strong>closure</strong> یک متغیر متفاوت را می‌گیرد. ✨</p>
<blockquote>
<p><strong>نکته:</strong> قبل از نسخه‌ی C# 5.0، حلقه‌های <code>foreach</code> هم همین رفتار را داشتند و باعث سردرگمی می‌شدند. چون متغیر در <code>foreach</code> تغییرناپذیر است، انتظار می‌رفت محلی باشد، ولی نبود. خوشبختانه این موضوع اصلاح شده و حالا می‌توانید متغیرهای <code>foreach</code> را بدون نگرانی Capture کنید. ✅</p>
</blockquote>
<hr>
<h3>مقایسه‌ی <strong>Lambda Expressions</strong> و <strong>Local Methods</strong> 🆚</h3>
<p>عملکرد <strong>local methods</strong> (بخش «Local methods» در صفحه 106) شباهت زیادی به <strong>lambda expressions</strong> دارد، اما سه مزیت دارند:</p>
<ol>
<li>می‌توانند <strong>بازگشتی (recursive)</strong> باشند (خودشان را صدا بزنند) بدون نیاز به روش‌های پیچیده.</li>
<li>نیاز به مشخص کردن نوع delegate ندارند و کد شلوغ نمی‌شود.</li>
<li><strong>کارایی بیشتری</strong> دارند چون سربار delegate را حذف می‌کنند.</li>
</ol>
<p><strong>Local methods</strong> بهینه‌تر هستند چون از واسطه‌ی delegate استفاده نمی‌کنند (این کار باعث صرف مقداری CPU و حافظه می‌شود). همچنین می‌توانند به متغیرهای محلی متد والد دسترسی داشته باشند بدون اینکه کامپایلر مجبور به <strong>hoist کردن</strong> آن‌ها در یک کلاس مخفی باشد.</p>
<p>اما در بسیاری از موارد شما به delegate نیاز دارید؛ مثل وقتی که می‌خواهید متدی با پارامتر از نوع delegate را صدا بزنید:</p>
<pre><code class="language-csharp">public void Foo(Func&lt;int, bool&gt; predicate) { ... }
</code></pre>
<p>(نمونه‌های بیشتری در فصل 8 خواهید دید.) در این مواقع، استفاده از <strong>lambda</strong> معمولاً کوتاه‌تر و تمیزتر است.</p>
<hr>
<h3>متدهای ناشناس (Anonymous Methods) 🕶️</h3>
<p><strong>Anonymous methods</strong> قابلیتی در C# 2.0 بودند که تا حد زیادی با <strong>lambda expressions</strong> در C# 3.0 جایگزین شدند. متدهای ناشناس مثل lambda هستند، اما امکانات زیر را ندارند:</p>
<ul>
<li><strong>پارامترهای نوع‌دهی ضمنی (implicitly typed)</strong></li>
<li><strong>نوشتار به شکل expression</strong> (همیشه باید به صورت بلوک بیانیه باشند)</li>
<li>توانایی <strong>تبدیل به Expression Tree</strong> با <code>Expression&lt;T&gt;</code></li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">delegate int Transformer(int i);
Transformer sqr = delegate (int x) { return x * x; };
Console.WriteLine(sqr(3));  // 9
</code></pre>
<p>این معادل نوشتار زیر با lambda است:</p>
<pre><code class="language-csharp">Transformer sqr = (int x) =&gt; { return x * x; };
// یا ساده‌تر:
Transformer sqr = x =&gt; x * x;
</code></pre>
<p>متدهای ناشناس هم مثل lambdaها متغیرهای بیرونی را Capture می‌کنند و حتی می‌توانند با کلمه‌ی کلیدی <code>static</code> شبیه lambdaهای استاتیک رفتار کنند.</p>
<p>ویژگی خاص آن‌ها این است که <strong>می‌توان پارامترها را کاملاً حذف کرد</strong>، حتی اگر delegate آن‌ها را انتظار داشته باشد. این برای تعریف event با handler خالی مفید است:</p>
<pre><code class="language-csharp">public event EventHandler Clicked = delegate { };
</code></pre>
<p>این کار باعث می‌شود قبل از صدا زدن event نیازی به بررسی null نداشته باشید. همچنین نوشتن زیر هم معتبر است:</p>
<pre><code class="language-csharp">// پارامترها حذف شده‌اند:
Clicked += delegate { Console.WriteLine(&quot;clicked&quot;); };
</code></pre>
<hr>
<h3>دستورات try و مدیریت استثناها (try Statements and Exceptions) ⚠️</h3>
<p>یک دستور <code>try</code> یک بلوک کد را مشخص می‌کند که ممکن است خطا رخ دهد یا نیاز به پاکسازی داشته باشد. بلوک <code>try</code> باید حداقل با یک <code>catch</code> یا یک <code>finally</code> (یا هر دو) همراه باشد:</p>
<ul>
<li><strong>catch</strong> زمانی اجرا می‌شود که خطا در بلوک try رخ دهد.</li>
<li><strong>finally</strong> همیشه بعد از خروج از try (یا catch) اجرا می‌شود و معمولاً برای کارهای پاکسازی مثل بستن اتصالات شبکه است.</li>
</ul>
<p><code>catch</code> به شیء <code>Exception</code> دسترسی دارد که اطلاعات خطا را نگه می‌دارد. شما می‌توانید خطا را مدیریت کنید یا دوباره پرتاب کنید (برای لاگ کردن یا بالا بردن سطح خطا).</p>
<p>مثال:</p>
<pre><code class="language-csharp">try
{
    // ممکن است خطا رخ دهد
}
catch (ExceptionA ex)
{
    // مدیریت خطای نوع ExceptionA
}
catch (ExceptionB ex)
{
    // مدیریت خطای نوع ExceptionB
}
finally
{
    // پاکسازی
}
</code></pre>
<p>برنامه‌ی زیر را در نظر بگیرید:</p>
<pre><code class="language-csharp">int y = Calc(0);
Console.WriteLine(y);

int Calc(int x) =&gt; 10 / x;
</code></pre>
<p>چون <code>x</code> صفر است، خطای <code>DivideByZeroException</code> رخ می‌دهد و برنامه متوقف می‌شود. حالا با <code>try/catch</code>:</p>
<pre><code class="language-csharp">try
{
    int y = Calc(0);
    Console.WriteLine(y);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine(&quot;x cannot be zero&quot;);
}
Console.WriteLine(&quot;program completed&quot;);

int Calc(int x) =&gt; 10 / x;
</code></pre>
<p>خروجی:</p>
<pre><code>x cannot be zero
program completed
</code></pre>
<p>در عمل، بهتر است <strong>خطاهای قابل پیشگیری را قبل از وقوع بررسی کنید</strong>، مثلاً تقسیم بر صفر را چک کنید، چون <strong>exceptionها هزینه‌بر هستند</strong> (صدها سیکل پردازنده یا بیشتر).</p>
<p>وقتی exception رخ می‌دهد، CLR بررسی می‌کند:</p>
<ul>
<li>اگر <code>catch</code> سازگار پیدا شد: همان را اجرا می‌کند، سپس <code>finally</code> و برنامه ادامه می‌یابد.</li>
<li>اگر پیدا نشد: <code>finally</code> اجرا می‌شود (اگر باشد) و CLR به عقب در stack دنبال <code>try</code> می‌گردد.</li>
<li>اگر هیچ تابعی مسئولیت نگرفت: برنامه متوقف می‌شود.</li>
</ul>
<hr>
<h3>بخش catch (بخش گرفتن استثناها) 🛡️</h3>
<p>یک <strong>catch clause</strong> مشخص می‌کند که چه نوع استثنایی (<strong>Exception</strong>) باید گرفته شود. این نوع باید یا <strong>System.Exception</strong> باشد یا یک زیرکلاس از <strong>System.Exception</strong>.</p>
<p>اگر <strong>System.Exception</strong> را بگیرید، تمام خطاهای ممکن را خواهید گرفت. این کار در شرایط زیر مفید است:</p>
<ul>
<li>وقتی برنامه‌تان می‌تواند بدون توجه به نوع خاص استثنا، بهبود یابد.</li>
<li>وقتی قصد دارید استثنا را دوباره پرتاب کنید (مثلاً بعد از ثبت یا <strong>Log</strong> کردن آن).</li>
<li>وقتی هندلر خطای شما آخرین خط دفاعی قبل از پایان برنامه است.</li>
</ul>
<p>اما در حالت معمول، بهتر است نوع‌های خاص استثنا را بگیرید تا مجبور نشوید با شرایطی روبه‌رو شوید که هندلر شما برای آن طراحی نشده است (مثلاً <strong>OutOfMemoryException</strong>).</p>
<p>برای مدیریت چند نوع استثنا، می‌توانید از چندین بخش <strong>catch</strong> استفاده کنید (هرچند در این مثال می‌توان به جای مدیریت استثنا، بررسی ورودی‌ها را انجام داد):</p>
<pre><code class="language-csharp">class Test
{
  static void Main (string[] args)
  {
    try
    {
      byte b = byte.Parse (args[0]);
      Console.WriteLine (b);
    }
    catch (IndexOutOfRangeException)
    {
      Console.WriteLine (&quot;Please provide at least one argument&quot;);
    }
    catch (FormatException)
    {
      Console.WriteLine (&quot;That's not a number!&quot;);
    }
    catch (OverflowException)
    {
      Console.WriteLine (&quot;You've given me more than a byte!&quot;);
    }
  }
}
</code></pre>
<p>برای هر استثنا فقط یک <strong>catch</strong> اجرا می‌شود. اگر می‌خواهید یک هندلر کلی مثل <strong>System.Exception</strong> داشته باشید، باید هندلرهای خاص‌تر را قبل از آن قرار دهید.</p>
<p>گاهی نیاز ندارید به ویژگی‌های استثنا دسترسی داشته باشید. در این حالت می‌توانید متغیر را حذف کنید:</p>
<pre><code class="language-csharp">catch (OverflowException)   // بدون متغیر
{
  ...
}
</code></pre>
<p>حتی می‌توانید هم متغیر و هم نوع را حذف کنید (به این معنی که همه استثناها گرفته می‌شوند):</p>
<pre><code class="language-csharp">catch { ... }
</code></pre>
<hr>
<h3>Exception filters (فیلترهای استثنا) 🔍</h3>
<p>می‌توانید در بخش <strong>catch</strong> یک فیلتر استثنا با استفاده از کلمه <strong>when</strong> مشخص کنید:</p>
<pre><code class="language-csharp">catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{
  ...
}
</code></pre>
<p>در این مثال، اگر <strong>WebException</strong> پرتاب شود، عبارت بولی بعد از <strong>when</strong> ارزیابی می‌شود. اگر نتیجه <strong>false</strong> باشد، این <strong>catch</strong> نادیده گرفته شده و به سراغ <strong>catch</strong>های بعدی می‌رود.</p>
<p>با <strong>exception filters</strong> می‌توان یک نوع استثنا را چند بار با شرایط متفاوت گرفت:</p>
<pre><code class="language-csharp">catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{ ... }
catch (WebException ex) when (ex.Status == WebExceptionStatus.SendFailure)
{ ... }
</code></pre>
<p>عبارت بولی در <strong>when</strong> حتی می‌تواند شامل متدهایی باشد که عملیات جانبی انجام می‌دهند، مانند ثبت خطا برای اهداف عیب‌یابی.</p>
<hr>
<h3>بخش finally (بخش پایانی) 🧹</h3>
<p>بخش <strong>finally</strong> همیشه اجرا می‌شود—چه استثنا رخ دهد چه نه، و چه <strong>try</strong> به طور کامل اجرا شود یا خیر. معمولاً از <strong>finally</strong> برای کدهای پاک‌سازی استفاده می‌کنیم.</p>
<p>بخش <strong>finally</strong> بعد از هر یک از این حالت‌ها اجرا می‌شود:</p>
<ul>
<li>بعد از اتمام یک <strong>catch</strong> (یا زمانی که یک استثنای جدید پرتاب شود).</li>
<li>بعد از اتمام بلوک <strong>try</strong> (یا زمانی که استثنایی رخ دهد که هندلری برایش وجود ندارد).</li>
<li>زمانی که کنترل با یک دستور پرش (مثل <strong>return</strong> یا <strong>goto</strong>) از بلوک <strong>try</strong> خارج شود.</li>
</ul>
<p>تنها مواردی که می‌توانند مانع اجرای <strong>finally</strong> شوند، یک حلقه بی‌نهایت یا پایان ناگهانی پردازش است.</p>
<p>بخش <strong>finally</strong> به برنامه‌تان نظم و قطعیت اضافه می‌کند. در مثال زیر، فایلی که باز شده همیشه بسته می‌شود، صرف‌نظر از اینکه:</p>
<ul>
<li>بلوک <strong>try</strong> به طور عادی تمام شود.</li>
<li>اجرا به دلیل خالی بودن فایل (<strong>EndOfStream</strong>) زودتر بازگردد.</li>
<li>یک <strong>IOException</strong> هنگام خواندن فایل رخ دهد:</li>
</ul>
<pre><code class="language-csharp">void ReadFile()
{
  StreamReader reader = null;    // در فضای نام System.IO
  try
  {
    reader = File.OpenText (&quot;file.txt&quot;);
    if (reader.EndOfStream) return;
    Console.WriteLine (reader.ReadToEnd());
  }
  finally
  {
    if (reader != null) reader.Dispose();
  }
}
</code></pre>
<p>در این مثال، فایل را با فراخوانی <strong>Dispose</strong> روی <strong>StreamReader</strong> بستیم. فراخوانی <strong>Dispose</strong> روی یک شیء در داخل <strong>finally</strong> یک روش استاندارد است و در #C با دستور <strong>using</strong> نیز پشتیبانی می‌شود.</p>
<hr>
<h3>دستور <code>using</code> ♻️</h3>
<p>بسیاری از کلاس‌ها منابع مدیریت‌نشده (Unmanaged Resources) مانند <strong>دستگیره‌های فایل (File Handles)</strong>، <strong>دستگیره‌های گرافیکی (Graphics Handles)</strong> یا <strong>اتصالات پایگاه داده (Database Connections)</strong> را در خود جای می‌دهند. این کلاس‌ها اینترفیس <strong><code>System.IDisposable</code></strong> را پیاده‌سازی می‌کنند که تنها یک متد بدون پارامتر به نام <strong><code>Dispose</code></strong> دارد و برای پاک‌سازی این منابع استفاده می‌شود.</p>
<p>دستور <strong><code>using</code></strong> یک نگارش ساده و شکیل برای فراخوانی <strong><code>Dispose</code></strong> روی یک شیء پیاده‌ساز <strong><code>IDisposable</code></strong>، درون یک بلوک <strong><code>finally</code></strong> فراهم می‌کند.</p>
<p>به‌عنوان مثال:</p>
<pre><code class="language-csharp">using (StreamReader reader = File.OpenText(&quot;file.txt&quot;))
{
    ...
}
</code></pre>
<p>این قطعه‌کد دقیقاً معادل زیر است:</p>
<pre><code class="language-csharp">StreamReader reader = File.OpenText(&quot;file.txt&quot;);
try
{
    ...
}
finally
{
    if (reader != null)
        ((IDisposable)reader).Dispose();
}
</code></pre>
<hr>
<h3>اعلان‌های <code>using</code> (Using Declarations) ✍️</h3>
<p>اگر در <strong>C# 8 و نسخه‌های بالاتر</strong>، براکت‌ها و بلوک کد بعد از دستور <strong><code>using</code></strong> حذف شوند، این دستور تبدیل به <strong>اعلان using</strong> می‌شود. در این حالت، منبع زمانی آزاد می‌شود که اجرای برنامه از بلوک محصورکننده خارج گردد.</p>
<p>مثال:</p>
<pre><code class="language-csharp">if (File.Exists(&quot;file.txt&quot;))
{
    using var reader = File.OpenText(&quot;file.txt&quot;);
    Console.WriteLine(reader.ReadLine());
    ...
}
</code></pre>
<p>در این حالت، <strong><code>reader</code></strong> زمانی Dispose می‌شود که اجرای برنامه از بلوک <strong><code>if</code></strong> خارج شود.</p>
<hr>
<h3>پرتاب استثنا (Throwing Exceptions) 🚀</h3>
<p>استثناها (Exceptions) می‌توانند هم توسط <strong>زمان اجرا (Runtime)</strong> و هم در <strong>کدهای کاربر</strong> پرتاب شوند. در مثال زیر، متد <strong><code>Display</code></strong> یک استثنای <strong><code>System.ArgumentNullException</code></strong> را پرتاب می‌کند:</p>
<pre><code class="language-csharp">try { Display(null); }
catch (ArgumentNullException ex)
{
    Console.WriteLine(&quot;Caught the exception&quot;);
}

void Display(string name)
{
    if (name == null)
        throw new ArgumentNullException(nameof(name));
    Console.WriteLine(name);
}
</code></pre>
<p>از آن‌جایی که بررسی آرگومان برای مقدار <strong>null</strong> و پرتاب <strong><code>ArgumentNullException</code></strong> بسیار رایج است، از <strong>.NET 6</strong> یک میان‌بر ارائه شده است:</p>
<pre><code class="language-csharp">void Display(string name)
{
    ArgumentNullException.ThrowIfNull(name);
    Console.WriteLine(name);
}
</code></pre>
<p>توجه کنید که در این روش، نیازی به مشخص کردن نام پارامتر نداریم. دلیل این موضوع در بخش <strong>CallerArgumentExpression</strong> (صفحه 247) توضیح داده خواهد شد.</p>
<hr>
<h3>عبارت‌های <code>throw</code> (Throw Expressions) 🎯</h3>
<p>عبارت <strong><code>throw</code></strong> می‌تواند به‌عنوان یک <strong>عبارت (Expression)</strong> در متدهای <strong>Expression-bodied</strong> استفاده شود:</p>
<pre><code class="language-csharp">public string Foo() =&gt; throw new NotImplementedException();
</code></pre>
<p>همچنین می‌تواند در یک <strong>عبارت شرطی سه‌تایی (Ternary Conditional Expression)</strong> ظاهر شود:</p>
<pre><code class="language-csharp">string ProperCase(string value) =&gt;
    value == null ? throw new ArgumentException(&quot;value&quot;) :
    value == &quot;&quot; ? &quot;&quot; :
    char.ToUpper(value[0]) + value.Substring(1);
</code></pre>
<hr>
<h3>پرتاب دوباره استثنا (Rethrowing an Exception) 🔄</h3>
<p>می‌توانید یک استثنا را گرفته و دوباره پرتاب کنید:</p>
<pre><code class="language-csharp">try
{
    ...
}
catch (Exception ex)
{
    // Log error
    ...
    throw; // پرتاب دوباره همان استثنا
}
</code></pre>
<p>اگر به‌جای <strong><code>throw</code></strong> از <strong><code>throw ex</code></strong> استفاده کنیم، برنامه همچنان کار می‌کند اما خاصیت <strong><code>StackTrace</code></strong> دیگر مسیر خطای اصلی را نشان نمی‌دهد.</p>
<p>پرتاب دوباره به شما اجازه می‌دهد خطا را <strong>ثبت (Log)</strong> کنید بدون اینکه آن را نادیده بگیرید، یا زمانی که شرایط فراتر از انتظار است، از ادامه مدیریت خطا صرف‌نظر کنید.</p>
<p>یکی دیگر از سناریوهای رایج، پرتاب یک استثنای <strong>خاص‌تر</strong> است:</p>
<pre><code class="language-csharp">try
{
    // Parse a DateTime from XML element data
}
catch (FormatException ex)
{
    throw new XmlException(&quot;Invalid DateTime&quot;, ex);
}
</code></pre>
<p>دقت کنید که هنگام ساخت <strong><code>XmlException</code></strong>، استثنای اصلی <strong><code>ex</code></strong> را به‌عنوان آرگومان دوم پاس دادیم. این آرگومان خاصیت <strong><code>InnerException</code></strong> را مقداردهی می‌کند و در اشکال‌زدایی کمک زیادی می‌کند. تقریباً همه انواع استثنا چنین سازنده‌ای دارند.</p>
<hr>
<h3>پرتاب یک استثنای کلی‌تر (Less-Specific Exception)</h3>
<p>این روش زمانی مفید است که در حال عبور از یک <strong>مرز اعتماد (Trust Boundary)</strong> هستید تا از افشای اطلاعات فنی برای مهاجمان بالقوه جلوگیری کنید.</p>
<hr>
<h3>ویژگی‌های کلیدی <strong>System.Exception</strong> ⚙️</h3>
<p>مهم‌ترین ویژگی‌های <strong>System.Exception</strong> به شرح زیر هستند:</p>
<ul>
<li>
<p><strong>StackTrace</strong>
رشته‌ای (<strong>string</strong>) که تمام متدهایی را که از نقطه شروع رخداد استثنا تا بلوک <strong>catch</strong> فراخوانی شده‌اند، نمایش می‌دهد.</p>
</li>
<li>
<p><strong>Message</strong>
رشته‌ای که توضیح خطا را در خود نگه می‌دارد.</p>
</li>
<li>
<p><strong>InnerException</strong>
استثنای داخلی (در صورت وجود) که باعث ایجاد استثنای بیرونی شده است. این استثنا خود می‌تواند شامل <strong>InnerException</strong> دیگری نیز باشد.</p>
</li>
</ul>
<blockquote>
<p>در زبان C# تمام استثناها در زمان اجرا (<strong>runtime exceptions</strong>) اتفاق می‌افتند و معادلی برای استثناهای بررسی‌شده در زمان کامپایل (<strong>compile-time checked exceptions</strong>) مانند Java وجود ندارد.</p>
</blockquote>
<hr>
<h3>انواع رایج استثناها 🚨</h3>
<p>انواع زیر از استثناها به‌طور گسترده در سراسر <strong>CLR</strong> و کتابخانه‌های <strong>.NET</strong> استفاده می‌شوند. شما می‌توانید آن‌ها را خودتان پرتاب کنید یا از آن‌ها به‌عنوان کلاس پایه برای ساخت انواع سفارشی استثنا استفاده نمایید:</p>
<ul>
<li>
<p><strong>System.ArgumentException</strong>
زمانی پرتاب می‌شود که یک تابع با آرگومان نامعتبر فراخوانی شود. معمولاً نشان‌دهنده یک خطای برنامه‌نویسی است.</p>
</li>
<li>
<p><strong>System.ArgumentNullException</strong>
زیرکلاس <strong>ArgumentException</strong> که وقتی یک آرگومان تابع به‌طور غیرمنتظره <strong>null</strong> باشد، پرتاب می‌شود.</p>
</li>
<li>
<p><strong>System.ArgumentOutOfRangeException</strong>
زیرکلاس <strong>ArgumentException</strong> که وقتی یک آرگومان (معمولاً عددی) خیلی بزرگ یا خیلی کوچک باشد، پرتاب می‌شود. برای مثال، ارسال یک عدد منفی به تابعی که فقط مقادیر مثبت را می‌پذیرد.</p>
</li>
<li>
<p><strong>System.InvalidOperationException</strong>
زمانی پرتاب می‌شود که وضعیت یک شیء برای اجرای موفقیت‌آمیز متد مناسب نباشد، بدون توجه به مقدار آرگومان‌ها. مثال‌ها شامل خواندن یک فایل بازنشده یا دریافت عنصر بعدی از یک شمارنده (<strong>Enumerator</strong>) است که لیست زیرین آن در میانه اجرا تغییر کرده است.</p>
</li>
<li>
<p><strong>System.NotSupportedException</strong>
زمانی پرتاب می‌شود که یک قابلیت خاص پشتیبانی نمی‌شود. مثالی مناسب: فراخوانی متد <strong>Add</strong> روی مجموعه‌ای که <strong>IsReadOnly</strong> آن <strong>true</strong> است.</p>
</li>
<li>
<p><strong>System.NotImplementedException</strong>
زمانی پرتاب می‌شود که یک تابع هنوز پیاده‌سازی نشده است.</p>
</li>
<li>
<p><strong>System.ObjectDisposedException</strong>
زمانی پرتاب می‌شود که روی شیئی که قبلاً <strong>Dispose</strong> شده، متدی فراخوانی شود.</p>
</li>
</ul>
<p>یکی دیگر از استثناهای رایج <strong>NullReferenceException</strong> است. این استثنا توسط <strong>CLR</strong> زمانی پرتاب می‌شود که تلاش کنید به عضوی از شیئی که مقدار آن <strong>null</strong> است دسترسی پیدا کنید (که نشان‌دهنده وجود باگ در کد شماست). برای تست، می‌توانید به‌طور مستقیم این استثنا را پرتاب کنید:</p>
<pre><code class="language-csharp">throw null;
</code></pre>
<hr>
<h3>الگوی متدهای <strong>TryXXX</strong> 🔄</h3>
<p>هنگام نوشتن یک متد، زمانی که مشکلی پیش می‌آید، دو انتخاب دارید: یا یک کد خطا برگردانید یا یک استثنا پرتاب کنید. به‌طور کلی، زمانی که خطا خارج از روند عادی برنامه باشد یا زمانی که انتظار ندارید فراخواننده بتواند با آن مقابله کند، استثنا پرتاب می‌کنید.</p>
<p>بااین‌حال، گاهی بهتر است هر دو انتخاب را به مصرف‌کننده ارائه دهید. مثالی از این مورد نوع <strong>int</strong> است که دو نسخه از متد <strong>Parse</strong> را ارائه می‌دهد:</p>
<pre><code class="language-csharp">public int Parse(string input);
public bool TryParse(string input, out int returnValue);
</code></pre>
<p>اگر <strong>Parse</strong> شکست بخورد، یک استثنا پرتاب می‌کند؛ اما <strong>TryParse</strong> در این حالت مقدار <strong>false</strong> برمی‌گرداند.</p>
<p>می‌توانید این الگو را با این روش پیاده‌سازی کنید که متد <strong>XXX</strong> در نهایت متد <strong>TryXXX</strong> را فراخوانی کند:</p>
<pre><code class="language-csharp">public return-type XXX(input-type input)
{
    return-type returnValue;
    if (!TryXXX(input, out returnValue))
        throw new YYYException(...);
    return returnValue;
}
</code></pre>
<hr>
<h3>جایگزین‌های استثناها 🛠️</h3>
<p>همانند <strong>int.TryParse</strong>، یک تابع می‌تواند با برگرداندن یک کد خطا از طریق مقدار بازگشتی یا پارامتر به تابع فراخواننده، شکست را اطلاع دهد. اگرچه این روش برای خطاهای ساده و قابل پیش‌بینی کارآمد است، اما هنگام مواجهه با خطاهای غیرمعمول یا غیرقابل پیش‌بینی دست‌وپاگیر می‌شود، امضای متدها را شلوغ می‌کند و پیچیدگی‌های غیرضروری ایجاد می‌نماید.</p>
<p>همچنین این روش برای توابعی که متد نیستند (مانند عملگرها مثل عملگر تقسیم یا ویژگی‌ها <strong>Properties</strong>) قابل استفاده نیست. یک جایگزین دیگر قرار دادن خطا در یک محل مشترک است که تمام توابع در زنجیره فراخوانی بتوانند آن را ببینند (مثلاً یک متد <strong>static</strong> که خطای فعلی را در هر نخ ذخیره کند). با این حال، این روش نیازمند مشارکت هر تابع در الگوی انتشار خطا است که هم دست‌وپاگیر و هم مستعد خطا خواهد بود.</p>
<hr>
<h3>شمارش (Enumeration) و پیمایشگرها (Iterators) 🔄</h3>
<h4>شمارش (Enumeration)</h4>
<p><strong>Enumerator (شمارش‌گر)</strong> یک مکان‌نما (cursor) <strong>فقط خواندنی</strong> و <strong>فقط رو به جلو</strong> روی یک دنباله از مقادیر است. در زبان #C، یک نوع (type) به‌عنوان شمارش‌گر شناخته می‌شود اگر یکی از شرایط زیر را داشته باشد:</p>
<ul>
<li>یک متد عمومی (public) بدون پارامتر به نام <code>MoveNext</code> و یک ویژگی (property) به نام <code>Current</code> داشته باشد.</li>
<li>واسط <code>System.Collections.Generic.IEnumerator&lt;T&gt;</code> را پیاده‌سازی کند.</li>
<li>واسط <code>System.Collections.IEnumerator</code> را پیاده‌سازی کند.</li>
</ul>
<p><strong>عبارت foreach</strong> روی یک <strong>Enumerable object (شیء شمارش‌پذیر)</strong> پیمایش می‌کند.
یک <strong>Enumerable object</strong> نمایش منطقی یک دنباله است. این شیء خودش مکان‌نما نیست، بلکه <strong>مکان‌نما تولید می‌کند</strong>. در #C، یک نوع به‌عنوان شمارش‌پذیر شناخته می‌شود اگر یکی از شرایط زیر را داشته باشد (بررسی‌ها به همین ترتیب انجام می‌شود):</p>
<ul>
<li>یک متد عمومی بدون پارامتر به نام <code>GetEnumerator</code> داشته باشد که یک شمارش‌گر برگرداند.</li>
<li>واسط <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code> را پیاده‌سازی کند.</li>
<li>واسط <code>System.Collections.IEnumerable</code> را پیاده‌سازی کند.</li>
<li>(از #C نسخه 9 به بعد) بتواند به یک متد توسعه‌ای (extension method) به نام <code>GetEnumerator</code> که یک شمارش‌گر برمی‌گرداند، متصل شود (بخش <strong>&quot;Extension Methods&quot;</strong> در صفحه 217 را ببینید).</li>
</ul>
<p><strong>الگوی شمارش</strong> به شکل زیر است:</p>
<pre><code class="language-csharp">class Enumerator   // معمولاً واسط IEnumerator یا IEnumerator&lt;T&gt; را پیاده‌سازی می‌کند
{
  public IteratorVariableType Current { get {...} }
  public bool MoveNext() {...}
}

class Enumerable   // معمولاً واسط IEnumerable یا IEnumerable&lt;T&gt; را پیاده‌سازی می‌کند
{
  public Enumerator GetEnumerator() {...}
}
</code></pre>
<p><strong>نمونه پیمایش سطح بالا</strong> روی کاراکترهای کلمه <code>&quot;beer&quot;</code> با استفاده از <code>foreach</code>:</p>
<pre><code class="language-csharp">foreach (char c in &quot;beer&quot;)
  Console.WriteLine(c);
</code></pre>
<p><strong>نمونه پیمایش سطح پایین</strong> روی کاراکترهای <code>&quot;beer&quot;</code> بدون استفاده از <code>foreach</code>:</p>
<pre><code class="language-csharp">using (var enumerator = &quot;beer&quot;.GetEnumerator())
  while (enumerator.MoveNext())
  {
    var element = enumerator.Current;
    Console.WriteLine(element);
  }
</code></pre>
<blockquote>
<p>اگر شمارش‌گر واسط <code>IDisposable</code> را پیاده‌سازی کند، عبارت <code>foreach</code> مانند یک عبارت <code>using</code> عمل کرده و <strong>به‌طور ضمنی</strong> شیء شمارش‌گر را آزاد (dispose) می‌کند.</p>
</blockquote>
<p>جزئیات بیشتر در مورد واسط‌های شمارش در <strong>فصل 7</strong> توضیح داده شده است.</p>
<hr>
<h4>مقداردهی اولیه مجموعه‌ها (Collection Initializers) و عبارات مجموعه‌ای (Collection Expressions) 📝</h4>
<p>شما می‌توانید در یک مرحله، یک شیء شمارش‌پذیر را ایجاد و مقداردهی کنید:</p>
<pre><code class="language-csharp">using System.Collections.Generic;
var list = new List&lt;int&gt; { 1, 2, 3 };
</code></pre>
<p>از نسخه #C 12 به بعد، می‌توانید این کار را کوتاه‌تر انجام دهید (با استفاده از <strong>براکت‌ها</strong>):</p>
<pre><code class="language-csharp">using System.Collections.Generic;
List&lt;int&gt; list = [1, 2, 3];
</code></pre>
<p><strong>عبارات مجموعه‌ای</strong> <strong>هدف‌نوعی (target-typed)</strong> هستند؛ یعنی نوع <code>[1, 2, 3]</code> به نوع متغیری که به آن انتساب داده می‌شود بستگی دارد. مثال:</p>
<pre><code class="language-csharp">int[] array = [1, 2, 3];
Span&lt;int&gt; span = [1, 2, 3];
</code></pre>
<p>حتی می‌توانید هنگام فراخوانی متدها هم نوع را حذف کنید اگر کامپایلر بتواند آن را استنباط کند:</p>
<pre><code class="language-csharp">Foo([1, 2, 3]);

void Foo(List&lt;int&gt; numbers) { ... }
</code></pre>
<p>کامپایلر این کد را به این شکل ترجمه می‌کند:</p>
<pre><code class="language-csharp">using System.Collections.Generic;
List&lt;int&gt; list = new List&lt;int&gt;();
list.Add(1);
list.Add(2);
list.Add(3);
</code></pre>
<p>این موضوع نیازمند این است که شیء شمارش‌پذیر واسط <code>System.Collections.IEnumerable</code> را پیاده‌سازی کند و یک متد <code>Add</code> با تعداد پارامتر مناسب داشته باشد. (در عبارات مجموعه‌ای، کامپایلر از الگوهای دیگر هم برای ایجاد مجموعه‌های فقط خواندنی پشتیبانی می‌کند.)</p>
<p>همچنین می‌توانید دیکشنری‌ها را هم به همین شکل مقداردهی کنید (بخش <strong>&quot;Dictionaries&quot;</strong> در صفحه 394 را ببینید):</p>
<pre><code class="language-csharp">var dict = new Dictionary&lt;int, string&gt;()
{
  { 5, &quot;five&quot; },
  { 10, &quot;ten&quot; }
};
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre><code class="language-csharp">var dict = new Dictionary&lt;int, string&gt;()
{
  [3] = &quot;three&quot;,
  [10] = &quot;ten&quot;
};
</code></pre>
<p>این روش نه تنها برای دیکشنری‌ها، بلکه برای هر نوعی که <strong>Indexer</strong> داشته باشد، معتبر است.</p>
<hr>
<h4>پیمایشگرها (Iterators) ⚙️</h4>
<p>در حالی که عبارت <code>foreach</code> <strong>مصرف‌کننده</strong> یک شمارش‌گر است، <strong>Iterator (پیمایشگر)</strong> <strong>تولیدکننده</strong> یک شمارش‌گر است.
مثال زیر یک پیمایشگر است که یک دنباله از اعداد فیبوناچی را تولید می‌کند (هر عدد حاصل جمع دو عدد قبلی است):</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
foreach (int fib in Fibs(6))
  Console.Write(fib + &quot;  &quot;);

IEnumerable&lt;int&gt; Fibs(int fibCount)
{
  for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)
  {
    yield return prevFib;
    int newFib = prevFib + curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}
</code></pre>
<p><strong>خروجی:</strong></p>
<pre><code>1  1  2  3  5  8
</code></pre>
<p>در حالی که دستور <code>return</code> می‌گوید: <strong>&quot;این مقداری است که از این متد خواسته بودی&quot;</strong>، دستور <code>yield return</code> می‌گوید: <strong>&quot;این عنصر بعدی است که از این شمارش‌گر خواسته بودی&quot;</strong>.
در هر دستور <code>yield</code>، کنترل به فراخواننده برمی‌گردد، اما <strong>وضعیت متد حفظ می‌شود</strong> تا وقتی فراخواننده عنصر بعدی را درخواست کرد، متد از همان‌جا ادامه یابد. این وضعیت به عمر شمارش‌گر وابسته است و بعد از اتمام پیمایش آزاد می‌شود.</p>
<p>کامپایلر متدهای پیمایشگر را به کلاس‌های خصوصی تبدیل می‌کند که واسط‌های <code>IEnumerable&lt;T&gt;</code> و/یا <code>IEnumerator&lt;T&gt;</code> را پیاده‌سازی می‌کنند.
منطق موجود در بلوک پیمایشگر در متد <code>MoveNext</code> و ویژگی <code>Current</code> کلاس تولیدشده توسط کامپایلر قرار داده می‌شود. <strong>این یعنی وقتی متد پیمایشگر را صدا می‌زنید، هیچ کدی اجرا نمی‌شود؛ تنها یک نمونه از کلاس ساخته می‌شود!</strong>
کد شما تنها وقتی اجرا می‌شود که پیمایش شروع شود، معمولاً با یک عبارت <code>foreach</code>.</p>
<blockquote>
<p>پیمایشگرها می‌توانند متدهای محلی (local methods) هم باشند (بخش <strong>&quot;Local methods&quot;</strong> در صفحه 106 را ببینید).</p>
</blockquote>
<hr>
<h3>معنای <strong>Iterator</strong> (تکرارکننده) 🔄</h3>
<p>یک <strong>Iterator</strong> یا «تکرارکننده» متدی، ویژگی (Property) یا ایندکسری است که شامل یک یا چند دستور <code>yield</code> است. یک <strong>Iterator</strong> باید یکی از چهار رابط (Interface) زیر را برگرداند، در غیر این صورت کامپایلر خطا تولید می‌کند:</p>
<pre><code class="language-csharp">// رابط‌های Enumerable
System.Collections.IEnumerable
System.Collections.Generic.IEnumerable&lt;T&gt;

// رابط‌های Enumerator
System.Collections.IEnumerator
System.Collections.Generic.IEnumerator&lt;T&gt;
</code></pre>
<p><strong>Iterator</strong> بسته به اینکه یک رابط <strong>Enumerable</strong> یا <strong>Enumerator</strong> برمی‌گرداند، رفتار متفاوتی دارد. توضیح کامل این موضوع در فصل ۷ آمده است.</p>
<hr>
<h3>استفاده از چندین دستور <code>yield</code></h3>
<p>در یک <strong>Iterator</strong> می‌توان چندین دستور <code>yield</code> استفاده کرد:</p>
<pre><code class="language-csharp">foreach (string s in Foo())
    Console.WriteLine(s); // چاپ می‌کند: &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;

IEnumerable&lt;string&gt; Foo()
{
    yield return &quot;One&quot;;
    yield return &quot;Two&quot;;
    yield return &quot;Three&quot;;
}
</code></pre>
<hr>
<h3>استفاده از <code>yield break</code></h3>
<p>در یک بلوک <strong>Iterator</strong> استفاده از دستور <code>return</code> مجاز نیست. برای خروج زودهنگام از <strong>Iterator</strong> (بدون برگرداندن عناصر بیشتر) باید از <code>yield break</code> استفاده کنید:</p>
<pre><code class="language-csharp">IEnumerable&lt;string&gt; Foo(bool breakEarly)
{
    yield return &quot;One&quot;;
    yield return &quot;Two&quot;;
    if (breakEarly)
        yield break;
    yield return &quot;Three&quot;;
}
</code></pre>
<hr>
<h3><strong>Iteratorها</strong> و بلوک‌های <strong>try/catch/finally</strong> ⚠️</h3>
<ul>
<li>استفاده از <code>yield return</code> در یک بلوک <code>try</code> که شامل بخش <code>catch</code> باشد، <strong>مجاز نیست</strong>:</li>
</ul>
<pre><code class="language-csharp">IEnumerable&lt;string&gt; Foo()
{
    try { yield return &quot;One&quot;; } // غیرمجاز
    catch { ... }
}
</code></pre>
<ul>
<li>
<p>همچنین استفاده از <code>yield return</code> در بخش‌های <code>catch</code> یا <code>finally</code> نیز مجاز نیست.
دلیل این محدودیت‌ها این است که کامپایلر باید <strong>Iteratorها</strong> را به کلاس‌های معمولی با متدهای <code>MoveNext</code>، <code>Current</code> و <code>Dispose</code> تبدیل کند و مدیریت بلاک‌های خطا پیچیدگی زیادی ایجاد می‌کند.</p>
</li>
<li>
<p>اما می‌توانید در بلوک <code>try</code> که <strong>فقط</strong> شامل یک بخش <code>finally</code> است از <code>yield return</code> استفاده کنید:</p>
</li>
</ul>
<pre><code class="language-csharp">IEnumerable&lt;string&gt; Foo()
{
    try { yield return &quot;One&quot;; } // مجاز
    finally { ... }
}
</code></pre>
<p>کد موجود در بلوک <code>finally</code> زمانی اجرا می‌شود که شمارنده (<strong>Enumerator</strong>) مصرف‌کننده به انتهای توالی برسد یا از بین برود. دستور <code>foreach</code> به‌صورت ضمنی شمارنده را Dispose می‌کند اگر زودتر از حلقه خارج شوید، بنابراین این روش امنی برای استفاده از شمارنده‌هاست.</p>
<hr>
<h3>احتیاط هنگام استفاده از <strong>Enumeratorها</strong> به‌صورت دستی 🔍</h3>
<p>اگر شمارنده را به‌صورت دستی استفاده می‌کنید و قبل از پایان کار آن را رها کنید بدون اینکه Dispose کنید، بلوک <code>finally</code> اجرا نمی‌شود. برای جلوگیری از این مشکل، شمارنده‌ها را درون یک دستور <code>using</code> قرار دهید:</p>
<pre><code class="language-csharp">string firstElement = null;
var sequence = Foo();
using (var enumerator = sequence.GetEnumerator())
    if (enumerator.MoveNext())
        firstElement = enumerator.Current;
</code></pre>
<hr>
<h3>ترکیب توالی‌ها (Composing Sequences) 🧩</h3>
<p><strong>Iteratorها</strong> قابلیت ترکیب بالایی دارند. مثال زیر تنها اعداد <strong>فیبوناچی زوج</strong> را تولید می‌کند:</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;

foreach (int fib in EvenNumbersOnly(Fibs(6)))
    Console.WriteLine(fib);

IEnumerable&lt;int&gt; Fibs(int fibCount)
{
    for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)
    {
        yield return prevFib;
        int newFib = prevFib + curFib;
        prevFib = curFib;
        curFib = newFib;
    }
}

IEnumerable&lt;int&gt; EvenNumbersOnly(IEnumerable&lt;int&gt; sequence)
{
    foreach (int x in sequence)
        if ((x % 2) == 0)
            yield return x;
}
</code></pre>
<p>نکته مهم این است که <strong>هر عنصر دقیقاً زمانی محاسبه می‌شود که درخواست شود</strong>، یعنی فقط هنگام فراخوانی متد <code>MoveNext()</code> مقدار جدید تولید می‌شود. (شکل ۴-۱ فرآیند درخواست و خروجی داده‌ها را در طول زمان نشان می‌دهد.)</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>ترکیب‌پذیری الگوی Iterator در LINQ و انواع مقدار تهی (Nullable Value Types) ✨</h3>
<p>ترکیب‌پذیری یا <strong>Composability</strong> در الگوی <strong>Iterator</strong> (تکرارکننده) بسیار مفید و کاربردی است، مخصوصاً در <strong>LINQ</strong>. ما این موضوع را دوباره در فصل ۸ به‌طور کامل بررسی خواهیم کرد.</p>
<hr>
<h2>انواع مقدار تهی (Nullable Value Types) 📝</h2>
<p>در زبان C#، <strong>Reference Types</strong> (انواع مرجع) می‌توانند نشان‌دهنده یک مقدار موجود نباشند، یعنی مقدار آن‌ها می‌تواند <code>null</code> باشد:</p>
<pre><code class="language-csharp">string s = null;   // مشکلی ندارد، نوع مرجع
</code></pre>
<p>اما <strong>Value Types</strong> (انواع مقداری) به‌صورت عادی نمی‌توانند <code>null</code> باشند و اگر تلاش کنید، خطای کامپایل دریافت می‌کنید:</p>
<pre><code class="language-csharp">int i = null;   // خطای کامپایل، نوع مقداری نمی‌تواند null باشد
</code></pre>
<p>برای این‌که یک <strong>Value Type</strong> قابلیت داشتن مقدار تهی را داشته باشد، باید از یک ساختار خاص به نام <strong>Nullable Type</strong> استفاده کنید. برای تعریف یک نوع Nullable کافی است بعد از نوع داده از علامت <code>?</code> استفاده کنید:</p>
<pre><code class="language-csharp">int? i = null;                  // صحیح، نوع Nullable
Console.WriteLine(i == null);   // خروجی True
</code></pre>
<hr>
<h2>ساختار Nullable<T> 🛠</h2>
<p>در واقع <code>T?</code> معادل <code>System.Nullable&lt;T&gt;</code> است. این یک <strong>Struct</strong> سبک و تغییرناپذیر (<strong>Immutable</strong>) است که فقط شامل دو فیلد است:</p>
<ul>
<li><strong>Value</strong>: مقدار ذخیره شده</li>
<li><strong>HasValue</strong>: نشان می‌دهد که آیا مقداری موجود است یا خیر</li>
</ul>
<p>تعریف ساده آن به شکل زیر است:</p>
<pre><code class="language-csharp">public struct Nullable&lt;T&gt; where T : struct
{
    public T Value { get; }
    public bool HasValue { get; }
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    ...
}
</code></pre>
<p>نمونه کد:</p>
<pre><code class="language-csharp">int? i = null;
Console.WriteLine(i == null);  // True
</code></pre>
<p>این کد در پشت صحنه به شکل زیر ترجمه می‌شود:</p>
<pre><code class="language-csharp">Nullable&lt;int&gt; i = new Nullable&lt;int&gt;();
Console.WriteLine(!i.HasValue);   // True
</code></pre>
<blockquote>
<p>توجه: اگر مقدار <strong>HasValue</strong> برابر <strong>false</strong> باشد و شما بخواهید <strong>Value</strong> را بخوانید، یک <strong>InvalidOperationException</strong> رخ می‌دهد.
متد <strong>GetValueOrDefault()</strong> در صورتی که <strong>HasValue = true</strong> باشد مقدار <strong>Value</strong> را برمی‌گرداند، وگرنه مقدار پیش‌فرض یا مقداری که شما مشخص کرده‌اید را برمی‌گرداند.</p>
</blockquote>
<p><strong>نکته مهم</strong>: مقدار پیش‌فرض برای هر <strong>T?</strong> برابر <code>null</code> است.</p>
<hr>
<h2>تبدیل‌های ضمنی و صریح (Implicit و Explicit Conversions) 🔄</h2>
<p>تبدیل یک مقدار <code>T</code> به <code>T?</code> <strong>ضمنی</strong> است (احتیاجی به عمل خاصی ندارد).
اما تبدیل از <code>T?</code> به <code>T</code> <strong>صریح</strong> است و نیاز به <strong>Cast</strong> دارد:</p>
<pre><code class="language-csharp">int? x = 5;         // تبدیل ضمنی
int y = (int)x;     // تبدیل صریح
</code></pre>
<p>در واقع، تبدیل صریح دقیقاً معادل دسترسی به ویژگی <strong>Value</strong> است.
بنابراین، اگر <strong>HasValue = false</strong> باشد و شما بخواهید Cast کنید، استثنای <strong>InvalidOperationException</strong> ایجاد می‌شود.</p>
<hr>
<h2>Boxing و Unboxing در Nullable Types 🎁</h2>
<p>هنگامی که یک <strong>T?</strong> جعبه‌بندی (<strong>Box</strong>) می‌شود، مقدار ذخیره‌شده در <strong>Heap</strong> فقط <strong>T</strong> است، نه <strong>T?</strong>. این بهینه‌سازی ممکن است زیرا <strong>Reference Types</strong> می‌توانند به‌طور طبیعی <code>null</code> را نمایش دهند.</p>
<p>همچنین می‌توانید <strong>Unboxing</strong> یا خارج کردن از جعبه را با عملگر <code>as</code> انجام دهید. اگر عملیات ناموفق باشد، نتیجه <code>null</code> خواهد بود:</p>
<pre><code class="language-csharp">object o = &quot;string&quot;;
int? x = o as int?;
Console.WriteLine(x.HasValue);   // False
</code></pre>
<h3>عملگرهای ارتقا (Operator Lifting) 🛠️</h3>
<p>ساختار <strong>Nullable<T></strong> عملگرهایی مثل <code>&lt;</code>، <code>&gt;</code> یا حتی <code>==</code> را تعریف نمی‌کند. با این حال، کد زیر بدون هیچ مشکلی کامپایل و اجرا می‌شود:</p>
<pre><code class="language-csharp">int? x = 5;
int? y = 10;
bool b = x &lt; y;      // true
</code></pre>
<p>این موضوع به این دلیل است که کامپایلر عملگر <strong>کمتر از</strong> را از نوع پایه (در اینجا <code>int</code>) قرض گرفته یا به اصطلاح <strong>ارتقا داده</strong> است. از نظر مفهومی، عبارت مقایسه بالا به شکل زیر ترجمه می‌شود:</p>
<pre><code class="language-csharp">bool b = (x.HasValue &amp;&amp; y.HasValue) ? (x.Value &lt; y.Value) : false;
</code></pre>
<p>به عبارت دیگر، اگر هر دو متغیر <code>x</code> و <code>y</code> مقدار داشته باشند، مقایسه با استفاده از عملگر کمتر از نوع <code>int</code> انجام می‌شود؛ در غیر این صورت، نتیجه <code>false</code> خواهد بود.</p>
<p>ارتقای عملگر به این معناست که شما می‌توانید به طور ضمنی از عملگرهای نوع <code>T</code> روی نوع <code>T?</code> استفاده کنید. همچنین می‌توانید عملگرهای مخصوص به <code>T?</code> تعریف کنید تا رفتار خاصی در برابر مقادیر <code>null</code> داشته باشند، اما در بیشتر مواقع بهتر است به کامپایلر اعتماد کنید تا به طور خودکار منطق مربوط به <code>nullable</code> را پیاده‌سازی کند. چند مثال:</p>
<pre><code class="language-csharp">int? x = 5;
int? y = null;

// مثال‌های عملگر برابری
Console.WriteLine (x == y);    // False
Console.WriteLine (x == null); // False
Console.WriteLine (x == 5);    // True
Console.WriteLine (y == null); // True
Console.WriteLine (y == 5);    // False
Console.WriteLine (y != 5);    // True

// مثال‌های عملگر مقایسه‌ای
Console.WriteLine (x &lt; 6);     // True
Console.WriteLine (y &lt; 6);     // False
Console.WriteLine (y &gt; 6);     // False

// مثال‌های سایر عملگرها
Console.WriteLine (x + 5);     // 10
Console.WriteLine (x + y);     // null (خط خالی چاپ می‌شود)
</code></pre>
<hr>
<h3>رفتار عملگرها با مقادیر <code>null</code> در Nullable 🧩</h3>
<p>کامپایلر بسته به نوع عملگر، منطق متفاوتی برای برخورد با مقادیر <code>null</code> در نظر می‌گیرد. در ادامه، قوانین مربوط به هر دسته از عملگرها توضیح داده شده است.</p>
<h4>1. عملگرهای برابری (<code>==</code> و <code>!=</code>)</h4>
<p>این عملگرها دقیقاً مشابه نوع‌های <strong>Reference</strong> با مقادیر <code>null</code> رفتار می‌کنند:</p>
<ul>
<li>دو مقدار <code>null</code> برابر هستند:</li>
</ul>
<pre><code class="language-csharp">Console.WriteLine (null == null);                       // True
Console.WriteLine ((bool?)null == (bool?)null);         // True
</code></pre>
<ul>
<li>اگر فقط یکی از عملوندها <code>null</code> باشد، برابر نیستند.</li>
<li>اگر هر دو مقدار داشته باشند، مقادیر آن‌ها مقایسه می‌شود.</li>
</ul>
<hr>
<h4>2. عملگرهای مقایسه‌ای (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>)</h4>
<p>مقایسه مقادیر <code>null</code> بی‌معنا است؛ بنابراین مقایسه هر مقدار <code>null</code> با <code>null</code> یا مقدار غیر <code>null</code> نتیجه <strong>false</strong> خواهد بود:</p>
<pre><code class="language-csharp">bool b = x &lt; y;    // ترجمه شده:
bool b = (x.HasValue &amp;&amp; y.HasValue) 
         ? (x.Value &lt; y.Value)
         : false;
// b برابر false است (با فرض x=5 و y=null)
</code></pre>
<hr>
<h4>3. سایر عملگرها (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>++</code>, <code>--</code>, <code>!</code>, <code>~</code>)</h4>
<p>هرگاه یکی از عملوندها <code>null</code> باشد، نتیجه نیز <code>null</code> خواهد بود. این الگو برای کاربران SQL آشناست:</p>
<pre><code class="language-csharp">int? c = x + y;   // ترجمه شده:
int? c = (x.HasValue &amp;&amp; y.HasValue)
         ? (int?) (x.Value + y.Value) 
         : null;
// c برابر null است (با فرض x=5 و y=null)
</code></pre>
<p>تنها استثنا زمانی است که عملگرهای <code>&amp;</code> و <code>|</code> روی نوع <code>bool?</code> اعمال شوند که به‌زودی توضیح داده می‌شود.</p>
<hr>
<h3>ترکیب انواع Nullable و Non-Nullable 🧮</h3>
<p>شما می‌توانید انواع <code>nullable</code> و <code>non-nullable</code> را با هم ترکیب کنید، چون تبدیل ضمنی از <code>T</code> به <code>T?</code> وجود دارد:</p>
<pre><code class="language-csharp">int? a = null;
int b = 2;
int? c = a + b;   // c برابر null است - معادل a + (int?)b
</code></pre>
<hr>
<h3>نوع‌های Nullable و عملگرهای <code>&amp;</code> و <code>|</code> برای <code>bool?</code> 🔹</h3>
<p>هنگامی که عملگرهای <code>&amp;</code> و <code>|</code> برای عملوندهایی از نوع <strong>bool?</strong> استفاده می‌شوند، مقدار <code>null</code> به‌عنوان یک <strong>مقدار ناشناخته</strong> در نظر گرفته می‌شود. بنابراین:</p>
<ul>
<li>
<p><code>null | true</code> برابر <strong>true</strong> است، زیرا:</p>
<ul>
<li>اگر مقدار ناشناخته false باشد، نتیجه true است.</li>
<li>اگر مقدار ناشناخته true باشد، نتیجه true است.</li>
</ul>
</li>
<li>
<p>به‌طور مشابه، <code>null &amp; false</code> برابر <strong>false</strong> است. این رفتار برای کاربران SQL آشناست.</p>
</li>
</ul>
<p>مثال دیگر:</p>
<pre><code class="language-csharp">bool? n = null;
bool? f = false;
bool? t = true;

Console.WriteLine (n | n);    // (null)
Console.WriteLine (n | f);    // (null)
Console.WriteLine (n | t);    // True
Console.WriteLine (n &amp; n);    // (null)
Console.WriteLine (n &amp; f);    // False
Console.WriteLine (n &amp; t);    // (null)
</code></pre>
<hr>
<h3>Nullable Value Types و عملگرهای کمکی (<code>??</code> و Null-Conditional) ⚡</h3>
<p>نوع‌های <strong>nullable</strong> به‌خوبی با عملگر <strong>Null Coalescing (<code>??</code>)</strong> کار می‌کنند:</p>
<pre><code class="language-csharp">int? x = null;
int y = x ?? 5;        // y برابر 5

int? a = null, b = 1, c = 2;
Console.WriteLine (a ?? b ?? c);  // 1 (اولین مقدار غیر-null)
</code></pre>
<p>استفاده از <code>??</code> روی یک مقدار nullable معادل فراخوانی متد <code>GetValueOrDefault</code> با یک مقدار پیش‌فرض است، با این تفاوت که اگر متغیر null نباشد، عبارت پیش‌فرض هرگز ارزیابی نمی‌شود.</p>
<p>همچنین <strong>Null-Conditional Operator (<code>?.</code>)</strong> با نوع‌های nullable به خوبی کار می‌کند:</p>
<pre><code class="language-csharp">System.Text.StringBuilder sb = null;
int? length = sb?.ToString().Length;  // length برابر null می‌شود
</code></pre>
<p>می‌توانیم این را با <code>??</code> ترکیب کنیم تا به جای null مقدار صفر برگردانیم:</p>
<pre><code class="language-csharp">int length = sb?.ToString().Length ?? 0;  // اگر sb null باشد، نتیجه 0 است
</code></pre>
<hr>
<h3>سناریوهای استفاده از نوع‌های Nullable 💡</h3>
<p>یکی از رایج‌ترین کاربردها برای <strong>nullable value types</strong> نمایش مقادیر ناشناخته است. این حالت به‌ویژه در برنامه‌نویسی پایگاه داده رایج است، جایی که یک کلاس به جدول با ستون‌های nullable نگاشت می‌شود.</p>
<p>اگر ستون‌ها از نوع <strong>string</strong> باشند، مشکلی وجود ندارد زیرا string نوع مرجع است و می‌تواند null باشد. اما اکثر ستون‌های SQL به نوع struct در CLR نگاشت می‌شوند، بنابراین استفاده از نوع‌های nullable بسیار مفید است:</p>
<pre><code class="language-csharp">// نگاشت به جدول Customer در پایگاه داده
public class Customer
{
  ...
  public decimal? AccountBalance;
}
</code></pre>
<p>همچنین، نوع nullable می‌تواند برای نمایش <strong>فیلد پشتیبان (backing field)</strong> یک property محیطی (ambient property) استفاده شود. یک <strong>ambient property</strong> اگر null باشد، مقدار parent خود را بازمی‌گرداند:</p>
<pre><code class="language-csharp">public class Row
{
  ...
  Grid parent;
  Color? color;

  public Color Color
  {
    get { return color ?? parent.Color; }
    set { color = value == parent.Color ? (Color?)null : value; }
  }
}
</code></pre>
<hr>
<h3>جایگزین‌ها برای Nullable Value Types ⚖️</h3>
<p>قبل از اینکه nullable value types بخشی از زبان C# باشند (قبل از C# 2.0)، استراتژی‌های مختلفی برای مدیریت آن‌ها وجود داشت. یکی از این استراتژی‌ها این بود که یک مقدار خاص غیر-null را به‌عنوان <strong>magic value</strong> یا مقدار null فرض کنیم.</p>
<p>مثال‌ها:</p>
<pre><code class="language-csharp">// String.IndexOf وقتی کاراکتر پیدا نشود، -1 برمی‌گرداند
int i = &quot;Pink&quot;.IndexOf('b');
Console.WriteLine(i);  // -1

// Array.IndexOf وقتی عنصر پیدا نشود (و آرایه از اندیس 1 شروع شود):
Array a = Array.CreateInstance(typeof(string), new int[] {2}, new int[] {1});
a.SetValue(&quot;a&quot;, 1);
a.SetValue(&quot;b&quot;, 2);
Console.WriteLine(Array.IndexOf(a, &quot;c&quot;));  // 0
</code></pre>
<p>مشکل انتخاب <strong>magic value</strong>:</p>
<ul>
<li>هر نوع مقداری می‌تواند null را به شیوه متفاوت نمایش دهد. در مقابل، nullable value types یک الگوی یکنواخت برای همه نوع‌ها ارائه می‌کند.</li>
<li>ممکن است مقدار مشخصی برای null وجود نداشته باشد.</li>
<li>فراموش کردن تست مقدار (مثل HasValue) باعث بروز خطا می‌شود، اما با nullable value types این خطا به‌صورت <strong>InvalidOperationException</strong> روی همان خط رخ می‌دهد.</li>
<li>قابلیت null بودن یک مقدار در نوع آن لحاظ نمی‌شود. نوع‌ها هدف برنامه را مشخص می‌کنند و به کامپایلر امکان بررسی صحت و رعایت قواعد یکنواخت را می‌دهند.</li>
</ul>
<h3>نوع‌های Nullable Reference Types 🟢</h3>
<p>در حالی که <strong>nullable value types</strong> امکان null بودن را به نوع‌های مقدار (value types) اضافه می‌کنند، <strong>nullable reference types</strong> (از C# 8 به بعد) برعکس عمل می‌کنند: آن‌ها مقداری از <strong>non-nullability</strong> را به نوع‌های مرجع (reference types) اضافه می‌کنند تا از بروز <strong>NullReferenceException</strong> جلوگیری کنند.</p>
<p>این قابلیت یک <strong>سطح ایمنی</strong> اضافه می‌کند که صرفاً توسط <strong>کامپایلر</strong> اعمال می‌شود و به صورت <strong>هشدارها (warnings)</strong> زمانی ظاهر می‌شود که کامپایلر تشخیص دهد کدی ممکن است باعث NullReferenceException شود.</p>
<hr>
<h3>فعال‌سازی Nullable Reference Types ⚙️</h3>
<p>برای فعال کردن nullable reference types، می‌توانید یکی از این روش‌ها را استفاده کنید:</p>
<ol>
<li>اضافه کردن عنصر <code>&lt;Nullable&gt;</code> به فایل <code>.csproj</code> پروژه (برای کل پروژه):</li>
</ol>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<ol start="2">
<li>یا/و استفاده از دستورالعمل‌های زیر در کد، در مکان‌هایی که می‌خواهید اعمال شود:</li>
</ol>
<pre><code class="language-csharp">#nullable enable    // فعال‌سازی nullable reference types از این نقطه به بعد
#nullable disable   // غیرفعال‌سازی nullable reference types از این نقطه به بعد
#nullable restore   // بازگرداندن تنظیمات به حالت پروژه
</code></pre>
<hr>
<h3>تعریف نوع‌های Nullable Reference</h3>
<p>پس از فعال شدن، <strong>non-nullability</strong> به صورت پیش‌فرض اعمال می‌شود. برای اینکه یک <strong>reference type</strong> بتواند مقدار null بگیرد، باید از علامت <code>?</code> استفاده کنید. مثال:</p>
<pre><code class="language-csharp">#nullable enable

string s1 = null;   // هشدار کامپایلر! ❌
string? s2 = null;  // صحیح ✅: s2 یک nullable reference type است
</code></pre>
<p>توجه کنید که <strong>string و string?</strong> در زمان اجرا تفاوتی ندارند، بر خلاف <strong>nullable value types</strong> که چیزی واقعی به سیستم نوع اضافه می‌کنند (<code>Nullable&lt;T&gt;</code>).</p>
<hr>
<h3>هشدارها و مقداردهی اولیه</h3>
<p>اگر یک فیلد non-nullable بدون مقداردهی اولیه تعریف شود، کامپایلر هشدار می‌دهد:</p>
<pre><code class="language-csharp">class Foo { string x; }   // هشدار: x مقداردهی نشده
</code></pre>
<p>هشدار با مقداردهی اولیه فیلد یا مقداردهی در سازنده حذف می‌شود.</p>
<hr>
<h3>عملگر Null-Forgiving (<code>!</code>) ⚠️</h3>
<p>کامپایلر هنگام دسترسی به یک <strong>nullable reference type</strong> که احتمال NullReferenceException دارد، هشدار می‌دهد:</p>
<pre><code class="language-csharp">void Foo(string? s) =&gt; Console.Write(s.Length);  // هشدار
</code></pre>
<p>برای حذف هشدار، می‌توان از <strong>null-forgiving operator</strong> استفاده کرد:</p>
<pre><code class="language-csharp">void Foo(string? s) =&gt; Console.Write(s!.Length);
</code></pre>
<p>⚠️ این روش خطرناک است و ممکن است همان <strong>NullReferenceException</strong> که می‌خواستیم جلوگیری کنیم را ایجاد کند. روش ایمن‌تر:</p>
<pre><code class="language-csharp">void Foo(string? s)
{
    if (s != null) 
        Console.Write(s.Length);
}
</code></pre>
<p>کامپایلر با تحلیل جریان برنامه (static flow analysis) می‌تواند تشخیص دهد که دسترسی ایمن است و هشدارها را ندهد.</p>
<hr>
<h3>محدودیت‌ها و تحلیل کامپایلر</h3>
<p>کامپایلر توانایی کامل برای تشخیص خطر NullReferenceException ندارد. مثلاً نمی‌تواند تشخیص دهد که عناصر یک آرایه مقداردهی شده‌اند یا نه:</p>
<pre><code class="language-csharp">var strings = new string[10];
Console.WriteLine(strings[0].Length);  // هیچ هشداری تولید نمی‌شود
</code></pre>
<hr>
<h3>تفکیک Annotation و Warning Contexts 🛠️</h3>
<p>فعال کردن nullable reference types با دستور <code>#nullable enable</code> یا <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> دو کار انجام می‌دهد:</p>
<ol>
<li><strong>nullable annotation context</strong>: همه متغیرهای reference-type را non-nullable فرض می‌کند مگر آنکه با <code>?</code> مشخص شوند.</li>
<li><strong>nullable warning context</strong>: کامپایلر هنگام مواجهه با کدی که احتمال NullReferenceException دارد، هشدار می‌دهد.</li>
</ol>
<p>می‌توان این دو مورد را جداگانه فعال کرد:</p>
<pre><code class="language-csharp">#nullable enable annotations  // فقط annotation context فعال است
#nullable enable warnings     // فقط warning context فعال است
</code></pre>
<p>یا در فایل پروژه:</p>
<pre><code class="language-xml">&lt;Nullable&gt;annotations&lt;/Nullable&gt;
&lt;!-- OR --&gt;
&lt;Nullable&gt;warnings&lt;/Nullable&gt;
</code></pre>
<p>فعال کردن فقط <strong>annotation context</strong> برای کلاس یا اسمبلی قدیمی می‌تواند اولین گام مناسب برای افزودن nullable reference types بدون مواجهه با هشدارها باشد.</p>
<hr>
<h3>تبدیل هشدارها به خطا ⚡</h3>
<p>در پروژه‌های جدید، می‌توان nullable context را از ابتدا فعال کرد و حتی هشدارها را به خطا تبدیل نمود تا پروژه تا زمانی که تمام هشدارهای null رفع نشده‌اند، <strong>قابل کامپایل نباشد</strong>:</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;WarningsAsErrors&gt;CS8600;CS8602;CS8603&lt;/WarningsAsErrors&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<h3>متدهای توسعه‌یافته (Extension Methods) ✨</h3>
<p><strong>متدهای توسعه‌یافته</strong> امکان افزودن متدهای جدید به یک نوع موجود را بدون تغییر در تعریف اصلی آن نوع فراهم می‌کنند.</p>
<hr>
<h3>تعریف Extension Method</h3>
<p>یک <strong>extension method</strong> در واقع یک <strong>متد static</strong> در یک کلاس <strong>static</strong> است که <strong>پارامتر اول آن با کلیدواژه <code>this</code> مشخص شده</strong> و نوع این پارامتر، همان نوعی است که می‌خواهیم گسترش دهیم:</p>
<pre><code class="language-csharp">public static class StringHelper
{
    public static bool IsCapitalized(this string s)
    {
        if (string.IsNullOrEmpty(s)) return false;
        return char.IsUpper(s[0]);
    }
}
</code></pre>
<p>این متد را می‌توان به صورت <strong>متد نمونه (instance method)</strong> روی رشته‌ها فراخوانی کرد:</p>
<pre><code class="language-csharp">Console.WriteLine(&quot;Perth&quot;.IsCapitalized());  // True
</code></pre>
<p>کامپایلر این کد را به فراخوانی معمولی <strong>static</strong> تبدیل می‌کند:</p>
<pre><code class="language-csharp">Console.WriteLine(StringHelper.IsCapitalized(&quot;Perth&quot;));
</code></pre>
<hr>
<h3>گسترش اینترفیس‌ها</h3>
<p>می‌توان این متدها را روی <strong>interface</strong>ها نیز اعمال کرد:</p>
<pre><code class="language-csharp">public static T First&lt;T&gt;(this IEnumerable&lt;T&gt; sequence)
{
    foreach (T element in sequence)
        return element;
    throw new InvalidOperationException(&quot;No elements!&quot;);
}

Console.WriteLine(&quot;Seattle&quot;.First());  // S
</code></pre>
<hr>
<h3>زنجیره‌سازی متدهای توسعه‌یافته (Extension Method Chaining)</h3>
<p>مثل متدهای نمونه، می‌توان extension methodها را <strong>زنجیره‌ای</strong> فراخوانی کرد:</p>
<pre><code class="language-csharp">public static class StringHelper
{
    public static string Pluralize(this string s) { ... }
    public static string Capitalize(this string s) { ... }
}

string x = &quot;sausage&quot;.Pluralize().Capitalize();   // &quot;Sausages&quot;
string y = StringHelper.Capitalize(StringHelper.Pluralize(&quot;sausage&quot;)); // معادل x
</code></pre>
<hr>
<h3>حل ابهام و قواعد دسترسی</h3>
<ol>
<li><strong>Namespace</strong>:
برای دسترسی به extension method، کلاس آن باید در <strong>scope</strong> باشد (معمولاً با import namespace):</li>
</ol>
<pre><code class="language-csharp">using Utils;  // کلاس StringHelper در namespace Utils قرار دارد
</code></pre>
<ol start="2">
<li><strong>Extension method vs Instance method</strong>:
هر متد نمونه‌ی سازگار، <strong>اولویت بیشتری نسبت به extension method دارد</strong>. برای فراخوانی extension method در این شرایط، باید از <strong>فراخوانی static</strong> استفاده کرد:</li>
</ol>
<pre><code class="language-csharp">class Test
{
    public void Foo(object x) { }   // همیشه برنده است
}

static class Extensions
{
    public static void Foo(this Test t, int x) { }
}

// فراخوانی:
Extensions.Foo(new Test(), 42);   // باید از روش static استفاده شود
</code></pre>
<ol start="3">
<li><strong>Extension method vs Extension method</strong>:
اگر دو متد extension با امضای یکسان وجود داشته باشد، برای رفع ابهام باید به صورت <strong>static</strong> فراخوانی شود.
اگر یکی از متدها آرگومان‌های خاص‌تری داشته باشد، متد خاص‌تر برنده است.</li>
</ol>
<pre><code class="language-csharp">static class StringHelper
{
    public static bool IsCapitalized(this string s) { ... }
}
static class ObjectHelper
{
    public static bool IsCapitalized(this object s) { ... }
}

bool test1 = &quot;Perth&quot;.IsCapitalized();  // فراخوانی StringHelper
</code></pre>
<hr>
<h3>کاهش سطح یک متد توسعه‌یافته (Demoting an Extension Method)</h3>
<p>فرض کنید یک متد توسعه‌یافته در کتابخانه شخص ثالث با یک متد جدید در کتابخانه .NET تداخل دارد. می‌توان بدون حذف آن، آن را <strong>به یک متد static معمولی تبدیل کرد</strong>:</p>
<ul>
<li>کافی است <code>this</code> را از پارامتر اول حذف کنیم.</li>
<li>همه‌ی فراخوانی‌هایی که قبلاً با extension method بوده‌اند، هنگام کامپایل دوباره به <strong>فراخوانی static</strong> تبدیل می‌شوند.</li>
<li>مصرف‌کنندگان کتابخانه فقط زمانی تحت تأثیر قرار می‌گیرند که دوباره پروژه را کامپایل کنند.</li>
</ul>
<hr>
<h3>نوع‌های ناشناس (Anonymous Types) و تاپل‌ها (Tuples) در C# 🟢</h3>
<hr>
<h2>۱. نوع‌های ناشناس (Anonymous Types) ✨</h2>
<p>یک <strong>نوع ناشناس</strong>، کلاس ساده‌ای است که <strong>کامپایلر به صورت خودکار ایجاد می‌کند</strong> تا مجموعه‌ای از مقادیر را ذخیره کند.</p>
<h3>نحوه تعریف</h3>
<pre><code class="language-csharp">var dude = new { Name = &quot;Bob&quot;, Age = 23 };
</code></pre>
<p>کامپایلر تقریباً این را به صورت زیر ترجمه می‌کند:</p>
<pre><code class="language-csharp">internal class AnonymousGeneratedTypeName
{
    private string name;
    private int age;
    public AnonymousGeneratedTypeName(string name, int age)
    {
        this.name = name; this.age = age;
    }
    public string Name =&gt; name;
    public int Age =&gt; age;
    // متدهای Equals، GetHashCode و ToString بازنویسی شده‌اند
}
</code></pre>
<blockquote>
<p>⚠️ باید همیشه از <code>var</code> برای ارجاع به نوع ناشناس استفاده کرد، چون <strong>نام ندارد</strong>.</p>
</blockquote>
<hr>
<h3>قواعد و نکات مهم</h3>
<ol>
<li><strong>استنتاج نام ویژگی‌ها:</strong>
اگر یک عبارت شامل <strong>شناسه‌ای موجود</strong> باشد، نام ویژگی می‌تواند از آن استخراج شود:</li>
</ol>
<pre><code class="language-csharp">int Age = 23;
var dude = new { Name = &quot;Bob&quot;, Age, Age.ToString().Length };
// معادل:
var dude = new { Name = &quot;Bob&quot;, Age = Age, Length = Age.ToString().Length };
</code></pre>
<ol start="2">
<li><strong>برابر بودن نوع ناشناس:</strong>
دو نمونه ناشناس با <strong>ویژگی‌های یکسان در همان اسمبلی</strong>، نوع یکسان دارند:</li>
</ol>
<pre><code class="language-csharp">var a1 = new { X = 2, Y = 4 };
var a2 = new { X = 2, Y = 4 };
Console.WriteLine(a1.GetType() == a2.GetType());  // True
</code></pre>
<ol start="3">
<li>
<p><strong>مقایسه مقادیر:</strong></p>
<ul>
<li><code>Equals</code> → مقایسه داده‌ها (ساختاری)</li>
<li><code>==</code> → مقایسه مرجع (referential)</li>
</ul>
</li>
</ol>
<pre><code class="language-csharp">Console.WriteLine(a1.Equals(a2));  // True
Console.WriteLine(a1 == a2);       // False
</code></pre>
<ol start="4">
<li><strong>آرایه‌ای از نوع ناشناس:</strong></li>
</ol>
<pre><code class="language-csharp">var dudes = new[]
{
    new { Name = &quot;Bob&quot;, Age = 30 },
    new { Name = &quot;Tom&quot;, Age = 40 }
};
</code></pre>
<ol start="5">
<li><strong>غیر قابل تغییر بودن (Immutable)</strong>
از C# 10 به بعد می‌توان با <code>with</code> یک نسخه جدید با تغییرات ساخت بدون تخریب نسخه اصلی:</li>
</ol>
<pre><code class="language-csharp">var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 };
Console.WriteLine(a2);  // { A = 1, B = 2, C = 3, D = 4, E = 10 }
</code></pre>
<blockquote>
<p>نوع‌های ناشناس بسیار کاربردی در <strong>LINQ</strong> هستند.</p>
</blockquote>
<hr>
<h2>۲. تاپل‌ها (Tuples) 🔹</h2>
<p><strong>تاپل‌ها</strong> مشابه نوع‌های ناشناس هستند، اما امکان بازگرداندن چند مقدار از یک متد را بدون پارامتر <code>out</code> می‌دهند.</p>
<h3>تعریف ساده</h3>
<pre><code class="language-csharp">var bob = (&quot;Bob&quot;, 23);  // المان‌ها نام‌گذاری نشده‌اند
Console.WriteLine(bob.Item1);  // Bob
Console.WriteLine(bob.Item2);  // 23
</code></pre>
<ul>
<li>تاپل‌ها <strong>Value Type</strong> هستند و المان‌هایشان قابل تغییر است:</li>
</ul>
<pre><code class="language-csharp">var joe = bob;    // کپی از bob
joe.Item1 = &quot;Joe&quot;;
Console.WriteLine(bob);  // (Bob, 23)
Console.WriteLine(joe);  // (Joe, 23)
</code></pre>
<h3>تعریف با نوع مشخص</h3>
<pre><code class="language-csharp">(string, int) bob = (&quot;Bob&quot;, 23);
</code></pre>
<ul>
<li>می‌توان تاپل را از متد بازگرداند:</li>
</ul>
<pre><code class="language-csharp">(string, int) GetPerson() =&gt; (&quot;Bob&quot;, 23);
(string, int) person = GetPerson();
Console.WriteLine(person.Item1);  // Bob
Console.WriteLine(person.Item2);  // 23
</code></pre>
<h3>سازگاری با جنریک‌ها</h3>
<pre><code class="language-csharp">Task&lt;(string,int)&gt;
Dictionary&lt;(string,int), Uri&gt;
IEnumerable&lt;(int id, string name)&gt;   // امکان نام‌گذاری المان‌ها
</code></pre>
<hr>
<h3>نام‌گذاری المان‌های تاپل و نکات پیشرفته 🟢</h3>
<hr>
<h2>۱. نام‌گذاری المان‌ها هنگام ایجاد تاپل</h2>
<p>می‌توان المان‌ها را با نام‌های معنی‌دار مشخص کرد:</p>
<pre><code class="language-csharp">var tuple = (name: &quot;Bob&quot;, age: 23);
Console.WriteLine(tuple.name);  // Bob
Console.WriteLine(tuple.age);   // 23
</code></pre>
<p>همین کار هنگام <strong>مشخص کردن نوع تاپل</strong> نیز ممکن است:</p>
<pre><code class="language-csharp">(string name, int age) GetPerson() =&gt; (&quot;Bob&quot;, 23);
var person = GetPerson();
Console.WriteLine(person.name);  // Bob
Console.WriteLine(person.age);   // 23
</code></pre>
<hr>
<h2>۲. استفاده از رکوردها (Records) برای نوع بازگشتی قوی‌تر</h2>
<p>به جای تاپل می‌توان از <strong>رکوردها</strong> استفاده کرد تا نوع بازگشتی <strong>قوی و قابل تغییر</strong> داشته باشیم:</p>
<pre><code class="language-csharp">record Person(string Name, int Age);

Person GetPerson() =&gt; new(&quot;Bob&quot;, 23);
var person = GetPerson();
Console.WriteLine(person.Name);  // Bob
Console.WriteLine(person.Age);   // 23
</code></pre>
<p>مزایا:</p>
<ul>
<li>نوع بازگشتی نام‌گذاری شده و قابل بازسازی/refactor است.</li>
<li>کاهش تکرار کد.</li>
<li>تشویق به طراحی خوب و اصول OOP.</li>
</ul>
<hr>
<h2>۳. استنتاج خودکار نام المان‌ها</h2>
<p>مثال:</p>
<pre><code class="language-csharp">var now = DateTime.Now;
var tuple = (now.Day, now.Month, now.Year);
Console.WriteLine(tuple.Day);  // OK
</code></pre>
<blockquote>
<p>کامپایلر از نام فیلد یا پراپرتی برای المان‌ها استفاده می‌کند.</p>
</blockquote>
<hr>
<h2>۴. سازگاری نوعی (Type Compatibility) و اشتباهات محتمل</h2>
<p>تاپل‌ها فقط از نظر <strong>نوع المان‌ها</strong> با هم سازگارند؛ <strong>نام المان‌ها اهمیتی ندارد</strong>:</p>
<pre><code class="language-csharp">(string name, int age, char sex) bob1 = (&quot;Bob&quot;, 23, 'M');
(string age, int sex, char name) bob2 = bob1;  // بدون خطا!
Console.WriteLine(bob2.name);  // M
Console.WriteLine(bob2.age);   // Bob
Console.WriteLine(bob2.sex);   // 23
</code></pre>
<blockquote>
<p>⚠️ این می‌تواند منجر به نتایج گیج‌کننده شود.</p>
</blockquote>
<hr>
<h2>۵. حذف نام المان‌ها در زمان اجرا (Type Erasure)</h2>
<ul>
<li>تاپل‌ها از <code>ValueTuple&lt;&gt;</code> استفاده می‌کنند و در runtime <strong>نام المان‌ها را ندارند</strong>.</li>
<li>فقط در سورس کد و کامپایلر وجود دارند.</li>
<li>در بیشتر ابزارها مثل <strong>Debugging</strong> یا <strong>Reflection</strong> نام‌ها قابل مشاهده نیستند.</li>
</ul>
<hr>
<h2>۶. ایجاد alias برای تاپل‌ها (C# 12)</h2>
<p>می‌توان با <code>using</code> برای تاپل‌ها نام مستعار تعریف کرد:</p>
<pre><code class="language-csharp">using Point = (int, int);
Point p = (3, 4);

// با نام المان:
using Point = (int X, int Y);  // Legal
Point p2 = (3, 4);
</code></pre>
<hr>
<h2>۷. استفاده از ValueTuple.Create</h2>
<p>می‌توان تاپل را با متد کارخانه‌ای نیز ساخت:</p>
<pre><code class="language-csharp">ValueTuple&lt;string,int&gt; bob1 = ValueTuple.Create(&quot;Bob&quot;, 23);
(string,int) bob2           = ValueTuple.Create(&quot;Bob&quot;, 23);
(string name,int age) bob3  = ValueTuple.Create(&quot;Bob&quot;, 23);
</code></pre>
<hr>
<h3>تجزیه (Deconstructing) تاپل‌ها 🧩</h3>
<p>تاپل‌ها به‌صورت ضمنی از <strong>الگوی تجزیه (deconstruction pattern)</strong> پشتیبانی می‌کنند (رجوع کنید به بخش «Deconstructors» در صفحه ۱۱۰)، بنابراین می‌توانید به راحتی یک تاپل را به متغیرهای جداگانه تقسیم کنید. به مثال زیر توجه کنید:</p>
<pre><code class="language-csharp">var bob = (&quot;Bob&quot;, 23);
string name = bob.Item1;
int age = bob.Item2;
</code></pre>
<p>با استفاده از <strong>deconstructor تاپل</strong>، می‌توان کد را ساده‌تر نوشت:</p>
<pre><code class="language-csharp">var bob = (&quot;Bob&quot;, 23);
(string name, int age) = bob;   // تجزیه تاپل bob به
                                // متغیرهای جداگانه (name و age)
Console.WriteLine(name);
Console.WriteLine(age);
</code></pre>
<p>نحو (syntax) تجزیه شبیه به نحو اعلام تاپل با <strong>عناصر نام‌گذاری‌شده</strong> است، اما تفاوت دارد:</p>
<pre><code class="language-csharp">(string name, int age)      = bob;   // تجزیه یک تاپل
(string name, int age) bob2 = bob;   // اعلام یک تاپل جدید
</code></pre>
<p>مثال دیگری هنگام فراخوانی یک متد با <strong>استفاده از استنتاج نوع (var)</strong>:</p>
<pre><code class="language-csharp">var (name, age, sex) = GetBob();
Console.WriteLine(name);  // Bob
Console.WriteLine(age);   // 23
Console.WriteLine(sex);   // M

(string name, int age, char sex) GetBob() =&gt; (&quot;Bob&quot;, 23, 'M');
</code></pre>
<p>همچنین می‌توانید مستقیماً <strong>مقداردهی به فیلدها و خصوصیات</strong> (fields and properties) انجام دهید، که یک روش کوتاه برای مقداردهی چندین فیلد یا property در سازنده (constructor) فراهم می‌کند:</p>
<pre><code class="language-csharp">class Point
{
    public readonly int X, Y;
    public Point(int x, int y) =&gt; (X, Y) = (x, y);
}
</code></pre>
<hr>
<h3>مقایسه برابری (Equality Comparison) ⚖️</h3>
<p>مانند <strong>anonymous types</strong>، متد <strong>Equals</strong> در تاپل‌ها یک مقایسه ساختاری (structural equality) انجام می‌دهد؛ یعنی داده‌های داخلی مقایسه می‌شوند نه مراجع (references):</p>
<pre><code class="language-csharp">var t1 = (&quot;one&quot;, 1);
var t2 = (&quot;one&quot;, 1);
Console.WriteLine(t1.Equals(t2));  // True
</code></pre>
<p>علاوه بر این، <strong>ValueTuple&lt;&gt;</strong> عملگرهای <code>==</code> و <code>!=</code> را بازتعریف کرده است:</p>
<pre><code class="language-csharp">Console.WriteLine(t1 == t2);  // True (از C# 7.3 به بعد)
</code></pre>
<p>تاپل‌ها همچنین <strong>متد GetHashCode</strong> را بازتعریف می‌کنند، بنابراین می‌توان از آن‌ها به‌عنوان <strong>کلید در دیکشنری‌ها</strong> استفاده کرد. مقایسه برابری را در بخش «Equality Comparison» صفحه ۳۴۴ و دیکشنری‌ها را در فصل ۷ به‌طور مفصل بررسی کرده‌ایم.</p>
<p>نوع‌های <strong>ValueTuple&lt;&gt;</strong> همچنین رابط <strong>IComparable</strong> را پیاده‌سازی می‌کنند (رجوع کنید به «Order Comparison» صفحه ۳۵۵)، بنابراین می‌توان از آن‌ها به‌عنوان کلید مرتب‌سازی استفاده کرد.</p>
<hr>
<h3>کلاس‌های System.Tuple 🗂️</h3>
<p>در فضای نام <strong>System</strong>، خانواده‌ای از نوع‌های generic به نام <strong>Tuple</strong> وجود دارد (نه ValueTuple). این‌ها از سال ۲۰۱۰ معرفی شدند و به‌صورت کلاس تعریف شده‌اند، در حالی که <strong>ValueTuple</strong> به‌صورت struct هستند.</p>
<p>در عمل، تعریف تاپل‌ها به‌صورت کلاس، اشتباه محسوب شد؛ چرا که در سناریوهای رایج استفاده از تاپل، <strong>struct</strong> کمی بهتر عمل می‌کند و از تخصیص حافظه اضافی جلوگیری می‌کند. به همین دلیل، وقتی مایکروسافت پشتیبانی زبانی برای تاپل‌ها در C# 7 اضافه کرد، <strong>Tuple</strong> قدیمی را کنار گذاشت و به <strong>ValueTuple</strong> جدید روی آورد.</p>
<p>با این حال، هنوز ممکن است در کدهای قبل از C# 7 با کلاس‌های Tuple برخورد کنید. این‌ها پشتیبانی زبانی خاصی ندارند و به شکل زیر استفاده می‌شوند:</p>
<pre><code class="language-csharp">Tuple&lt;string, int&gt; t = Tuple.Create(&quot;Bob&quot;, 23);  // متد کارخانه‌ای (Factory method)
Console.WriteLine(t.Item1);  // Bob
Console.WriteLine(t.Item2);  // 23
</code></pre>
<hr>
<h3>رکوردها (Records) 📄</h3>
<p>رکورد یک نوع خاص از <strong>کلاس یا struct</strong> است که برای کار با داده‌های <strong>غیرقابل تغییر (immutable/read-only)</strong> طراحی شده است.</p>
<p>ویژگی مفید آن، <strong>تغییر غیرمخرب (nondestructive mutation)</strong> است؛ با این حال، رکوردها برای ایجاد انواعی که صرفاً داده‌ها را نگه می‌دارند یا ترکیب می‌کنند نیز مفید هستند. در موارد ساده، رکوردها <strong>کدهای اضافی را حذف می‌کنند</strong> و در عین حال، <strong>مقایسه برابری مناسب برای انواع غیرقابل تغییر</strong> را رعایت می‌کنند.</p>
<p>رکوردها صرفاً یک <strong>مفهوم زمان کامپایل در C#</strong> هستند و در زمان اجرا، CLR آن‌ها را به‌صورت کلاس یا struct معمولی می‌بیند (با چند عضو اضافی «ترکیب‌شده» توسط کامپایلر).</p>
<hr>
<h3>مقدمه 📝</h3>
<p>نوشتن <strong>انواع غیرقابل تغییر (immutable types)</strong> که در آن‌ها فیلدها پس از مقداردهی اولیه قابل تغییر نباشند، یک استراتژی رایج برای ساده‌تر کردن نرم‌افزار و کاهش باگ‌ها است. این موضوع همچنین بخش اصلی <strong>برنامه‌نویسی تابعی (functional programming)</strong> است، جایی که از حالت قابل تغییر اجتناب می‌شود و توابع به‌عنوان داده در نظر گرفته می‌شوند. LINQ نیز از این اصل الهام گرفته است.</p>
<p>برای «تغییر» یک شیء غیرقابل تغییر، باید یک نمونه جدید بسازید و داده‌ها را با تغییرات مورد نظر خود منتقل کنید (<strong>تغییر غیرمخرب – nondestructive mutation</strong>). از نظر کارایی، این کار به اندازه‌ای که فکر می‌کنید ناکارآمد نیست، زیرا <strong>کپی سطحی (shallow copy)</strong> همیشه کافی است و نیازی به <strong>کپی عمیق (deep copy)</strong> که شامل زیرشی‌ها و مجموعه‌ها نیز باشد، نیست؛ چرا که داده‌ها غیرقابل تغییر هستند. اما از نظر حجم کدنویسی، پیاده‌سازی تغییر غیرمخرب می‌تواند بسیار پرزحمت باشد، به‌ویژه وقتی تعداد زیادی property وجود داشته باشد. <strong>رکوردها (records)</strong> این مشکل را با یک <strong>الگوی پشتیبانی‌شده توسط زبان</strong> حل می‌کنند.</p>
<p>مسئله دوم این است که برنامه‌نویسان—به‌ویژه برنامه‌نویسان تابعی—گاهی از انواع غیرقابل تغییر صرفاً برای <strong>ترکیب داده‌ها</strong> استفاده می‌کنند (بدون افزودن رفتار). تعریف چنین انواعی کاری بیشتر از آنچه باید باشد می‌برد، زیرا لازم است <strong>یک سازنده (constructor)</strong> داشته باشید تا هر پارامتر را به هر property عمومی اختصاص دهد (یک <strong>deconstructor</strong> نیز ممکن است مفید باشد). با رکوردها، کامپایلر این کار را برای شما انجام می‌دهد.</p>
<p>در نهایت، یکی از نتایج غیرقابل تغییر بودن یک شیء این است که <strong>هویت آن تغییر نمی‌کند</strong>؛ بنابراین برای این نوع‌ها، پیاده‌سازی <strong>برابری ساختاری (structural equality)</strong> بیشتر مفید است تا <strong>برابری مرجع (referential equality)</strong>. برابری ساختاری یعنی دو نمونه زمانی برابرند که <strong>داده‌های آن‌ها یکسان باشد</strong> (مانند تاپل‌ها). رکوردها به‌صورت پیش‌فرض برابری ساختاری را فراهم می‌کنند—صرف‌نظر از این‌که نوع زیرین کلاس باشد یا struct—بدون هیچ کد اضافی.</p>
<hr>
<h3>تعریف رکورد 🏷️</h3>
<p>تعریف یک رکورد شبیه تعریف <strong>کلاس یا struct</strong> است و می‌تواند شامل همان نوع اعضا باشد، از جمله فیلدها، propertyها، متدها و غیره. رکوردها می‌توانند <strong>interfaceها</strong> را پیاده‌سازی کنند و رکوردهای مبتنی بر کلاس می‌توانند از رکوردهای دیگر ارث‌بری کنند.</p>
<p>به‌صورت پیش‌فرض، <strong>نوع زیرین رکورد کلاس است</strong>:</p>
<pre><code class="language-csharp">record Point { }   // Point یک کلاس است
</code></pre>
<p>از C# 10 به بعد، نوع زیرین رکورد می‌تواند struct نیز باشد:</p>
<pre><code class="language-csharp">record struct Point { }   // Point یک struct است
</code></pre>
<p>(استفاده از <code>record class</code> نیز قانونی است و همان معنی <code>record</code> را دارد.)</p>
<p>یک رکورد ساده ممکن است فقط تعدادی <strong>property با init-only</strong> داشته باشد و احتمالاً یک <strong>سازنده</strong>:</p>
<pre><code class="language-csharp">record Point
{
    public Point(double x, double y) =&gt; (X, Y) = (x, y);
    public double X { get; init; }
    public double Y { get; init; }    
}
</code></pre>
<p>سازنده ما از یک <strong>میانبر (shortcut)</strong> استفاده می‌کند که در بخش قبل توضیح داده شد:</p>
<pre><code class="language-csharp">(X, Y) = (x, y);
</code></pre>
<p>این در واقع معادل است با:</p>
<pre><code class="language-csharp">{ this.X = x; this.Y = y; }
</code></pre>
<hr>
<h3>کارهای کامپایلر هنگام تعریف رکورد ⚙️</h3>
<p>پس از کامپایل، C# تعریف رکورد را به کلاس (یا struct) تبدیل می‌کند و مراحل اضافی زیر را انجام می‌دهد:</p>
<ul>
<li>نوشتن <strong>سازنده کپی (copy constructor)</strong> محافظت‌شده و یک <strong>متد Clone پنهان</strong> برای تسهیل تغییر غیرمخرب</li>
<li>بازتعریف/بارگذاری مجدد متدهای مرتبط با برابری برای پیاده‌سازی <strong>برابری ساختاری</strong></li>
<li>بازتعریف متد <strong>ToString()</strong> (برای نمایش propertyهای عمومی، مشابه anonymous types)</li>
</ul>
<p>مثال تقریباً برابر با آنچه بالا تعریف شد:</p>
<pre><code class="language-csharp">class Point
{  
    public Point(double x, double y) =&gt; (X, Y) = (x, y);
    public double X { get; init; }
    public double Y { get; init; }    

    protected Point(Point original)  // سازنده کپی
    {
        this.X = original.X; this.Y = original.Y;
    }

    // نام عجیب تولید شده توسط کامپایلر
    public virtual Point &lt;Clone&gt;$() =&gt; new Point(this);  // متد Clone

    // کد اضافی برای بازتعریف Equals, ==, !=, GetHashCode, ToString()
    // ...
}
</code></pre>
<hr>
<h3>لیست پارامترها 📝</h3>
<p>هیچ چیزی مانع قرار دادن <strong>پارامترهای اختیاری (optional)</strong> در سازنده نمی‌شود، اما یک الگوی خوب (به‌ویژه در کتابخانه‌های عمومی) این است که آن‌ها را <strong>از سازنده حذف کرده و صرفاً به‌صورت propertyهای init-only</strong> ارائه دهید:</p>
<pre><code class="language-csharp">new Foo(123, 234) { Optional2 = 345 };

record Foo
{
    public Foo(int required1, int required2) { ... }
    public int Required1 { get; init; }
    public int Required2 { get; init; }
    public int Optional1 { get; init; }
    public int Optional2 { get; init; }
}
</code></pre>
<p>مزیت این الگو این است که می‌توان <strong>propertyهای init-only جدید</strong> اضافه کرد بدون اینکه <strong>سازگاری باینری با نسخه‌های قدیمی</strong> را مختل کنید.</p>
<hr>
<h3>کوتاه‌سازی تعریف رکورد با لیست پارامترها ⚡</h3>
<p>تعریف رکورد را می‌توان با <strong>لیست پارامترها</strong> کوتاه کرد:</p>
<pre><code class="language-csharp">record Point(double X, double Y)
{
    // می‌توانید اعضای کلاس اضافی نیز تعریف کنید...
}
</code></pre>
<p>پارامترها می‌توانند شامل <strong>modifiers</strong> مانند <code>in</code> و <code>params</code> باشند، اما نه <code>out</code> یا <code>ref</code>. اگر لیست پارامتر مشخص شود، کامپایلر کارهای اضافی زیر را انجام می‌دهد:</p>
<ul>
<li>نوشتن یک property <strong>init-only</strong> برای هر پارامتر</li>
<li>نوشتن <strong>سازنده اصلی (primary constructor)</strong> برای مقداردهی propertyها</li>
<li>نوشتن یک <strong>deconstructor</strong></li>
</ul>
<p>بنابراین اگر رکورد خود را ساده تعریف کنیم:</p>
<pre><code class="language-csharp">record Point(double X, double Y);
</code></pre>
<p>کامپایلر تقریباً همان کدی را تولید می‌کند که در بخش قبل دیدیم. تنها تفاوت جزئی این است که نام پارامترها در سازنده اصلی <code>X</code> و <code>Y</code> خواهد بود، نه <code>x</code> و <code>y</code>:</p>
<pre><code class="language-csharp">public Point(double X, double Y)  // سازنده اصلی
{
    this.X = X; this.Y = Y;
}
</code></pre>
<hr>
<h3>قابلیت‌های اضافی لیست پارامترها</h3>
<ul>
<li>پارامترهای <code>X</code> و <code>Y</code> به‌صورت جادویی در هر <strong>initializer</strong> فیلد یا property در رکورد در دسترس هستند</li>
<li>کامپایلر <strong>یک deconstructor</strong> نیز تولید می‌کند:</li>
</ul>
<pre><code class="language-csharp">public void Deconstruct(out double X, out double Y)
{
    X = this.X; Y = this.Y;
}
</code></pre>
<ul>
<li>رکوردهایی با لیست پارامتر را می‌توان <strong>به‌عنوان subclass</strong> تعریف کرد:</li>
</ul>
<pre><code class="language-csharp">record Point3D(double X, double Y, double Z) : Point(X, Y);
</code></pre>
<p>که کامپایلر تولید می‌کند:</p>
<pre><code class="language-csharp">class Point3D : Point
{
    public double Z { get; init; }
    public Point3D(double X, double Y, double Z) : base(X, Y)
        =&gt; this.Z = Z;
}
</code></pre>
<p>لیست پارامترها یک <strong>میانبر عالی</strong> برای کلاس‌هایی هستند که صرفاً <strong>چند مقدار را گروه‌بندی می‌کنند (product type در برنامه‌نویسی تابعی)</strong> و برای <strong>نمونه‌سازی سریع (prototyping)</strong> مفید هستند. البته هنگام نیاز به <strong>اضافه کردن منطق به accessors init</strong> (مثلاً اعتبارسنجی پارامتر) چندان مناسب نیستند.</p>
<h3>قابلیت تغییرپذیری در رکوردهای Struct 🔄</h3>
<p>وقتی که <strong>لیست پارامتر</strong> در یک <strong>record struct</strong> تعریف می‌کنید، کامپایلر به‌صورت پیش‌فرض <strong>propertyهای قابل نوشتن (writable)</strong> ایجاد می‌کند، نه propertyهای <strong>init-only</strong>، مگر اینکه تعریف رکورد را با کلمه کلیدی <code>readonly</code> پیش‌فرض کنید:</p>
<pre><code class="language-csharp">readonly record struct Point(double X, double Y);
</code></pre>
<p>دلیل این رفتار این است که در <strong>سناریوهای معمولی</strong>، مزایای ایمنی <strong>غیرقابل تغییر بودن (immutability)</strong> از این ناشی می‌شود که <strong>خانه یا محیط نگهدارنده struct غیرقابل تغییر است</strong>، نه خود struct.</p>
<p>در مثال زیر، حتی اگر فیلد <code>X</code> قابل نوشتن باشد، قادر به تغییر آن نیستیم:</p>
<pre><code class="language-csharp">var test = new Immutable();
test.Field.X++;  // غیرمجاز، زیرا Field readonly است
test.Prop.X++;   // غیرمجاز، زیرا Prop فقط { get; } دارد

class Immutable
{
    public readonly Mutable Field;
    public Mutable Prop { get; }
}

struct Mutable { public int X, Y; }
</code></pre>
<p>و اگر بخواهیم کاری مانند زیر انجام دهیم:</p>
<pre><code class="language-csharp">var test = new Immutable();
Mutable m = test.Prop;
m.X++;
</code></pre>
<p>تمام کاری که انجام می‌دهیم این است که یک <strong>متغیر محلی (local variable)</strong> را تغییر می‌دهیم، که نسخه‌ای کپی از <code>test.Prop</code> است. تغییر یک متغیر محلی می‌تواند یک <strong>بهینه‌سازی مفید</strong> باشد و مزایای <strong>سیستم نوع غیرقابل تغییر</strong> را نقض نمی‌کند.</p>
<p>از طرف دیگر، اگر <code>Field</code> یک فیلد قابل نوشتن و <code>Prop</code> یک property قابل نوشتن باشد، می‌توانیم به راحتی <strong>محتویات آن‌ها را جایگزین کنیم</strong>—صرف‌نظر از اینکه struct <code>Mutable</code> چگونه تعریف شده است.</p>
<h3>تغییرات غیرمخرب (Nondestructive Mutation) 🔄✨</h3>
<p>مهم‌ترین کاری که کامپایلر با <strong>تمام رکوردها</strong> انجام می‌دهد، ایجاد یک <strong>کپی‌کننده (copy constructor)</strong> و یک <strong>متد پنهان Clone</strong> است. این امکان را فراهم می‌کند که بتوانید با استفاده از <strong>کلمه کلیدی <code>with</code></strong>، یک تغییر غیرمخرب روی رکورد انجام دهید:</p>
<pre><code class="language-csharp">Point p1 = new Point(3, 3);
Point p2 = p1 with { Y = 4 };
Console.WriteLine(p2);       // Point { X = 3, Y = 4 }

record Point(double X, double Y);
</code></pre>
<p>در این مثال، <code>p2</code> نسخه‌ای <strong>کپی از <code>p1</code></strong> است، ولی با مقدار <strong>Y = 4</strong>. مزیت این روش وقتی واضح‌تر می‌شود که رکورد تعداد زیادی property داشته باشد:</p>
<pre><code class="language-csharp">Test t1 = new Test(1,2,3,4,5,6,7,8);
Test t2 = t1 with { A = 10, C = 30 };
Console.WriteLine(t2);

record Test(int A, int B, int C, int D, int E, int F, int G, int H);
</code></pre>
<p>خروجی به شکل زیر خواهد بود:</p>
<pre><code>Test { A = 10, B = 2, C = 30, D = 4, E = 5, F = 6, G = 7, H = 8 }
</code></pre>
<h3>مراحل تغییر غیرمخرب 🛠️</h3>
<p>1️⃣ ابتدا، <strong>کپی‌کننده</strong> رکورد را clone می‌کند. به‌طور پیش‌فرض، هر یک از فیلدهای داخلی رکورد کپی می‌شوند، که یک <strong>نسخه دقیق</strong> ایجاد می‌کند و از اجرای منطق در accessorهای init جلوگیری می‌کند. تمام فیلدها شامل <strong>عمومی، خصوصی و فیلدهای پنهان پشت propertyهای اتوماتیک</strong> در کپی گنجانده می‌شوند.</p>
<p>2️⃣ سپس، هر property در <strong>لیست مقداردهی اعضا (member initializer)</strong> به‌روزرسانی می‌شود، این بار با استفاده از <strong>init accessor</strong>.</p>
<p>کامپایلر کد زیر را:</p>
<pre><code class="language-csharp">Test t2 = t1 with { A = 10, C = 30 };
</code></pre>
<p>به چیزی شبیه به این تبدیل می‌کند:</p>
<pre><code class="language-csharp">Test t2 = new Test(t1);  // استفاده از copy constructor برای clone کردن t1 فیلد به فیلد
t2.A = 10;               // به‌روزرسانی property A
t2.C = 30;               // به‌روزرسانی property C
</code></pre>
<blockquote>
<p>⚠️ همان‌طور که می‌بینید، نوشتن مستقیم این کد در حالت عادی <strong>کامپایل نمی‌شود</strong> چون A و C propertyهای <strong>init-only</strong> هستند. علاوه بر این، copy constructor <strong>protected</strong> است و C# برای دور زدن این محدودیت، آن را از طریق متد پنهان <code>&lt;Clone&gt;$</code> فراخوانی می‌کند.</p>
</blockquote>
<h3>تعریف کپی‌کننده سفارشی ✍️</h3>
<p>اگر لازم باشد، می‌توانید <strong>copy constructor خودتان</strong> را تعریف کنید. کامپایلر از تعریف شما استفاده خواهد کرد:</p>
<pre><code class="language-csharp">protected Point(Point original)
{
    this.X = original.X; 
    this.Y = original.Y;
}
</code></pre>
<p>نوشتن کپی‌کننده سفارشی مفید است اگر رکورد شما حاوی <strong>زیر-اشیاء یا مجموعه‌های قابل تغییر</strong> باشد که باید clone شوند، یا فیلدهای محاسبه‌شده‌ای داشته باشید که می‌خواهید پاک شوند. ⚠️ توجه کنید که تنها می‌توانید <strong>جایگزین</strong> کنید، نه <strong>بهبود دهید</strong>.</p>
<p>در <strong>Subclass کردن رکورد دیگر</strong>، copy constructor مسئول <strong>کپی فقط فیلدهای خودش</strong> است. برای کپی فیلدهای رکورد پایه، از <strong>delegate به base</strong> استفاده کنید:</p>
<pre><code class="language-csharp">protected Point(Point original) : base(original)
{
    ...
}
</code></pre>
<h3>اعتبارسنجی propertyها ✅</h3>
<p>با propertyهای <strong>صریح</strong>، می‌توانید منطق اعتبارسنجی را در <strong>init accessor</strong> بنویسید. به عنوان مثال، مطمئن می‌شویم X هیچ‌گاه <strong>NaN</strong> نباشد:</p>
<pre><code class="language-csharp">record Point
{
    public Point(double x, double y) =&gt; (X, Y) = (x, y);
    double _x;
    public double X
    { 
        get =&gt; _x;
        init
        {
            if (double.IsNaN(value))
                throw new ArgumentException(&quot;X Cannot be NaN&quot;);
            _x = value;
        }
    }
    public double Y { get; init; }    
}
</code></pre>
<p>با این طراحی، اعتبارسنجی هم <strong>در زمان ساخت رکورد</strong> و هم <strong>در زمان تغییر غیرمخرب</strong> انجام می‌شود:</p>
<pre><code class="language-csharp">Point p1 = new Point(2,3);
Point p2 = p1 with { X = double.NaN };   // پرتاب Exception
</code></pre>
<p>کپی‌کننده خودکار، <strong>تمام فیلدها و propertyهای اتوماتیک</strong> را کپی می‌کند:</p>
<pre><code class="language-csharp">protected Point(Point original)
{
    _x = original._x; 
    Y = original.Y;
}
</code></pre>
<p>کپی کردن <code>_x</code> از طریق <strong>accessor</strong> انجام نمی‌شود، ولی مشکلی ایجاد نمی‌کند چون مقدار قبلاً با <strong>init accessor</strong> به‌صورت امن مقداردهی شده است.</p>
<h3>فیلدهای محاسبه‌شده و ارزیابی Lazy ⚡</h3>
<p>یکی از الگوهای رایج در <strong>برنامه‌نویسی تابعی (Functional)</strong> که با رکوردهای غیرقابل تغییر خوب کار می‌کند، <strong>lazy evaluation</strong> است: مقدار تنها وقتی محاسبه می‌شود که لازم باشد و سپس برای استفاده بعدی <strong>کش</strong> می‌شود.</p>
<p>مثلاً می‌خواهیم propertyی در رکورد Point تعریف کنیم که فاصله از مبدأ (0,0) را برگرداند:</p>
<pre><code class="language-csharp">record Point(double X, double Y)
{
    public double DistanceFromOrigin =&gt; Math.Sqrt(X*X + Y*Y);
}
</code></pre>
<p>برای بهینه‌سازی و جلوگیری از محاسبه مکرر، می‌توانیم مقدار آن را <strong>lazy</strong> در یک فیلد ذخیره کنیم:</p>
<pre><code class="language-csharp">record Point
{
    double? _distance;
    public double X { get; init; }
    public double Y { get; init; }
    public double DistanceFromOrigin =&gt; _distance ??= Math.Sqrt(X*X + Y*Y);
}
</code></pre>
<p>✅ در این حالت، <code>_distance</code> تنها <strong>یک بار محاسبه</strong> می‌شود و تغییر <code>X</code> یا <code>Y</code> باعث پاک شدن مقدار کش شده می‌شود.</p>
<pre><code class="language-csharp">Point p1 = new Point(2,3);
Console.WriteLine(p1.DistanceFromOrigin);   // 3.605551275463989
Point p2 = p1 with { Y = 4 };
Console.WriteLine(p2.DistanceFromOrigin);   // 4.47213595499958
</code></pre>
<p>مزیت دیگر این است که <strong>copy constructor خودکار</strong> نیز فیلد کش شده <code>_distance</code> را کپی می‌کند، بنابراین اگر propertyهای دیگری که در محاسبات دخیل نیستند، تغییر کنند، <strong>مقدار کش شده از بین نمی‌رود</strong>.</p>
<p>اگر نخواهید این رفتار را داشته باشید، می‌توانید در <strong>init accessor</strong> مقدار کش را پاک کنید یا یک <strong>copy constructor سفارشی</strong> بنویسید که فیلد کش را نادیده بگیرد.</p>
<hr>
<h3>سازنده‌های اولیه (Primary Constructors) 🏗️✨</h3>
<p>وقتی یک <strong>رکورد</strong> با <strong>لیست پارامترها</strong> تعریف می‌کنید، کامپایلر به‌طور خودکار <strong>propertyها</strong> را تعریف می‌کند و یک <strong>سازنده اولیه (primary constructor)</strong> و یک <strong>deconstructor</strong> ایجاد می‌کند. همان‌طور که دیدیم، این روش در موارد ساده خوب کار می‌کند و در موارد پیچیده‌تر می‌توانید لیست پارامترها را حذف کرده و propertyها و سازنده را به‌صورت دستی بنویسید.</p>
<p>C# همچنین یک گزینه <strong>میان‌راه مفید</strong> ارائه می‌دهد؛ اگر بخواهید با <strong>معنای عجیب سازنده‌های اولیه</strong> کنار بیایید، می‌توانید یک <strong>لیست پارامتر تعریف کنید</strong> و در عین حال برخی یا همه propertyها را خودتان تعریف کنید:</p>
<pre><code class="language-csharp">record Student(string ID, string LastName, string GivenName)
{
    public string ID { get; } = ID;
}
</code></pre>
<p>در این حالت، ما property <strong>ID</strong> را <strong>به‌طور دستی مدیریت کردیم</strong> و آن را به صورت <strong>read-only</strong> تعریف کردیم (به جای init-only)، بنابراین این property دیگر در <strong>تغییر غیرمخرب (nondestructive mutation)</strong> شرکت نمی‌کند.</p>
<p>اگر هیچ‌وقت نیازی به تغییر غیرمخرب یک property ندارید، تعریف آن به صورت <strong>read-only</strong> اجازه می‌دهد داده‌های محاسبه‌شده را بدون نیاز به نوشتن مکانیسم تازه‌سازی ذخیره کنید.</p>
<p>⚠️ دقت کنید که لازم بود <strong>یک مقداردهی اولیه برای property</strong> ارائه دهیم:</p>
<pre><code class="language-csharp">public string ID { get; } = ID;
</code></pre>
<p>زمانی که <strong>تعریف property را به عهده می‌گیرید</strong>، مسئول مقداردهی آن هستید و <strong>سازنده اولیه دیگر به‌صورت خودکار آن را مقداردهی نمی‌کند</strong>. (این دقیقاً مشابه رفتار کلاس‌ها و structها با سازنده‌های اولیه است.) همچنین توجه کنید که <strong>ID در اینجا به پارامتر سازنده اولیه اشاره دارد، نه به property.</strong></p>
<hr>
<h3>رکوردهای struct و بازتعریف property به عنوان field 🧱</h3>
<p>با <strong>record struct</strong>، قانونی است که property را به عنوان <strong>field</strong> بازتعریف کنید:</p>
<pre><code class="language-csharp">record struct Student(string ID)
{
    public string ID = ID;
}
</code></pre>
<p>طبق <strong>معنای سازنده‌های اولیه در کلاس‌ها و structها</strong>، پارامترهای سازنده اولیه (مثل ID، LastName و GivenName) <strong>به‌طور جادویی در تمام initializerهای field و property قابل دسترس هستند</strong>. مثال:</p>
<pre><code class="language-csharp">record Student(string ID, string LastName, string FirstName)
{
    public string ID { get; } = ID;
    readonly int _enrollmentYear = int.Parse(ID.Substring(0, 4));
}
</code></pre>
<p>در این مثال، <code>_enrollmentYear</code> از چهار رقم اول <strong>ID</strong> محاسبه شده است. چون property <strong>ID read-only</strong> است، می‌توان آن را امن در یک <strong>field read-only</strong> ذخیره کرد، بدون اینکه تغییر غیرمخرب مشکلی ایجاد کند.</p>
<p>⚠️ اما در دنیای واقعی، بدون <strong>سازنده صریح</strong>، هیچ مکان مرکزی برای اعتبارسنجی ID و پرتاب <strong>exception معنی‌دار</strong> وجود ندارد.</p>
<hr>
<h3>اعتبارسنجی با init-only accessors ✅</h3>
<p>برای انجام <strong>اعتبارسنجی</strong> روی propertyها، باید از <strong>init-only accessor صریح</strong> استفاده کنید:</p>
<pre><code class="language-csharp">record Person(string Name)
{
    string _name = Name;
    public string Name
    {
        get =&gt; _name;
        init =&gt; _name = value ?? throw new ArgumentNullException(&quot;Name&quot;);
    }
}
</code></pre>
<p>⚠️ چون <strong>Name یک property اتوماتیک نیست</strong>، نمی‌توان initializer تعریف کرد. بهترین کار این است که initializer را روی <strong>field پشت property</strong> قرار دهید، اما این باعث می‌شود که <strong>check null نادیده گرفته شود</strong>:</p>
<pre><code class="language-csharp">var p = new Person(null);    // موفقیت‌آمیز! (check نادیده گرفته شد)
</code></pre>
<p>مشکل اصلی این است که <strong>نمی‌توان بدون نوشتن سازنده، پارامتر سازنده اولیه را به property اختصاص داد</strong>. راه‌حل ساده این است که <strong>لیست پارامتر را حذف کرده و یک سازنده معمولی بنویسید</strong>:</p>
<pre><code class="language-csharp">record Person
{
    public Person(string name) =&gt; Name = name;  // اختصاص به PROPERTY
    string _name;
    public string Name { get =&gt; _name; init =&gt; ... }
}
</code></pre>
<hr>
<h3>رکوردها و مقایسه برابری (Equality) ⚖️</h3>
<p>مانند <strong>structها، anonymous types و tuples</strong>، رکوردها <strong>structural equality</strong> را به صورت پیش‌فرض ارائه می‌کنند؛ یعنی دو رکورد <strong>برابرند اگر فیلدها و propertyهای اتوماتیک آنها برابر باشند</strong>:</p>
<pre><code class="language-csharp">var p1 = new Point(1,2);
var p2 = new Point(1,2);
Console.WriteLine(p1.Equals(p2));   // True

record Point(double X, double Y);
</code></pre>
<p>عملگر <strong>==</strong> نیز با رکوردها کار می‌کند (مانند tuples):</p>
<pre><code class="language-csharp">Console.WriteLine(p1 == p2);         // True
</code></pre>
<p>⚠️ اجرای پیش‌فرض برابری برای رکوردها ممکن است آسیب‌پذیر باشد، به‌خصوص اگر رکورد حاوی <strong>مقادیر lazy، transient، آرایه‌ها یا collectionها</strong> باشد که نیاز به مدیریت ویژه برای مقایسه دارند. خوشبختانه، اصلاح آن نسبتاً ساده است و نیاز به کار زیادی ندارد.</p>
<hr>
<h3>نوشتن Equals سفارشی 🖋️</h3>
<p>بر خلاف کلاس‌ها و structها، <strong>نمی‌توانید object.Equals را override کنید</strong>؛ در عوض باید یک متد <strong>public Equals</strong> با این <strong>امضا</strong> تعریف کنید:</p>
<pre><code class="language-csharp">record Point(double X, double Y)
{
    double _someOtherField;
    public virtual bool Equals(Point other) =&gt;
        other != null &amp;&amp; X == other.X &amp;&amp; Y == other.Y;
}
</code></pre>
<ul>
<li>متد <strong>Equals</strong> باید <strong>virtual</strong> باشد، نه override.</li>
<li>نوع پارامتر باید <strong>نوع رکورد واقعی</strong> باشد (در این مثال Point، نه object).</li>
<li>وقتی امضا درست باشد، کامپایلر به صورت خودکار متد شما را patch می‌کند.</li>
</ul>
<p>در مثال بالا، منطق برابری را تغییر دادیم تا فقط <strong>X و Y</strong> مقایسه شوند و <code>_someOtherField</code> نادیده گرفته شود.</p>
<p>اگر رکورد دیگری را <strong>subclass</strong> کنید، می‌توانید <strong>base.Equals</strong> را فراخوانی کنید:</p>
<pre><code class="language-csharp">public virtual bool Equals(Point other) =&gt; base.Equals(other) &amp;&amp; ...
</code></pre>
<p>✅ نکته مهم: اگر منطق برابری را خودتان پیاده کنید، باید <strong>GetHashCode</strong> را نیز override کنید. خوشبختانه در رکوردها نیازی به overload کردن <strong>!= یا ==</strong> و پیاده‌سازی <strong>IEquatable<T></strong> نیست؛ همه این‌ها به‌صورت خودکار انجام می‌شود.</p>
<p>موضوع <strong>مقایسه برابری رکوردها</strong> به صورت کامل در بخش «Equality Comparison» صفحه 344 پوشش داده شده است.</p>
<h3>الگوها (Patterns) 🧩✨</h3>
<p>در فصل ۳، نشان دادیم که چگونه می‌توان از عملگر <strong>is</strong> برای بررسی موفقیت <strong>تبدیل مرجع (reference conversion)</strong> استفاده کرد:</p>
<pre><code class="language-csharp">if (obj is string)
    Console.WriteLine(((string)obj).Length);
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre><code class="language-csharp">if (obj is string s)
    Console.WriteLine(s.Length);
</code></pre>
<p>این روش کوتاه، یکی از <strong>الگوها (type pattern)</strong> را به کار می‌گیرد. عملگر <strong>is</strong> همچنین از الگوهای دیگری پشتیبانی می‌کند که در نسخه‌های اخیر C# معرفی شده‌اند، مانند <strong>property pattern</strong>:</p>
<pre><code class="language-csharp">if (obj is string { Length: 4 })
    Console.WriteLine(&quot;A string with 4 characters&quot;);
</code></pre>
<p>الگوها در زمینه‌های زیر پشتیبانی می‌شوند:</p>
<ul>
<li>بعد از عملگر <strong>is</strong> <code>(variable is pattern)</code></li>
<li>در <strong>switch statements</strong></li>
<li>در <strong>switch expressions</strong></li>
</ul>
<p>ما قبلاً <strong>type pattern</strong> (و به طور خلاصه، <strong>tuple pattern</strong>) را در بخش‌های «Switching on types» صفحه 89 و «The is operator» صفحه 130 پوشش داده‌ایم. در این بخش، الگوهای پیشرفته‌تر معرفی شده در نسخه‌های جدید C# را بررسی می‌کنیم.</p>
<p>برخی از الگوهای تخصصی‌تر عمدتاً برای استفاده در <strong>switch statements/expressions</strong> طراحی شده‌اند و نیاز به <strong>when clauses</strong> را کاهش می‌دهند و امکان استفاده از <strong>switch</strong> را در مواقعی فراهم می‌کنند که قبلاً امکان آن نبود.</p>
<p>⚠️ به یاد داشته باشید که همیشه می‌توانید <strong>switch expressionهای پیچیده</strong> را با <strong>if ساده</strong> جایگزین کنید، یا در برخی موارد از <strong>عملگر شرطی سه‌تایی (ternary operator)</strong> استفاده کنید، معمولاً بدون نیاز به کد اضافی زیاد.</p>
<hr>
<h3>الگوی ثابت (Constant Pattern) 🔢</h3>
<p>الگوی ثابت به شما امکان می‌دهد مستقیماً با یک <strong>ثابت (constant)</strong> مطابقت دهید و هنگام کار با نوع <strong>object</strong> مفید است:</p>
<pre><code class="language-csharp">void Foo(object obj)
{
    if (obj is 3) ...
}
</code></pre>
<p>این عبارت با کد زیر معادل است:</p>
<pre><code class="language-csharp">obj is int &amp;&amp; (int)obj == 3
</code></pre>
<p>⚠️ چون این یک عملگر <strong>static</strong> است، C# اجازه نمی‌دهد که مستقیماً با <strong>==</strong> یک object را با یک constant مقایسه کنید، زیرا کامپایلر باید نوع‌ها را از قبل بداند.</p>
<p>به تنهایی، این الگو کاربرد محدودی دارد، زیرا جایگزین منطقی آن این است:</p>
<pre><code class="language-csharp">if (3.Equals(obj)) ...
</code></pre>
<p>به زودی خواهیم دید که <strong>الگوی ثابت</strong> با <strong>pattern combinators</strong> بسیار کاربردی‌تر می‌شود.</p>
<hr>
<h3>الگوهای رابطه‌ای (Relational Patterns) 📏</h3>
<p>از C# 9 به بعد، می‌توانید از عملگرهای <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> در الگوها استفاده کنید:</p>
<pre><code class="language-csharp">if (x is &gt; 100) Console.WriteLine(&quot;x is greater than 100&quot;);
</code></pre>
<p>این الگو در <strong>switch</strong> بسیار مفید می‌شود:</p>
<pre><code class="language-csharp">string GetWeightCategory(decimal bmi) =&gt; bmi switch
{
    &lt; 18.5m =&gt; &quot;underweight&quot;,
    &lt; 25m =&gt; &quot;normal&quot;,
    &lt; 30m =&gt; &quot;overweight&quot;,
    _ =&gt; &quot;obese&quot;
};
</code></pre>
<p>⚠️ الگوهای رابطه‌ای حتی زمانی که متغیر از نوع <strong>object</strong> باشد کار می‌کنند، اما باید در استفاده از <strong>ثابت‌های عددی</strong> بسیار دقت کنید:</p>
<pre><code class="language-csharp">object obj = 2m;                  // obj از نوع decimal است
Console.WriteLine(obj is &lt; 3m);   // True
Console.WriteLine(obj is &lt; 3);    // False
</code></pre>
<hr>
<h3>ترکیب‌کننده‌های الگو (Pattern Combinators) 🔗</h3>
<p>از C# 9 به بعد، می‌توانید از کلیدواژه‌های <strong>and, or, not</strong> برای ترکیب الگوها استفاده کنید:</p>
<pre><code class="language-csharp">bool IsJanetOrJohn(string name) =&gt; name.ToUpper() is &quot;JANET&quot; or &quot;JOHN&quot;;
bool IsVowel(char c) =&gt; c is 'a' or 'e' or 'i' or 'o' or 'u';
bool Between1And9(int n) =&gt; n is &gt;= 1 and &lt;= 9;
bool IsLetter(char c) =&gt; c is &gt;= 'a' and &lt;= 'z' or &gt;= 'A' and &lt;= 'Z';
</code></pre>
<ul>
<li>مانند عملگرهای <code>&amp;&amp;</code> و <code>||</code>، <strong>and</strong> اولویت بالاتری نسبت به <strong>or</strong> دارد و می‌توان با پرانتز این ترتیب را تغییر داد.</li>
</ul>
<p>یک ترفند مفید این است که <strong>not combinator</strong> را با <strong>type pattern</strong> ترکیب کنید تا بررسی کنید آیا یک object <strong>از نوع خاصی نیست</strong>:</p>
<pre><code class="language-csharp">if (obj is not string) ...
</code></pre>
<p>این حالت زیباتر از نوشتن زیر است:</p>
<pre><code class="language-csharp">if (!(obj is string)) ...
</code></pre>
<h3>الگوی <code>var</code> 🟢</h3>
<p>الگوی <strong>var</strong> نوعی <strong>type pattern</strong> است که در آن به جای نام نوع، از کلمه کلیدی <strong>var</strong> استفاده می‌کنید. این تبدیل همیشه موفق است و هدف آن فقط <strong>امکان استفاده مجدد از متغیری است که پس از آن می‌آید</strong>:</p>
<pre><code class="language-csharp">bool IsJanetOrJohn(string name) =&gt; 
    name.ToUpper() is var upper &amp;&amp; (upper == &quot;JANET&quot; || upper == &quot;JOHN&quot;);
</code></pre>
<p>این معادل کد زیر است:</p>
<pre><code class="language-csharp">bool IsJanetOrJohn(string name)
{
    string upper = name.ToUpper();
    return upper == &quot;JANET&quot; || upper == &quot;JOHN&quot;;
}
</code></pre>
<p>💡 توانایی <strong>معرفی و استفاده مجدد یک متغیر میانی</strong> (مثل <code>upper</code>) در یک متد با <strong>expression-bodied</strong> بسیار کاربردی است، به ویژه در <strong>lambda expressions</strong>.
⚠️ متأسفانه، این الگو عمدتاً زمانی مفید است که متد مورد نظر <strong>نوع بازگشتی bool</strong> داشته باشد.</p>
<hr>
<h3>الگوهای Tuple و Positional 🟦</h3>
<p><strong>Tuple pattern</strong> (معرفی‌شده در C# 8) برای مطابقت با <strong>tuples</strong> استفاده می‌شود:</p>
<pre><code class="language-csharp">var p = (2, 3);
Console.WriteLine(p is (2, 3));  // True
</code></pre>
<p>می‌توانید از آن برای <strong>switch</strong> روی چند مقدار استفاده کنید:</p>
<pre><code class="language-csharp">int AverageCelsiusTemperature(Season season, bool daytime) =&gt;
    (season, daytime) switch
    {
        (Season.Spring, true) =&gt; 20,
        (Season.Spring, false) =&gt; 16,
        (Season.Summer, true) =&gt; 27,
        (Season.Summer, false) =&gt; 22,
        (Season.Fall, true) =&gt; 18,
        (Season.Fall, false) =&gt; 12,
        (Season.Winter, true) =&gt; 10,
        (Season.Winter, false) =&gt; -2,
        _ =&gt; throw new Exception(&quot;Unexpected combination&quot;)
    };

enum Season { Spring, Summer, Fall, Winter };
</code></pre>
<p>⚡ <strong>Tuple pattern</strong> در واقع یک <strong>حالت ویژه از positional pattern</strong> است (C# 8+) که با هر نوعی که متد <strong>Deconstruct</strong> ارائه دهد، کار می‌کند.</p>
<p>مثال با <strong>record Point</strong> و <strong>deconstructor تولید شده توسط کامپایلر</strong>:</p>
<pre><code class="language-csharp">var p = new Point(2, 2);
Console.WriteLine(p is (2, 2));  // True
record Point(int X, int Y);      // دارای deconstructor تولید شده توسط کامپایلر
</code></pre>
<p>می‌توانید هنگام <strong>match</strong>، متغیرها را <strong>deconstruct</strong> کنید:</p>
<pre><code class="language-csharp">Console.WriteLine(p is (var x, var y) &amp;&amp; x == y);  // True
</code></pre>
<p>مثال <strong>switch expression</strong> که <strong>type pattern</strong> را با <strong>positional pattern</strong> ترکیب می‌کند:</p>
<pre><code class="language-csharp">string Print(object obj) =&gt; obj switch 
{
    Point(0, 0) =&gt; &quot;Empty point&quot;,
    Point(var x, var y) when x == y =&gt; &quot;Diagonal&quot;,
    ...
};
</code></pre>
<hr>
<h3>الگوهای Property 🏷️</h3>
<p><strong>Property pattern</strong> (C# 8+) بر اساس یک یا چند <strong>مقدار property</strong> یک object مطابقت می‌دهد.
مثال ساده قبلاً با <strong>is operator</strong> داشتیم:</p>
<pre><code class="language-csharp">if (obj is string { Length:4 }) ...
</code></pre>
<p>⚠️ این تنها کمی از نوشتن کد زیر صرفه‌جویی می‌کند:</p>
<pre><code class="language-csharp">if (obj is string s &amp;&amp; s.Length == 4) ...
</code></pre>
<p>با <strong>switch statements</strong> و <strong>expressions</strong>، property patterns کاربرد بیشتری پیدا می‌کنند.</p>
<p>مثال با کلاس <strong>System.Uri</strong>:</p>
<pre><code class="language-csharp">bool ShouldAllow(Uri uri) =&gt; uri switch
{
    { Scheme: &quot;http&quot;,  Port: 80  } =&gt; true,
    { Scheme: &quot;https&quot;, Port: 443 } =&gt; true,
    { Scheme: &quot;ftp&quot;,   Port: 21  } =&gt; true,
    { IsLoopback: true } =&gt; true,
    _ =&gt; false
};
</code></pre>
<p>می‌توانید <strong>propertyها را تو در تو (nested)</strong> کنید، که از C# 10 به بعد می‌توان ساده‌سازی کرد:</p>
<pre><code class="language-csharp">{ Scheme.Length: 4, Port: 80 } =&gt; true,
</code></pre>
<p>همچنین می‌توان از <strong>الگوهای دیگر داخل property patterns</strong> استفاده کرد، مثل <strong>relational patterns</strong>:</p>
<pre><code class="language-csharp">{ Host: { Length: &lt; 1000 }, Port: &gt; 0 } =&gt; true,
</code></pre>
<p>شرایط پیچیده‌تر را می‌توان با <strong>when clause</strong> بیان کرد:</p>
<pre><code class="language-csharp">{ Scheme: &quot;http&quot; } when string.IsNullOrWhiteSpace(uri.Query) =&gt; true,
</code></pre>
<p>می‌توانید <strong>property pattern را با type pattern ترکیب کنید</strong> و متغیر معرفی کنید:</p>
<pre><code class="language-csharp">Uri { Scheme: &quot;http&quot;, Port: 80 } httpUri =&gt; httpUri.Host.Length &lt; 1000,
</code></pre>
<p>و همین متغیر را می‌توان در <strong>when clause</strong> استفاده کرد:</p>
<pre><code class="language-csharp">Uri { Scheme: &quot;http&quot;, Port: 80 } httpUri 
    when httpUri.Host.Length &lt; 1000 =&gt; true,
</code></pre>
<p>نکته جالب: می‌توان متغیرها را در سطح property نیز معرفی کرد:</p>
<pre><code class="language-csharp">{ Scheme: &quot;http&quot;, Port: 80, Host: string host } =&gt; host.Length &lt; 1000,
</code></pre>
<p>تایپ ضمنی نیز مجاز است، یعنی می‌توانید <strong>string</strong> را با <strong>var</strong> جایگزین کنید:</p>
<pre><code class="language-csharp">bool ShouldAllow(Uri uri) =&gt; uri switch
{
    { Scheme: &quot;http&quot;,  Port: 80, Host: var host } =&gt; host.Length &lt; 1000,
    { Scheme: &quot;https&quot;, Port: 443 } =&gt; true,
    { Scheme: &quot;ftp&quot;,   Port: 21  } =&gt; true,
    { IsLoopback: true } =&gt; true,
    _ =&gt; false
};
</code></pre>
<p>⚠️ در بسیاری از موارد، صرفه‌جویی در تعداد کاراکترها زیاد نیست. جایگزین ساده‌تر می‌تواند این باشد:</p>
<pre><code class="language-csharp">{ Scheme: &quot;http&quot;, Port: 80 } =&gt; uri.Host.Length &lt; 1000,
</code></pre>
<p>یا:</p>
<pre><code class="language-csharp">{ Scheme: &quot;http&quot;, Port: 80, Host: { Length: &lt; 1000 } } =&gt; ...
</code></pre>
<h3>الگوهای List 📋</h3>
<p><strong>List patterns</strong> (معرفی‌شده در C# 11) روی هر نوع collection قابل شمارش (<strong>Count</strong> یا <strong>Length</strong>) و با <strong>indexer عددی</strong> کار می‌کنند.</p>
<p>یک <strong>list pattern</strong> با استفاده از براکت‌ها <code>[ ]</code> تعریف می‌شود:</p>
<pre><code class="language-csharp">int[] numbers = { 0, 1, 2, 3, 4 };
Console.Write(numbers is [0, 1, 2, 3, 4]);   // True
</code></pre>
<ul>
<li>علامت <strong>underscore <code>_</code></strong> برای مطابقت با یک عنصر با هر مقداری استفاده می‌شود:</li>
</ul>
<pre><code class="language-csharp">Console.Write(numbers is [0, 1, _, _, 4]);   // True
</code></pre>
<ul>
<li>می‌توانید از <strong>var pattern</strong> برای گرفتن یک عنصر استفاده کنید:</li>
</ul>
<pre><code class="language-csharp">Console.Write(numbers is [0, 1, var x, 3, 4] &amp;&amp; x &gt; 1);   // True
</code></pre>
<ul>
<li><strong>دو نقطه <code>..</code></strong> برای مشخص کردن یک <strong>slice</strong> استفاده می‌شود که صفر یا چند عنصر را مطابقت می‌دهد:</li>
</ul>
<pre><code class="language-csharp">Console.Write(numbers is [0, .., 4]);    // True
</code></pre>
<ul>
<li>با آرایه‌ها یا سایر انواعی که از <strong>indices و ranges</strong> پشتیبانی می‌کنند، می‌توان slice را با var pattern ترکیب کرد:</li>
</ul>
<pre><code class="language-csharp">Console.Write(numbers is [0, .. var mid, 4] &amp;&amp; mid.Contains(2)); // True
</code></pre>
<p>⚠️ یک <strong>list pattern</strong> می‌تواند حداکثر یک slice داشته باشد.</p>
<hr>
<h3>Attributes 🏷️</h3>
<p><strong>Attributes</strong> مکانیزمی <strong>extensible</strong> برای اضافه کردن اطلاعات <strong>سفارشی</strong> به عناصر کد هستند (assembly، نوع، member، return value، parameter و generic type parameters).</p>
<ul>
<li>برای تعریف یک attribute، از یک کلاس که از <code>System.Attribute</code> ارث‌بری می‌کند استفاده می‌کنیم.</li>
<li>برای اعمال attribute، نام نوع آن را در <strong>براکت‌های <code>[ ]</code></strong> قبل از عنصر کد قرار می‌دهیم:</li>
</ul>
<pre><code class="language-csharp">[ObsoleteAttribute]
public class Foo {...}
</code></pre>
<p>⚡ به دلیل اینکه convention تمام attributeها با <code>Attribute</code> ختم می‌شوند، می‌توان suffix را حذف کرد:</p>
<pre><code class="language-csharp">[Obsolete]
public class Foo {...}
</code></pre>
<ul>
<li>
<p>پارامترهای attribute به دو دسته تقسیم می‌شوند:</p>
<ol>
<li><strong>Positional</strong>: مربوط به پارامترهای public constructor attribute</li>
<li><strong>Named</strong>: مربوط به فیلدها یا propertyهای عمومی attribute</li>
</ol>
</li>
</ul>
<p>مثال با XmlTypeAttribute:</p>
<pre><code class="language-csharp">[XmlType(&quot;Customer&quot;, Namespace=&quot;http://oreilly.com&quot;)]
public class CustomerEntity { ... }
</code></pre>
<ul>
<li><strong>Positional</strong>: <code>&quot;Customer&quot;</code></li>
<li><strong>Named</strong>: <code>Namespace=&quot;http://oreilly.com&quot;</code></li>
</ul>
<hr>
<h3>اعمال Attributes به Assembly و Fieldها 🏗️</h3>
<ul>
<li>می‌توان یک attribute را به <strong>assembly</strong> متصل کرد:</li>
</ul>
<pre><code class="language-csharp">[assembly: AssemblyFileVersion(&quot;1.2.3.4&quot;)]
</code></pre>
<ul>
<li>برای اعمال attribute به <strong>backing field</strong> یک property خودکار:</li>
</ul>
<pre><code class="language-csharp">[field:NonSerialized]
public int MyProperty { get; set; }
</code></pre>
<hr>
<h3>Attributes روی Lambda Expressions ⚡</h3>
<p>از C# 10 به بعد، می‌توان attributeها را به <strong>method، پارامترها و return value</strong> lambda اضافه کرد:</p>
<pre><code class="language-csharp">Action&lt;int&gt; a = [Description(&quot;Method&quot;)]
               [return: Description(&quot;Return value&quot;)]
               ([Description(&quot;Parameter&quot;)] int x) =&gt; Console.Write(x);
</code></pre>
<ul>
<li>این ویژگی برای فریمورک‌هایی مثل <strong>ASP.NET</strong> مفید است و نیاز به تعریف method جداگانه را از بین می‌برد.</li>
<li>برای دسترسی به این attributeها:</li>
</ul>
<pre><code class="language-csharp">var methodAtt = a.GetMethodInfo().GetCustomAttributes();
var paramAtt  = a.GetMethodInfo().GetParameters()[0].GetCustomAttributes();
var returnAtt = a.GetMethodInfo().ReturnParameter.GetCustomAttributes();
</code></pre>
<p>⚠️ برای جلوگیری از ابهام سینتکسی، <strong>پارامتر lambda همیشه باید داخل پرانتز باشد</strong>.
❌ اعمال attribute روی <strong>expression-tree lambdas</strong> مجاز نیست.</p>
<h3>مشخص کردن چند Attribute همزمان 🏷️</h3>
<p>می‌توان چند <strong>attribute</strong> را به یک عنصر کد نسبت داد. این کار را می‌توان به سه روش انجام داد:</p>
<ol>
<li>تمام attributeها در یک جفت براکت <code>[ ]</code>، با کاما جدا شده:</li>
</ol>
<pre><code class="language-csharp">[Serializable, Obsolete, CLSCompliant(false)]
public class Bar { ... }
</code></pre>
<ol start="2">
<li>هر attribute در یک جفت براکت جداگانه:</li>
</ol>
<pre><code class="language-csharp">[Serializable]
[Obsolete]
[CLSCompliant(false)]
public class Bar { ... }
</code></pre>
<ol start="3">
<li>ترکیبی از دو روش بالا:</li>
</ol>
<pre><code class="language-csharp">[Serializable, Obsolete]
[CLSCompliant(false)]
public class Bar { ... }
</code></pre>
<p>همه مثال‌های بالا از نظر معنایی <strong>یکسان</strong> هستند. ✅</p>
<hr>
<h3>Caller Info Attributes 📞</h3>
<p>سه <strong>attribute ویژه</strong> وجود دارد که می‌توان پارامترهای اختیاری را با آن‌ها علامت زد تا کامپایلر اطلاعات <strong>caller</strong> را در مقدار پیش‌فرض پارامتر قرار دهد:</p>
<ul>
<li><code>[CallerMemberName]</code>: نام عضو فراخواننده</li>
<li><code>[CallerFilePath]</code>: مسیر فایل منبع فراخواننده</li>
<li><code>[CallerLineNumber]</code>: شماره خط فراخواننده</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main() =&gt; Foo();

    static void Foo(
        [CallerMemberName] string memberName = null,
        [CallerFilePath] string filePath = null,
        [CallerLineNumber] int lineNumber = 0)
    {
        Console.WriteLine(memberName);
        Console.WriteLine(filePath);
        Console.WriteLine(lineNumber);
    }
}
</code></pre>
<p>فرض کنید فایل در <code>c:\source\test\Program.cs</code> است، خروجی:</p>
<pre><code>Main
c:\source\test\Program.cs
6
</code></pre>
<ul>
<li>این ویژگی برای <strong>logging</strong> و <strong>INotifyPropertyChanged</strong> بسیار مفید است.</li>
<li>مثال استفاده در کلاس با PropertyChanged:</li>
</ul>
<pre><code class="language-csharp">public class Foo : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged = delegate { };

    void RaisePropertyChanged([CallerMemberName] string propertyName = null)
        =&gt; PropertyChanged(this, new PropertyChangedEventArgs(propertyName));

    string customerName;
    public string CustomerName
    {
        get =&gt; customerName;
        set
        {
            if (value == customerName) return;
            customerName = value;
            RaisePropertyChanged();  // تبدیل می‌شود به: RaisePropertyChanged(&quot;CustomerName&quot;);
        }
    }
}
</code></pre>
<hr>
<h3>CallerArgumentExpression (C# 10) ✍️</h3>
<ul>
<li><code>[CallerArgumentExpression]</code> ثبت <strong>عبارت پارامتر</strong> در محل فراخوانی را ممکن می‌کند.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">Print(Math.PI * 2);

void Print(double number,
           [CallerArgumentExpression(&quot;number&quot;)] string expr = null)
    =&gt; Console.WriteLine(expr);
// خروجی: Math.PI * 2
</code></pre>
<ul>
<li>حتی کامنت‌ها هم در رشته قرار می‌گیرند:</li>
</ul>
<pre><code class="language-csharp">Print(Math.PI /*(π)*/ * 2);
// خروجی: Math.PI /*(π)*/ * 2
</code></pre>
<p>کاربرد اصلی: <strong>کتابخانه‌های validation و assertion</strong>:</p>
<pre><code class="language-csharp">Assert(2 + 2 == 5);

void Assert(bool condition,
            [CallerArgumentExpression(&quot;condition&quot;)] string message = null)
{
    if (!condition) throw new Exception(&quot;Assertion failed: &quot; + message);
}
</code></pre>
<ul>
<li>نمونه دیگر: <code>ArgumentNullException.ThrowIfNull</code> در .NET 6:</li>
</ul>
<pre><code class="language-csharp">ArgumentNullException.ThrowIfNull(message);
</code></pre>
<p>⚠️ می‌توان <code>[CallerArgumentExpression]</code> را چند بار استفاده کرد تا چند عبارت پارامتر ثبت شود.</p>
<hr>
<h3>Dynamic Binding 🔄</h3>
<ul>
<li><strong>Dynamic binding</strong> زمان <strong>resolve کردن type، member و operator</strong> را به <strong>runtime</strong> موکول می‌کند.</li>
<li>مفید در interoperating با <strong>dynamic languages</strong> یا <strong>COM</strong> و همچنین زمانی که می‌خواهید از <strong>reflection</strong> استفاده کنید.</li>
</ul>
<pre><code class="language-csharp">dynamic d = GetSomeObject();
d.Quack();  // کامپایلر بررسی نمی‌کند، اجرا در زمان runtime
</code></pre>
<ul>
<li>در dynamic binding، کامپایلر <strong>binding</strong> را به runtime واگذار می‌کند، برخلاف <strong>static binding</strong> که در زمان کامپایل رخ می‌دهد.</li>
</ul>
<h3><strong>Static Binding در مقابل Dynamic Binding ⚡</strong></h3>
<p>در C#، <strong>binding</strong> یعنی اتصال نام یک عضو (مانند متد) به پیاده‌سازی آن.</p>
<hr>
<h4><strong>Static Binding (Binding ایستا) 🏗️</strong></h4>
<ul>
<li>اتصال در <strong>زمان کامپایل</strong> انجام می‌شود.</li>
<li>کامپایلر باید <strong>نوع متغیرها را بداند</strong> تا بتواند متدها یا عملگرها را پیدا کند.</li>
<li>مثال:</li>
</ul>
<pre><code class="language-csharp">Duck d = new Duck();
d.Quack();  // کامپایلر بررسی می‌کند که کلاس Duck متد Quack دارد یا خیر
</code></pre>
<ul>
<li>اگر نوع متغیر <code>object</code> باشد، دسترسی به متد ناموفق خواهد بود:</li>
</ul>
<pre><code class="language-csharp">object d = new Duck();
d.Quack();  // خطای کامپایل
</code></pre>
<hr>
<h4><strong>Dynamic Binding (Binding پویا) 🌀</strong></h4>
<ul>
<li>اتصال در <strong>زمان اجرا (runtime)</strong> انجام می‌شود.</li>
<li>نوع متغیر <code>dynamic</code> است و کامپایلر فرض می‌کند <strong>ممکن است متد وجود داشته باشد</strong>:</li>
</ul>
<pre><code class="language-csharp">dynamic d = new Duck();
d.Quack();  // بررسی و اتصال در زمان اجرا انجام می‌شود
</code></pre>
<ul>
<li>اگر نوع واقعی متغیر متدی نداشته باشد، <strong>RuntimeBinderException</strong> پرتاب می‌شود:</li>
</ul>
<pre><code class="language-csharp">dynamic d = 5;
d.Hello();  // RuntimeBinderException
</code></pre>
<hr>
<h4><strong>انواع Dynamic Binding</strong></h4>
<ol>
<li>
<p><strong>Custom Binding</strong> 🔧</p>
<ul>
<li>زمانی که شیء dynamic، اینترفیس <code>IDynamicMetaObjectProvider</code> را پیاده‌سازی کند.</li>
<li>برای کنترل رفتار متدها در زبان‌های داینامیک مثل IronPython یا IronRuby استفاده می‌شود.</li>
<li>مثال:</li>
</ul>
</li>
</ol>
<pre><code class="language-csharp">using System;
using System.Dynamic;

dynamic d = new Duck();
d.Quack();  // &quot;Quack method was called&quot;
d.Waddle(); // &quot;Waddle method was called&quot;

public class Duck : DynamicObject
{
    public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
    {
        Console.WriteLine(binder.Name + &quot; method was called&quot;);
        result = null;
        return true;
    }
}
</code></pre>
<ol start="2">
<li>
<p><strong>Language Binding</strong> 📚</p>
<ul>
<li>زمانی که شیء dynamic، <code>IDynamicMetaObjectProvider</code> را پیاده‌سازی نکند.</li>
<li>مفید برای دور زدن محدودیت‌های سیستم نوع .NET و اجتناب از کپی کد برای هر نوع داده.</li>
<li>مثال محاسبه میانگین:</li>
</ul>
</li>
</ol>
<pre><code class="language-csharp">int x = 3, y = 4;
Console.WriteLine(Mean(x, y));
dynamic Mean(dynamic a, dynamic b) =&gt; (a + b) / 2;
</code></pre>
<p>⚠️ <strong>نکته:</strong> در dynamic binding، امنیت نوع <strong>compile-time</strong> از بین می‌رود، ولی امنیت نوع <strong>runtime</strong> حفظ می‌شود.</p>
<hr>
<h4><strong>نمایش Runtime شیء dynamic</strong></h4>
<pre><code class="language-csharp">dynamic x = &quot;hello&quot;;
Console.WriteLine(x.GetType().Name);  // String
x = 123;
Console.WriteLine(x.GetType().Name);  // Int32
</code></pre>
<ul>
<li><code>dynamic</code> از نظر ساختاری با <code>object</code> یکسان است، فقط اجازه عملیات داینامیک می‌دهد.</li>
</ul>
<pre><code class="language-csharp">object o = new System.Text.StringBuilder();
dynamic d = o;
d.Append(&quot;hello&quot;);
Console.WriteLine(o);  // hello
</code></pre>
<ul>
<li>در runtime، اعضای dynamic با Attribute مشخص می‌شوند:</li>
</ul>
<pre><code class="language-csharp">public class Test
{
    public dynamic Foo;
}
// معادل با:
public class Test
{
    [System.Runtime.CompilerServices.DynamicAttribute]
    public object Foo;
}
</code></pre>
<hr>
<h4><strong>تبدیل‌های Dynamic 🔄</strong></h4>
<ul>
<li>dynamic قابلیت تبدیل ضمنی با همه نوع‌ها را دارد:</li>
</ul>
<pre><code class="language-csharp">int i = 7;
dynamic d = i;
long j = d;   // بدون نیاز به cast
</code></pre>
<ul>
<li>اگر تبدیل ضمنی ممکن نباشد، <strong>RuntimeBinderException</strong> پرتاب می‌شود:</li>
</ul>
<pre><code class="language-csharp">short k = d;  // RuntimeBinderException
</code></pre>
<hr>
<h4><strong>مقایسه var و dynamic</strong></h4>
<table>
<thead>
<tr>
<th>ویژگی</th>
<th><code>var</code></th>
<th><code>dynamic</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>زمان تعیین نوع</td>
<td>Compile-time</td>
<td>Runtime</td>
</tr>
<tr>
<td>مثال</td>
<td><code>var y = &quot;hello&quot;;</code></td>
<td><code>dynamic x = &quot;hello&quot;;</code></td>
</tr>
<tr>
<td>رفتار انتساب</td>
<td>خطای کامپایل در نوع نادرست</td>
<td>خطای زمان اجرا در نوع نادرست</td>
</tr>
</tbody>
</table>
<p>مثال:</p>
<pre><code class="language-csharp">dynamic x = &quot;hello&quot;;
var y = x;        // y نیز dynamic است
int z = y;        // Runtime error
</code></pre>
<ul>
<li><code>var</code> می‌گوید: &quot;بگذار نوع توسط کامپایلر مشخص شود&quot;</li>
<li><code>dynamic</code> می‌گوید: &quot;بگذار نوع توسط runtime مشخص شود&quot;</li>
</ul>
<h3><strong>Dynamic Expressions در C# 🌀</strong></h3>
<p>در C#، تقریبا همه اعضای یک شیء (fields, properties, methods, events, constructors, indexers, operators و conversions) را می‌توان <strong>به صورت داینامیک</strong> فراخوانی کرد.</p>
<hr>
<h4><strong>نتیجه متدهای void</strong></h4>
<ul>
<li>نمی‌توانید نتیجه یک <strong>عبارت dynamic با نوع بازگشتی void</strong> را مصرف کنید.</li>
<li>تفاوت با static typing: خطا <strong>در زمان اجرا</strong> رخ می‌دهد:</li>
</ul>
<pre><code class="language-csharp">dynamic list = new List&lt;int&gt;();
var result = list.Add(5);  // RuntimeBinderException
</code></pre>
<hr>
<h4><strong>تأثیر cascading dynamic</strong></h4>
<ul>
<li>هر عبارتی که شامل <strong>عملوند dynamic</strong> باشد، معمولا خودش dynamic خواهد بود:</li>
</ul>
<pre><code class="language-csharp">dynamic x = 2;
var y = x * 3;  // نوع static y: dynamic
</code></pre>
<ul>
<li>
<p>استثناها:</p>
<ol>
<li><strong>کست به نوع static</strong>:</li>
</ol>
</li>
</ul>
<pre><code class="language-csharp">dynamic x = 2;
var y = (int)x;  // y از نوع int
</code></pre>
<ol start="2">
<li><strong>صدا زدن constructor</strong> همیشه static است:</li>
</ol>
<pre><code class="language-csharp">dynamic capacity = 10;
var sb = new System.Text.StringBuilder(capacity);  // sb از نوع StringBuilder
</code></pre>
<hr>
<h3><strong>Dynamic Calls بدون Dynamic Receiver</strong></h3>
<ul>
<li>معمول‌ترین حالت، <strong>receiver داینامیک</strong> است:</li>
</ul>
<pre><code class="language-csharp">dynamic x = ...;
x.Foo();  // x receiver است
</code></pre>
<ul>
<li>اما می‌توان <strong>متدهای statically known</strong> را با آرگومان‌های dynamic فراخوانی کرد.</li>
<li>مثال با overload resolution:</li>
</ul>
<pre><code class="language-csharp">class Program
{
    static void Foo(int x) =&gt; Console.WriteLine(&quot;int&quot;);
    static void Foo(string x) =&gt; Console.WriteLine(&quot;string&quot;);

    static void Main()
    {
        dynamic x = 5;
        dynamic y = &quot;watermelon&quot;;
        Foo(x);  // int
        Foo(y);  // string
    }
}
</code></pre>
<ul>
<li>اگر نام متد یا تعداد پارامترها درست نباشد، <strong>خطای کامپایل</strong> دریافت می‌کنیم.</li>
</ul>
<hr>
<h3><strong>استفاده از Static Types در Dynamic Binding</strong></h3>
<ul>
<li>حتی در binding داینامیک، اگر برخی آرگومان‌ها <strong>static type مشخص</strong> داشته باشند، استفاده می‌شود:</li>
</ul>
<pre><code class="language-csharp">class Program
{
    static void Foo(object x, object y) { Console.WriteLine(&quot;oo&quot;); }
    static void Foo(object x, string y) { Console.WriteLine(&quot;os&quot;); }
    static void Foo(string x, object y) { Console.WriteLine(&quot;so&quot;); }
    static void Foo(string x, string y) { Console.WriteLine(&quot;ss&quot;); }

    static void Main()
    {
        object o = &quot;hello&quot;;
        dynamic d = &quot;goodbye&quot;;
        Foo(o, d);  // os
    }
}
</code></pre>
<hr>
<h3><strong>توابع غیرقابل فراخوانی Dynamically ❌</strong></h3>
<ul>
<li>
<p>برخی توابع نمی‌توانند با dynamic فراخوانی شوند:</p>
<ol>
<li><strong>Extension methods</strong> (با syntax extension)</li>
<li><strong>اعضای interface</strong> در صورتی که نیاز به cast به آن interface باشد</li>
<li><strong>Base members که توسط subclass پنهان شده‌اند</strong></li>
</ol>
</li>
<li>
<p>دلیل: dynamic binding فقط به <strong>نام متد و receiver</strong> نیاز دارد، اما در این سه مورد، <strong>نوع اضافی compile-time-only</strong> نیز دخیل است و در runtime موجود نیست.</p>
</li>
</ul>
<hr>
<h4><strong>مثال: فراخوانی عضو Interface با dynamic</strong></h4>
<pre><code class="language-csharp">interface IFoo { void Test(); }
class Foo : IFoo { void IFoo.Test() {} }

IFoo f = new Foo();
dynamic d = f;
d.Test();  // Runtime exception
</code></pre>
<ul>
<li>cast به interface در زمان کامپایل مشخص می‌کند که binding باید روی IFoo انجام شود، اما در runtime این اطلاعات از دست می‌رود.</li>
</ul>
<hr>
<h4><strong>راهکار: کتابخانه Uncapsulator ⚡</strong></h4>
<ul>
<li>کتابخانه open-source برای <strong>dynamic بهتر</strong>، حل مشکل فراخوانی اعضای interface، base types و static members به صورت داینامیک.</li>
<li>مثال:</li>
</ul>
<pre><code class="language-csharp">IFoo f = new Foo();
dynamic uf = f.Uncapsulate();
uf.Test();  // حالا کار می‌کند
</code></pre>
<ul>
<li>
<p>قابلیت‌های Uncapsulator:</p>
<ul>
<li>Cast به base types و interfaces</li>
<li>فراخوانی static members به صورت داینامیک</li>
<li>دسترسی به اعضای غیر عمومی (nonpublic members)</li>
</ul>
</li>
</ul>
<h3>بارگذاری مجدد عملگرها (Operator Overloading) ⚙️</h3>
<p>شما می‌توانید عملگرها را بارگذاری مجدد کنید تا نحو (syntax) طبیعی‌تری برای نوع‌های سفارشی فراهم شود. بارگذاری مجدد عملگرها بیشتر برای پیاده‌سازی <code>struct</code>های سفارشی که نمایانگر نوع‌های داده‌ای نسبتاً ابتدایی هستند، مناسب است. به‌عنوان مثال، یک نوع عددی سفارشی گزینه‌ی بسیار مناسبی برای بارگذاری مجدد عملگرها است.</p>
<p>عملگرهای نمادین زیر قابل بارگذاری مجدد هستند:</p>
<pre><code>+ (unary) - (unary) ! ˜ ++ --
+ % &gt;&gt;
&gt;= &amp; == &lt;= * / | ^ &lt;&lt; != &gt; &lt; 
</code></pre>
<p>عملگرهای زیر نیز قابل بارگذاری مجدد هستند:</p>
<ul>
<li>تبدیل‌های ضمنی و صریح (با کلمات کلیدی <code>implicit</code> و <code>explicit</code>)</li>
<li>عملگرهای <code>true</code> و <code>false</code> (نه مقادیر ثابت)</li>
</ul>
<p>عملگرهای زیر به‌صورت غیرمستقیم بارگذاری می‌شوند:</p>
<ul>
<li>عملگرهای ترکیبی (<code>+=, /=</code> و غیره) به‌طور ضمنی با بازنویسی عملگرهای غیرترکیبی (<code>+, /</code>) بازنویسی می‌شوند.</li>
<li>عملگرهای شرطی <code>&amp;&amp;</code> و <code>||</code> به‌طور ضمنی با بازنویسی عملگرهای بیتی <code>&amp;</code> و <code>|</code> بازنویسی می‌شوند.</li>
</ul>
<hr>
<h3>توابع عملگر (Operator Functions) 🛠️</h3>
<p>برای بارگذاری یک عملگر، باید یک <strong>تابع عملگر</strong> تعریف کنید. قوانین توابع عملگر به شرح زیر است:</p>
<ul>
<li>نام تابع با کلمه کلیدی <code>operator</code> و سپس نماد عملگر مشخص می‌شود.</li>
<li>تابع عملگر باید <code>static</code> و <code>public</code> باشد.</li>
<li>پارامترهای تابع عملگر نشان‌دهنده‌ی عملوندها هستند.</li>
<li>نوع بازگشتی تابع عملگر نشان‌دهنده‌ی نتیجه‌ی یک عبارت است.</li>
<li>حداقل یکی از عملوندها باید از نوعی باشد که تابع عملگر در آن تعریف شده است.</li>
</ul>
<p>مثال زیر یک <code>struct</code> به نام <code>Note</code> تعریف می‌کند که نمایانگر یک نت موسیقی است و سپس عملگر <code>+</code> را بارگذاری می‌کند:</p>
<pre><code class="language-csharp">public struct Note
{
    int value;
    public Note (int semitonesFromA) { value = semitonesFromA; }

    public static Note operator + (Note x, int semitones)
    {
        return new Note (x.value + semitones);
    }
}
</code></pre>
<p>این بارگذاری به ما اجازه می‌دهد یک <code>int</code> را به یک <code>Note</code> اضافه کنیم:</p>
<pre><code class="language-csharp">Note B = new Note (2);
Note CSharp = B + 2;
</code></pre>
<p>بارگذاری یک عملگر، به‌طور خودکار عملگر ترکیبی متناظر را نیز بارگذاری می‌کند. در مثال ما، چون <code>+</code> را بازنویسی کردیم، می‌توانیم از <code>+=</code> هم استفاده کنیم:</p>
<pre><code class="language-csharp">CSharp += 2;
</code></pre>
<p>همانند متدها و پراپرتی‌ها، C# اجازه می‌دهد توابع عملگر که شامل یک عبارت هستند با <strong>نحو بدنه-عبارتی (expression-bodied syntax)</strong> کوتاه‌تر نوشته شوند:</p>
<pre><code class="language-csharp">public static Note operator + (Note x, int semitones)
    =&gt; new Note (x.value + semitones);
</code></pre>
<hr>
<h3>عملگرهای Checked ✔️</h3>
<p>از C# 11 به بعد، هنگام تعریف تابع عملگر، می‌توان نسخه‌ی <code>checked</code> آن را نیز تعریف کرد:</p>
<pre><code class="language-csharp">public static Note operator + (Note x, int semitones)
    =&gt; new Note (x.value + semitones);

public static Note operator checked + (Note x, int semitones)
    =&gt; checked (new Note (x.value + semitones));
</code></pre>
<p>نسخه‌ی <code>checked</code> داخل عبارت‌ها یا بلوک‌های <code>checked</code> فراخوانی می‌شود:</p>
<pre><code class="language-csharp">Note B = new Note (2);
Note other = checked (B + int.MaxValue);  // پرتاب OverflowException
</code></pre>
<hr>
<h3>بارگذاری عملگرهای برابری و مقایسه ⚖️</h3>
<p>عملگرهای برابری و مقایسه گاهی هنگام نوشتن <code>struct</code>ها و در موارد نادر هنگام نوشتن کلاس‌ها بازنویسی می‌شوند. قوانین و الزامات خاصی برای بارگذاری این عملگرها وجود دارد که در فصل ۶ توضیح داده شده است. خلاصه این قوانین:</p>
<p><strong>جفت‌بندی (Pairing)</strong>
کامپایلر C# اطمینان می‌دهد که عملگرهای منطقی جفت شده، هر دو تعریف شده باشند: <code>(== !=), (&lt; &gt;), (&lt;= &gt;=)</code></p>
<p><strong>Equals و GetHashCode</strong>
در بیشتر موارد، اگر <code>==</code> و <code>!=</code> را بارگذاری می‌کنید، باید متدهای <code>Equals</code> و <code>GetHashCode</code> تعریف شده در <code>object</code> را بازنویسی کنید تا رفتار معناداری داشته باشید. اگر این کار را نکنید، کامپایلر هشدار می‌دهد.</p>
<p><strong>IComparable و IComparable<T></strong>
اگر <code>&lt; &gt;</code> و <code>&lt;= &gt;=</code> را بارگذاری می‌کنید، بهتر است <code>IComparable</code> و <code>IComparable&lt;T&gt;</code> را پیاده‌سازی کنید.</p>
<hr>
<h3>تبدیل‌های ضمنی و صریح سفارشی 🔄</h3>
<p>تبدیل‌های ضمنی و صریح نیز عملگرهای قابل بارگذاری هستند. این تبدیل‌ها معمولاً برای ساده و طبیعی کردن تبدیل بین نوع‌های مرتبط (مثلاً نوع‌های عددی) استفاده می‌شوند.</p>
<p>برای تبدیل بین نوع‌های کمتر مرتبط، روش‌های زیر مناسب‌تر هستند:</p>
<ul>
<li>نوشتن یک سازنده که پارامتر آن از نوع مبدأ باشد.</li>
<li>نوشتن متدهای <code>ToXXX</code> و (static) <code>FromXXX</code> برای تبدیل بین نوع‌ها.</li>
</ul>
<p>همان‌طور که در بحث نوع‌ها توضیح داده شد، دلیل اصلی تبدیل‌های ضمنی این است که تضمین می‌کنند عملیات موفقیت‌آمیز باشد و اطلاعات از دست نرود. در مقابل، تبدیل صریح زمانی لازم است که شرایط زمان اجرا مشخص کند آیا تبدیل موفق است یا اطلاعات ممکن است از دست برود.</p>
<p>مثال زیر تبدیل بین نوع موسیقی <code>Note</code> و <code>double</code> (نمایش فرکانس بر حسب هرتز) را نشان می‌دهد:</p>
<pre><code class="language-csharp">// تبدیل به هرتز
public static implicit operator double (Note x)
    =&gt; 440 * Math.Pow(2, (double)x.value / 12);

// تبدیل از هرتز (دقیق تا نزدیک‌ترین نیم‌پرده)
public static explicit operator Note (double x)
    =&gt; new Note((int)(0.5 + 12 * (Math.Log(x/440) / Math.Log(2))));
</code></pre>
<pre><code class="language-csharp">Note n = (Note)554.37;  // تبدیل صریح
double x = n;           // تبدیل ضمنی
</code></pre>
<p>با توجه به راهنمایی‌های خود، این مثال ممکن است بهتر باشد با متد <code>ToFrequency</code> و متد استاتیک <code>FromFrequency</code> پیاده‌سازی شود، به جای استفاده از عملگرهای ضمنی و صریح.</p>
<p>تبدیل‌های سفارشی توسط عملگرهای <code>as</code> و <code>is</code> نادیده گرفته می‌شوند:</p>
<pre><code class="language-csharp">Console.WriteLine(554.37 is Note);   // False
Note n = 554.37 as Note;             // خطا
</code></pre>
<h3>بارگذاری مجدد عملگرهای true و false ✅</h3>
<p>عملگرهای <code>true</code> و <code>false</code> به ندرت در نوع‌هایی بارگذاری می‌شوند که به لحاظ «روحی» بولی هستند ولی تبدیل به <code>bool</code> ندارند. نمونه‌ی آن نوعی است که منطق سه‌حالته (three-state logic) را پیاده‌سازی می‌کند. با بارگذاری این عملگرها، این نوع می‌تواند به‌طور یکپارچه با دستورات شرطی و عملگرها کار کند؛ مانند: <code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>&amp;&amp;</code>, <code>||</code> و <code>?:</code>.</p>
<p>ساختار <code>System.Data.SqlTypes.SqlBoolean</code> این قابلیت را ارائه می‌دهد:</p>
<pre><code class="language-csharp">SqlBoolean a = SqlBoolean.Null;
if (a)
    Console.WriteLine(&quot;True&quot;);
else if (!a)
    Console.WriteLine(&quot;False&quot;);
else
    Console.WriteLine(&quot;Null&quot;);
</code></pre>
<p>خروجی:</p>
<pre><code>Null
</code></pre>
<p>کد زیر بازپیاده‌سازی بخش‌های مورد نیاز <code>SqlBoolean</code> برای نشان دادن عملگرهای <code>true</code> و <code>false</code> است:</p>
<pre><code class="language-csharp">public struct SqlBoolean
{
    public static bool operator true(SqlBoolean x)
        =&gt; x.m_value == True.m_value;
    public static bool operator false(SqlBoolean x)
        =&gt; x.m_value == False.m_value;

    public static SqlBoolean operator !(SqlBoolean x)
    {
        if (x.m_value == Null.m_value) return Null;
        if (x.m_value == False.m_value) return True;
        return False;
    }

    public static readonly SqlBoolean Null = new SqlBoolean(0);
    public static readonly SqlBoolean False = new SqlBoolean(1);
    public static readonly SqlBoolean True = new SqlBoolean(2);

    private SqlBoolean(byte value) { m_value = value; }
    private byte m_value;
}
</code></pre>
<hr>
<h3>چندریختی ایستا (Static Polymorphism) 🌀</h3>
<p>در بخش «Calling Static Virtual/Abstract Interface Members» صفحه ۸۲۶، ویژگی پیشرفته‌ای معرفی شد که در آن یک رابط (interface) می‌تواند اعضای <code>static virtual</code> یا <code>static abstract</code> تعریف کند که توسط کلاس‌ها و <code>struct</code>ها به‌صورت اعضای ایستا پیاده‌سازی می‌شوند.</p>
<p>سپس در بخش «Generic Constraints» صفحه ۱۶۳ نشان داده شد که اعمال محدودیت رابط روی پارامتر نوع، امکان دسترسی متد به اعضای آن رابط را فراهم می‌کند. در این بخش، نشان خواهیم داد که چگونه این قابلیت چندریختی ایستا را ممکن می‌سازد و ویژگی‌هایی مانند ریاضیات عمومی (generic math) را فعال می‌کند.</p>
<p>برای نمونه، رابط زیر یک متد ایستا تعریف می‌کند که یک نمونه تصادفی از نوع <code>T</code> ایجاد می‌کند:</p>
<pre><code class="language-csharp">interface ICreateRandom&lt;T&gt;
{
    static abstract T CreateRandom();  // ایجاد یک نمونه تصادفی از T
}
</code></pre>
<p>فرض کنید می‌خواهیم این رابط را در رکورد زیر پیاده‌سازی کنیم:</p>
<pre><code class="language-csharp">record Point(int X, int Y);
</code></pre>
<p>با کمک کلاس <code>System.Random</code> (که متد <code>Next</code> آن یک عدد صحیح تصادفی تولید می‌کند)، می‌توانیم متد ایستا <code>CreateRandom</code> را به این صورت پیاده‌سازی کنیم:</p>
<pre><code class="language-csharp">record Point(int X, int Y) : ICreateRandom&lt;Point&gt;
{
    static Random rnd = new();
    public static Point CreateRandom() =&gt; new Point(rnd.Next(), rnd.Next());
}
</code></pre>
<p>برای فراخوانی این متد از طریق رابط، از پارامتر نوع محدود شده استفاده می‌کنیم. متد زیر یک آرایه داده‌ی تست با این روش ایجاد می‌کند:</p>
<pre><code class="language-csharp">T[] CreateTestData&lt;T&gt;(int count) where T : ICreateRandom&lt;T&gt;
{
    T[] result = new T[count];
    for (int i = 0; i &lt; count; i++)
        result[i] = T.CreateRandom();
    return result;
}
</code></pre>
<p>مثال استفاده:</p>
<pre><code class="language-csharp">Point[] testData = CreateTestData&lt;Point&gt;(50);  // ایجاد ۵۰ نقطه تصادفی
</code></pre>
<p>فراخوانی متد ایستا <code>CreateRandom</code> در <code>CreateTestData</code> چندریختی است، زیرا نه‌تنها با <code>Point</code> بلکه با هر نوعی که <code>ICreateRandom&lt;T&gt;</code> را پیاده‌سازی کرده باشد، کار می‌کند. این با چندریختی نمونه‌ای متفاوت است، زیرا برای فراخوانی <code>CreateRandom</code> نیاز به نمونه‌ای از <code>ICreateRandom&lt;T&gt;</code> نداریم؛ بلکه آن را روی نوع خود فراخوانی می‌کنیم.</p>
<hr>
<h3>عملگرهای چندریختی (Polymorphic Operators) ⚡</h3>
<p>از آنجا که عملگرها اساساً توابع ایستا هستند (صفحه ۲۵۶)، می‌توان آن‌ها را نیز به‌عنوان اعضای ایستا، مجازی یا رابط تعریف کرد:</p>
<pre><code class="language-csharp">interface IAddable&lt;T&gt; where T : IAddable&lt;T&gt;
{
    abstract static T operator + (T left, T right);
}
</code></pre>
<p>محدودیت نوع خودارجاعی (self-referencing type constraint) در این تعریف رابط برای رعایت قوانین کامپایلر در بارگذاری عملگر ضروری است. به خاطر بیاورید که هنگام تعریف تابع عملگر، حداقل یکی از عملوندها باید از نوعی باشد که تابع در آن تعریف شده است. در این مثال، عملوندها از نوع <code>T</code> هستند، در حالی که نوع شامل <code>IAddable&lt;T&gt;</code> است، بنابراین نیاز به محدودیت نوع خودارجاع داریم تا <code>T</code> بتواند به‌عنوان <code>IAddable&lt;T&gt;</code> در نظر گرفته شود.</p>
<p>پیاده‌سازی رابط به این صورت است:</p>
<pre><code class="language-csharp">record Point(int X, int Y) : IAddable&lt;Point&gt;
{
    public static Point operator + (Point left, Point right) =&gt;
        new Point(left.X + right.X, left.Y + right.Y);
}
</code></pre>
<p>با پارامتر نوع محدود شده، می‌توانیم متدی بنویسیم که عملگر جمع را به‌صورت چندریختی فراخوانی کند:</p>
<pre><code class="language-csharp">T Sum&lt;T&gt;(params T[] values) where T : IAddable&lt;T&gt;
{
    T total = values[0];
    for (int i = 1; i &lt; values.Length; i++)
        total += values[i];
    return total;
}
</code></pre>
<p>فراخوانی عملگر <code>+</code> (از طریق <code>+=</code>) چندریختی است، زیرا به <code>IAddable&lt;T&gt;</code> متصل می‌شود، نه <code>Point</code>. بنابراین متد <code>Sum</code> با تمام نوع‌هایی که <code>IAddable&lt;T&gt;</code> را پیاده‌سازی کرده‌اند کار می‌کند.</p>
<p>البته، رابطی مانند <code>IAddable&lt;T&gt;</code> زمانی مفیدتر است که در runtime دات‌نت تعریف شود و همه نوع‌های عددی .NET آن را پیاده‌سازی کنند. خوشبختانه از .NET 7، فضای نام <code>System.Numerics</code> نسخه‌ای پیشرفته‌تر از <code>IAddable</code> را همراه با سایر رابط‌های ریاضی ارائه می‌دهد—که بیشتر آن‌ها تحت پوشش <code>INumber&lt;TSelf&gt;</code> هستند.</p>
<h3>ریاضیات عمومی (Generic Math) ➕</h3>
<p>قبل از .NET 7، کدی که عملیات حسابی انجام می‌داد، باید برای یک نوع عددی مشخص نوشته می‌شد:</p>
<pre><code class="language-csharp">int Sum(params int[] numbers)   // فقط با int کار می‌کند
{
    // با double، decimal و غیره کار نمی‌کند
    int total = 0;
    foreach (int n in numbers)
        total += n;
    return total;
}
</code></pre>
<p>در .NET 7، رابط <code>INumber&lt;TSelf&gt;</code> معرفی شد تا عملیات حسابی را در تمامی نوع‌های عددی یکپارچه کند. این یعنی حالا می‌توان نسخه‌ی عمومی (generic) متد بالا را نوشت:</p>
<pre><code class="language-csharp">T Sum&lt;T&gt;(params T[] numbers) where T : INumber&lt;T&gt;
{
    T total = T.Zero;
    foreach (T n in numbers)
        total += n;  // عملگر جمع برای هر نوع عددی فراخوانی می‌شود
    return total;
}

int intSum = Sum(3, 5, 7);
double doubleSum = Sum(3.2, 5.3, 7.1);
decimal decimalSum = Sum(3.2m, 5.3m, 7.1m);
</code></pre>
<p>تمام نوع‌های عددی صحیح و اعشاری در .NET (و همچنین <code>char</code>) رابط <code>INumber&lt;TSelf&gt;</code> را پیاده‌سازی می‌کنند. این رابط را می‌توان به‌عنوان یک رابط کلی (umbrella interface) تصور کرد که شامل رابط‌های جزئی‌تر برای هر نوع عملیات حسابی (جمع، تفریق، ضرب، تقسیم، باقی‌مانده، مقایسه و غیره) و همچنین رابط‌هایی برای پارسینگ و قالب‌بندی است.</p>
<p>مثالی از چنین رابطی:</p>
<pre><code class="language-csharp">public interface IAdditionOperators&lt;TSelf, TOther, TResult&gt;
    where TSelf : IAdditionOperators&lt;TSelf, TOther, TResult&gt;?
{
    static abstract TResult operator + (TSelf left, TOther right);
    public static virtual TResult operator checked + 
        (TSelf left, TOther right) =&gt; left + right;  // فراخوانی عملگر بالا
}
</code></pre>
<p>عملگر ایستا و انتزاعی <code>+</code> همان چیزی است که باعث می‌شود عملگر <code>+=</code> داخل متد <code>Sum</code> کار کند. همچنین توجه کنید که استفاده از <code>static virtual</code> روی عملگر <code>checked</code>، رفتار پیش‌فرض برای پیاده‌سازانی که نسخه‌ی <code>checked</code> عملگر جمع را ارائه نمی‌کنند، فراهم می‌کند.</p>
<p>فضای نام <code>System.Numerics</code> همچنین شامل رابط‌هایی است که بخشی از <code>INumber</code> نیستند و مخصوص عملیات نوع‌های خاصی از اعداد (مثل اعداد اعشاری) هستند.</p>
<p>به‌عنوان مثال، برای محاسبه‌ی <strong>میانگین مربعات (Root Mean Square)</strong> می‌توانیم رابط <code>IRootFunctions&lt;T&gt;</code> را به فهرست محدودیت‌ها اضافه کنیم تا متد ایستا <code>RootN</code> آن برای <code>T</code> در دسترس باشد:</p>
<pre><code class="language-csharp">T RMS&lt;T&gt;(params T[] values) where T : INumber&lt;T&gt;, IRootFunctions&lt;T&gt;
{
    T total = T.Zero;
    for (int i = 0; i &lt; values.Length; i++)
        total += values[i] * values[i];

    // استفاده از T.CreateChecked برای تبدیل values.Length (نوع int) به T
    T count = T.CreateChecked(values.Length);
    return T.RootN(total / count, 2);  // محاسبه ریشه دوم (مربع)
}
</code></pre>
<hr>
<h3>کد ناایمن و اشاره‌گرها (Unsafe Code and Pointers) ⚠️</h3>
<p>C# امکان دسترسی مستقیم به حافظه را از طریق اشاره‌گرها در بلوک‌های کد <code>unsafe</code> فراهم می‌کند. نوع‌های اشاره‌گر برای تعامل با APIهای بومی (native)، دسترسی به حافظه خارج از heap مدیریت‌شده، و پیاده‌سازی بهینه‌سازی‌های کوچک در نقاط حساس عملکرد مفید هستند.</p>
<p>پروژه‌هایی که شامل کد ناایمن هستند، باید در فایل پروژه <code>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</code> را مشخص کنند.</p>
<h4>اصول اولیه اشاره‌گرها (Pointer Basics)</h4>
<p>برای هر نوع مقدار یا مرجع <code>V</code>، نوع اشاره‌گر متناظر <code>V*</code> وجود دارد. یک نمونه از اشاره‌گر آدرس یک متغیر را نگه می‌دارد. نوع‌های اشاره‌گر می‌توانند به صورت ناایمن به هر نوع اشاره‌گر دیگری تبدیل (cast) شوند.</p>
<p>عملگرهای اصلی اشاره‌گر عبارت‌اند از:</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>کد ناایمن و اشاره‌گرها (ادامه) ⚡</h3>
<p>همانند زبان C، اضافه کردن (یا کم کردن) یک آفست عدد صحیح به یک اشاره‌گر، یک اشاره‌گر دیگر تولید می‌کند. کم کردن یک اشاره‌گر از دیگری یک عدد صحیح ۶۴ بیتی تولید می‌کند (در هر دو پلتفرم ۳۲ و ۶۴ بیتی).</p>
<hr>
<h3>کد ناایمن (Unsafe Code) 🛡️</h3>
<p>با علامت‌گذاری یک نوع، عضو نوع، یا بلوک دستوری با کلیدواژه <code>unsafe</code>، اجازه دارید از نوع‌های اشاره‌گر استفاده کنید و عملیات اشاره‌گر به سبک C روی حافظه انجام دهید. مثال زیر استفاده از اشاره‌گرها برای پردازش سریع یک بیت‌مپ را نشان می‌دهد:</p>
<pre><code class="language-csharp">unsafe void BlueFilter(int[,] bitmap)
{
    int length = bitmap.Length;
    fixed (int* b = bitmap)
    {
        int* p = b;
        for (int i = 0; i &lt; length; i++)
            *p++ &amp;= 0xFF;
    }
}
</code></pre>
<p>کد ناایمن می‌تواند سریع‌تر از پیاده‌سازی امن مشابه اجرا شود. در این مثال، نسخه امن نیاز به حلقه‌ی تو در تو با اندیس‌دهی آرایه و بررسی حدود داشت. همچنین، متد ناایمن C# می‌تواند سریع‌تر از فراخوانی یک تابع C خارجی باشد، چون سربار ترک محیط اجرای مدیریت‌شده وجود ندارد.</p>
<hr>
<h3>دستور fixed 📌</h3>
<p>دستور <code>fixed</code> برای <strong>سنجاق کردن (pin)</strong> یک شی مدیریت‌شده مانند بیت‌مپ استفاده می‌شود. در طول اجرای برنامه، بسیاری از اشیا از heap تخصیص و آزاد می‌شوند. برای جلوگیری از هدررفت یا تکه‌تکه شدن حافظه، جمع‌آورنده زباله (GC) اشیا را جابه‌جا می‌کند. اگر آدرس یک شی تغییر کند، اشاره به آن بی‌فایده است، بنابراین <code>fixed</code> به GC می‌گوید شی را جابه‌جا نکند. استفاده بیش از حد از بلوک‌های <code>fixed</code> می‌تواند روی کارایی زمان اجرا تاثیر بگذارد، بنابراین بهتر است از آن‌ها کوتاه استفاده کنید و از تخصیص حافظه درون بلوک <code>fixed</code> خودداری کنید.</p>
<p>درون دستور <code>fixed</code>، می‌توانید یک اشاره‌گر به هر نوع مقدار، آرایه‌ای از نوع‌های مقدار، یا رشته دریافت کنید. در مورد آرایه‌ها و رشته‌ها، اشاره‌گر در واقع به اولین عنصر اشاره می‌کند که از نوع مقدار است.</p>
<p>نمونه‌ای از سنجاق کردن نوع مقدار داخل نوع مرجع:</p>
<pre><code class="language-csharp">Test test = new Test();
unsafe
{
    fixed (int* p = &amp;test.X)   // سنجاق کردن test
    {
        *p = 9;
    }
}
Console.WriteLine(test.X);

class Test { public int X; }
</code></pre>
<p>توضیحات بیشتر درباره‌ی <code>fixed</code> در بخش «Mapping a Struct to Unmanaged Memory» صفحه ۹۹۷ آمده است.</p>
<hr>
<h3>عملگر اشاره‌گر به عضو (Pointer-to-Member Operator) 🔗</h3>
<p>علاوه بر عملگرهای <code>&amp;</code> و <code>*</code>، C# عملگر سبک C++ یعنی <code>-&gt;</code> را نیز ارائه می‌دهد که می‌توان از آن روی <code>struct</code>ها استفاده کرد:</p>
<pre><code class="language-csharp">Test test = new Test();
unsafe
{
    Test* p = &amp;test;
    p-&gt;X = 9;
    System.Console.WriteLine(test.X);
}
struct Test { public int X; }
</code></pre>
<hr>
<h3>کلیدواژه stackalloc 📚</h3>
<p>با استفاده از <code>stackalloc</code> می‌توانید حافظه‌ای را به‌طور مستقیم در <strong>استک</strong> اختصاص دهید. چون روی استک تخصیص می‌یابد، طول عمر آن محدود به اجرای متد است، همانند متغیرهای محلی دیگر که توسط lambda، iterator یا متد async افزایش طول عمر نیافته‌اند. بلوک می‌تواند از عملگر <code>[]</code> برای دسترسی به حافظه استفاده کند:</p>
<pre><code class="language-csharp">int* a = stackalloc int[10];
for (int i = 0; i &lt; 10; ++i)
    Console.WriteLine(a[i]);
</code></pre>
<p>در فصل ۲۳، نشان داده می‌شود چگونه می‌توان با <code>Span&lt;T&gt;</code> حافظه اختصاص‌یافته روی استک را بدون استفاده از <code>unsafe</code> مدیریت کرد:</p>
<pre><code class="language-csharp">Span&lt;int&gt; a = stackalloc int[10];
for (int i = 0; i &lt; 10; ++i)
    Console.WriteLine(a[i]);
</code></pre>
<hr>
<h3>بافرهای با اندازه ثابت (Fixed-Size Buffers) 🧱</h3>
<p>کلیدواژه <code>fixed</code> کاربرد دیگری نیز دارد: ایجاد بافرهای با اندازه ثابت درون <code>struct</code>ها (مفید برای فراخوانی توابع unmanaged؛ فصل ۲۴).</p>
<pre><code class="language-csharp">unsafe struct UnsafeUnicodeString
{
    public short Length;
    public fixed byte Buffer[30];   // تخصیص ۳۰ بایت
}

unsafe class UnsafeClass
{
    UnsafeUnicodeString uus;

    public UnsafeClass(string s)
    {
        uus.Length = (short)s.Length;
        fixed (byte* p = uus.Buffer)
            for (int i = 0; i &lt; s.Length; i++)
                p[i] = (byte)s[i];
    }
}

new UnsafeClass(&quot;Christian Troy&quot;);
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>بافرهای با اندازه ثابت آرایه نیستند؛ اگر <code>Buffer</code> آرایه بود، شامل مرجعی به شیء روی heap مدیریت‌شده می‌شد، نه ۳۰ بایت داخل خود <code>struct</code>.</li>
<li>کلیدواژه <code>fixed</code> در این مثال همچنین شیء روی heap (نمونه <code>UnsafeClass</code>) را سنجاق می‌کند. بنابراین <code>fixed</code> دو معنا دارد: <strong>ثابت در اندازه</strong> و <strong>ثابت در مکان</strong>. اغلب با هم استفاده می‌شوند، زیرا یک بافر با اندازه ثابت باید در مکان ثابت باشد تا قابل استفاده باشد.</li>
</ul>
<h3>اشاره‌گر void (<code>void*</code>) 🔹</h3>
<p>یک <strong>اشاره‌گر void</strong> (<code>void*</code>) هیچ فرضی درباره نوع داده پایه ندارد و برای توابعی که با حافظه خام کار می‌کنند مفید است. تبدیل ضمنی از هر نوع اشاره‌گر به <code>void*</code> وجود دارد.</p>
<p>نکات مهم:</p>
<ul>
<li>یک <code>void*</code> قابل <strong>دسترسی مستقیم (dereference)</strong> نیست.</li>
<li>عملیات حسابی روی اشاره‌گرهای void امکان‌پذیر نیست.</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">short[] a = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 };
unsafe
{
    fixed (short* p = a)
    {
        // sizeof اندازه نوع مقدار را برحسب بایت برمی‌گرداند
        Zap(p, a.Length * sizeof(short));
    }
}

foreach (short x in a)
    Console.WriteLine(x);   // همه مقادیر صفر چاپ می‌شوند

unsafe void Zap(void* memory, int byteCount)
{
    byte* b = (byte*)memory;
    for (int i = 0; i &lt; byteCount; i++)
        *b++ = 0;
}
</code></pre>
<hr>
<h3>اعداد با اندازه بومی (Native-Sized Integers) 🧮</h3>
<p>نوع‌های <code>nint</code> و <code>nuint</code> (معرفی شده در C# 9) اندازه‌ای مطابق فضای آدرس پردازش در زمان اجرا دارند (در عمل، ۳۲ یا ۶۴ بیت). این نوع‌ها مانند اعداد استاندارد رفتار می‌کنند و از عملیات حسابی و بررسی سرریز (overflow) پشتیبانی کامل دارند:</p>
<pre><code class="language-csharp">nint x = 123, y = 234;
checked
{
    nint sum = x + y, product = x * y;
    Console.WriteLine(product);
}
</code></pre>
<p>ویژگی‌ها:</p>
<ul>
<li>می‌توان به آن‌ها مقادیر صحیح ۳۲ بیتی داد، اما نه ۶۴ بیتی (ممکن است در زمان اجرا سرریز رخ دهد).</li>
<li>تبدیل به یا از دیگر نوع‌های عدد صحیح با cast صریح امکان‌پذیر است.</li>
<li>می‌توان از آن‌ها برای نمایش آدرس حافظه یا آفست بدون استفاده از اشاره‌گر استفاده کرد.</li>
<li><code>nuint</code> برای نمایش طول یک بلاک حافظه مناسب است.</li>
</ul>
<p>مثال برای بهبود کارایی هنگام کار با اشاره‌گرها:</p>
<pre><code class="language-csharp">unsafe nint AddressDif(char* x, char* y) =&gt; (nint)x - (nint)y;
</code></pre>
<p>یک مثال واقعی از کاربرد <code>nint</code> و <code>nuint</code> در کنار اشاره‌گرها، پیاده‌سازی <code>Buffer.MemoryCopy</code> است.</p>
<hr>
<h3>رفتار زمان اجرا در .NET 7+ ⚙️</h3>
<p>در پروژه‌هایی که هدف آن‌ها .NET 7 یا بالاتر است، <code>nint</code> و <code>nuint</code> معادل <code>System.IntPtr</code> و <code>System.UIntPtr</code> عمل می‌کنند، مشابه اینکه <code>int</code> معادل <code>System.Int32</code> است.</p>
<ul>
<li><code>IntPtr</code> و <code>UIntPtr</code> از .NET 7 به بعد قابلیت انجام عملیات حسابی و بررسی سرریز با کامپایلر C# را دارند.</li>
<li>اضافه شدن قابلیت حسابی checked به IntPtr/UIntPtr یک تغییر فنی شکستن سازگاری محسوب می‌شود، اما اثر آن محدود است و فقط در صورتی که پروژه دوباره با هدف .NET 7+ کامپایل شود، ممکن است رخ دهد.</li>
</ul>
<hr>
<h3>رفتار زمان اجرا در .NET 6 یا پایین‌تر ⚡</h3>
<p>در پروژه‌هایی که هدف آن‌ها .NET 6 یا پایین‌تر است، <code>nint</code> و <code>nuint</code> هنوز از <code>IntPtr</code> و <code>UIntPtr</code> استفاده می‌کنند.</p>
<ul>
<li>چون نوع‌های قدیمی <code>IntPtr</code> و <code>UIntPtr</code> اکثر عملیات حسابی را پشتیبانی نمی‌کنند، کامپایلر خلاها را پر می‌کند تا رفتار <code>nint</code>/<code>nuint</code> مشابه .NET 7+ شود.</li>
<li>می‌توان تصور کرد که یک متغیر <code>nint</code>/<code>nuint</code> مانند <code>IntPtr</code>/<code>UIntPtr</code> با یک «کلاه ویژه» است که کامپایلر آن را به‌عنوان یک IntPtr/UIntPtr مدرن می‌شناسد.</li>
<li>این کلاه در صورت تبدیل به IntPtr/UIntPtr از بین می‌رود:</li>
</ul>
<pre><code class="language-csharp">nint x = 123;
Console.WriteLine(x * x);   // درست: ضرب پشتیبانی می‌شود
IntPtr y = x;
Console.WriteLine(y * y);   // خطای کامپایل: عملگر * پشتیبانی نمی‌شود
</code></pre>
<hr>
<h3>اشاره‌گرهای تابع (Function Pointers) 🔗</h3>
<p>یک <strong>اشاره‌گر تابع</strong> (معرفی در C# 9) مانند delegate است اما بدون واسطه نمونه delegate؛ مستقیماً به آدرس یک متد اشاره می‌کند.</p>
<p>ویژگی‌ها:</p>
<ul>
<li>فقط به متدهای ایستا (static) اشاره می‌کند.</li>
<li>قابلیت multicast ندارد.</li>
<li>نیازمند زمینه <code>unsafe</code> است (زیرا از بررسی نوع زمان اجرا عبور می‌کند).</li>
<li>هدف اصلی: ساده‌سازی و بهینه‌سازی تعامل با APIهای unmanaged.</li>
</ul>
<p>تعریف نوع اشاره‌گر تابع:</p>
<pre><code class="language-csharp">delegate*&lt;int, char, string, void&gt;   // void نوع بازگشتی است
</code></pre>
<p>مطابق تابع زیر:</p>
<pre><code class="language-csharp">void SomeFunction(int x, char y, string z)
</code></pre>
<p>عملگر <code>&amp;</code> یک اشاره‌گر تابع از گروه متد ایجاد می‌کند. مثال کامل:</p>
<pre><code class="language-csharp">unsafe
{
    delegate*&lt;string, int&gt; functionPointer = &amp;GetLength;
    int length = functionPointer(&quot;Hello, world&quot;);
    static int GetLength(string s) =&gt; s.Length;
}
</code></pre>
<p>نکات مهم:</p>
<ul>
<li><code>functionPointer</code> یک شیء نیست که بتوان روی آن <code>Invoke</code> فراخوانی کرد.</li>
<li>مستقیماً به آدرس حافظه متد هدف اشاره می‌کند:</li>
</ul>
<pre><code class="language-csharp">Console.WriteLine((IntPtr)functionPointer);
</code></pre>
<ul>
<li>مانند هر اشاره‌گر دیگری، بررسی نوع زمان اجرا ندارد.</li>
<li>نمونه زیر نتیجه تابع را به <code>decimal</code> تبدیل می‌کند و ممکن است حافظه تصادفی در خروجی دخیل شود:</li>
</ul>
<pre><code class="language-csharp">var pointer2 = (delegate*&lt;string, decimal&gt;)(IntPtr)functionPointer;
Console.WriteLine(pointer2(&quot;Hello, unsafe world&quot;));
</code></pre>
<h3><code>[SkipLocalsInit]</code> ⚡</h3>
<p>وقتی C# یک متد را کامپایل می‌کند، یک flag تولید می‌کند که به runtime می‌گوید متغیرهای محلی متد را به مقادیر پیش‌فرضشان مقداردهی کند (با صفر کردن حافظه).</p>
<p>از C# 9 به بعد، می‌توانید از کامپایلر بخواهید این flag را تولید نکند با اعمال <strong>attribute</strong> <code>[SkipLocalsInit]</code> روی یک متد (در namespace <code>System.Runtime.CompilerServices</code>):</p>
<pre><code class="language-csharp">[SkipLocalsInit]
void Foo() ...
</code></pre>
<p>می‌توانید این attribute را روی یک نوع (type) اعمال کنید—که معادل اعمال آن روی همه متدهای آن نوع است—یا حتی روی کل یک ماژول (module) که محتوای یک assembly است:</p>
<pre><code class="language-csharp">[module: System.Runtime.CompilerServices.SkipLocalsInit]
</code></pre>
<p>در سناریوهای امن معمولی، <code>[SkipLocalsInit]</code> تأثیر زیادی روی عملکرد یا کارکرد ندارد، چون <strong>قانون تخصیص قطعی (definite assignment)</strong> در C# نیاز دارد که متغیرهای محلی قبل از خوانده شدن مقداردهی شوند. این بدان معناست که JIT optimizer احتمالاً همان کد ماشین را تولید می‌کند، چه attribute اعمال شده باشد یا نه.</p>
<p>اما در زمینه unsafe، استفاده از <code>[SkipLocalsInit]</code> می‌تواند بار CLR برای مقداردهی اولیه متغیرهای محلی از نوع value را کاهش دهد و باعث <strong>افزایش جزئی عملکرد</strong> شود، مخصوصاً در متدهایی که استفاده زیادی از استک دارند (مثلاً با stackalloc بزرگ). مثال زیر حافظه مقداردهی‌نشده را چاپ می‌کند وقتی <code>[SkipLocalsInit]</code> اعمال شده باشد (به جای صفر):</p>
<pre><code class="language-csharp">[SkipLocalsInit]
unsafe void Foo()
{
    int local;
    int* ptr = &amp;local;
    Console.WriteLine(*ptr);

    int* a = stackalloc int[100];
    for (int i = 0; i &lt; 100; ++i) Console.WriteLine(a[i]);
}
</code></pre>
<p>جالب این که می‌توان به همان نتیجه در محیط “ایمن” با استفاده از <code>Span&lt;T&gt;</code> رسید:</p>
<pre><code class="language-csharp">[SkipLocalsInit]
void Foo()
{
    Span&lt;int&gt; a = stackalloc int[100];
    for (int i = 0; i &lt; 100; ++i) Console.WriteLine(a[i]);
}
</code></pre>
<p>بنابراین، استفاده از <code>[SkipLocalsInit]</code> نیاز دارد که پروژه شما با <code>&lt;AllowUnsafeBlocks&gt;</code> برابر <code>true</code> کامپایل شود—حتی اگر هیچ متدی unsafe علامت‌گذاری نشده باشد.</p>
<hr>
<h3>دستورات پیش‌پردازنده (Preprocessor Directives) 🛠️</h3>
<p>دستورات پیش‌پردازنده به کامپایلر اطلاعات اضافی درباره بخش‌های کد می‌دهند. رایج‌ترین آن‌ها <strong>دستورات شرطی</strong> هستند که راهی برای شامل یا حذف بخش‌هایی از کد در زمان کامپایل فراهم می‌کنند:</p>
<pre><code class="language-csharp">#define DEBUG

class MyClass
{
    int x;
    void Foo()
    {
        #if DEBUG
            Console.WriteLine(&quot;Testing: x = {0}&quot;, x);
        #endif
    }
    ...
}
</code></pre>
<p>در این مثال، دستور داخل <code>Foo</code> مشروط به وجود سمبل <code>DEBUG</code> کامپایل می‌شود. اگر سمبل <code>DEBUG</code> حذف شود، دستور کامپایل نمی‌شود.</p>
<p>می‌توان سمبل‌های پیش‌پردازنده را در فایل سورس تعریف کرد یا در سطح پروژه در فایل <code>.csproj</code>:</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
    &lt;DefineConstants&gt;DEBUG;ANOTHERSYMBOL&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>با دستورات <code>#if</code> و <code>#elif</code> می‌توان از عملگرهای <code>||</code>، <code>&amp;&amp;</code> و <code>!</code> برای انجام عملیات <strong>or، and و not</strong> روی چند سمبل استفاده کرد. مثال:</p>
<pre><code class="language-csharp">#if TESTMODE &amp;&amp; !DEBUG
    ...
#endif
</code></pre>
<p>توجه کنید که این یک عبارت معمولی C# نیست و سمبل‌ها هیچ ارتباطی با متغیرها—چه static و چه غیر—ندارند.</p>
<hr>
<h3><code>#error</code> و <code>#warning</code> ⚠️</h3>
<p>این دستورات از سوءاستفاده تصادفی از دستورات شرطی جلوگیری می‌کنند، با ایجاد <strong>هشدار یا خطا توسط کامپایلر</strong> در صورت مجموعه نامطلوبی از سمبل‌ها.</p>
<p>جدول ۴-۱ فهرست دستورات پیش‌پردازنده را ارائه می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>Conditional Attributes 🎯</h3>
<p>یک <strong>attribute</strong> که با <code>Conditional</code> تزئین شده باشد، تنها در صورتی کامپایل می‌شود که <strong>سمبل پیش‌پردازنده مشخص شده</strong> موجود باشد:</p>
<pre><code class="language-csharp">// file1.cs
#define DEBUG
using System;
using System.Diagnostics;

[Conditional(&quot;DEBUG&quot;)]
public class TestAttribute : Attribute {}

// file2.cs
#define DEBUG
[Test]
class Foo
{
    [Test]
    string s;
}
</code></pre>
<p>کامپایلر تنها زمانی attributeهای <code>[Test]</code> را در فایل <code>file2.cs</code> وارد می‌کند که سمبل <code>DEBUG</code> در محدوده آن فایل تعریف شده باشد.</p>
<hr>
<h3>Pragma Warning ⚠️</h3>
<p>کامپایلر وقتی چیزی در کد شما را غیرعمدی تشخیص دهد، یک <strong>هشدار (warning)</strong> ایجاد می‌کند. بر خلاف خطاها، هشدارها معمولاً مانع کامپایل شدن برنامه نمی‌شوند.</p>
<p>هشدارهای کامپایلر بسیار مفیدند برای شناسایی باگ‌ها، اما وقتی هشدارهای کاذب زیاد شوند، مفید بودنشان کاهش می‌یابد. در برنامه‌های بزرگ، حفظ <strong>نسبت سیگنال به نویز</strong> برای مشاهده هشدارهای واقعی ضروری است.</p>
<p>برای این منظور، می‌توانید هشدارها را به‌صورت انتخابی با دستور <code>#pragma warning</code> غیرفعال کنید. مثال:</p>
<pre><code class="language-csharp">public class Foo
{
    static void Main() { }

    #pragma warning disable 414
    static string Message = &quot;Hello&quot;;   // این هشدار غیرفعال شد
    #pragma warning restore 414
}
</code></pre>
<p>اگر شماره هشدار در دستور <code>#pragma warning</code> حذف شود، همه هشدارها غیرفعال یا فعال می‌شوند.
با دقت در استفاده از این دستور، می‌توان پروژه را با سوئیچ <code>/warnaserror</code> کامپایل کرد—که باعث می‌شود هر هشدار باقیمانده به یک <strong>خطا</strong> تبدیل شود.</p>
<hr>
<h3>مستندسازی XML 📄</h3>
<p>یک <strong>کامنت مستندسازی (documentation comment)</strong>، تکه‌ای از XML است که یک نوع یا عضو را مستند می‌کند. این کامنت درست قبل از تعریف نوع یا عضو قرار می‌گیرد و با سه اسلش <code>///</code> شروع می‌شود:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;Cancels a running query.&lt;/summary&gt;
public void Cancel() { ... }
</code></pre>
<p>کامنت‌های چندخطی به این صورت هستند:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Cancels a running query
/// &lt;/summary&gt;
public void Cancel() { ... }
</code></pre>
<p>یا به این شکل (با ستاره اضافی):</p>
<pre><code class="language-csharp">/** 
    &lt;summary&gt; Cancels a running query. &lt;/summary&gt;
*/
public void Cancel() { ... }
</code></pre>
<p>اگر گزینه زیر به فایل <code>.csproj</code> اضافه شود:</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
    &lt;DocumentationFile&gt;SomeFile.xml&lt;/DocumentationFile&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>کامپایلر <strong>کامنت‌های مستندسازی</strong> را استخراج و در فایل XML مشخص شده جمع‌آوری می‌کند. کاربردها:</p>
<ul>
<li>اگر در همان فولدر اسمبلی کامپایل‌شده قرار گیرد، ابزارهایی مثل <strong>Visual Studio</strong> و <strong>LINQPad</strong> به‌طور خودکار فایل XML را می‌خوانند و از آن برای ارائه IntelliSense استفاده می‌کنند.</li>
<li>ابزارهای جانبی (مثل Sandcastle و NDoc) می‌توانند فایل XML را به HTML تبدیل کنند.</li>
</ul>
<hr>
<h3>تگ‌های استاندارد XML برای مستندسازی 📑</h3>
<p>تگ‌های استاندارد XML که Visual Studio و ابزارهای تولید مستندات می‌شناسند:</p>
<ul>
<li>
<p><code>&lt;summary&gt;</code>
توضیح کوتاهی که IntelliSense نمایش می‌دهد؛ معمولاً یک جمله یا عبارت کوتاه است.</p>
</li>
<li>
<p><code>&lt;remarks&gt;</code>
متن اضافی که نوع یا عضو را شرح می‌دهد. ابزارهای مستندسازی این متن را در توضیح کلی ادغام می‌کنند.</p>
</li>
<li>
<p><code>&lt;param&gt;</code>
توضیح پارامتر یک متد:</p>
<pre><code class="language-xml">&lt;param name=&quot;name&quot;&gt;...&lt;/param&gt;
</code></pre>
</li>
</ul>
<ul>
<li><code>&lt;returns&gt;</code>
توضیح مقدار برگشتی یک متد.</li>
</ul>
<ul>
<li>
<p><code>&lt;exception&gt;</code>
لیست استثناهایی که متد می‌تواند پرتاب کند:</p>
<pre><code class="language-xml">&lt;exception cref=&quot;type&quot;&gt;...&lt;/exception&gt;
</code></pre>
</li>
</ul>
<ul>
<li>
<p><code>&lt;example&gt;</code>
مثال عملی (شامل توضیح و کد نمونه):</p>
<pre><code class="language-xml">&lt;example&gt;
    &lt;code&gt;...&lt;/code&gt;
&lt;/example&gt;
</code></pre>
</li>
<li>
<p><code>&lt;c&gt;</code> و <code>&lt;code&gt;</code></p>
<ul>
<li><code>&lt;c&gt;</code>: قطعه کد خطی داخل مثال.</li>
<li><code>&lt;code&gt;</code>: نمونه کد چندخطی داخل مثال.</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>&lt;see&gt;</code>
ارجاع داخلی به یک نوع یا عضو دیگر:</p>
<pre><code class="language-xml">&lt;see cref=&quot;member&quot;&gt;...&lt;/see&gt;
</code></pre>
</li>
</ul>
<ul>
<li><code>&lt;seealso&gt;</code>
ارجاع متقابل به نوع یا عضو دیگر، معمولاً در بخش “See Also”.</li>
</ul>
<ul>
<li>
<p><code>&lt;paramref&gt;</code>
ارجاع به پارامتر در <code>&lt;summary&gt;</code> یا <code>&lt;remarks&gt;</code>:</p>
<pre><code class="language-xml">&lt;paramref name=&quot;name&quot;/&gt;
</code></pre>
</li>
</ul>
<ul>
<li>
<p><code>&lt;list&gt;</code>
ایجاد لیست بولت‌دار، شماره‌دار یا جدولی:</p>
<pre><code class="language-xml">&lt;list type=&quot;bullet|number|table&quot;&gt;
    &lt;listheader&gt;
        &lt;term&gt;...&lt;/term&gt;
        &lt;description&gt;...&lt;/description&gt;
    &lt;/listheader&gt;
    &lt;item&gt;
        &lt;term&gt;...&lt;/term&gt;
        &lt;description&gt;...&lt;/description&gt;
    &lt;/item&gt;
&lt;/list&gt;
</code></pre>
</li>
<li>
<p><code>&lt;para&gt;</code>
ایجاد یک پاراگراف جدا:</p>
<pre><code class="language-xml">&lt;para&gt;...&lt;/para&gt;
</code></pre>
</li>
<li>
<p><code>&lt;include&gt;</code>
ادغام یک فایل XML خارجی که مستندات را دارد:</p>
<pre><code class="language-xml">&lt;include file='filename' path='tagpath[@name=&quot;id&quot;]'&gt;...&lt;/include&gt;
</code></pre>
</li>
</ul>
<h3>User-Defined Tags 🏷️</h3>
<p>چیزی به‌خصوص در مورد تگ‌های پیش‌فرض XML که توسط کامپایلر C# شناخته می‌شوند وجود ندارد و شما آزاد هستید <strong>تگ‌های خودتان</strong> را تعریف کنید.</p>
<p>تنها پردازش ویژه‌ای که کامپایلر انجام می‌دهد مربوط به:</p>
<ul>
<li><code>&lt;param&gt;</code>: که نام پارامتر را بررسی می‌کند و مطمئن می‌شود تمام پارامترهای متد مستندسازی شده باشند.</li>
<li>صفت <code>cref</code>: که بررسی می‌کند این صفت به یک نوع یا عضو واقعی ارجاع می‌دهد و آن را به یک <strong>ID کاملاً واجد شرایط</strong> از نوع یا عضو گسترش می‌دهد.</li>
</ul>
<p>همچنین می‌توانید از صفت <code>cref</code> در تگ‌های خودتان استفاده کنید؛ کامپایلر همان بررسی و گسترش را انجام می‌دهد، درست مانند تگ‌های پیش‌فرض <code>&lt;exception&gt;</code>, <code>&lt;permission&gt;</code>, <code>&lt;see&gt;</code>, و <code>&lt;seealso&gt;</code>.</p>
<hr>
<h3>Type or Member Cross-References 🔗</h3>
<p>نام‌های نوع و ارجاعات متقابل به نوع یا عضو به <strong>IDهایی یکتا</strong> تبدیل می‌شوند که نوع یا عضو را مشخص می‌کنند.</p>
<p>این نام‌ها شامل دو بخش هستند:</p>
<ol>
<li><strong>پیش‌وند (prefix)</strong> که مشخص می‌کند ID چه چیزی را نمایندگی می‌کند.</li>
<li><strong>امضا (signature)</strong> نوع یا عضو.</li>
</ol>
<p>در ادامه، پیش‌وندهای اعضا (member prefixes) معرفی می‌شوند:</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>نمونه‌ای از Type و Member IDs 📝</h3>
<p>قواعدی که مشخص می‌کنند <strong>امضاها (signatures)</strong> چگونه تولید می‌شوند، مستند شده‌اند، اگرچه نسبتاً پیچیده هستند.</p>
<p>در اینجا یک مثال از یک نوع و IDهای تولیدشده آن آورده شده است:</p>
<pre><code class="language-csharp">// فضاهای نام (Namespaces) امضای مستقل ندارند
namespace NS
{
    /// T:NS.MyClass
    class MyClass
    {
        /// F:NS.MyClass.aField
        string aField;

        /// P:NS.MyClass.aProperty
        short aProperty { get { ... } set { ... } }

        /// T:NS.MyClass.NestedType
        class NestedType { ... }

        /// M:NS.MyClass.X()
        void X() { ... }

        /// M:NS.MyClass.Y(System.Int32,System.Double@,System.Decimal@)
        void Y(int p1, ref double p2, out decimal p3) { ... }

        /// M:NS.MyClass.Z(System.Char[],System.Single[0:,0:])
        void Z(char[] p1, float[,] p2) { ... }

        /// M:NS.MyClass.op_Addition(NS.MyClass,NS.MyClass)
        public static MyClass operator + (MyClass c1, MyClass c2) { ... }

        /// M:NS.MyClass.op_Implicit(NS.MyClass)~System.Int32
        public static implicit operator int(MyClass c) { ... }

        /// M:NS.MyClass.#ctor
        MyClass() { ... }

        /// M:NS.MyClass.Finalize
        ~MyClass() { ... }

        /// M:NS.MyClass.#cctor
        static MyClass() { ... }
    }
}
</code></pre>
<ul>
<li><code>T:</code> پیش‌وند برای <strong>Type</strong></li>
<li><code>F:</code> پیش‌وند برای <strong>Field</strong></li>
<li><code>P:</code> پیش‌وند برای <strong>Property</strong></li>
<li><code>M:</code> پیش‌وند برای <strong>Method</strong></li>
</ul>
<p>IDها شامل <strong>فضای نام، نام کلاس، و نام عضو</strong> هستند و برای متدها، پارامترها و نوع بازگشتی نیز دقیقاً مشخص می‌شوند.</p>
<p>این سیستم به <strong>کامپایلر و ابزارهای مستندسازی</strong> اجازه می‌دهد تا ارجاعات داخلی و خارجی را به‌درستی پیگیری کنند و خطاهای احتمالی را تشخیص دهند.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
