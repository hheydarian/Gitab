<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل هفتم: <strong>مجموعه‌ها (Collections) 📚</strong></h1>
<p>.NET یک مجموعه استاندارد از نوع‌ها را برای ذخیره‌سازی و مدیریت مجموعه‌ای از اشیاء ارائه می‌دهد. این نوع‌ها شامل لیست‌های قابل تغییر اندازه (resizable lists)، لیست‌های پیوندی (linked lists)، دیکشنری‌های مرتب و نامرتب (sorted و unsorted dictionaries) و همچنین آرایه‌ها (arrays) هستند. از بین این‌ها، تنها آرایه‌ها بخشی از زبان C# را تشکیل می‌دهند؛ بقیه مجموعه‌ها فقط کلاس‌هایی هستند که می‌توانید مانند هر کلاس دیگری نمونه‌سازی (instantiate) کنید.</p>
<p>می‌توانیم نوع‌ها در BCL دات‌نت برای مجموعه‌ها را به دسته‌های زیر تقسیم کنیم:</p>
<p>• اینترفیس‌هایی که پروتکل‌های استاندارد مجموعه را تعریف می‌کنند</p>
<p>• کلاس‌های آماده برای استفاده در مجموعه‌ها (لیست‌ها، دیکشنری‌ها و غیره)</p>
<p>• کلاس‌های پایه برای نوشتن مجموعه‌های مخصوص برنامه</p>
<p>این فصل هر یک از این دسته‌ها را پوشش می‌دهد، به‌علاوه یک بخش اضافی درباره نوع‌هایی که برای تعیین برابری و ترتیب عناصر استفاده می‌شوند، ارائه می‌کند.</p>
<p>فضاهای نام (namespaces) مربوط به مجموعه‌ها به شرح زیر هستند:</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><strong>شماره‌گذاری (Enumeration) 🔢</strong></p>
<p>در علوم کامپیوتر، مجموعه‌های مختلفی وجود دارند که از ساختارهای داده ساده مانند آرایه‌ها (arrays) یا لیست‌های پیوندی (linked lists)، تا ساختارهای پیچیده‌تر مانند درخت‌های قرمز/سیاه (red/black trees) و هشت‌جدول‌ها (hashtables) را شامل می‌شوند.</p>
<p>اگرچه پیاده‌سازی داخلی و ویژگی‌های خارجی این ساختارهای داده بسیار متفاوت است، اما توانایی پیمایش (traverse) محتویات مجموعه، نیاز تقریباً جهانی است. BCL دات‌نت این نیاز را از طریق یک جفت اینترفیس (IEnumerable و IEnumerator و نسخه‌های Generic آن‌ها) پشتیبانی می‌کند که به ساختارهای داده مختلف اجازه می‌دهد یک API مشترک برای پیمایش ارائه دهند.</p>
<p>این اینترفیس‌ها بخشی از مجموعه بزرگ‌تری از اینترفیس‌های مجموعه هستند که در شکل ۷-۱ نشان داده شده‌اند.</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><strong>IEnumerable و IEnumerator 🔄</strong></p>
<p>اینترفیس <code>IEnumerator</code> پروتکل پایه و سطح پایین را تعریف می‌کند که با آن عناصر یک مجموعه به‌صورت پیش‌رونده (forward-only) پیمایش یا شماره‌گذاری (enumerate) می‌شوند. تعریف آن به صورت زیر است:</p>
<pre><code class="language-csharp">public interface IEnumerator
{
  bool MoveNext();
  object Current { get; }
  void Reset();
}
</code></pre>
<p>متد <code>MoveNext</code> عنصر فعلی یا «کرسر» (cursor) را به موقعیت بعدی منتقل می‌کند و اگر دیگر عنصری در مجموعه وجود نداشته باشد، مقدار <code>false</code> برمی‌گرداند. <code>Current</code> عنصری را که در موقعیت فعلی قرار دارد برمی‌گرداند (معمولاً از نوع <code>object</code> به نوع خاص‌تر تبدیل می‌شود). قبل از دسترسی به اولین عنصر، حتماً باید <code>MoveNext</code> فراخوانی شود — این کار اجازه می‌دهد تا مجموعه خالی نیز مدیریت شود. متد <code>Reset</code>، در صورت پیاده‌سازی، کرسر را به ابتدای مجموعه بازمی‌گرداند تا امکان پیمایش مجدد فراهم شود. وجود <code>Reset</code> بیشتر برای سازگاری با <strong>Component Object Model (COM)</strong> است؛ فراخوانی مستقیم آن معمولاً اجتناب می‌شود چون همیشه پشتیبانی نمی‌شود و به طور کلی لازم نیست، زیرا ایجاد یک نمونه جدید از enumerator اغلب ساده‌تر است.</p>
<p>معمولاً مجموعه‌ها خودشان enumerator را پیاده‌سازی نمی‌کنند؛ بلکه <strong>enumerator</strong> را از طریق اینترفیس <code>IEnumerable</code> فراهم می‌کنند:</p>
<pre><code class="language-csharp">public interface IEnumerable
{
  IEnumerator GetEnumerator();
}
</code></pre>
<p>با تعریف یک متد که یک enumerator بازمی‌گرداند، <code>IEnumerable</code> انعطاف‌پذیری ایجاد می‌کند تا منطق تکرار (iteration) به کلاس دیگری سپرده شود. همچنین این به این معنی است که چند مصرف‌کننده می‌توانند همزمان مجموعه را پیمایش کنند بدون اینکه با یکدیگر تداخل داشته باشند. می‌توان <code>IEnumerable</code> را «<code>IEnumeratorProvider</code>» در نظر گرفت، و این ابتدایی‌ترین اینترفیس است که کلاس‌های مجموعه پیاده‌سازی می‌کنند.</p>
<p>نمونه زیر استفاده سطح پایین از <code>IEnumerable</code> و <code>IEnumerator</code> را نشان می‌دهد:</p>
<pre><code class="language-csharp">string s = &quot;Hello&quot;;
// چون رشته String اینترفیس IEnumerable را پیاده‌سازی می‌کند، می‌توانیم GetEnumerator را فراخوانی کنیم:
IEnumerator rator = s.GetEnumerator();
while (rator.MoveNext())
{
  char c = (char) rator.Current;
  Console.Write(c + &quot;.&quot;);
}
// خروجی: H.e.l.l.o.
</code></pre>
<p>با این حال، به‌ندرت پیش می‌آید که متدها روی enumerator به این شکل فراخوانی شوند، زیرا C# یک میان‌بر نحوی فراهم می‌کند: دستور <code>foreach</code>. مثال بالا با استفاده از <code>foreach</code> به شکل زیر بازنویسی می‌شود:</p>
<pre><code class="language-csharp">string s = &quot;Hello&quot;;      // کلاس String اینترفیس IEnumerable را پیاده‌سازی می‌کند
foreach (char c in s)
  Console.Write(c + &quot;.&quot;);
</code></pre>
<hr>
<h3><code>IEnumerable&lt;T&gt;</code> و <code>IEnumerator&lt;T&gt;</code> 🧩</h3>
<p><code>IEnumerator</code> و <code>IEnumerable</code> تقریباً همیشه همراه با نسخه‌های Generic خود پیاده‌سازی می‌شوند:</p>
<pre><code class="language-csharp">public interface IEnumerator&lt;T&gt; : IEnumerator, IDisposable
{
  T Current { get; }
}

public interface IEnumerable&lt;T&gt; : IEnumerable
{
  IEnumerator&lt;T&gt; GetEnumerator();
}
</code></pre>
<p>با تعریف نسخه‌ای نوع‌دار (typed) از <code>Current</code> و <code>GetEnumerator</code>، این اینترفیس‌ها ایمنی نوع ایستا (static type safety) را تقویت می‌کنند، از سربار <strong>boxing</strong> در عناصر نوع مقدار (value-type) جلوگیری می‌کنند و برای مصرف‌کننده راحت‌تر هستند. آرایه‌ها به‌صورت خودکار <code>IEnumerable&lt;T&gt;</code> را پیاده‌سازی می‌کنند (که T نوع عضو آرایه است).</p>
<p>به لطف ایمنی نوع ایستا، فراخوانی متد زیر با آرایه‌ای از کاراکترها باعث ایجاد خطای زمان کامپایل می‌شود:</p>
<pre><code class="language-csharp">void Test (IEnumerable&lt;int&gt; numbers) { ... }
</code></pre>
<p>یک روش استاندارد در کلاس‌های مجموعه این است که <code>IEnumerable&lt;T&gt;</code> را به‌صورت عمومی (public) نمایش دهند و <code>IEnumerable</code> غیر Generic را از طریق پیاده‌سازی صریح اینترفیس (explicit interface implementation) «مخفی» کنند. این کار به این دلیل است که اگر مستقیماً <code>GetEnumerator()</code> فراخوانی شود، یک <code>IEnumerator&lt;T&gt;</code> ایمن از نظر نوع بازگردانده شود.</p>
<p>با این حال، گاهی این قانون برای سازگاری با نسخه‌های قدیمی شکسته می‌شود (زیرا Genericها قبل از C# 2.0 وجود نداشتند). یک مثال خوب آرایه‌ها هستند — این‌ها باید <code>IEnumerator</code> غیر Generic (یا همان نسخه «کلاسیک») را برگردانند تا کدهای قبلی خراب نشوند. برای به دست آوردن <code>IEnumerator&lt;T&gt;</code> Generic، باید نوع را به صورت صریح تبدیل (cast) کنید:</p>
<pre><code class="language-csharp">int[] data = { 1, 2, 3 };
var rator = ((IEnumerable&lt;int&gt;)data).GetEnumerator();
</code></pre>
<p>خوشبختانه به لطف دستور <code>foreach</code>، به ندرت نیاز است چنین کدی نوشته شود.</p>
<p><strong>IEnumerable<T> و IDisposable ♻️</strong></p>
<p><code>IEnumerator&lt;T&gt;</code> از <code>IDisposable</code> ارث‌بری می‌کند. این امکان را به enumerator می‌دهد که به منابعی مانند اتصال به پایگاه داده (database connections) دسترسی داشته باشد و اطمینان حاصل کند که این منابع پس از اتمام یا قطع پیمایش آزاد می‌شوند. دستور <code>foreach</code> این نکته را تشخیص می‌دهد و عبارت زیر را:</p>
<pre><code class="language-csharp">foreach (var element in somethingEnumerable) { ... }
</code></pre>
<p>به معادل منطقی زیر تبدیل می‌کند:</p>
<pre><code class="language-csharp">using (var rator = somethingEnumerable.GetEnumerator())
  while (rator.MoveNext())
  {
    var element = rator.Current;
    ...
  }
</code></pre>
<p>بلوک <code>using</code> تضمین می‌کند که منابع به درستی Dispose شوند — درباره <code>IDisposable</code> در فصل ۱۲ بیشتر توضیح داده می‌شود.</p>
<hr>
<h3>استفاده از اینترفیس‌های غیر Generic ❓</h3>
<p>با توجه به ایمنی نوع اضافی که اینترفیس‌های مجموعه Generic مانند <code>IEnumerable&lt;T&gt;</code> ارائه می‌دهند، این سؤال مطرح می‌شود: آیا واقعاً نیاز به استفاده از <code>IEnumerable</code> غیر Generic (یا <code>ICollection</code> یا <code>IList</code>) وجود دارد؟</p>
<p>در مورد <code>IEnumerable</code>، باید این اینترفیس را همراه با <code>IEnumerable&lt;T&gt;</code> پیاده‌سازی کنید، زیرا نسخه Generic از نسخه غیر Generic ارث‌بری می‌کند. با این حال، بسیار نادر است که بخواهید این اینترفیس‌ها را از ابتدا پیاده‌سازی کنید؛ در اکثر موارد می‌توانید از روش‌های سطح بالاتر مانند <strong>iterator methods</strong>، <code>Collection&lt;T&gt;</code> و <strong>LINQ</strong> استفاده کنید.</p>
<hr>
<h3>به‌عنوان مصرف‌کننده 🔍</h3>
<p>در اکثر موارد، می‌توانید به‌طور کامل با اینترفیس‌های Generic کار کنید. با این حال، اینترفیس‌های غیر Generic هنوز گاهی مفید هستند، زیرا توانایی ارائه <strong>یکپارچگی نوع</strong> برای مجموعه‌ها با همه نوع عناصر را دارند.</p>
<p>برای مثال، متد زیر تعداد عناصر موجود در هر مجموعه‌ای را به‌صورت بازگشتی می‌شمارد:</p>
<pre><code class="language-csharp">public static int Count(IEnumerable e)
{
    int count = 0;
    foreach (object element in e)
    {
        var subCollection = element as IEnumerable;
        if (subCollection != null)
            count += Count(subCollection);
        else
            count++;
    }
    return count;
}
</code></pre>
<p>چون C# با اینترفیس‌های Generic امکان <strong>covariance</strong> را ارائه می‌دهد، ممکن است فکر کنید می‌توانستیم به جای آن <code>IEnumerable&lt;object&gt;</code> دریافت کنیم. اما این روش با عناصر نوع مقدار (value-type) و مجموعه‌های قدیمی که <code>IEnumerable&lt;T&gt;</code> را پیاده‌سازی نکرده‌اند، شکست می‌خورد — مثالی از این نوع، <code>ControlCollection</code> در Windows Forms است.</p>
<blockquote>
<p>⚠️ نکته: در مثال بالا، ارجاعات چرخه‌ای (cyclic references) می‌توانند باعث بازگشت نامتناهی و کرش شدن برنامه شوند. ساده‌ترین راه حل، استفاده از <code>HashSet</code> است (به بخش &quot;HashSet<T> و SortedSet<T>&quot; در صفحه ۳۹۲ مراجعه کنید).</p>
</blockquote>
<hr>
<h3>پیاده‌سازی اینترفیس‌های Enumeration 🛠️</h3>
<p>ممکن است بخواهید <code>IEnumerable</code> یا <code>IEnumerable&lt;T&gt;</code> را به یکی یا چند دلیل زیر پیاده‌سازی کنید:</p>
<ul>
<li>پشتیبانی از دستور <code>foreach</code></li>
<li>همکاری با هر چیزی که مجموعه استاندارد انتظار دارد</li>
<li>رعایت نیازمندی‌های یک اینترفیس مجموعه پیشرفته‌تر</li>
<li>پشتیبانی از <strong>collection initializers</strong></li>
</ul>
<p>برای پیاده‌سازی <code>IEnumerable/IEnumerable&lt;T&gt;</code>، باید یک <strong>enumerator</strong> ارائه دهید. سه روش برای انجام این کار وجود دارد:</p>
<ol>
<li>اگر کلاس، مجموعه دیگری را <strong>wrapper</strong> می‌کند، با بازگرداندن enumerator مجموعه داخلی</li>
<li>از طریق یک <strong>iterator</strong> با استفاده از <code>yield return</code></li>
<li>با ایجاد نمونه‌ای از پیاده‌سازی خود <code>IEnumerator/IEnumerator&lt;T&gt;</code></li>
</ol>
<hr>
<h3>نمونه استفاده از iterator با <code>yield return</code> ✨</h3>
<pre><code class="language-csharp">public class MyCollection : IEnumerable
{
    int[] data = { 1, 2, 3 };
    public IEnumerator GetEnumerator()
    {
        foreach (int i in data)
            yield return i;
    }
}
</code></pre>
<p>در نگاه اول، به نظر می‌رسد <code>GetEnumerator</code> هیچ enumerator‌ای باز نمی‌گرداند! اما کامپایلر هنگام پردازش <code>yield return</code>، یک کلاس enumerator پنهان می‌سازد و <code>GetEnumerator</code> را طوری تغییر می‌دهد که آن کلاس را نمونه‌سازی و بازگرداند.</p>
<p>این روش ساده، قدرتمند و در پیاده‌سازی <strong>LINQ-to-Objects</strong> بسیار استفاده می‌شود.</p>
<hr>
<h3>پیاده‌سازی نسخه Generic 🧩</h3>
<pre><code class="language-csharp">public class MyGenCollection : IEnumerable&lt;int&gt;
{
    int[] data = { 1, 2, 3 };
    public IEnumerator&lt;int&gt; GetEnumerator()
    {
        foreach (int i in data)
            yield return i;
    }

    // پیاده‌سازی صریح نسخه غیر Generic:
    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}
</code></pre>
<p>چون <code>IEnumerable&lt;T&gt;</code> از <code>IEnumerable</code> ارث‌بری می‌کند، باید هر دو نسخه Generic و غیر Generic از <code>GetEnumerator</code> پیاده‌سازی شوند. نسخه غیر Generic معمولاً به‌صورت صریح (explicit) پیاده‌سازی می‌شود تا بتواند نسخه Generic را فراخوانی کند، زیرا <code>IEnumerator&lt;T&gt;</code> از <code>IEnumerator</code> ارث‌بری می‌کند.</p>
<hr>
<h3>پیاده‌سازی مستقیم IEnumerator 🔧</h3>
<p>در برخی موارد، می‌توانید یک کلاس بنویسید که مستقیماً <code>IEnumerator</code> را پیاده‌سازی کند. مثال زیر یک مجموعه ثابت با اعداد 1، 2 و 3 را نشان می‌دهد:</p>
<pre><code class="language-csharp">public class MyIntList : IEnumerable
{
    int[] data = { 1, 2, 3 };
    public IEnumerator GetEnumerator() =&gt; new Enumerator(this);

    class Enumerator : IEnumerator
    {
        MyIntList collection;
        int currentIndex = -1;

        public Enumerator(MyIntList items) =&gt; this.collection = items;

        public object Current
        {
            get
            {
                if (currentIndex == -1)
                    throw new InvalidOperationException(&quot;Enumeration not started!&quot;);
                if (currentIndex == collection.data.Length)
                    throw new InvalidOperationException(&quot;Past end of list!&quot;);
                return collection.data[currentIndex];
            }
        }

        public bool MoveNext()
        {
            if (currentIndex &gt;= collection.data.Length - 1) return false;
            return ++currentIndex &lt; collection.data.Length;
        }

        public void Reset() =&gt; currentIndex = -1;
    }
}
</code></pre>
<p>پیاده‌سازی <code>Reset</code> اختیاری است — می‌توانید به جای آن <code>NotSupportedException</code> پرتاب کنید.</p>
<hr>
<h3>پیاده‌سازی Generic مستقیم ✅</h3>
<pre><code class="language-csharp">class MyIntList : IEnumerable&lt;int&gt;
{
    int[] data = { 1, 2, 3 };

    public IEnumerator&lt;int&gt; GetEnumerator() =&gt; new Enumerator(this);
    IEnumerator IEnumerable.GetEnumerator() =&gt; new Enumerator(this);

    class Enumerator : IEnumerator&lt;int&gt;
    {
        int currentIndex = -1;
        MyIntList collection;

        public Enumerator(MyIntList items) =&gt; collection = items;

        public int Current =&gt; collection.data[currentIndex];
        object IEnumerator.Current =&gt; Current;

        public bool MoveNext() =&gt; ++currentIndex &lt; collection.data.Length;
        public void Reset() =&gt; currentIndex = -1;

        // از آنجا که نیاز به Dispose نداریم، بهتر است صریح پیاده‌سازی شود تا از رابط عمومی مخفی بماند
        void IDisposable.Dispose() {}
    }
}
</code></pre>
<p>نسخه Generic سریع‌تر است زیرا <code>IEnumerator&lt;int&gt;.Current</code> نیاز به <strong>casting</strong> از <code>int</code> به <code>object</code> ندارد و سربار <strong>boxing</strong> را حذف می‌کند.</p>
<p><strong>اینترفیس‌های ICollection و IList 🗂️</strong></p>
<p>اگرچه اینترفیس‌های Enumeration یک پروتکل برای پیمایش <strong>فقط به جلو</strong> (forward-only) در مجموعه‌ها فراهم می‌کنند، اما مکانیزمی برای تعیین اندازه مجموعه، دسترسی به عضو از طریق اندیس، یا تغییر محتویات مجموعه ارائه نمی‌دهند. برای چنین قابلیت‌هایی، دات‌نت اینترفیس‌های <code>ICollection</code>، <code>IList</code> و <code>IDictionary</code> را تعریف کرده است. هرکدام از این اینترفیس‌ها نسخه‌های <strong>Generic</strong> و <strong>Non-Generic</strong> دارند؛ با این حال، نسخه‌های غیر Generic عمدتاً برای پشتیبانی از کدهای قدیمی وجود دارند.</p>
<p>شکل ۷-۱ سلسله مراتب ارث‌بری این اینترفیس‌ها را نشان داد. ساده‌ترین راه برای خلاصه‌سازی آن‌ها به شرح زیر است:</p>
<ul>
<li><code>IEnumerable&lt;T&gt;</code> (و <code>IEnumerable</code>)
حداقل قابلیت‌ها را فراهم می‌کند (فقط پیمایش)</li>
<li><code>ICollection&lt;T&gt;</code> (و <code>ICollection</code>)
قابلیت‌های متوسط را ارائه می‌دهد (مثلاً ویژگی <code>Count</code>)</li>
<li><code>IList&lt;T&gt;</code> / <code>IDictionary&lt;K,V&gt;</code> و نسخه‌های غیر Generic آن‌ها
حداکثر قابلیت‌ها را ارائه می‌دهند (شامل دسترسی «تصادفی» به عناصر با اندیس یا کلید)</li>
</ul>
<p>به ندرت پیش می‌آید که نیاز داشته باشید هر یک از این اینترفیس‌ها را خودتان پیاده‌سازی کنید. در اکثر مواقع، هنگام نوشتن یک کلاس مجموعه، می‌توانید به جای آن از <strong>subclass</strong> کردن <code>Collection&lt;T&gt;</code> استفاده کنید (به بخش &quot;Customizable Collections and Proxies&quot; در صفحه ۴۰۱ مراجعه کنید). <strong>LINQ</strong> نیز گزینه دیگری ارائه می‌دهد که بسیاری از سناریوها را پوشش می‌دهد.</p>
<p>نسخه‌های Generic و Non-Generic تفاوت‌هایی فراتر از انتظار معمول دارند، به‌ویژه در مورد <code>ICollection</code>. این تفاوت‌ها عمدتاً تاریخی هستند: چون Genericها بعداً وارد شدند، اینترفیس‌های Generic با بهره‌مندی از تجربه پیشین توسعه یافتند و اعضای متفاوت (و بهتری) انتخاب شدند.</p>
<p>به همین دلیل:</p>
<ul>
<li><code>ICollection&lt;T&gt;</code> از <code>ICollection</code> ارث‌بری نمی‌کند</li>
<li><code>IList&lt;T&gt;</code> از <code>IList</code> ارث‌بری نمی‌کند</li>
<li><code>IDictionary&lt;TKey, TValue&gt;</code> از <code>IDictionary</code> ارث‌بری نمی‌کند</li>
</ul>
<p>البته، یک کلاس مجموعه می‌تواند هر دو نسخه یک اینترفیس را پیاده‌سازی کند اگر مفید باشد (که اغلب مفید است).</p>
<p>دلیل ظریف‌تر دیگری که باعث شده <code>IList&lt;T&gt;</code> از <code>IList</code> ارث‌بری نکند این است که اگر این کار انجام شود، تبدیل به <code>IList&lt;T&gt;</code> موجب بازگشت یک اینترفیس با اعضای <code>Add(T)</code> و <code>Add(object)</code> می‌شود، که در واقع ایمنی نوع ایستا (static type safety) را نقض می‌کند، زیرا می‌توانستید با هر نوع شیئی <code>Add</code> را فراخوانی کنید.</p>
<hr>
<h3>این بخش شامل چه مواردی است 📖</h3>
<p>این بخش به <code>ICollection&lt;T&gt;</code> و <code>IList&lt;T&gt;</code> و نسخه‌های غیر Generic آن‌ها می‌پردازد؛ <strong>دیکشنری‌ها</strong> در صفحه ۳۹۴ تحت پوشش قرار دارند.</p>
<p>در کتابخانه‌های دات‌نت، هیچ منطق یکپارچه‌ای برای استفاده از واژه‌های &quot;collection&quot; و &quot;list&quot; وجود ندارد.
برای مثال، چون <code>IList&lt;T&gt;</code> نسخه‌ای با قابلیت بیشتر از <code>ICollection&lt;T&gt;</code> است، ممکن است انتظار داشته باشید کلاس <code>List&lt;T&gt;</code> به‌طور مشابه از کلاس <code>Collection&lt;T&gt;</code> کاربردی‌تر باشد، اما این‌گونه نیست. بهتر است این دو واژه را به‌طور کلی مترادف در نظر بگیرید، مگر آنکه نوع خاصی مدنظر باشد.</p>
<hr>
<h3>ICollection<T> و ICollection 📦</h3>
<p><code>ICollection&lt;T&gt;</code> اینترفیس استاندارد برای مجموعه‌های شمارش‌پذیر است. این اینترفیس امکان:</p>
<ul>
<li>تعیین اندازه مجموعه (<code>Count</code>)</li>
<li>بررسی وجود یک آیتم در مجموعه (<code>Contains</code>)</li>
<li>کپی مجموعه به آرایه (<code>ToArray</code>)</li>
<li>تعیین اینکه مجموعه فقط خواندنی است (<code>IsReadOnly</code>)</li>
</ul>
<p>و برای مجموعه‌های قابل نوشتن، امکان افزودن (<code>Add</code>)، حذف (<code>Remove</code>) و پاک کردن (<code>Clear</code>) عناصر را نیز فراهم می‌کند.
همچنین چون از <code>IEnumerable&lt;T&gt;</code> ارث‌بری می‌کند، می‌توان از دستور <code>foreach</code> نیز برای پیمایش آن استفاده کرد:</p>
<pre><code class="language-csharp">public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable
{
    int Count { get; }
    bool Contains(T item);
    void CopyTo(T[] array, int arrayIndex);
    bool IsReadOnly { get; }
    void Add(T item);
    bool Remove(T item);
    void Clear();
}
</code></pre>
<p>نسخه غیر Generic <code>ICollection</code> مشابه است و مجموعه‌ای شمارش‌پذیر ارائه می‌دهد، اما قابلیت تغییر محتویات مجموعه یا بررسی عضویت عناصر را ندارد:</p>
<pre><code class="language-csharp">public interface ICollection : IEnumerable
{
    int Count { get; }
    bool IsSynchronized { get; }
    object SyncRoot { get; }
    void CopyTo(Array array, int index);
}
</code></pre>
<p>این نسخه غیر Generic همچنین ویژگی‌هایی برای کمک به <strong>سینک کردن (synchronization)</strong> دارد (فصل ۱۴) — این ویژگی‌ها در نسخه Generic حذف شدند زیرا <strong>Thread Safety</strong> دیگر ذاتاً بخشی از مجموعه‌ها محسوب نمی‌شود.</p>
<p>هر دو اینترفیس نسبتاً ساده برای پیاده‌سازی هستند. اگر بخواهید یک <code>ICollection&lt;T&gt;</code> فقط خواندنی پیاده‌سازی کنید، متدهای <code>Add</code>، <code>Remove</code> و <code>Clear</code> باید <code>NotSupportedException</code> پرتاب کنند.</p>
<p>معمولاً این اینترفیس‌ها همراه با <code>IList</code> یا <code>IDictionary</code> پیاده‌سازی می‌شوند.
<strong>اینترفیس‌های IList<T> و IList 📋</strong></p>
<p><code>IList&lt;T&gt;</code> اینترفیس استاندارد برای مجموعه‌هایی است که می‌توان به عناصر آن‌ها با <strong>موقعیت (اندیس)</strong> دسترسی داشت. علاوه بر قابلیت‌هایی که از <code>ICollection&lt;T&gt;</code> و <code>IEnumerable&lt;T&gt;</code> به ارث برده، این اینترفیس امکان <strong>خواندن و نوشتن عنصر با استفاده از اندیس</strong> و <strong>درج/حذف عنصر بر اساس موقعیت</strong> را نیز فراهم می‌کند:</p>
<pre><code class="language-csharp">public interface IList&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable
{
    T this[int index] { get; set; }
    int IndexOf(T item);
    void Insert(int index, T item);
    void RemoveAt(int index);
}
</code></pre>
<p>متد <code>IndexOf</code> جستجوی خطی (linear search) در لیست انجام می‌دهد و اگر عنصر مشخص شده پیدا نشود، مقدار <code>-1</code> برمی‌گرداند.</p>
<p>نسخه غیر Generic <code>IList</code> اعضای بیشتری دارد، زیرا از <code>ICollection</code> کمتری ارث‌بری می‌کند:</p>
<pre><code class="language-csharp">public interface IList : ICollection, IEnumerable
{
    object this[int index] { get; set; }
    bool IsFixedSize { get; }
    bool IsReadOnly { get; }
    int Add(object value);
    void Clear();
    bool Contains(object value);
    int IndexOf(object value);
    void Insert(int index, object value);
    void Remove(object value);
    void RemoveAt(int index);
}
</code></pre>
<p>در نسخه غیر Generic، متد <code>Add</code> یک <strong>عدد صحیح (int)</strong> برمی‌گرداند که نشان‌دهنده <strong>اندیس عنصر اضافه‌شده</strong> است. در مقابل، متد <code>Add</code> در <code>ICollection&lt;T&gt;</code> دارای نوع بازگشتی <code>void</code> است.</p>
<p>کلاس عمومی <code>List&lt;T&gt;</code> نمونه بارز پیاده‌سازی هر دو اینترفیس <code>IList&lt;T&gt;</code> و <code>IList</code> است. آرایه‌های C# نیز هر دو نسخه Generic و Non-Generic <code>IList</code> را پیاده‌سازی می‌کنند، اگرچه متدهایی که برای اضافه یا حذف عناصر هستند، از طریق پیاده‌سازی صریح اینترفیس پنهان شده‌اند و در صورت فراخوانی، <code>NotSupportedException</code> پرتاب می‌کنند.</p>
<blockquote>
<p>⚠️ اگر تلاش کنید به یک <strong>آرایه چندبعدی</strong> از طریق ایندکسر <code>IList</code> دسترسی پیدا کنید، یک <code>ArgumentException</code> پرتاب خواهد شد. این نکته ممکن است هنگام نوشتن متدهایی مانند زیر مشکل‌ساز شود:</p>
</blockquote>
<pre><code class="language-csharp">public object FirstOrNull(IList list)
{
    if (list == null || list.Count == 0) return null;
    return list[0];
}
</code></pre>
<p>این کد ممکن است ظاهراً بی‌خطا باشد، اما اگر با آرایه چندبعدی فراخوانی شود، یک استثنا پرتاب خواهد کرد. می‌توان در زمان اجرا بررسی کرد که آیا آرایه چندبعدی است یا خیر:</p>
<pre><code class="language-csharp">list.GetType().IsArray &amp;&amp; list.GetType().GetArrayRank() &gt; 1
</code></pre>
<hr>
<h3>IReadOnlyCollection<T> و IReadOnlyList<T> 🔒</h3>
<p>.NET اینترفیس‌های <strong>مجموعه و لیست فقط خواندنی</strong> نیز دارد که فقط اعضای لازم برای عملیات <strong>فقط خواندنی</strong> را ارائه می‌دهند:</p>
<pre><code class="language-csharp">public interface IReadOnlyCollection&lt;out T&gt; : IEnumerable&lt;T&gt;, IEnumerable
{
    int Count { get; }
}

public interface IReadOnlyList&lt;out T&gt; : IReadOnlyCollection&lt;T&gt;,
                                       IEnumerable&lt;T&gt;, IEnumerable
{
    T this[int index] { get; }
}
</code></pre>
<p>از آنجا که پارامتر نوع (<code>T</code>) تنها در <strong>موقعیت خروجی</strong> استفاده می‌شود، به صورت <strong>Covariant</strong> علامت‌گذاری شده است. این امکان را می‌دهد که مثلاً <strong>لیستی از گربه‌ها</strong> به عنوان یک <strong>لیست فقط خواندنی از حیوانات</strong> تلقی شود.</p>
<p>در مقابل، <code>T</code> در <code>ICollection&lt;T&gt;</code> و <code>IList&lt;T&gt;</code> Covariant نیست، زیرا در هر دو موقعیت ورودی و خروجی استفاده می‌شود.</p>
<p>این اینترفیس‌ها نمایی <strong>فقط خواندنی</strong> از یک مجموعه یا لیست ارائه می‌کنند؛ پیاده‌سازی واقعی ممکن است هنوز قابل نوشتن باشد. اکثر مجموعه‌های قابل تغییر (Mutable) هم اینترفیس‌های فقط خواندنی و هم خواندنی/نوشتنی را پیاده‌سازی می‌کنند.</p>
<p>علاوه بر امکان کار با مجموعه‌ها به صورت Covariant، اینترفیس‌های فقط خواندنی اجازه می‌دهند یک کلاس <strong>نمایی فقط خواندنی از یک مجموعه خصوصی قابل نوشتن</strong> را به صورت عمومی ارائه کند. این موضوع در بخش <code>ReadOnlyCollection&lt;T&gt;</code> در صفحه ۴۰۶ نشان داده شده است.</p>
<blockquote>
<p><code>IReadOnlyList&lt;T&gt;</code> با نوع Windows Runtime <code>IVectorView&lt;T&gt;</code> مطابقت دارد.</p>
</blockquote>
<hr>
<h3>کلاس Array 🗃️</h3>
<p>کلاس <code>Array</code> کلاس پایه <strong>ضمنی (implicit)</strong> برای تمام آرایه‌های تک‌بعدی و چندبعدی است و یکی از <strong>اساسی‌ترین نوع‌ها</strong> است که اینترفیس‌های استاندارد مجموعه را پیاده‌سازی می‌کند.</p>
<p>کلاس <code>Array</code> یکپارچگی نوع را فراهم می‌کند، بنابراین یک مجموعه از <strong>متدهای مشترک</strong> برای تمام آرایه‌ها، صرف‌نظر از اعلان یا نوع عناصر، در دسترس است.</p>
<p>از آنجا که آرایه‌ها بسیار اساسی هستند، C# <strong>سینتکس ویژه‌ای برای اعلان و مقداردهی اولیه آن‌ها</strong> ارائه می‌دهد (که در فصل‌های ۲ و ۳ توضیح داده شد). وقتی آرایه‌ای با سینتکس C# اعلام می‌شود، <strong>CLR به طور ضمنی</strong> کلاس <code>Array</code> را زیرنوع‌دهی می‌کند و یک <strong>Pseudo-Type</strong> مناسب برای ابعاد و نوع عناصر آرایه ایجاد می‌کند. این Pseudo-Type اینترفیس‌های Generic نوع‌دار را پیاده‌سازی می‌کند، مانند <code>IList&lt;string&gt;</code>.</p>
<p>CLR همچنین هنگام ساخت آرایه‌ها به آن‌ها به صورت ویژه نگاه می‌کند و <strong>فضای متوالی در حافظه</strong> برای آن‌ها اختصاص می‌دهد. این کار باعث می‌شود <strong>دسترسی با اندیس به آرایه‌ها بسیار کارآمد</strong> باشد، اما اجازه تغییر اندازه بعد از ساخت را نمی‌دهد.</p>
<p>کلاس <code>Array</code> اینترفیس‌های مجموعه را تا <code>IList&lt;T&gt;</code> پیاده‌سازی می‌کند، هم در نسخه Generic و هم غیر Generic. خود <code>IList&lt;T&gt;</code> به صورت صریح پیاده‌سازی شده تا <strong>متدهایی مانند Add و Remove</strong> که برای آرایه‌های با طول ثابت نامناسب هستند، از رابط عمومی <code>Array</code> پنهان بمانند و در صورت فراخوانی استثنا پرتاب کنند.</p>
<p>کلاس <code>Array</code> یک متد <strong>استاتیک <code>Resize</code></strong> نیز ارائه می‌دهد، اما این متد با <strong>ایجاد یک آرایه جدید و کپی کردن هر عنصر</strong> کار می‌کند. این روش نه تنها ناکارآمد است، بلکه مراجع به آرایه اصلی در بخش‌های دیگر برنامه همچنان به نسخه اولیه اشاره خواهند کرد. راه حل بهتر برای مجموعه‌های قابل تغییر، استفاده از کلاس <code>List&lt;T&gt;</code> است (که در بخش بعدی توضیح داده می‌شود).</p>
<p>آرایه می‌تواند شامل عناصر <strong>Value-Type</strong> یا <strong>Reference-Type</strong> باشد. عناصر Value-Type در محل آرایه ذخیره می‌شوند، بنابراین یک آرایه از سه عدد صحیح طولانی (هر کدام ۸ بایت) <strong>۲۴ بایت حافظه متوالی</strong> اشغال می‌کند. اما عنصر Reference-Type تنها به اندازه یک مرجع فضای آرایه را اشغال می‌کند (۴ بایت در محیط ۳۲ بیتی یا ۸ بایت در محیط ۶۴ بیتی).</p>
<p>شکل ۷-۲ تأثیر این موضوع را در حافظه نشان می‌دهد:</p>
<pre><code class="language-csharp">StringBuilder[] builders = new StringBuilder[5];
builders[0] = new StringBuilder(&quot;builder1&quot;);
builders[1] = new StringBuilder(&quot;builder2&quot;);
builders[2] = new StringBuilder(&quot;builder3&quot;);

long[] numbers = new long[3];
numbers[0] = 12345;
numbers[1] = 54321;
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>چون <code>Array</code> یک کلاس است، <strong>آرایه‌ها همیشه خودشان نوع مرجع (Reference Type) هستند</strong>—صرف‌نظر از نوع عناصر آرایه. این بدان معناست که دستور زیر:</p>
<pre><code class="language-csharp">arrayB = arrayA
</code></pre>
<p>منجر به ایجاد <strong>دو متغیری می‌شود که به همان آرایه ارجاع می‌دهند</strong>.</p>
<p>به همین ترتیب، <strong>دو آرایه مجزا همیشه در آزمون برابری شکست خواهند خورد</strong>، مگر اینکه از یک <strong>مقایسه‌کننده برابری ساختاری (Structural Equality Comparer)</strong> استفاده کنید که هر عنصر آرایه را مقایسه می‌کند:</p>
<pre><code class="language-csharp">object[] a1 = { &quot;string&quot;, 123, true };
object[] a2 = { &quot;string&quot;, 123, true };

Console.WriteLine(a1 == a2);                         // False
Console.WriteLine(a1.Equals(a2));                    // False

IStructuralEquatable se1 = a1;
Console.WriteLine(se1.Equals(a2, StructuralComparisons.StructuralEqualityComparer));   // True
</code></pre>
<p>آرایه‌ها می‌توانند با فراخوانی متد <code>Clone</code> کپی شوند:</p>
<pre><code class="language-csharp">arrayB = arrayA.Clone();
</code></pre>
<p>اما این یک <strong>کپی سطحی (Shallow Clone)</strong> ایجاد می‌کند، یعنی فقط <strong>حافظه‌ای که خود آرایه اشغال کرده است</strong> کپی می‌شود. اگر آرایه شامل <strong>اشیاء Value-Type</strong> باشد، خود مقادیر کپی می‌شوند؛ اما اگر شامل <strong>اشیاء Reference-Type</strong> باشد، فقط <strong>ارجاعات (References)</strong> کپی می‌شوند، در نتیجه دو آرایه‌ای خواهید داشت که اعضای آن‌ها به <strong>همان اشیاء</strong> اشاره می‌کنند.</p>
<p>شکل ۷-۳ اثر این موضوع را هنگام افزودن کد زیر به مثال نشان می‌دهد:</p>
<pre><code class="language-csharp">StringBuilder[] builders2 = builders;
StringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>برای ایجاد یک <strong>کپی عمیق (Deep Copy)</strong>—که در آن <strong>زیر اشیاء Reference-Type</strong> نیز تکرار می‌شوند—باید از آرایه عبور کرده و هر عنصر را به‌صورت دستی کپی کنید. همان قوانین برای سایر انواع مجموعه‌ها در .NET نیز صدق می‌کند.</p>
<p>اگرچه <code>Array</code> عمدتاً برای استفاده با <strong>ایندکس‌های ۳۲ بیتی</strong> طراحی شده، اما از <strong>ایندکس‌های ۶۴ بیتی</strong> نیز پشتیبانی محدودی دارد (که به صورت تئوری امکان دسترسی به تا $2^{64}$ عنصر را می‌دهد) از طریق چندین متدی که هم <strong>Int32</strong> و هم <strong>Int64</strong> را می‌پذیرند. این اورلودها در عمل بی‌فایده هستند، زیرا <strong>CLR اجازه نمی‌دهد هیچ شیء—از جمله آرایه‌ها—بزرگ‌تر از دو گیگابایت باشد</strong> (چه در محیط ۳۲ بیتی و چه ۶۴ بیتی).</p>
<p>بسیاری از متدهایی که انتظار دارید در کلاس <code>Array</code> <strong>متد نمونه (Instance Method)</strong> باشند، در واقع <strong>متدهای استاتیک</strong> هستند. این تصمیم طراحی کمی عجیب است و به این معناست که هنگام جستجوی یک متد در <code>Array</code> باید هم <strong>متدهای استاتیک</strong> و هم <strong>متدهای نمونه</strong> را بررسی کنید.</p>
<hr>
<h3>ایجاد و ایندکس‌گذاری آرایه‌ها 🗂️</h3>
<p>ساده‌ترین راه برای ایجاد و ایندکس کردن آرایه‌ها، استفاده از ساختارهای زبانی C# است:</p>
<pre><code class="language-csharp">int[] myArray = { 1, 2, 3 };
int first = myArray[0];
int last = myArray[myArray.Length - 1];
</code></pre>
<p>همچنین می‌توانید یک آرایه را <strong>پویا (Dynamic)</strong> با استفاده از <code>Array.CreateInstance</code> بسازید. این روش به شما امکان می‌دهد نوع عنصر و <strong>بعد (Rank)</strong> را در زمان اجرا مشخص کنید و همچنین آرایه‌های <strong>غیر صفر-مبنا</strong> ایجاد کنید. آرایه‌های غیر صفر-مبنا با <strong>.NET Common Language Specification (CLS)</strong> سازگار نیستند و نباید به‌عنوان اعضای عمومی در کتابخانه‌هایی که ممکن است توسط برنامه‌ای در F# یا Visual Basic استفاده شوند، ارائه شوند.</p>
<p>متدهای <code>GetValue</code> و <code>SetValue</code> اجازه می‌دهند عناصر آرایه‌های پویا یا معمولی را دسترسی یا مقداردهی کنید:</p>
<pre><code class="language-csharp">// ایجاد آرایه رشته‌ای با 2 عنصر
Array a = Array.CreateInstance(typeof(string), 2);
a.SetValue(&quot;hi&quot;, 0);       // → a[0] = &quot;hi&quot;;
a.SetValue(&quot;there&quot;, 1);    // → a[1] = &quot;there&quot;;
string s = (string)a.GetValue(0);  // → s = a[0];

// تبدیل به آرایه C#:
string[] cSharpArray = (string[])a;
string s2 = cSharpArray[0];
</code></pre>
<p>آرایه‌های صفر-مبنا که به‌صورت پویا ایجاد می‌شوند، می‌توانند به آرایه‌ای از نوع مشابه یا <strong>سازگار</strong> در C# تبدیل شوند. برای مثال، اگر <code>Apple</code> از <code>Fruit</code> ارث‌بری کند، می‌توان <code>Apple[]</code> را به <code>Fruit[]</code> تبدیل کرد. این مسئله دلیل استفاده از کلاس <code>Array</code> به جای <code>object[]</code> برای نوع یکنواخت را توضیح می‌دهد، زیرا <code>object[]</code> با <strong>آرایه‌های چندبعدی و Value-Type</strong> سازگار نیست.</p>
<p><code>GetValue</code> و <code>SetValue</code> همچنین روی آرایه‌های ساخته شده توسط کامپایلر نیز کار می‌کنند و زمانی که می‌خواهید <strong>متدی بنویسید که با هر نوع و بعدی از آرایه کار کند</strong> مفید هستند. برای آرایه‌های چندبعدی، آن‌ها <strong>آرایه‌ای از ایندکس‌ها</strong> می‌پذیرند:</p>
<pre><code class="language-csharp">public object GetValue(params int[] indices)
public void SetValue(object value, params int[] indices)
</code></pre>
<p>مثال زیر، <strong>اولین عنصر هر آرایه‌ای را بدون توجه به بعد آن چاپ می‌کند</strong>:</p>
<pre><code class="language-csharp">void WriteFirstValue(Array a)
{
    Console.Write(a.Rank + &quot;-dimensional; &quot;);
    int[] indexers = new int[a.Rank]; // خودکار صفر-مبنا
    Console.WriteLine(&quot;First value is &quot; + a.GetValue(indexers));
}

void Demo()
{
    int[] oneD = { 1, 2, 3 };
    int[,] twoD = { {5,6}, {8,9} };
    WriteFirstValue(oneD);   // 1-dimensional; first value is 1
    WriteFirstValue(twoD);   // 2-dimensional; first value is 5
}
</code></pre>
<hr>
<p>برای <strong>آرایه‌هایی با نوع ناشناخته اما بعد مشخص</strong>، <strong>Generics</strong> راهکار ساده‌تر و کارآمدتری ارائه می‌دهند:</p>
<pre><code class="language-csharp">void WriteFirstValue&lt;T&gt;(T[] array)
{
    Console.WriteLine(array[0]);
}
</code></pre>
<p>متد <code>SetValue</code> در صورت ناسازگار بودن نوع عنصر با آرایه، استثنا پرتاب می‌کند.</p>
<p>هنگام ایجاد آرایه—چه با <strong>سینتکس زبان</strong> و چه با <code>Array.CreateInstance</code>—عناصر آرایه <strong>به‌صورت خودکار به مقدار پیش‌فرضشان مقداردهی می‌شوند</strong>. برای آرایه‌های Reference-Type، این مقداردهی با <code>null</code> انجام می‌شود؛ برای آرایه‌های Value-Type، اعضا به صورت بیت‌به‌بیت صفر می‌شوند.</p>
<p>کلاس <code>Array</code> همچنین متد <code>Clear</code> را ارائه می‌دهد تا به‌صورت اختیاری آرایه را پاکسازی کند:</p>
<pre><code class="language-csharp">public static void Clear(Array array, int index, int length);
</code></pre>
<p>این متد اندازه آرایه را تغییر نمی‌دهد، بر خلاف <code>ICollection&lt;T&gt;.Clear</code> که تعداد عناصر را به صفر کاهش می‌دهد.</p>
<hr>
<h3>پیمایش آرایه‌ها 🔄</h3>
<p>آرایه‌ها به‌راحتی با <strong>foreach</strong> پیمایش می‌شوند:</p>
<pre><code class="language-csharp">int[] myArray = { 1, 2, 3 };
foreach (int val in myArray)
    Console.WriteLine(val);
</code></pre>
<p>همچنین می‌توان از <strong>متد استاتیک <code>Array.ForEach</code></strong> استفاده کرد:</p>
<pre><code class="language-csharp">public static void ForEach&lt;T&gt;(T[] array, Action&lt;T&gt; action);
public delegate void Action&lt;T&gt;(T obj);
</code></pre>
<p>مثال بازنویسی شده با <code>Array.ForEach</code>:</p>
<pre><code class="language-csharp">Array.ForEach(new[] { 1, 2, 3 }, Console.WriteLine);
</code></pre>
<p>و در C# 12، می‌توان این را ساده‌تر کرد:</p>
<pre><code class="language-csharp">Array.ForEach([1, 2, 3], Console.WriteLine);
</code></pre>
<h3>طول و بعد آرایه 📏</h3>
<p>کلاس <code>Array</code> متدها و ویژگی‌های زیر را برای <strong>پرس‌وجو درباره طول و بعد</strong> آرایه ارائه می‌دهد:</p>
<pre><code class="language-csharp">public int  GetLength(int dimension);
public long GetLongLength(int dimension);
public int  Length { get; }
public long LongLength { get; }

public int GetLowerBound(int dimension);
public int GetUpperBound(int dimension);
public int Rank { get; }    // تعداد بعدهای آرایه را باز می‌گرداند
</code></pre>
<ul>
<li><code>GetLength</code> و <code>GetLongLength</code> طول یک بعد مشخص (0 برای آرایه‌های تک‌بعدی) را باز می‌گردانند.</li>
<li><code>Length</code> و <code>LongLength</code> تعداد کل عناصر آرایه را در <strong>تمامی ابعاد</strong> بازمی‌گردانند.</li>
<li><code>GetLowerBound</code> و <code>GetUpperBound</code> در آرایه‌های <strong>غیر صفر-مبنا</strong> کاربرد دارند. <code>GetUpperBound</code> همان نتیجه‌ی <code>GetLowerBound + GetLength</code> برای یک بعد مشخص را بازمی‌گرداند.</li>
</ul>
<hr>
<h3>جستجو در آرایه 🔍</h3>
<p>کلاس <code>Array</code> مجموعه‌ای از متدها را برای پیدا کردن عناصر در <strong>آرایه‌های تک‌بعدی</strong> ارائه می‌دهد:</p>
<ul>
<li>
<p><strong>متدهای BinarySearch</strong>
برای جستجوی سریع در یک آرایه مرتب برای یک عنصر مشخص.</p>
</li>
<li>
<p><strong>متدهای IndexOf / LastIndexOf</strong>
برای جستجوی آرایه‌های نامرتب برای یک عنصر خاص.</p>
</li>
<li>
<p><strong>متدهای Find / FindLast / FindIndex / FindLastIndex / FindAll / Exists / TrueForAll</strong>
برای جستجوی آرایه‌های نامرتب بر اساس معیار یک <strong>Predicate<T></strong>.</p>
</li>
</ul>
<p>نکات مهم:</p>
<ul>
<li>
<p>هیچ‌یک از متدهای جستجوی آرایه، در صورت پیدا نشدن عنصر، <strong>استثنا پرتاب نمی‌کنند</strong>.</p>
<ul>
<li>متدهایی که <strong>int</strong> بازمی‌گردانند، مقدار <code>-1</code> بازمی‌گردانند (فرض بر صفر-مبنا بودن آرایه).</li>
<li>متدهایی که نوع <strong>Generic</strong> بازمی‌گردانند، مقدار پیش‌فرض آن نوع را برمی‌گردانند (مثلاً <code>0</code> برای <code>int</code> یا <code>null</code> برای <code>string</code>).</li>
</ul>
</li>
<li>
<p><strong>BinarySearch</strong> سریع است، اما فقط روی آرایه‌های مرتب کار می‌کند و نیاز دارد عناصر <strong>ترتیب‌پذیر باشند</strong>. این متدها می‌توانند یک شیء <code>IComparer</code> یا <code>IComparer&lt;T&gt;</code> دریافت کنند تا ترتیب عناصر را تعیین کند (باید با ترتیبی که هنگام مرتب‌سازی اولیه استفاده شده، سازگار باشد). در صورت عدم ارائه، الگوریتم مرتب‌سازی پیش‌فرض نوع استفاده می‌شود (براساس <code>IComparable</code> / <code>IComparable&lt;T&gt;</code>).</p>
</li>
<li>
<p><strong>IndexOf / LastIndexOf</strong> صرفاً آرایه را پیمایش می‌کنند و موقعیت <strong>اولین یا آخرین عنصر مطابق</strong> را بازمی‌گردانند.</p>
</li>
<li>
<p>متدهای مبتنی بر <strong>Predicate</strong> اجازه می‌دهند <strong>Delegate</strong> یا <strong>Lambda Expression</strong> تصمیم بگیرد که آیا عنصر مشخصی با معیار موردنظر مطابقت دارد یا خیر.</p>
</li>
</ul>
<pre><code class="language-csharp">public delegate bool Predicate&lt;T&gt;(T obj);
</code></pre>
<p>مثال:</p>
<pre><code class="language-csharp">string[] names = { &quot;Rodney&quot;, &quot;Jack&quot;, &quot;Jill&quot; };
string match = Array.Find(names, ContainsA);
Console.WriteLine(match); // Jack

bool ContainsA(string name) { return name.Contains(&quot;a&quot;); }
</code></pre>
<p>همان مثال با <strong>Lambda Expression</strong>:</p>
<pre><code class="language-csharp">string[] names = { &quot;Rodney&quot;, &quot;Jack&quot;, &quot;Jill&quot; };
string match = Array.Find(names, n =&gt; n.Contains(&quot;a&quot;)); // Jack
</code></pre>
<ul>
<li>
<p><code>FindAll</code> آرایه‌ای شامل <strong>تمام عناصر مطابق با Predicate</strong> بازمی‌گرداند و مشابه <code>Enumerable.Where</code> در <code>System.Linq</code> است، با این تفاوت که خروجی به صورت آرایه است، نه <code>IEnumerable&lt;T&gt;</code>.</p>
</li>
<li>
<p><code>Exists</code> باز می‌گرداند <code>true</code> اگر <strong>هر عضو آرایه</strong> معیار Predicate را برآورده کند، مشابه <code>Any</code> در <code>System.Linq.Enumerable</code>.</p>
</li>
<li>
<p><code>TrueForAll</code> باز می‌گرداند <code>true</code> اگر <strong>همه عناصر</strong> معیار Predicate را برآورده کنند، مشابه <code>All</code> در <code>System.Linq.Enumerable</code>.</p>
</li>
</ul>
<h3>مرتب‌سازی آرایه 🗂️</h3>
<p>کلاس <code>Array</code> چندین متد <strong>مرتب‌سازی داخلی</strong> دارد:</p>
<pre><code class="language-csharp">// مرتب‌سازی یک آرایه تک‌بعدی:
public static void Sort&lt;T&gt;(T[] array);
public static void Sort(Array array);

// مرتب‌سازی جفت آرایه‌ها:
public static void Sort&lt;TKey,TValue&gt;(TKey[] keys, TValue[] items);
public static void Sort(Array keys, Array items);
</code></pre>
<p>هر یک از این متدها به‌صورت <strong>Overload</strong> می‌توانند پارامترهای زیر را هم بگیرند:</p>
<ul>
<li><code>int index</code> → شروع مرتب‌سازی از ایندکس مشخص</li>
<li><code>int length</code> → تعداد عناصر برای مرتب‌سازی</li>
<li><code>IComparer&lt;T&gt; comparer</code> → شیء تعیین‌کننده ترتیب عناصر</li>
<li><code>Comparison&lt;T&gt; comparison</code> → Delegate تعیین‌کننده ترتیب عناصر</li>
</ul>
<p>مثال ساده:</p>
<pre><code class="language-csharp">int[] numbers = { 3, 2, 1 };
Array.Sort(numbers);  // آرایه حالا { 1, 2, 3 }
</code></pre>
<p>متدهای <strong>جفت آرایه‌ای</strong>، عناصر هر دو آرایه را <strong>به‌صورت هم‌زمان مرتب</strong> می‌کنند و ترتیب را براساس آرایه اول اعمال می‌کنند:</p>
<pre><code class="language-csharp">int[] numbers = { 3, 2, 1 };
string[] words = { &quot;three&quot;, &quot;two&quot;, &quot;one&quot; };
Array.Sort(numbers, words);
// numbers → { 1, 2, 3 }
// words   → { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; }
</code></pre>
<blockquote>
<p>⚠️ نکته: <code>Array.Sort</code> نیاز دارد که عناصر آرایه <code>IComparable</code> را پیاده‌سازی کنند. اگر عناصر قابل مقایسه ذاتی نباشند یا بخواهید ترتیب پیش‌فرض را تغییر دهید، باید <strong>Comparison سفارشی</strong> یا شیء <code>IComparer&lt;T&gt;</code> ارائه دهید.</p>
</blockquote>
<p>مثال با <strong>Comparison Delegate</strong>:</p>
<pre><code class="language-csharp">public delegate int Comparison&lt;T&gt;(T x, T y);
</code></pre>
<ul>
<li>اگر <code>x</code> قبل از <code>y</code> باشد → عدد منفی بازمی‌گرداند</li>
<li>اگر <code>x</code> بعد از <code>y</code> باشد → عدد مثبت بازمی‌گرداند</li>
<li>اگر برابر باشند → <code>0</code> بازمی‌گرداند</li>
</ul>
<p>مثال عملی:</p>
<pre><code class="language-csharp">int[] numbers = { 1, 2, 3, 4, 5 };
Array.Sort(numbers, (x, y) =&gt; x % 2 == y % 2 ? 0 : x % 2 == 1 ? -1 : 1);
// numbers → { 1, 3, 5, 2, 4 }
</code></pre>
<ul>
<li>به جای <code>Array.Sort</code> می‌توانید از <strong>LINQ</strong> و متدهای <code>OrderBy</code> و <code>ThenBy</code> استفاده کنید.
این روش <strong>آرایه اصلی را تغییر نمی‌دهد</strong> و خروجی را به صورت یک <code>IEnumerable&lt;T&gt;</code> مرتب‌شده ارائه می‌دهد.</li>
</ul>
<hr>
<h3>معکوس کردن عناصر 🔄</h3>
<p>کلاس <code>Array</code> متدهایی برای معکوس کردن تمام یا بخشی از آرایه ارائه می‌دهد:</p>
<pre><code class="language-csharp">public static void Reverse(Array array);
public static void Reverse(Array array, int index, int length);
</code></pre>
<hr>
<h3>کپی کردن آرایه 📋</h3>
<p>کلاس <code>Array</code> چهار روش برای <strong>کپی سطحی</strong> دارد: <code>Clone</code>، <code>CopyTo</code>، <code>Copy</code> و <code>ConstrainedCopy</code></p>
<ul>
<li>
<p><code>Clone</code> و <code>CopyTo</code> → <strong>متدهای نمونه‌ای</strong></p>
</li>
<li>
<p><code>Copy</code> و <code>ConstrainedCopy</code> → <strong>متدهای استاتیک</strong></p>
</li>
<li>
<p><code>Clone</code> → آرایه جدید (سطحی) بازمی‌گرداند</p>
</li>
<li>
<p><code>CopyTo</code> و <code>Copy</code> → بخش متوالی از آرایه را کپی می‌کنند</p>
<ul>
<li>برای آرایه‌های چندبعدی، باید <strong>ایندکس چندبعدی را به ایندکس خطی</strong> تبدیل کنید</li>
<li>مثال: خانه وسط <code>[1,1]</code> در آرایه 3×3 → <code>1 * 3 + 1 = 4</code></li>
<li>محدوده‌های منبع و مقصد می‌توانند <strong>همپوشانی داشته باشند</strong> بدون مشکل</li>
</ul>
</li>
<li>
<p><code>ConstrainedCopy</code> → عملیات <strong>اتمی</strong>؛ اگر همه عناصر نتوانند کپی شوند، عملیات بازگردانده می‌شود</p>
</li>
<li>
<p><code>AsReadOnly</code> → <strong>Wrapper</strong> بازمی‌گرداند که از تغییر عناصر جلوگیری می‌کند</p>
</li>
</ul>
<h3>تبدیل و تغییر اندازه آرایه 🔄📏</h3>
<p>کلاس <code>Array</code> متدهایی برای <strong>تبدیل عناصر آرایه</strong> و <strong>تغییر اندازه آرایه</strong> ارائه می‌دهد:</p>
<ul>
<li><code>Array.ConvertAll</code> → یک آرایه جدید از نوع <code>TOutput</code> ایجاد می‌کند و عناصر را با استفاده از <strong>Delegate تبدیل‌کننده</strong> کپی می‌کند.
تعریف Delegate به شکل زیر است:</li>
</ul>
<pre><code class="language-csharp">public delegate TOutput Converter&lt;TInput, TOutput&gt;(TInput input);
</code></pre>
<p>مثال:</p>
<pre><code class="language-csharp">float[] reals = { 1.3f, 1.5f, 1.8f };
int[] wholes = Array.ConvertAll(reals, r =&gt; Convert.ToInt32(r));
// wholes → { 1, 2, 2 }
</code></pre>
<ul>
<li><code>Array.Resize</code> → با ایجاد آرایه جدید و کپی عناصر، آرایه را تغییر اندازه می‌دهد و نتیجه را از طریق پارامتر مرجع بازمی‌گرداند.
⚠️ توجه: سایر مراجع به آرایه اصلی <strong>تغییری نمی‌کنند</strong>.</li>
</ul>
<blockquote>
<p>فضای نام <code>System.Linq</code> هم تعداد زیادی <strong>Extension Method</strong> برای تبدیل آرایه ارائه می‌دهد که خروجی آن <code>IEnumerable&lt;T&gt;</code> است و می‌توان دوباره با <code>ToArray</code> به آرایه تبدیل کرد.</p>
</blockquote>
<hr>
<h3>لیست‌ها، صف‌ها، پشته‌ها و مجموعه‌ها 📚🛒</h3>
<p>.NET مجموعه‌ای از کلاس‌های <strong>مجموعه‌ای آماده</strong> ارائه می‌دهد که رابط‌های معرفی‌شده در این فصل را پیاده‌سازی می‌کنند.
این بخش روی <strong>مجموعه‌های شبیه لیست</strong> تمرکز دارد و نه مجموعه‌های دیکشنری، که بعداً در فصل «Dictionaries» بررسی می‌کنیم.</p>
<ul>
<li>برای اکثر کلاس‌ها، می‌توانید نسخه <strong>Generic</strong> یا <strong>Non-Generic</strong> را انتخاب کنید.</li>
<li>کلاس‌های Generic از نظر <strong>انعطاف‌پذیری و عملکرد</strong> بهترند و نسخه غیرجنریک معمولاً فقط برای <strong>سازگاری با نسخه‌های قدیمی</strong> لازم است.</li>
<li>از بین این کلاس‌ها، <code>List&lt;T&gt;</code> پرکاربردترین است.</li>
</ul>
<hr>
<h3>کلاس‌های List<T> و ArrayList 📝</h3>
<ul>
<li>کلاس Generic <code>List&lt;T&gt;</code> و Non-Generic <code>ArrayList</code> آرایه‌ای <strong>پویا</strong> از اشیاء فراهم می‌کنند.</li>
<li><code>ArrayList</code> → پیاده‌سازی <code>IList</code></li>
<li><code>List&lt;T&gt;</code> → پیاده‌سازی <code>IList</code> و <code>IList&lt;T&gt;</code> (و نسخه فقط خواندنی <code>IReadOnlyList&lt;T&gt;</code>)</li>
</ul>
<blockquote>
<p>تفاوت با آرایه‌ها: تمام این رابط‌ها <strong>عمومی پیاده‌سازی</strong> شده‌اند و متدهایی مانند <code>Add</code> و <code>Remove</code> <strong>مستقیماً قابل استفاده</strong> هستند.</p>
</blockquote>
<h4>جزئیات داخلی</h4>
<ul>
<li><code>List&lt;T&gt;</code> و <code>ArrayList</code> یک <strong>آرایه داخلی</strong> دارند که هنگام پر شدن، جایگزین با آرایه بزرگ‌تر می‌شود.</li>
<li>افزودن عنصر → سریع (معمولاً جای خالی در انتها وجود دارد)</li>
<li>درج عنصر → کند (چون همه عناصر بعد از نقطه درج باید جابجا شوند)</li>
<li>حذف عنصر → کند، به‌خصوص در ابتدای آرایه</li>
<li>جستجو → سریع با <code>BinarySearch</code>، در غیر این صورت کند (چون باید همه عناصر بررسی شوند)</li>
</ul>
<blockquote>
<p>اگر <code>T</code> یک نوع مقدار (Value Type) باشد، <code>List&lt;T&gt;</code> چندین برابر سریع‌تر از <code>ArrayList</code> است، چون از <strong>Boxing/Unboxing</strong> جلوگیری می‌کند.</p>
</blockquote>
<hr>
<h3>سازنده‌ها و متدهای مهم <code>List&lt;T&gt;</code> ⚙️</h3>
<pre><code class="language-csharp">public class List&lt;T&gt; : IList&lt;T&gt;, IReadOnlyList&lt;T&gt;
{
  public List();                          // آرایه خالی
  public List(IEnumerable&lt;T&gt; collection); // کپی از مجموعه موجود
  public List(int capacity);               // مشخص کردن ظرفیت اولیه

  // افزودن و درج
  public void Add(T item);
  public void AddRange(IEnumerable&lt;T&gt; collection);
  public void Insert(int index, T item);
  public void InsertRange(int index, IEnumerable&lt;T&gt; collection);

  // حذف
  public bool Remove(T item);
  public void RemoveAt(int index);
  public void RemoveRange(int index, int count);
  public int RemoveAll(Predicate&lt;T&gt; match);

  // دسترسی با ایندکس
  public T this[int index] { get; set; }
  public List&lt;T&gt; GetRange(int index, int count);
  public Enumerator&lt;T&gt; GetEnumerator();

  // کپی و تبدیل
  public T[] ToArray();
  public void CopyTo(T[] array);
  public void CopyTo(T[] array, int arrayIndex);
  public void CopyTo(int index, T[] array, int arrayIndex, int count);
  public ReadOnlyCollection&lt;T&gt; AsReadOnly();
  public List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt;(Converter&lt;T,TOutput&gt; converter);

  // سایر متدها
  public void Reverse();      // معکوس کردن ترتیب عناصر
  public int Capacity { get; set; }  // گسترش آرایه داخلی
  public void TrimExcess();   // کاهش آرایه داخلی به اندازه واقعی
  public void Clear();        // حذف تمام عناصر، Count=0
}
</code></pre>
<ul>
<li><code>List&lt;T&gt;</code> همچنین <strong>نسخه‌های نمونه‌ای تمام متدهای جستجو و مرتب‌سازی آرایه</strong> را دارد.</li>
</ul>
<hr>
<h3>مثال عملی با List<T> 🎯</h3>
<pre><code class="language-csharp">var words = new List&lt;string&gt;();          // لیست رشته‌ای
words.Add(&quot;melon&quot;);
words.Add(&quot;avocado&quot;);
words.AddRange([&quot;banana&quot;, &quot;plum&quot;]);
words.Insert(0, &quot;lemon&quot;);                // درج در ابتدا
words.InsertRange(0, [&quot;peach&quot;, &quot;nashi&quot;]); // درج چندگانه در ابتدا
words.Remove(&quot;melon&quot;);
words.RemoveAt(3);                        // حذف عنصر چهارم
words.RemoveRange(0, 2);                  // حذف دو عنصر اول
words.RemoveAll(s =&gt; s.StartsWith(&quot;n&quot;)); // حذف تمام رشته‌ها با شروع 'n'

Console.WriteLine(words[0]);              // اولین عنصر
Console.WriteLine(words[words.Count-1]);  // آخرین عنصر
foreach(string s in words) Console.WriteLine(s); // تمام عناصر

List&lt;string&gt; subset = words.GetRange(1, 2);      // از دوم تا سوم
string[] wordsArray = words.ToArray();          // تبدیل به آرایه
string[] existing = new string[1000];
words.CopyTo(0, existing, 998, 2);             // کپی دو عنصر اول به آرایه موجود
List&lt;string&gt; upperCaseWords = words.ConvertAll(s =&gt; s.ToUpper());
List&lt;int&gt; lengths = words.ConvertAll(s =&gt; s.Length);
</code></pre>
<hr>
<h3>تفاوت با ArrayList ⚠️</h3>
<pre><code class="language-csharp">ArrayList al = new ArrayList();
al.Add(&quot;hello&quot;);
string first = (string)al[0];              // نیاز به cast
string[] strArr = (string[])al.ToArray(typeof(string));
</code></pre>
<ul>
<li>چنین castهایی توسط کامپایلر <strong>چک نمی‌شوند</strong> و ممکن است در زمان اجرا خطا بدهند:</li>
</ul>
<pre><code class="language-csharp">int first = (int)al[0]; // Exception در زمان اجرا
</code></pre>
<ul>
<li><code>ArrayList</code> مشابه <code>List&lt;object&gt;</code> عمل می‌کند و برای <strong>لیست‌های چند نوعی</strong> مناسب است.</li>
<li>مزیت انتخاب <code>ArrayList</code> در این حالت: <strong>سهولت استفاده با Reflection</strong> نسبت به <code>List&lt;object&gt;</code></li>
</ul>
<blockquote>
<p>اگر <code>System.Linq</code> را وارد کنید، می‌توانید یک <code>ArrayList</code> را به یک <code>List&lt;T&gt;</code> جنریک تبدیل کنید:</p>
</blockquote>
<pre><code class="language-csharp">ArrayList al = new ArrayList();
al.AddRange(new[] { 1, 5, 9 });
List&lt;int&gt; list = al.Cast&lt;int&gt;().ToList();
</code></pre>
<ul>
<li><code>Cast</code> و <code>ToList</code> متدهای <strong>Extension</strong> در <code>System.Linq.Enumerable</code> هستند.</li>
</ul>
<h3>LinkedList<T> 🔗</h3>
<p><code>LinkedList&lt;T&gt;</code> یک <strong>لیست پیوندی دوطرفه (doubly linked list)</strong> جنریک است.</p>
<h4>ساختار</h4>
<ul>
<li>
<p>شامل <strong>گره‌ها (nodes)</strong> است که هر گره شامل سه چیز است:</p>
<ol>
<li><strong>مقدار (Value)</strong></li>
<li><strong>ارجاع به گره قبلی (Previous)</strong></li>
<li><strong>ارجاع به گره بعدی (Next)</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>شکل ساده:</p>
</blockquote>
<pre><code>null &lt;- [Node1] &lt;-&gt; [Node2] &lt;-&gt; [Node3] -&gt; null
</code></pre>
<h4>مزیت اصلی</h4>
<ul>
<li>درج عنصر در هر نقطه از لیست <strong>بسیار سریع و کارآمد</strong> است، زیرا فقط کافیست یک گره جدید بسازید و چند ارجاع را به‌روزرسانی کنید.</li>
</ul>
<h4>محدودیت</h4>
<ul>
<li><strong>دسترسی مستقیم با ایندکس وجود ندارد</strong>.</li>
<li>برای یافتن مکان درج یا جستجوی یک عنصر، باید از ابتدا یا انتهای لیست پیمایش کنید.</li>
<li><strong>جستجوی باینری یا دسترسی تصادفی به عناصر امکان‌پذیر نیست</strong>.</li>
</ul>
<blockquote>
<p>بنابراین <code>LinkedList&lt;T&gt;</code> زمانی مناسب است که <strong>عملیات درج و حذف در میانه لیست</strong> زیاد انجام می‌شود و نیاز به <strong>دسترسی مستقیم به عناصر کمتر</strong> است.</p>
</blockquote>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>LinkedList<T> 🔗 – ادامه</h3>
<p><code>LinkedList&lt;T&gt;</code> پیاده‌سازی می‌شود از <strong>IEnumerable<T> و ICollection<T></strong> (و نسخه‌های غیرجنریک آن‌ها) اما <strong>IList<T> پیاده‌سازی نمی‌شود</strong>، چون <strong>دسترسی بر اساس ایندکس پشتیبانی نمی‌شود</strong>.</p>
<h4>گره‌ها</h4>
<p>گره‌های لیست با کلاس زیر پیاده‌سازی می‌شوند:</p>
<pre><code class="language-csharp">public sealed class LinkedListNode&lt;T&gt;
{
  public LinkedList&lt;T&gt; List { get; }      // ارجاع به لیست والد
  public LinkedListNode&lt;T&gt; Next { get; }  // گره بعدی
  public LinkedListNode&lt;T&gt; Previous { get; } // گره قبلی
  public T Value { get; set; }            // مقدار ذخیره‌شده
}
</code></pre>
<h4>افزودن گره‌ها</h4>
<p>می‌توانید موقعیت گره جدید را <strong>نسبت به گره‌ای دیگر</strong> یا <strong>در ابتدای/انتهای لیست</strong> مشخص کنید:</p>
<pre><code class="language-csharp">public void AddFirst(LinkedListNode&lt;T&gt; node);
public LinkedListNode&lt;T&gt; AddFirst(T value);
public void AddLast(LinkedListNode&lt;T&gt; node);
public LinkedListNode&lt;T&gt; AddLast(T value);
public void AddAfter(LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);
public LinkedListNode&lt;T&gt; AddAfter(LinkedListNode&lt;T&gt; node, T value);
public void AddBefore(LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);
public LinkedListNode&lt;T&gt; AddBefore(LinkedListNode&lt;T&gt; node, T value);
</code></pre>
<h4>حذف گره‌ها</h4>
<p>متدهای مشابه برای حذف عناصر وجود دارد:</p>
<pre><code class="language-csharp">public void Clear();
public void RemoveFirst();
public void RemoveLast();
public bool Remove(T value);
public void Remove(LinkedListNode&lt;T&gt; node);
</code></pre>
<h4>خواص عمومی</h4>
<p>لیست داخلی LinkedList<T> شامل <strong>تعداد عناصر</strong> و <strong>سر و ته لیست</strong> است و با خواص زیر در دسترس قرار دارد:</p>
<pre><code class="language-csharp">public int Count { get; }                     // سریع
public LinkedListNode&lt;T&gt; First { get; }       // سریع
public LinkedListNode&lt;T&gt; Last { get; }        // سریع
</code></pre>
<h4>جستجو</h4>
<p>LinkedList<T> متدهای جستجوی زیر را ارائه می‌دهد (با پیمایش داخلی لیست):</p>
<pre><code class="language-csharp">public bool Contains(T value);
public LinkedListNode&lt;T&gt; Find(T value);
public LinkedListNode&lt;T&gt; FindLast(T value);
</code></pre>
<h4>کپی و پیمایش</h4>
<p>برای پردازش ایندکس‌بندی‌شده و استفاده از <code>foreach</code>:</p>
<pre><code class="language-csharp">public void CopyTo(T[] array, int index);
public Enumerator&lt;T&gt; GetEnumerator();
</code></pre>
<h4>مثال عملی</h4>
<pre><code class="language-csharp">var tune = new LinkedList&lt;string&gt;();
tune.AddFirst(&quot;do&quot;);                            // do
tune.AddLast(&quot;so&quot;);                             // do - so
tune.AddAfter(tune.First, &quot;re&quot;);                // do - re - so
tune.AddAfter(tune.First.Next, &quot;mi&quot;);           // do - re - mi - so
tune.AddBefore(tune.Last, &quot;fa&quot;);                // do - re - mi - fa - so
tune.RemoveFirst();                             // re - mi - fa - so
tune.RemoveLast();                              // re - mi - fa
LinkedListNode&lt;string&gt; miNode = tune.Find(&quot;mi&quot;);
tune.Remove(miNode);                            // re - fa
tune.AddFirst(miNode);                          // mi - re - fa

foreach (string s in tune) 
    Console.WriteLine(s);
</code></pre>
<blockquote>
<p>این مثال نشان می‌دهد چگونه می‌توان عناصر را اضافه، حذف و جستجو کرد و از پیمایش foreach برای چاپ استفاده کرد.</p>
</blockquote>
<h3>Queue<T> و Stack<T> ⏳📚</h3>
<h4>Queue<T> – صف (FIFO)</h4>
<p><code>Queue&lt;T&gt;</code> و نسخه غیرجنریک <code>Queue</code> پیاده‌سازی می‌شوند از <strong>Enumerable و ICollection</strong> و نماینده یک ساختار داده <strong>First-In-First-Out (FIFO)</strong> هستند:</p>
<ul>
<li><strong>Enqueue(T item)</strong> → اضافه کردن به انتهای صف</li>
<li><strong>Dequeue()</strong> → حذف و بازگرداندن عنصر از ابتدای صف</li>
<li><strong>Peek()</strong> → مشاهده عنصر ابتدای صف بدون حذف آن</li>
<li><strong>Count</strong> → تعداد عناصر موجود</li>
<li><strong>ToArray()</strong> → کپی عناصر به یک آرایه برای دسترسی تصادفی</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var q = new Queue&lt;int&gt;();
q.Enqueue(10);
q.Enqueue(20);
int[] data = q.ToArray();       // کپی به آرایه
Console.WriteLine(q.Count);     // 2
Console.WriteLine(q.Peek());    // 10
Console.WriteLine(q.Dequeue()); // 10
Console.WriteLine(q.Dequeue()); // 20
Console.WriteLine(q.Dequeue()); // Exception (صف خالی)
</code></pre>
<blockquote>
<p>صف‌ها معمولاً با آرایه داخلی پیاده‌سازی می‌شوند و اندیس‌های سر و ته صف باعث سریع بودن عملیات Enqueue/Dequeue می‌شوند.</p>
</blockquote>
<hr>
<h4>Stack<T> – پشته (LIFO)</h4>
<p><code>Stack&lt;T&gt;</code> و نسخه غیرجنریک <code>Stack</code> نماینده یک ساختار داده <strong>Last-In-First-Out (LIFO)</strong> هستند:</p>
<ul>
<li><strong>Push(T item)</strong> → افزودن به بالای پشته</li>
<li><strong>Pop()</strong> → حذف و بازگرداندن عنصر از بالای پشته</li>
<li><strong>Peek()</strong> → مشاهده عنصر بالای پشته بدون حذف آن</li>
<li><strong>Count</strong> → تعداد عناصر</li>
<li><strong>ToArray()</strong> → کپی عناصر برای دسترسی تصادفی</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var s = new Stack&lt;int&gt;();
s.Push(1);                      // Stack = 1
s.Push(2);                      // Stack = 1,2
s.Push(3);                      // Stack = 1,2,3
Console.WriteLine(s.Count);     // 3
Console.WriteLine(s.Peek());    // 3
Console.WriteLine(s.Pop());     // 3
Console.WriteLine(s.Pop());     // 2
Console.WriteLine(s.Pop());     // 1
Console.WriteLine(s.Pop());     // Exception
</code></pre>
<blockquote>
<p>پشته‌ها هم مشابه صف‌ها با آرایه داخلی پیاده‌سازی می‌شوند و در صورت نیاز به تغییر اندازه، آرایه داخلی بزرگ‌تر جایگزین می‌شود.</p>
</blockquote>
<hr>
<h4>BitArray – آرایه بیت 🟢⚫</h4>
<p><code>BitArray</code> یک <strong>مجموعه دینامیک از مقادیر bool</strong> است که <strong>هر عنصر فقط یک بیت حافظه اشغال می‌کند</strong> و نسبت به آرایه معمولی bool یا List<bool> بسیار حافظه‌کارآمد است.</p>
<ul>
<li>دسترسی به بیت‌ها با <strong>Indexer</strong>:</li>
</ul>
<pre><code class="language-csharp">var bits = new BitArray(2);
bits[1] = true;
</code></pre>
<ul>
<li>عملیات‌های بیت به بیت: <strong>And, Or, Xor, Not</strong></li>
</ul>
<pre><code class="language-csharp">bits.Xor(bits);               // XOR بیت‌ها با خودشان
Console.WriteLine(bits[1]);   // False
</code></pre>
<blockquote>
<p>BitArray برای ذخیره و پردازش مجموعه‌های بزرگ بیتی بسیار مناسب است.</p>
</blockquote>
<h3>HashSet<T> و SortedSet<T> 🔹🔸</h3>
<h4>ویژگی‌های مشترک</h4>
<p><code>HashSet&lt;T&gt;</code> و <code>SortedSet&lt;T&gt;</code> مجموعه‌هایی از عناصر یکتا هستند که چند ویژگی مهم دارند:</p>
<ul>
<li><strong>Contains</strong> بسیار سریع با استفاده از <strong>hash lookup</strong> اجرا می‌شود.</li>
<li><strong>عناصر تکراری ذخیره نمی‌شوند</strong> و اضافه کردن تکراری نادیده گرفته می‌شود.</li>
<li><strong>دسترسی به عنصر با موقعیت (index) امکان‌پذیر نیست.</strong></li>
</ul>
<h4>تفاوت اصلی</h4>
<ul>
<li><code>SortedSet&lt;T&gt;</code> عناصر را مرتب نگه می‌دارد.</li>
<li><code>HashSet&lt;T&gt;</code> ترتیب عناصر را حفظ نمی‌کند.</li>
</ul>
<p>هر دو پیاده‌سازی <code>ISet&lt;T&gt;</code>, <code>ICollection&lt;T&gt;</code> و از .NET 5 به بعد <code>IReadOnlySet&lt;T&gt;</code> را دارند.</p>
<ul>
<li><code>HashSet&lt;T&gt;</code> → با <strong>Hashtable</strong> پیاده‌سازی می‌شود.</li>
<li><code>SortedSet&lt;T&gt;</code> → با <strong>Red-Black Tree</strong> پیاده‌سازی می‌شود.</li>
</ul>
<p>متدهای پایه شامل <code>Contains</code>, <code>Add</code>, <code>Remove</code> و <code>RemoveWhere</code> هستند.</p>
<hr>
<h4>مثال HashSet<T></h4>
<pre><code class="language-csharp">var letters = new HashSet&lt;char&gt;(&quot;the quick brown fox&quot;);
Console.WriteLine(letters.Contains('t')); // true
Console.WriteLine(letters.Contains('j')); // false

foreach (char c in letters)
    Console.Write(c); // عناصر بدون تکرار: the quickbrownfx
</code></pre>
<hr>
<h4>عملیات مجموعه‌ای (Set Operations)</h4>
<p><strong>تغییر دهنده مجموعه (Destructive):</strong></p>
<ul>
<li><code>UnionWith(IEnumerable&lt;T&gt; other)</code> → ترکیب</li>
<li><code>IntersectWith(IEnumerable&lt;T&gt; other)</code> → اشتراک</li>
<li><code>ExceptWith(IEnumerable&lt;T&gt; other)</code> → حذف عناصر مشخص</li>
<li><code>SymmetricExceptWith(IEnumerable&lt;T&gt; other)</code> → فقط عناصر یکتا در یکی از مجموعه‌ها</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var letters = new HashSet&lt;char&gt;(&quot;the quick brown fox&quot;);
letters.IntersectWith(&quot;aeiou&quot;); // فقط حروف صدادار
foreach (char c in letters) Console.Write(c); // euio
</code></pre>
<ul>
<li>روش‌های <strong>غیرتغییری (Non-destructive)</strong> برای بررسی مجموعه:
<code>IsSubsetOf</code>, <code>IsProperSubsetOf</code>, <code>IsSupersetOf</code>, <code>IsProperSupersetOf</code>, <code>Overlaps</code>, <code>SetEquals</code></li>
</ul>
<hr>
<h4>SortedSet<T> ویژگی‌های اضافه</h4>
<ul>
<li><code>GetViewBetween(T lowerValue, T upperValue)</code> → بازه از عناصر</li>
<li><code>Reverse()</code> → بازگرداندن ترتیب معکوس</li>
<li><code>Min</code> و <code>Max</code> → کوچک‌ترین و بزرگ‌ترین عنصر</li>
<li>پذیرش <code>IComparer&lt;T&gt;</code> در سازنده برای سفارشی‌سازی ترتیب</li>
</ul>
<p>مثال:</p>
<pre><code class="language-csharp">var letters = new SortedSet&lt;char&gt;(&quot;the quick brown fox&quot;);
foreach (char c in letters) Console.Write(c); // bcefhiknoqrtuwx
foreach (char c in letters.GetViewBetween('f', 'i'))
    Console.Write(c); // fhi
</code></pre>
<hr>
<h3>نکته مهم</h3>
<ul>
<li>هر دو مجموعه قابل تکرار (<code>IEnumerable&lt;T&gt;</code>) هستند، بنابراین می‌توان هر نوع مجموعه یا لیست را به عنوان آرگومان در عملیات مجموعه‌ای استفاده کرد.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>در <strong>نماد Big-O</strong>، زمان بازیابی (retrieval) بر اساس کلید برای انواع دیکشنری‌ها به شرح زیر است:</p>
<table>
<thead>
<tr>
<th>ساختار داده</th>
<th>زمان بازیابی (Big-O)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Hashtable</strong>, <strong>Dictionary</strong>, <strong>OrderedDictionary</strong></td>
<td>O(1) → تقریباً فوری</td>
</tr>
<tr>
<td><strong>SortedDictionary</strong>, <strong>SortedList</strong></td>
<td>O(log n) → لگاریتمی</td>
</tr>
<tr>
<td><strong>ListDictionary</strong> و انواع غیر دیکشنری مانند <strong>List<T></strong></td>
<td>O(n) → خطی، یعنی باید همه عناصر را بررسی کرد</td>
</tr>
</tbody>
</table>
<p><strong>توضیح:</strong></p>
<ul>
<li><code>n</code> تعداد عناصر موجود در مجموعه است.</li>
<li>دیکشنری‌های مبتنی بر هش (Hashtable, Dictionary) تقریباً ثابت هستند چون از hashing برای یافتن کلید استفاده می‌کنند.</li>
<li>دیکشنری‌های مرتب (SortedDictionary/SortedList) از درخت یا ساختار مرتب استفاده می‌کنند، بنابراین جستجو لگاریتمی است.</li>
<li>لیست‌های ساده یا ListDictionary باید عنصر به عنصر جستجو کنند، بنابراین زمان بازیابی خطی است.</li>
</ul>
<p>در این بخش، توضیح داده شده که <strong>IDictionary&lt;TKey, TValue&gt;</strong> و نسخه‌ی غیرجنریک آن <strong>IDictionary</strong> چگونه کار می‌کنند و کلاس‌های معمولی مانند <strong>Dictionary&lt;TKey, TValue&gt;</strong> و <strong>Hashtable</strong> از چه مکانیسمی استفاده می‌کنند. در ادامه خلاصه و نکات مهم آورده شده است:</p>
<hr>
<h3>۱. رابط IDictionary&lt;TKey,TValue&gt;</h3>
<p>رابط <strong>IDictionary&lt;TKey,TValue&gt;</strong> استانداردی برای مجموعه‌های کلید/مقدار ارائه می‌دهد و امکانات زیر را دارد:</p>
<pre><code class="language-csharp">public interface IDictionary&lt;TKey, TValue&gt; : ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable
{
    bool ContainsKey(TKey key);
    bool TryGetValue(TKey key, out TValue value);
    void Add(TKey key, TValue value);
    bool Remove(TKey key);
    TValue this[TKey key] { get; set; } // دسترسی به مقدار بر اساس کلید
    ICollection&lt;TKey&gt; Keys { get; }     // مجموعه کلیدها
    ICollection&lt;TValue&gt; Values { get; } // مجموعه مقادیر
}
</code></pre>
<ul>
<li><strong>Add</strong>: یک عنصر جدید اضافه می‌کند، اگر کلید تکراری باشد، استثناء می‌دهد.</li>
<li><strong>Indexer (<code>this[TKey]</code>)</strong>: اگر کلید موجود نباشد، استثناء پرتاب می‌کند.</li>
<li><strong>TryGetValue</strong>: سعی می‌کند مقدار را دریافت کند، اگر کلید نباشد <code>false</code> برمی‌گرداند.</li>
<li><strong>ContainsKey</strong>: بررسی می‌کند که کلید وجود دارد یا نه.</li>
</ul>
<hr>
<h3>۲. رابط IReadOnlyDictionary&lt;TKey,TValue&gt;</h3>
<ul>
<li>فقط دسترسی خواندنی (Read-Only) به اعضای دیکشنری را ارائه می‌دهد.</li>
</ul>
<hr>
<h3>۳. نسخه غیرجنریک IDictionary</h3>
<ul>
<li>هنگام دسترسی به کلید غیرموجود با <strong>indexer</strong> مقدار <code>null</code> بازمی‌گرداند (به جای استثناء).</li>
<li>از متد <strong>Contains</strong> برای بررسی وجود کلید استفاده می‌کند.</li>
<li>هنگام enumeration، از ساختار <strong>DictionaryEntry</strong> استفاده می‌کند:</li>
</ul>
<pre><code class="language-csharp">public struct DictionaryEntry
{
    public object Key { get; set; }
    public object Value { get; set; }
}
</code></pre>
<hr>
<h3>۴. Dictionary&lt;TKey,TValue&gt; و Hashtable</h3>
<ul>
<li><strong>Dictionary&lt;TKey,TValue&gt;</strong> کلاس عمومی و پرکاربرد است، مبتنی بر <strong>Hashtable</strong>.</li>
<li>نسخه غیرجنریک آن <strong>Hashtable</strong> است.</li>
<li>کلیدها با استفاده از <strong>GetHashCode</strong> به هش تبدیل می‌شوند و سپس در &quot;bucket&quot; مناسب قرار می‌گیرند.</li>
<li>اگر چند مقدار در یک bucket باشند، جستجو خطی در آن bucket انجام می‌شود.</li>
<li>کلیدها باید قابلیت محاسبه hash و بررسی برابری را داشته باشند.</li>
</ul>
<h4>مثال استفاده از Dictionary&lt;TKey,TValue&gt;</h4>
<pre><code class="language-csharp">var d = new Dictionary&lt;string,int&gt;();
d.Add(&quot;One&quot;, 1);
d[&quot;Two&quot;] = 2;     // اضافه کردن
d[&quot;Two&quot;] = 22;    // بروزرسانی
Console.WriteLine(d[&quot;Two&quot;]);               // 22
Console.WriteLine(d.ContainsKey(&quot;One&quot;));   // true
int val = 0;
if (!d.TryGetValue(&quot;onE&quot;, out val))
    Console.WriteLine(&quot;No val&quot;);           // &quot;No val&quot;
</code></pre>
<ul>
<li>کلیدها <strong>تکراری نمی‌توانند باشند</strong>.</li>
<li>عناصر مرتب یا به ترتیب اضافه شدن <strong>ذخیره نمی‌شوند</strong>.</li>
</ul>
<hr>
<h3>۵. نکات عملکردی</h3>
<ul>
<li>استفاده از <strong>StringComparer.OrdinalIgnoreCase</strong> برای کلیدهای رشته‌ای می‌تواند برابری بدون حساسیت به حروف ایجاد کند.</li>
<li>مشخص کردن ظرفیت اولیه دیکشنری می‌تواند از resize داخلی جلوگیری کند و عملکرد را بهتر کند.</li>
</ul>
<h3>🗂️ OrderedDictionary</h3>
<p>یک <strong>OrderedDictionary</strong> یک دیکشنری غیرجنریک است که عناصر را در همان ترتیبی که اضافه شده‌اند نگه می‌دارد. با استفاده از <strong>OrderedDictionary</strong> می‌توانید به عناصر هم از طریق <strong>اندیس (index)</strong> و هم از طریق <strong>کلید (key)</strong> دسترسی داشته باشید.
یک <strong>OrderedDictionary</strong>، دیکشنری مرتب (sorted) نیست.
یک <strong>OrderedDictionary</strong> ترکیبی از <strong>Hashtable</strong> و <strong>ArrayList</strong> است. این یعنی تمام قابلیت‌های <strong>Hashtable</strong> را دارد، به علاوه توابعی مانند <strong>RemoveAt</strong> و یک اندیسری عددی. همچنین ویژگی‌های <strong>Keys</strong> و <strong>Values</strong> را ارائه می‌دهد که عناصر را در ترتیب اصلی‌شان باز می‌گردانند.
این کلاس در <strong>.NET 2.0</strong> معرفی شد؛ اما به‌طور عجیب، نسخه جنریک ندارد.</p>
<hr>
<h3>📋 ListDictionary و HybridDictionary</h3>
<p><strong>ListDictionary</strong> از یک <strong>لیست پیوندی تک‌جهته (singly linked list)</strong> برای ذخیره داده‌ها استفاده می‌کند. این دیکشنری <strong>مرتب‌سازی</strong> انجام نمی‌دهد، اما ترتیب ورودی اصلی عناصر را حفظ می‌کند.
<strong>ListDictionary</strong> با لیست‌های بزرگ بسیار کند است و تنها مزیت واقعی آن، کارایی بالا با لیست‌های بسیار کوچک (کمتر از ۱۰ عنصر) است.</p>
<p><strong>HybridDictionary</strong> یک <strong>ListDictionary</strong> است که هنگام رسیدن به اندازه خاصی به صورت خودکار به <strong>Hashtable</strong> تبدیل می‌شود تا مشکلات عملکردی <strong>ListDictionary</strong> رفع شود. ایده این است که وقتی دیکشنری کوچک است، مصرف حافظه کم باشد و وقتی دیکشنری بزرگ است، عملکرد مناسب داشته باشد. با این حال، با توجه به سربار تبدیل بین دو حالت—و این واقعیت که <strong>Dictionary</strong> در هر دو حالت سنگین یا کند نیست—استفاده از <strong>Dictionary</strong> از ابتدا هم انتخاب معقولی است.
هر دو کلاس فقط در نسخه غیرجنریک ارائه می‌شوند.</p>
<hr>
<h3>📈 Sorted Dictionaries</h3>
<p><strong>BCL</strong> دات‌نت دو کلاس دیکشنری ارائه می‌دهد که به صورت داخلی همیشه بر اساس <strong>کلید</strong> مرتب هستند:</p>
<ul>
<li><strong>SortedDictionary&lt;TKey,TValue&gt;</strong></li>
<li><strong>SortedList&lt;TKey,TValue&gt;</strong></li>
</ul>
<p>(در این بخش، <code>&lt;TKey,TValue&gt;</code> را به <code>&lt;,&gt;</code> خلاصه می‌کنیم.)</p>
<p><strong>SortedDictionary&lt;,&gt;</strong> از <strong>درخت قرمز/سیاه (red/black tree)</strong> استفاده می‌کند: یک ساختار داده طراحی‌شده برای عملکرد پایدار در هر سناریوی درج یا بازیابی.
<strong>SortedList&lt;,&gt;</strong> به صورت داخلی با یک جفت آرایه مرتب پیاده‌سازی شده است و دسترسی سریع (با جستجوی دودویی) ارائه می‌دهد، اما عملکرد درج ضعیفی دارد (چون مقادیر موجود باید برای اضافه کردن عنصر جدید جابه‌جا شوند).</p>
<p><strong>SortedDictionary&lt;,&gt;</strong> بسیار سریع‌تر از <strong>SortedList&lt;,&gt;</strong> در درج عناصر به صورت تصادفی است (خصوصاً با لیست‌های بزرگ). با این حال، <strong>SortedList&lt;,&gt;</strong> قابلیت اضافه دارد: دسترسی به عناصر هم از طریق <strong>اندیس</strong> و هم از طریق <strong>کلید</strong>. با یک <strong>SortedList</strong> می‌توانید مستقیماً به عنصر nام در ترتیب مرتب‌سازی بروید (از طریق اندیس در ویژگی‌های <strong>Keys/Values</strong>). برای انجام همین کار با <strong>SortedDictionary&lt;,&gt;</strong>، باید به صورت دستی روی n عنصر شمارش کنید. (یا می‌توانید یک کلاس بنویسید که <strong>SortedDictionary</strong> را با یک کلاس لیست ترکیب کند.)</p>
<p>هیچ‌یک از این سه مجموعه اجازه کلیدهای تکراری را نمی‌دهند (همانند همه دیکشنری‌ها).</p>
<p>همچنین یک نسخه غیرجنریک مشابه با عملکرد یکسان به نام <strong>SortedList</strong> وجود دارد.</p>
<hr>
<h3>🔍 مثال استفاده از SortedList</h3>
<p>مثال زیر با استفاده از <strong>reflection</strong>، تمام متدهای تعریف‌شده در <code>System.Object</code> را در یک <strong>SortedList</strong> با کلید نام متد بارگذاری می‌کند و سپس کلیدها و مقادیر آن‌ها را شمارش می‌کند:</p>
<pre><code class="language-csharp">// MethodInfo در فضای نام System.Reflection است
var sorted = new SortedList&lt;string, MethodInfo&gt;();
foreach (MethodInfo m in typeof(object).GetMethods())
    sorted[m.Name] = m;

foreach (string name in sorted.Keys)
    Console.WriteLine(name);

foreach (MethodInfo m in sorted.Values)
    Console.WriteLine(m.Name + &quot; returns a &quot; + m.ReturnType);
</code></pre>
<p>نتیجه شمارش اول:</p>
<pre><code>Equals
GetHashCode
GetType
ReferenceEquals
ToString
</code></pre>
<p>نتیجه شمارش دوم:</p>
<pre><code>Equals returns a System.Boolean
GetHashCode returns a System.Int32
GetType returns a System.Type
ReferenceEquals returns a System.Boolean
ToString returns a System.String
</code></pre>
<p>توجه کنید که دیکشنری از طریق <strong>اندیسری (indexer)</strong> پر شد. اگر به جای آن از متد <strong>Add</strong> استفاده می‌کردیم، خطا رخ می‌داد چون کلاس <code>object</code> متد <strong>Equals</strong> را overload کرده و نمی‌توان همان کلید را دوبار اضافه کرد. با استفاده از اندیسری، ورودی بعدی جایگزین ورودی قبلی می‌شود و این خطا جلوگیری می‌شود.</p>
<p>همچنین می‌توانید چندین عضو با یک کلید را با تبدیل هر مقدار به یک <strong>لیست</strong> ذخیره کنید:</p>
<pre><code class="language-csharp">SortedList&lt;string, List&lt;MethodInfo&gt;&gt;
</code></pre>
<p>در ادامه مثال، بازیابی <code>MethodInfo</code> با کلید <code>&quot;GetHashCode&quot;</code> همانند یک دیکشنری معمولی انجام می‌شود:</p>
<pre><code class="language-csharp">Console.WriteLine(sorted[&quot;GetHashCode&quot;]);  // Int32 GetHashCode()
</code></pre>
<p>همه کارهایی که تاکنون انجام داده‌ایم، با <strong>SortedDictionary&lt;,&gt;</strong> نیز قابل اجرا است. اما دو خط زیر، که آخرین کلید و مقدار را بازیابی می‌کنند، فقط با <strong>SortedList</strong> کار می‌کنند:</p>
<pre><code class="language-csharp">Console.WriteLine(sorted.Keys[sorted.Count - 1]);           // ToString
Console.WriteLine(sorted.Values[sorted.Count - 1].IsVirtual); // True
</code></pre>
<h3>🛠️ Collections قابل سفارشی‌سازی و پراکسی‌ها</h3>
<p>کلاس‌های مجموعه‌ای که در بخش‌های قبلی بررسی شد، راحت هستند چون می‌توانید مستقیماً نمونه‌سازی (instantiate) کنید، اما <strong>امکان کنترل رفتار هنگام افزودن یا حذف یک آیتم</strong> را به شما نمی‌دهند. در برنامه‌هایی با مجموعه‌های قوی‌تایپ (strongly typed)، گاهی به این کنترل نیاز دارید؛ برای مثال:</p>
<ul>
<li>🔹 اجرای یک <strong>رویداد (event)</strong> هنگام افزودن یا حذف آیتم</li>
<li>🔹 به‌روزرسانی <strong>ویژگی‌ها (properties)</strong> به خاطر آیتم اضافه یا حذف‌شده</li>
<li>🔹 تشخیص یک <strong>عملیات غیرمجاز افزودن/حذف</strong> و پرتاب استثنا (exception) (مثلاً اگر عملیات قوانین تجاری را نقض کند)</li>
</ul>
<p><strong>.NET BCL</strong> کلاس‌هایی برای این منظور ارائه می‌دهد که در فضای نام <code>System.Collections.ObjectModel</code> قرار دارند. این‌ها در اصل <strong>پراکسی‌ها یا wrapperها</strong> هستند که <code>IList&lt;T&gt;</code> یا <code>IDictionary&lt;,&gt;</code> را پیاده‌سازی می‌کنند و متدها را به یک مجموعه زیرین هدایت می‌کنند. هر عملیات <strong>Add</strong>، <strong>Remove</strong> یا <strong>Clear</strong> از طریق یک متد مجازی (virtual) هدایت می‌شود که هنگام override شدن به عنوان یک “درگاه” عمل می‌کند.</p>
<p>کلاس‌های مجموعه قابل سفارشی‌سازی معمولاً برای <strong>مجموعه‌های عمومی (publicly exposed)</strong> استفاده می‌شوند؛ مثلاً یک مجموعه از کنترل‌ها که به صورت عمومی در یک کلاس <code>System.Windows.Form</code> در دسترس است.</p>
<hr>
<h3>📦 Collection<T> و CollectionBase</h3>
<p>کلاس <strong>Collection<T></strong> یک <strong>wrapper قابل سفارشی‌سازی</strong> برای <code>List&lt;T&gt;</code> است.
علاوه بر پیاده‌سازی <code>IList&lt;T&gt;</code> و <code>IList</code>، چهار متد مجازی و یک ویژگی محافظت‌شده (protected) اضافه ارائه می‌دهد:</p>
<pre><code class="language-csharp">public class Collection&lt;T&gt; :
    IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable
{
    // ...
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    protected IList&lt;T&gt; Items { get; }
}
</code></pre>
<p>متدهای مجازی، <strong>درگاه</strong>ی برای “hook in” کردن شما فراهم می‌کنند تا رفتار پیش‌فرض لیست را تغییر یا تقویت کنید. ویژگی محافظت‌شده <strong>Items</strong> به پیاده‌ساز اجازه می‌دهد به <strong>لیست داخلی (inner list)</strong> دسترسی مستقیم داشته باشد و بدون فعال شدن متدهای مجازی، تغییرات داخلی ایجاد کند.</p>
<p>لازم نیست متدهای مجازی override شوند؛ می‌توان تا زمانی که نیازی به تغییر رفتار پیش‌فرض لیست وجود دارد، آن‌ها را دست‌نخورده گذاشت. مثال زیر استفاده معمولی <strong>Collection<T></strong> را نشان می‌دهد:</p>
<pre><code class="language-csharp">Zoo zoo = new Zoo();
zoo.Animals.Add(new Animal(&quot;Kangaroo&quot;, 10));
zoo.Animals.Add(new Animal(&quot;Mr Sea Lion&quot;, 20));
foreach (Animal a in zoo.Animals) Console.WriteLine(a.Name);

public class Animal
{
    public string Name;
    public int Popularity;
    public Animal(string name, int popularity)
    {
        Name = name; Popularity = popularity;
    }
}

public class AnimalCollection : Collection&lt;Animal&gt;
{
    // AnimalCollection هم اکنون یک لیست کامل از حیوانات است.
    // نیازی به کد اضافی نیست.
}

public class Zoo
{
    public readonly AnimalCollection Animals = new AnimalCollection();
}
</code></pre>
<p>همانطور که می‌بینیم، <strong>AnimalCollection</strong> از نظر عملکردی تفاوتی با یک <code>List&lt;Animal&gt;</code> ساده ندارد؛ نقش آن فراهم کردن پایه‌ای برای <strong>گسترش آینده</strong> است.</p>
<hr>
<h3>🔄 افزودن ویژگی Zoo به حیوانات و override متدهای مجازی</h3>
<p>اکنون می‌خواهیم به کلاس <code>Animal</code> ویژگی <code>Zoo</code> اضافه کنیم تا مرجع به باغ‌وحش خود را داشته باشد و همه متدهای مجازی <code>Collection&lt;Animal&gt;</code> را override کنیم تا این ویژگی به‌صورت خودکار مدیریت شود:</p>
<pre><code class="language-csharp">public class Animal
{
    public string Name;
    public int Popularity;
    public Zoo Zoo { get; internal set; }
    public Animal(string name, int popularity)
    {
        Name = name; Popularity = popularity;
    }
}

public class AnimalCollection : Collection&lt;Animal&gt;
{
    Zoo zoo;
    public AnimalCollection(Zoo zoo) { this.zoo = zoo; }

    protected override void InsertItem(int index, Animal item)
    {
        base.InsertItem(index, item);
        item.Zoo = zoo;
    }

    protected override void SetItem(int index, Animal item)
    {
        base.SetItem(index, item);
        item.Zoo = zoo;
    }

    protected override void RemoveItem(int index)
    {
        this[index].Zoo = null;
        base.RemoveItem(index);
    }

    protected override void ClearItems()
    {
        foreach (Animal a in this) a.Zoo = null;
        base.ClearItems();
    }
}

public class Zoo
{
    public readonly AnimalCollection Animals;
    public Zoo() { Animals = new AnimalCollection(this); }
}
</code></pre>
<p><strong>نکته مهم:</strong> <code>Collection&lt;T&gt;</code> همچنین یک سازنده می‌پذیرد که یک <code>IList&lt;T&gt;</code> موجود را دریافت می‌کند. برخلاف سایر کلاس‌های مجموعه، لیست ارائه‌شده <strong>proxied</strong> می‌شود نه کپی؛ بنابراین تغییرات بعدی در لیست اصلی، در <code>Collection&lt;T&gt;</code> نیز منعکس می‌شود (هرچند متدهای مجازی آن فعال نمی‌شوند). به همین ترتیب، تغییرات اعمال‌شده از طریق <code>Collection&lt;T&gt;</code>، لیست زیرین را تغییر می‌دهد.</p>
<hr>
<h3>⚙️ CollectionBase</h3>
<p><strong>CollectionBase</strong> نسخه غیرجنریک <code>Collection&lt;T&gt;</code> است. این کلاس بیشتر قابلیت‌های مشابه <code>Collection&lt;T&gt;</code> را ارائه می‌دهد اما استفاده از آن <strong>دست‌وپاگیرتر</strong> است.
به جای متدهای قالبی <strong>InsertItem</strong>، <strong>RemoveItem</strong>، <strong>SetItem</strong> و <strong>ClearItems</strong>، <strong>CollectionBase</strong> دارای متدهای “hook” است که تعداد متدها را دو برابر می‌کند:</p>
<ul>
<li><code>OnInsert</code>, <code>OnInsertComplete</code></li>
<li><code>OnSet</code>, <code>OnSetComplete</code></li>
<li><code>OnRemove</code>, <code>OnRemoveComplete</code></li>
<li><code>OnClear</code>, <code>OnClearComplete</code></li>
</ul>
<p>چون <strong>CollectionBase</strong> غیرجنریک است، هنگام subclass کردن باید متدهای تایپ‌شده نیز پیاده‌سازی کنید؛ حداقل یک <strong>اندیسری تایپ‌شده (typed indexer)</strong> و متد <strong>Add</strong>.</p>
<h3>🗝️ KeyedCollection&lt;TKey,TItem&gt; و DictionaryBase</h3>
<p>کلاس <strong>KeyedCollection&lt;TKey,TItem&gt;</strong> از <code>Collection&lt;TItem&gt;</code> مشتق شده و هم <strong>ویژگی‌هایی اضافه می‌کند</strong> و هم <strong>ویژگی‌هایی را حذف می‌کند</strong>.</p>
<ul>
<li>آنچه اضافه می‌کند: <strong>امکان دسترسی به آیتم‌ها از طریق کلید (key)</strong>، درست مانند یک دیکشنری.</li>
<li>آنچه حذف می‌کند: <strong>امکان proxy کردن لیست داخلی خود</strong>.</li>
</ul>
<p>یک مجموعه keyed شباهت‌هایی به <code>OrderedDictionary</code> دارد، زیرا <strong>لیست خطی را با یک Hashtable ترکیب می‌کند</strong>. با این حال، برخلاف <code>OrderedDictionary</code>، <strong>IDictionary را پیاده‌سازی نمی‌کند</strong> و مفهوم کلید/مقدار (key/value) را پشتیبانی نمی‌کند. <strong>کلیدها از خود آیتم‌ها گرفته می‌شوند</strong>، از طریق متد انتزاعی <code>GetKeyForItem</code>. این یعنی <strong>enumeration</strong> یک مجموعه keyed دقیقاً مانند enumeration یک لیست معمولی است.</p>
<p>می‌توانید <strong>KeyedCollection&lt;TKey,TItem&gt;</strong> را به‌عنوان <code>Collection&lt;TItem&gt;</code> به اضافه <strong>جستجوی سریع بر اساس کلید</strong> در نظر بگیرید.</p>
<p>چون این کلاس از <code>Collection&lt;&gt;</code> مشتق شده، تمام عملکردهای Collection&lt;&gt; را به ارث می‌برد، به جز امکان تعیین یک لیست موجود در سازنده. اعضای اضافی که تعریف می‌کند به صورت زیر هستند:</p>
<pre><code class="language-csharp">public abstract class KeyedCollection&lt;TKey, TItem&gt; : Collection&lt;TItem&gt;
{
    // ...
    protected abstract TKey GetKeyForItem(TItem item);
    protected void ChangeItemKey(TItem item, TKey newKey);
    // جستجوی سریع بر اساس کلید - علاوه بر جستجوی بر اساس اندیس
    public TItem this[TKey key] { get; }
    protected IDictionary&lt;TKey, TItem&gt; Dictionary { get; }
}
</code></pre>
<ul>
<li>متد <code>GetKeyForItem</code> توسط پیاده‌ساز override می‌شود تا <strong>کلید یک آیتم را از شیء زیرین</strong> دریافت کند.</li>
<li>متد <code>ChangeItemKey</code> باید <strong>هنگام تغییر کلید آیتم</strong> فراخوانی شود تا دیکشنری داخلی به‌روزرسانی شود.</li>
<li>ویژگی <code>Dictionary</code> دیکشنری داخلی را برمی‌گرداند که برای <strong>پیاده‌سازی جستجو</strong> استفاده می‌شود و هنگام افزودن اولین آیتم ساخته می‌شود. می‌توان رفتار ایجاد دیکشنری داخلی را با تعیین <strong>creation threshold</strong> در سازنده تغییر داد، به طوری که تا رسیدن به آستانه، جستجو با خطی انجام شود.</li>
</ul>
<p>یک دلیل خوب برای تعیین نکردن <strong>creation threshold</strong> این است که داشتن دیکشنری معتبر می‌تواند در <strong>دریافت ICollection&lt;&gt; از کلیدها</strong> مفید باشد، از طریق ویژگی <code>Keys</code> دیکشنری. این مجموعه سپس می‌تواند به یک ویژگی عمومی منتقل شود.</p>
<hr>
<h3>🐾 مثال: استفاده از KeyedCollection برای Zoo</h3>
<p>متداول‌ترین کاربرد <code>KeyedCollection&lt;,&gt;</code> فراهم کردن <strong>مجموعه‌ای از آیتم‌ها با دسترسی هم از طریق اندیس و هم از طریق نام</strong> است.</p>
<pre><code class="language-csharp">public class Animal
{
    string name;
    public string Name
    {
        get { return name; }
        set {
            if (Zoo != null) Zoo.Animals.NotifyNameChange(this, value);
            name = value;
        }
    }
    public int Popularity;
    public Zoo Zoo { get; internal set; }

    public Animal(string name, int popularity)
    {
        Name = name; Popularity = popularity;
    }
}

public class AnimalCollection : KeyedCollection&lt;string, Animal&gt;
{
    Zoo zoo;
    public AnimalCollection(Zoo zoo) { this.zoo = zoo; }

    internal void NotifyNameChange(Animal a, string newName) =&gt;
        this.ChangeItemKey(a, newName);

    protected override string GetKeyForItem(Animal item) =&gt; item.Name;

    // متدهای زیر مشابه مثال قبلی پیاده‌سازی می‌شوند:
    protected override void InsertItem(int index, Animal item)...
    protected override void SetItem(int index, Animal item)...
    protected override void RemoveItem(int index)...
    protected override void ClearItems()...
}

public class Zoo
{
    public readonly AnimalCollection Animals;
    public Zoo() { Animals = new AnimalCollection(this); }
}
</code></pre>
<p>مثال استفاده از آن:</p>
<pre><code class="language-csharp">Zoo zoo = new Zoo();
zoo.Animals.Add(new Animal(&quot;Kangaroo&quot;, 10));
zoo.Animals.Add(new Animal(&quot;Mr Sea Lion&quot;, 20));
Console.WriteLine(zoo.Animals[0].Popularity);               // 10
Console.WriteLine(zoo.Animals[&quot;Mr Sea Lion&quot;].Popularity);   // 20
zoo.Animals[&quot;Kangaroo&quot;].Name = &quot;Mr Roo&quot;;
Console.WriteLine(zoo.Animals[&quot;Mr Roo&quot;].Popularity);        // 10
</code></pre>
<hr>
<h3>🏛️ DictionaryBase</h3>
<p>نسخه غیرجنریک <code>KeyedCollection</code>، کلاس <strong>DictionaryBase</strong> است. این کلاس قدیمی <strong>رویکرد متفاوتی</strong> دارد:</p>
<ul>
<li><code>IDictionary</code> را پیاده‌سازی می‌کند</li>
<li>از متدهای hook دست‌وپاگیر مانند CollectionBase استفاده می‌کند:
<code>OnInsert</code>, <code>OnInsertComplete</code>, <code>OnSet</code>, <code>OnSetComplete</code>, <code>OnRemove</code>, <code>OnRemoveComplete</code>, <code>OnClear</code>, <code>OnClearComplete</code> و همچنین <code>OnGet</code>.</li>
</ul>
<p>مزیت اصلی پیاده‌سازی IDictionary نسبت به KeyedCollection این است که <strong>نیازی به subclass کردن برای دسترسی به کلیدها نیست</strong>. اما چون هدف DictionaryBase در اصل subclass شدن است، این مزیت چندان کاربردی ندارد.</p>
<p>مدل بهبود یافته در <strong>KeyedCollection</strong> احتمالاً به این دلیل است که چند سال بعد نوشته شده و از تجربیات گذشته بهره‌مند بوده است.
<strong>DictionaryBase</strong> بیشتر برای <strong>سازگاری با نسخه‌های قدیمی (backward compatibility)</strong> مفید است.</p>
<h3>🔒 ReadOnlyCollection<T></h3>
<p>کلاس <strong>ReadOnlyCollection<T></strong> یک <strong>wrapper</strong> یا <strong>proxy</strong> است که یک <strong>نمای فقط-خواندنی</strong> از یک مجموعه را فراهم می‌کند. این ویژگی به شما اجازه می‌دهد تا یک کلاس <strong>دسترسی عمومی فقط-خواندنی</strong> به یک مجموعه را ارائه دهد، در حالی که خود کلاس هنوز می‌تواند مجموعه را به‌صورت داخلی به‌روزرسانی کند.</p>
<p>یک مجموعه فقط-خواندنی، <strong>مجموعه ورودی را در سازنده خود دریافت می‌کند</strong> و یک <strong>ارجاع دائمی</strong> به آن نگه می‌دارد. این کلاس <strong>نسخه‌ای ایستا از مجموعه ورودی نمی‌سازد</strong>، بنابراین تغییرات بعدی در مجموعه ورودی از طریق wrapper فقط-خواندنی قابل مشاهده است.</p>
<p>برای مثال، فرض کنید کلاس شما می‌خواهد <strong>دسترسی عمومی فقط-خواندنی</strong> به لیستی از رشته‌ها به نام <code>Names</code> فراهم کند:</p>
<pre><code class="language-csharp">public class Test
{
    List&lt;string&gt; names = new List&lt;string&gt;();
    public IReadOnlyList&lt;string&gt; Names =&gt; names;
}
</code></pre>
<p>با اینکه <code>Names</code> یک رابط فقط-خواندنی بازمی‌گرداند، مصرف‌کننده هنوز می‌تواند در زمان اجرا به <code>List&lt;string&gt;</code> یا <code>IList&lt;string&gt;</code> <strong>downcast</strong> کند و سپس متدهای <code>Add</code>، <code>Remove</code> یا <code>Clear</code> را فراخوانی کند.</p>
<p>راه‌حل <strong>ReadOnlyCollection<T></strong> این مشکل را به صورت محکم‌تر حل می‌کند:</p>
<pre><code class="language-csharp">public class Test
{
    List&lt;string&gt; names = new List&lt;string&gt;();
    public ReadOnlyCollection&lt;string&gt; Names { get; private set; }

    public Test() =&gt; Names = new ReadOnlyCollection&lt;string&gt;(names);

    public void AddInternally() =&gt; names.Add(&quot;test&quot;);
}
</code></pre>
<p>در این حالت، تنها اعضای داخل کلاس <strong>Test</strong> می‌توانند لیست <code>names</code> را تغییر دهند:</p>
<pre><code class="language-csharp">Test t = new Test();
Console.WriteLine(t.Names.Count);       // 0
t.AddInternally();
Console.WriteLine(t.Names.Count);       // 1
t.Names.Add(&quot;test&quot;);                    // خطای کامپایل
((IList&lt;string&gt;)t.Names).Add(&quot;test&quot;);   // NotSupportedException
</code></pre>
<hr>
<h3>🛡️ Immutable Collections</h3>
<p>قبلاً توضیح دادیم که چگونه <strong>ReadOnlyCollection<T></strong> یک نمای فقط-خواندنی ایجاد می‌کند. محدود کردن توانایی نوشتن (mutate) یک مجموعه یا هر شیء دیگر، <strong>ساده‌سازی نرم‌افزار و کاهش باگ‌ها</strong> را به دنبال دارد.</p>
<p><strong>مجموعه‌های immutable</strong> این اصل را گسترش می‌دهند و <strong>مجموعه‌هایی ارائه می‌کنند که پس از مقداردهی اولیه اصلاً قابل تغییر نیستند</strong>. اگر بخواهید آیتمی به یک مجموعه immutable اضافه کنید، باید یک <strong>مجموعه جدید بسازید</strong> و مجموعه قدیمی بدون تغییر باقی بماند.</p>
<hr>
<h4>⚡ مزایای Immutable Collections</h4>
<ul>
<li><strong>از بین بردن تعداد زیادی از باگ‌ها</strong> که با تغییر وضعیت ایجاد می‌شوند.</li>
<li><strong>ساده‌سازی موازی‌سازی و چندنخی</strong> (multithreading) با اجتناب از بیشتر مشکلات thread-safety که در فصل‌های 14، 22 و 23 توضیح داده می‌شوند.</li>
<li><strong>ساده‌تر کردن منطق و تحلیل کد</strong>.</li>
</ul>
<h4>❌ معایب</h4>
<ul>
<li>هرگاه نیاز به تغییر باشد، باید <strong>کل شیء جدیدی ساخته شود</strong> که ممکن است <strong>هزینه عملکردی</strong> به همراه داشته باشد. با این حال، <strong>استراتژی‌هایی برای کاهش این هزینه</strong> وجود دارد، از جمله قابلیت <strong>استفاده مجدد از بخش‌هایی از ساختار اولیه</strong>.</li>
</ul>
<hr>
<p>مجموعه‌های immutable بخشی از <strong>.NET</strong> هستند (در .NET Framework، از طریق پکیج NuGet به نام <code>System.Collections.Immutable</code> قابل دسترسی‌اند). همه مجموعه‌ها در namespace زیر تعریف شده‌اند:</p>
<pre><code class="language-text">System.Collections.Immutable
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>🧱 ImmutableArray<T> و ImmutableList<T></h3>
<p>انواع <strong>ImmutableArray<T></strong> و <strong>ImmutableList<T></strong> هر دو نسخه‌های <strong>immutable</strong> از <strong>List<T></strong> هستند. هر دو کار مشابهی انجام می‌دهند، اما <strong>ویژگی‌های عملکردی متفاوتی</strong> دارند که در بخش «Immutable Collections and Performance» در صفحه 409 بررسی شده است.</p>
<p>مجموعه‌های immutable یک <strong>رابط عمومی مشابه نسخه‌های قابل تغییر</strong> خود ارائه می‌کنند. تفاوت کلیدی این است که <strong>متدهایی که به نظر می‌رسد مجموعه را تغییر می‌دهند</strong> (مثل <code>Add</code> یا <code>Remove</code>) در واقع <strong>مجموعه اصلی را تغییر نمی‌دهند</strong>؛ بلکه <strong>یک مجموعه جدید با آیتم اضافه یا حذف شده</strong> برمی‌گردانند. به این رفتار <strong>nondestructive mutation</strong> گفته می‌شود.</p>
<p>توجه داشته باشید که <strong>مجموعه‌های immutable از اضافه یا حذف آیتم‌ها جلوگیری می‌کنند</strong>؛ اما این <strong>محدودیت روی خود آیتم‌ها اعمال نمی‌شود</strong>. برای بهره کامل از <strong>immutable بودن</strong>، باید اطمینان حاصل کنید که فقط <strong>آیتم‌های immutable</strong> در مجموعه immutable قرار می‌گیرند.</p>
<hr>
<h3>🏗️ ایجاد Immutable Collections</h3>
<p>هر نوع مجموعه immutable یک متد <strong>Create<T>()</strong> ارائه می‌دهد که <strong>مقادیر اولیه اختیاری</strong> را می‌پذیرد و <strong>یک مجموعه immutable مقداردهی‌شده</strong> برمی‌گرداند:</p>
<pre><code class="language-csharp">ImmutableArray&lt;int&gt; array = ImmutableArray.Create&lt;int&gt;(1, 2, 3);
</code></pre>
<p>همچنین متد <strong>CreateRange<T></strong> وجود دارد که مشابه <code>Create&lt;T&gt;</code> عمل می‌کند؛ تفاوت آن در این است که <strong>پارامتر آن از نوع IEnumerable<T></strong> است، نه <code>params T[]</code>.</p>
<p>می‌توانید یک <strong>مجموعه immutable</strong> را از یک <code>IEnumerable&lt;T&gt;</code> موجود با استفاده از <strong>extension methodهای مناسب</strong> بسازید (<code>ToImmutableArray</code>، <code>ToImmutableList</code>، <code>ToImmutableDictionary</code> و غیره):</p>
<pre><code class="language-csharp">var list = new[] { 1, 2, 3 }.ToImmutableList();
</code></pre>
<hr>
<h3>🔄 دستکاری Immutable Collections</h3>
<p>متد <strong>Add</strong> یک <strong>مجموعه جدید</strong> شامل <strong>عناصر موجود به‌علاوه عنصر جدید</strong> برمی‌گرداند:</p>
<pre><code class="language-csharp">var oldList = ImmutableList.Create&lt;int&gt;(1, 2, 3);
ImmutableList&lt;int&gt; newList = oldList.Add(4);

Console.WriteLine(oldList.Count);   // 3  (تغییر نکرده)
Console.WriteLine(newList.Count);   // 4
</code></pre>
<p>متد <strong>Remove</strong> نیز به همین شکل عمل می‌کند و یک مجموعه جدید با آیتم حذف‌شده برمی‌گرداند.</p>
<p>اضافه یا حذف مکرر به این روش <strong>ناکارآمد است</strong>، زیرا برای هر عملیات یک مجموعه immutable جدید ساخته می‌شود.
راه بهتر استفاده از <strong>AddRange</strong> یا <strong>RemoveRange</strong> است که یک <code>IEnumerable&lt;T&gt;</code> از آیتم‌ها می‌پذیرد و همه آیتم‌ها را <strong>یکجا اضافه یا حذف می‌کند</strong>:</p>
<pre><code class="language-csharp">var anotherList = oldList.AddRange(new[] { 4, 5, 6 });
</code></pre>
<p>همچنین <strong>ImmutableList</strong> و <strong>ImmutableArray</strong> متدهای <strong>Insert</strong> و <strong>InsertRange</strong> برای درج آیتم در اندیس مشخص، <strong>RemoveAt</strong> برای حذف در اندیس مشخص و <strong>RemoveAll</strong> بر اساس predicate ارائه می‌دهند.</p>
<hr>
<h3>🏗️ Builders</h3>
<p>برای نیازهای مقداردهی پیچیده‌تر، هر کلاس مجموعه immutable دارای <strong>Builder</strong> متناظر است.
Builders به لحاظ عملکرد مشابه یک <strong>مجموعه mutable</strong> هستند. پس از مقداردهی، با فراخوانی <code>.ToImmutable()</code> روی Builder، یک مجموعه immutable جدید دریافت می‌کنید:</p>
<pre><code class="language-csharp">ImmutableArray&lt;int&gt;.Builder builder = ImmutableArray.CreateBuilder&lt;int&gt;();
builder.Add(1);
builder.Add(2);
builder.Add(3);
builder.RemoveAt(0);

ImmutableArray&lt;int&gt; myImmutable = builder.ToImmutable();
</code></pre>
<p>همچنین می‌توانید <strong>چندین تغییر را روی یک مجموعه immutable موجود به‌صورت گروهی</strong> انجام دهید:</p>
<pre><code class="language-csharp">var builder2 = myImmutable.ToBuilder();
builder2.Add(4);      // کارآمد
builder2.Remove(2);   // کارآمد
// تغییرات بیشتر روی builder...
ImmutableArray&lt;int&gt; myImmutable2 = builder2.ToImmutable(); // مجموعه جدید با تمام تغییرات
</code></pre>
<hr>
<h3>⚡ Immutable Collections و عملکرد</h3>
<p>بیشتر مجموعه‌های immutable از <strong>درخت AVL</strong> داخلی استفاده می‌کنند، که اجازه می‌دهد عملیات <strong>add/remove</strong> از بخش‌هایی از ساختار داخلی قبلی استفاده کنند و <strong>کل مجموعه دوباره ساخته نشود</strong>. این باعث می‌شود <strong>هزینه عملیات add/remove از بزرگ (در مجموعه‌های بزرگ) به متوسط کاهش یابد</strong>؛ اما خواندن داده‌ها کمی کندتر خواهد شد.
نتیجه نهایی این است که بیشتر مجموعه‌های immutable <strong>برای خواندن و نوشتن کندتر</strong> از نسخه‌های mutable هستند.</p>
<ul>
<li>بیشترین تاثیر روی <strong>ImmutableList<T></strong> است، که <strong>خواندن و افزودن آیتم</strong> در آن <strong>10 تا 200 برابر کندتر از List<T></strong> است (بسته به اندازه لیست).</li>
<li>به همین دلیل <strong>ImmutableArray<T></strong> وجود دارد: با استفاده از یک <strong>آرایه داخلی</strong>، عملکرد خواندن بدون کاهش سرعت انجام می‌شود (مشابه آرایه mutable معمولی). اما افزودن آیتم‌ها کندتر از حتی ImmutableList<T> است، زیرا ساختار قبلی قابل استفاده مجدد نیست.</li>
</ul>
<p>بنابراین، <strong>ImmutableArray<T></strong> زمانی مطلوب است که بخواهید <strong>عملکرد خواندن بدون محدودیت</strong> داشته باشید و انتظار <strong>اضافه/حذف مکرر آیتم‌ها</strong> را نداشته باشید (بدون استفاده از Builder).</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>❌ هزینه حذف در ImmutableArray</h3>
<p>فراخوانی <strong>Remove</strong> روی <strong>ImmutableArray</strong> گران‌تر از فراخوانی همان متد روی <strong>List<T></strong> است — حتی در <strong>بدترین حالت</strong> که اولین عنصر حذف شود — زیرا <strong>ایجاد مجموعه جدید فشار اضافی روی Garbage Collector وارد می‌کند</strong>.</p>
<p>با وجود اینکه مجموعه‌های immutable به‌طور کلی <strong>هزینه عملکردی قابل توجهی</strong> دارند، اما باید <strong>میزان واقعی را درک کرد</strong>. برای مثال، یک عملیات <strong>Add</strong> روی یک <strong>ImmutableList</strong> با یک میلیون عنصر، احتمالاً <strong>کمتر از یک میکروثانیه</strong> در یک لپ‌تاپ معمولی طول می‌کشد، و یک عملیات خواندن در <strong>کمتر از 100 نانوثانیه</strong> انجام می‌شود.</p>
<p>همچنین اگر نیاز باشد <strong>عملیات نوشتن در حلقه</strong> انجام شود، می‌توان با استفاده از <strong>Builder</strong> از هزینه تجمعی جلوگیری کرد.</p>
<hr>
<h3>⚡ کاهش هزینه‌ها در Immutable Collections</h3>
<p>عوامل زیر به کاهش هزینه‌ها کمک می‌کنند:</p>
<ul>
<li><strong>Immutable بودن</strong> امکان <strong>همزمانی و پردازش موازی ساده</strong> را فراهم می‌کند (Chapter 23)، بنابراین می‌توان از همه هسته‌های پردازنده استفاده کرد. پردازش موازی با حالت mutable به‌راحتی منجر به خطا می‌شود و نیاز به قفل‌ها یا مجموعه‌های همزمان دارد که هر دو عملکرد را کاهش می‌دهند.</li>
<li>با <strong>Immutable بودن</strong> نیازی به <strong>کپی حفاظتی (defensive copy)</strong> از مجموعه‌ها یا ساختارهای داده برای جلوگیری از تغییرات غیرمنتظره نیست. این یکی از دلایلی است که در نوشتن بخش‌های اخیر <strong>Visual Studio</strong> از مجموعه‌های immutable استفاده شد.</li>
<li>در اکثر برنامه‌های معمولی، تعداد کمی از مجموعه‌ها دارای آیتم کافی هستند که تفاوت ملموس باشد.</li>
</ul>
<p>علاوه بر <strong>Visual Studio</strong>، <strong>Microsoft Roslyn</strong> نیز با استفاده از مجموعه‌های immutable ساخته شده است، که نشان می‌دهد مزایا می‌توانند بر هزینه‌ها غالب شوند.</p>
<hr>
<h3>❄️ Frozen Collections</h3>
<p>از <strong>.NET 8</strong>، فضای نام <strong>System.Collections.Frozen</strong> شامل دو کلاس <strong>مجموعه فقط‌خواندنی</strong> است:</p>
<ul>
<li><code>FrozenDictionary&lt;TKey,TValue&gt;</code></li>
<li><code>FrozenSet&lt;T&gt;</code></li>
</ul>
<p>این مجموعه‌ها مشابه <strong>ImmutableDictionary&lt;K,V&gt;</strong> و <strong>ImmutableHashSet<T></strong> هستند، اما <strong>متدهایی برای nondestructive mutation</strong> (مثل Add یا Remove) ندارند و بنابراین <strong>عملکرد خواندن بهینه‌ای دارند</strong>.</p>
<p>برای ایجاد یک <strong>Frozen Collection</strong>، ابتدا با یک مجموعه یا دنباله شروع می‌کنید و سپس از <strong>extension method</strong>های <code>ToFrozenDictionary</code> یا <code>ToFrozenSet</code> استفاده می‌کنید:</p>
<pre><code class="language-csharp">int[] numbers = { 10, 20, 30 };
FrozenSet&lt;int&gt; frozen = numbers.ToFrozenSet();
Console.WriteLine(frozen.Contains(10));  // True
</code></pre>
<p>مجموعه‌های frozen برای <strong>جستجوهایی که در ابتدای برنامه مقداردهی می‌شوند و در طول برنامه استفاده می‌شوند</strong> عالی هستند:</p>
<pre><code class="language-csharp">class Disassembler
{
    public readonly static IReadOnlyDictionary&lt;string,string&gt; OpCodeLookup =
        new Dictionary&lt;string, string&gt;()
        {
            { &quot;ADC&quot;, &quot;Add with Carry&quot; },
            { &quot;ADD&quot;, &quot;Add&quot; },
            { &quot;AND&quot;, &quot;Logical AND&quot; },
            { &quot;ANDN&quot;, &quot;Logical AND NOT&quot; },
            ...
        }
        .ToFrozenDictionary();
    ...
}
</code></pre>
<p>مجموعه‌های frozen <strong>رابط استاندارد dictionary/set</strong> و نسخه‌های فقط‌خواندنی آن‌ها را پیاده‌سازی می‌کنند. در مثال بالا، <strong>FrozenDictionary&lt;string,string&gt;</strong> به‌عنوان <strong>فیلدی از نوع IReadOnlyDictionary&lt;string,string&gt;</strong> در دسترس قرار گرفته است.</p>
<hr>
<h3>⚙️ Plugging in Equality and Order</h3>
<p>در بخش‌های <strong>“Equality Comparison”</strong> (صفحه 226) و <strong>“Order Comparison”</strong> (صفحه 355) پروتکل‌های استاندارد .NET توضیح داده شد که یک نوع را <strong>قابل مقایسه، قابل هش و equatable</strong> می‌کنند.</p>
<p>یک نوع که این پروتکل‌ها را پیاده‌سازی کند، می‌تواند به‌طور صحیح در <strong>dictionary</strong> یا <strong>sorted list</strong> استفاده شود:</p>
<ul>
<li>نوعی که <strong>Equals</strong> و <strong>GetHashCode</strong> نتایج معناداری برمی‌گرداند، می‌تواند به‌عنوان <strong>کلید در Dictionary یا Hashtable</strong> استفاده شود.</li>
<li>نوعی که <strong>IComparable / IComparable<T></strong> پیاده‌سازی کند، می‌تواند به‌عنوان <strong>کلید در هر dictionary یا لیست مرتب شده</strong> استفاده شود.</li>
</ul>
<p>پیاده‌سازی پیش‌فرض معمولاً رفتار طبیعی نوع را بازتاب می‌دهد، اما گاهی اوقات لازم است رفتار متفاوتی داشته باشید. برای مثال:</p>
<ul>
<li>یک dictionary با <strong>کلیدهای string بدون حساسیت به حروف</strong></li>
<li>یا یک <strong>sorted list از مشتریان، مرتب‌شده بر اساس کدپستی</strong></li>
</ul>
<p>به همین دلیل، .NET مجموعه‌ای از <strong>“plug-in” پروتکل‌ها</strong> را تعریف کرده است. این پروتکل‌ها دو کار انجام می‌دهند:</p>
<ul>
<li>امکان <strong>جایگزینی رفتار پیش‌فرض برای مقایسه و برابری</strong></li>
<li>استفاده از dictionary یا مجموعه مرتب با <strong>نوع کلیدی که به‌طور ذاتی equatable یا comparable نیست</strong></li>
</ul>
<p>پروتکل‌های plug-in شامل <strong>interfaceهای زیر</strong> هستند:</p>
<p><strong>IEqualityComparer و IEqualityComparer<T></strong></p>
<ul>
<li>انجام <strong>مقایسه و هشینگ جایگزین</strong></li>
<li>توسط <strong>Hashtable و Dictionary</strong> شناخته می‌شود</li>
</ul>
<p><strong>IComparer و IComparer<T></strong></p>
<ul>
<li>انجام <strong>مقایسه ترتیب جایگزین</strong></li>
<li>توسط <strong>sorted dictionaries و collections</strong> شناخته می‌شود؛ همچنین توسط <strong>Array.Sort</strong></li>
</ul>
<p>هر interface هم <strong>نسخه generic و nongeneric</strong> دارد.
همچنین، <strong>IEqualityComparer</strong> شامل یک <strong>پیاده‌سازی پیش‌فرض در کلاس EqualityComparer</strong> است.
علاوه بر این، <strong>interfaceهایی به نام IStructuralEquatable و IStructuralComparable</strong> وجود دارند که امکان <strong>مقایسه‌های ساختاری (structural comparisons)</strong> را برای کلاس‌ها و آرایه‌ها فراهم می‌کنند.</p>
<hr>
<h3>⚖️ IEqualityComparer و EqualityComparer</h3>
<p>یک <strong>equality comparer</strong> این امکان را فراهم می‌کند که رفتار <strong>برابری و هشینگ غیرپیش‌فرض</strong> جایگزین شود، عمدتاً برای کلاس‌های <strong>Dictionary</strong> و <strong>Hashtable</strong>.</p>
<p>به یاد بیاورید که یک <strong>dictionary مبتنی بر hashtable</strong> به دو سؤال برای هر کلید نیاز دارد:</p>
<ul>
<li>آیا این کلید <strong>همانند کلید دیگری</strong> است؟</li>
<li><strong>HashCode صحیح</strong> آن چیست؟</li>
</ul>
<p>یک equality comparer به این دو سؤال پاسخ می‌دهد با پیاده‌سازی <strong>interfaceهای IEqualityComparer</strong>:</p>
<pre><code class="language-csharp">public interface IEqualityComparer&lt;T&gt;
{
    bool Equals(T x, T y);
    int GetHashCode(T obj);
}

public interface IEqualityComparer   // نسخه nongeneric
{
    bool Equals(object x, object y);
    int GetHashCode(object obj);
}
</code></pre>
<p>برای نوشتن <strong>comparer سفارشی</strong>، می‌توانید یکی یا هر دو interface را پیاده‌سازی کنید (پیاده‌سازی هر دو حداکثر سازگاری را فراهم می‌کند).</p>
<p>چون این کار کمی وقت‌گیر است، یک جایگزین استفاده از <strong>کلاس انتزاعی EqualityComparer</strong> است:</p>
<pre><code class="language-csharp">public abstract class EqualityComparer&lt;T&gt; : IEqualityComparer, IEqualityComparer&lt;T&gt;
{
    public abstract bool Equals(T x, T y);
    public abstract int GetHashCode(T obj);

    bool IEqualityComparer.Equals(object x, object y);
    int IEqualityComparer.GetHashCode(object obj);
    public static EqualityComparer&lt;T&gt; Default { get; }
}
</code></pre>
<p>کلاس <strong>EqualityComparer</strong> هر دو interface را پیاده‌سازی می‌کند و تنها کاری که شما باید انجام دهید، <strong>override کردن دو متد انتزاعی</strong> است.</p>
<hr>
<h3>🧾 مثال: Customer و EqualityComparer سفارشی</h3>
<p>مثلاً یک کلاس <strong>Customer</strong> با دو فیلد داریم و یک equality comparer می‌نویسیم که هر دو <strong>نام و نام خانوادگی</strong> را مقایسه کند:</p>
<pre><code class="language-csharp">public class Customer
{
    public string LastName;
    public string FirstName;
    public Customer(string last, string first)
    {
        LastName = last;
        FirstName = first;
    }
}

public class LastFirstEqComparer : EqualityComparer&lt;Customer&gt;
{
    public override bool Equals(Customer x, Customer y)
        =&gt; x.LastName == y.LastName &amp;&amp; x.FirstName == y.FirstName;
    public override int GetHashCode(Customer obj)
        =&gt; (obj.LastName + &quot;;&quot; + obj.FirstName).GetHashCode();
}
</code></pre>
<p>حالا دو customer ایجاد می‌کنیم:</p>
<pre><code class="language-csharp">Customer c1 = new Customer(&quot;Bloggs&quot;, &quot;Joe&quot;);
Customer c2 = new Customer(&quot;Bloggs&quot;, &quot;Joe&quot;);
</code></pre>
<p>چون <strong>object.Equals</strong> را override نکرده‌ایم، رفتار پیش‌فرض <strong>reference equality</strong> اعمال می‌شود:</p>
<pre><code class="language-csharp">Console.WriteLine(c1 == c2);       // False
Console.WriteLine(c1.Equals(c2));  // False
</code></pre>
<p>در استفاده از Dictionary بدون تعیین equality comparer، همین رفتار پیش‌فرض اعمال می‌شود:</p>
<pre><code class="language-csharp">var d = new Dictionary&lt;Customer, string&gt;();
d[c1] = &quot;Joe&quot;;
Console.WriteLine(d.ContainsKey(c2));  // False
</code></pre>
<p>اما با استفاده از equality comparer سفارشی:</p>
<pre><code class="language-csharp">var eqComparer = new LastFirstEqComparer();
var d = new Dictionary&lt;Customer, string&gt;(eqComparer);
d[c1] = &quot;Joe&quot;;
Console.WriteLine(d.ContainsKey(c2));  // True
</code></pre>
<p>⚠️ نکته: هنگام استفاده از Dictionary با یک <strong>comparer سفارشی</strong>، باید مراقب باشید که <strong>FirstName یا LastName مشتری تغییر نکند</strong>، چون تغییر HashCode باعث شکستن Dictionary می‌شود.</p>
<hr>
<h3>✅ EqualityComparer<T>.Default</h3>
<p>فراخوانی <code>EqualityComparer&lt;T&gt;.Default</code> یک <strong>equality comparer عمومی</strong> برمی‌گرداند که می‌توان آن را به جای <strong>object.Equals</strong> استفاده کرد.
مزیت آن این است که ابتدا بررسی می‌کند آیا <strong>T IEquatable<T></strong> پیاده‌سازی کرده است یا خیر، و اگر کرده باشد، آن پیاده‌سازی را فراخوانی می‌کند و از <strong>boxing overhead</strong> جلوگیری می‌کند.</p>
<p>مثال:</p>
<pre><code class="language-csharp">static bool Foo&lt;T&gt;(T x, T y)
{
    bool same = EqualityComparer&lt;T&gt;.Default.Equals(x, y);
    ...
}
</code></pre>
<hr>
<h3>🧩 ReferenceEqualityComparer.Instance (.NET 5+)</h3>
<p>از <strong>.NET 5</strong>، <code>ReferenceEqualityComparer.Instance</code> یک <strong>equality comparer</strong> برمی‌گرداند که همیشه <strong>referential equality</strong> را اعمال می‌کند.
در مورد <strong>value types</strong>، متد <strong>Equals</strong> آن همیشه <strong>false</strong> برمی‌گرداند.</p>
<h3>🏷️ IComparer و Comparer</h3>
<p><strong>Comparers</strong> برای جایگزینی منطق <strong>مرتب‌سازی سفارشی</strong> در <strong>dictionaries و collectionهای مرتب</strong> استفاده می‌شوند.</p>
<p>توجه کنید که <strong>comparerها برای دیکشنری‌های بدون ترتیب</strong> مانند <strong>Dictionary</strong> و <strong>Hashtable</strong> کاربردی ندارند—چرا که این‌ها نیاز به <strong>IEqualityComparer</strong> برای گرفتن hashcode دارند.
به همین ترتیب، یک <strong>equality comparer</strong> برای دیکشنری‌ها یا collectionهای مرتب کاربردی ندارد.</p>
<p>تعاریف interface <strong>IComparer</strong> به شرح زیر است:</p>
<pre><code class="language-csharp">public interface IComparer
{
    int Compare(object x, object y);
}

public interface IComparer&lt;in T&gt;
{
    int Compare(T x, T y);
}
</code></pre>
<p>همانند <strong>equality comparers</strong>، یک کلاس انتزاعی وجود دارد که می‌توانید آن را subclass کنید به جای پیاده‌سازی مستقیم interfaceها:</p>
<pre><code class="language-csharp">public abstract class Comparer&lt;T&gt; : IComparer, IComparer&lt;T&gt;
{
    public static Comparer&lt;T&gt; Default { get; }
    public abstract int Compare(T x, T y);          // توسط شما پیاده‌سازی می‌شود
    int IComparer.Compare(object x, object y);     // برای شما پیاده‌سازی شده
}
</code></pre>
<hr>
<h3>مثال: مرتب‌سازی Wish بر اساس Priority</h3>
<pre><code class="language-csharp">class Wish
{
    public string Name;
    public int Priority;
    public Wish(string name, int priority)
    {
        Name = name;
        Priority = priority;
    }
}

class PriorityComparer : Comparer&lt;Wish&gt;
{
    public override int Compare(Wish x, Wish y)
    {
        if (object.Equals(x, y)) return 0;    // بهینه‌سازی
        if (x == null) return -1;
        if (y == null) return 1;
        return x.Priority.CompareTo(y.Priority);
    }
}
</code></pre>
<p>✅ نکته: بررسی <code>object.Equals</code> اطمینان می‌دهد که هیچ‌گاه با روش <code>Equals</code> تناقض پیدا نکنیم. استفاده از متد <strong>static object.Equals</strong> بهتر از <code>x.Equals</code> است چون حتی وقتی <code>x</code> برابر null است، کار می‌کند.</p>
<p>مرتب‌سازی یک لیست با استفاده از <strong>PriorityComparer</strong>:</p>
<pre><code class="language-csharp">var wishList = new List&lt;Wish&gt;();
wishList.Add(new Wish(&quot;Peace&quot;, 2));
wishList.Add(new Wish(&quot;Wealth&quot;, 3));
wishList.Add(new Wish(&quot;Love&quot;, 2));
wishList.Add(new Wish(&quot;3 more wishes&quot;, 1));

wishList.Sort(new PriorityComparer());

foreach (Wish w in wishList)
    Console.Write(w.Name + &quot; | &quot;);
// OUTPUT: 3 more wishes | Love | Peace | Wealth |
</code></pre>
<hr>
<h3>مثال: مرتب‌سازی رشته‌ها برای دفترچه تلفن</h3>
<pre><code class="language-csharp">class SurnameComparer : Comparer&lt;string&gt;
{
    string Normalize(string s)
    {
        s = s.Trim().ToUpper();
        if (s.StartsWith(&quot;MC&quot;)) s = &quot;MAC&quot; + s.Substring(2);
        return s;
    }
    public override int Compare(string x, string y)
        =&gt; Normalize(x).CompareTo(Normalize(y));
}
</code></pre>
<p>استفاده در یک <strong>SortedDictionary</strong>:</p>
<pre><code class="language-csharp">var dic = new SortedDictionary&lt;string, string&gt;(new SurnameComparer());
dic.Add(&quot;MacPhail&quot;, &quot;second!&quot;);
dic.Add(&quot;MacWilliam&quot;, &quot;third!&quot;);
dic.Add(&quot;McDonald&quot;, &quot;first!&quot;);

foreach (string s in dic.Values)
    Console.Write(s + &quot; &quot;);  // first! second! third!
</code></pre>
<hr>
<h3>🔤 StringComparer</h3>
<p><code>StringComparer</code> یک کلاس plug-in پیش‌فرض برای <strong>برابری و مقایسه رشته‌ها</strong> است که امکان تعیین <strong>زبان و حساسیت به حروف بزرگ/کوچک</strong> را می‌دهد.
این کلاس هم <strong>IEqualityComparer</strong> و هم <strong>IComparer</strong> (نسخه‌های generic و nongeneric) را پیاده‌سازی می‌کند، بنابراین می‌توان از آن با هر نوع dictionary یا collection مرتب استفاده کرد.</p>
<p>چون StringComparer انتزاعی است، نمونه‌ها از طریق <strong>static properties</strong> آن بدست می‌آیند:</p>
<pre><code class="language-csharp">public static StringComparer CurrentCulture { get; }
public static StringComparer CurrentCultureIgnoreCase { get; }
public static StringComparer InvariantCulture { get; }
public static StringComparer InvariantCultureIgnoreCase { get; }
public static StringComparer Ordinal { get; }
public static StringComparer OrdinalIgnoreCase { get; }
public static StringComparer Create(CultureInfo culture, bool ignoreCase);
</code></pre>
<p>مثال: دیکشنری حساس به حروف که <code>&quot;Joe&quot;</code> و <code>&quot;JOE&quot;</code> را برابر می‌داند:</p>
<pre><code class="language-csharp">var dict = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase);
</code></pre>
<p>مثال مرتب‌سازی آرایه‌ای با زبان <strong>انگلیسی استرالیا</strong>:</p>
<pre><code class="language-csharp">string[] names = { &quot;Tom&quot;, &quot;HARRY&quot;, &quot;sheila&quot; };
CultureInfo ci = new CultureInfo(&quot;en-AU&quot;);
Array.Sort&lt;string&gt;(names, StringComparer.Create(ci, false));
</code></pre>
<p>نسخه‌ای culture-aware از <strong>SurnameComparer</strong>:</p>
<pre><code class="language-csharp">class SurnameComparer : Comparer&lt;string&gt;
{
    StringComparer strCmp;
    public SurnameComparer(CultureInfo ci)
    {
        // ایجاد string comparer حساس به فرهنگ و حساس به حروف
        strCmp = StringComparer.Create(ci, false);
    }

    string Normalize(string s)
    {
        s = s.Trim();
        if (s.ToUpper().StartsWith(&quot;MC&quot;)) s = &quot;MAC&quot; + s.Substring(2);
        return s;
    }

    public override int Compare(string x, string y)
    {
        return strCmp.Compare(Normalize(x), Normalize(y));
    }
}
</code></pre>
<hr>
<h3>⚙️ IStructuralEquatable و IStructuralComparable</h3>
<p>همان‌طور که در فصل ۶ گفتیم، <strong>structها به طور پیش‌فرض</strong> مقایسه ساختاری دارند: دو struct برابر هستند اگر تمام فیلدهایشان برابر باشند.
گاهی اوقات، <strong>برابری و مرتب‌سازی ساختاری</strong> برای انواع دیگر مانند آرایه‌ها نیز مفید است.</p>
<pre><code class="language-csharp">public interface IStructuralEquatable
{
    bool Equals(object other, IEqualityComparer comparer);
    int GetHashCode(IEqualityComparer comparer);
}

public interface IStructuralComparable
{
    int CompareTo(object other, IComparer comparer);
}
</code></pre>
<p><strong>IEqualityComparer / IComparer</strong> که پاس داده می‌شوند، روی <strong>هر عنصر از شیء مرکب</strong> اعمال می‌شوند.</p>
<p>مثال مقایسه آرایه‌ها:</p>
<pre><code class="language-csharp">int[] a1 = { 1, 2, 3 };
int[] a2 = { 1, 2, 3 };
IStructuralEquatable se1 = a1;

Console.Write(a1.Equals(a2));                                  // False
Console.Write(se1.Equals(a2, EqualityComparer&lt;int&gt;.Default));  // True
</code></pre>
<p>مثال دیگر:</p>
<pre><code class="language-csharp">string[] a1 = &quot;the quick brown fox&quot;.Split();
string[] a2 = &quot;THE QUICK BROWN FOX&quot;.Split();
IStructuralEquatable se1 = a1;
bool isTrue = se1.Equals(a2, StringComparer.InvariantCultureIgnoreCase);
</code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
