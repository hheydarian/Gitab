

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>پاسخ‌های احتمالی برای تمرین‌ها</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  @font-face {
    font-family: "Lalezar";
    src: url('fonts/Lalezar.ttf') format('truetype');
    font-display: swap;
}
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
         <a href="/Gitab/giter.html" >دوره ها</a>
          <!-- 
         <a href="/Gitab/translator.html" >مترجمین</a>
           -->
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>پیوست ۲ - پاسخ‌های احتمالی برای تمرین‌ها</h1>
<blockquote>
<p><em>«ترجیح می‌دهم سوالاتی داشته باشم که نمی‌توان به آن‌ها پاسخ داد، تا پاسخ‌هایی که نمی‌توان آن‌ها را زیر سوال برد.»</em><br>
— ریچارد فاینمن</p>
</blockquote>
<p><strong>پاسخ ۱ (از تمرین ۱)</strong><br>
از نظر ما، کلاس <code>Split2</code> متعامدتر (Orthogonal) است. این کلاس روی وظیفه خودش، یعنی تقسیم خطوط تمرکز می‌کند و جزئیاتی مانند اینکه خطوط از کجا می‌آیند را نادیده می‌گیرد. این کار نه تنها توسعه کد را آسان‌تر می‌کند، بلکه آن را منعطف‌تر نیز می‌سازد. <code>Split2</code> می‌تواند خطوط خوانده شده از یک فایل، تولید شده توسط یک روتین دیگر، یا ارسال شده از طریق محیط (Environment) را تقسیم کند.</p>
<p><strong>پاسخ ۲ (از تمرین ۲)</strong><br>
بیایید با یک ادعا شروع کنیم: شما می‌توانید تقریباً در هر زبانی کد خوب و متعامد بنویسید. در عین حال، هر زبانی وسوسه‌هایی دارد: ویژگی‌هایی که می‌توانند منجر به افزایش وابستگی (Coupling) و کاهش تعامد شوند.</p>
<p>در زبان‌های شیءگرا (OO)، ویژگی‌هایی مثل ارث‌بری چندگانه، استثناها (Exceptions)، سربارگذاری عملگرها (Operator Overloading)، و بازنویسی متدهای والد (از طریق زیرکلاس‌سازی) فرصت‌های فراوانی را برای افزایش وابستگی به روش‌های غیربدیهی فراهم می‌کنند. همچنین نوعی وابستگی وجود دارد زیرا یک کلاس، کد را به داده متصل می‌کند. این معمولاً چیز خوبی است (وقتی وابستگی خوب است، به آن <strong>انسجام</strong> یا Cohesion می‌گوییم). اما اگر کلاس‌هایتان را به اندازه کافی متمرکز نسازید، می‌تواند منجر به رابط‌های (Interfaces) بسیار زشتی شود.</p>
<p>در زبان‌های تابعی، شما تشویق می‌شوید که توابع کوچک و جدا از همِ (Decoupled) زیادی بنویسید و آن‌ها را به روش‌های مختلف ترکیب کنید تا مشکلتان را حل کنید. در تئوری این خوب به نظر می‌رسد. در عمل هم اغلب همین‌طور است. اما در اینجا هم نوعی وابستگی می‌تواند رخ دهد. این توابع معمولاً داده‌ها را تغییر شکل (Transform) می‌دهند، که یعنی نتیجه یک تابع می‌تواند ورودی تابع دیگری شود. اگر مراقب نباشید، ایجاد تغییر در فرمت داده‌ای که یک تابع تولید می‌کند، می‌تواند منجر به شکست در جایی پایین‌تر در جریانِ تغییر شکل (Transformational stream) شود. زبان‌هایی با سیستم‌های نوع (Type systems) خوب می‌توانند به کاهش این مشکل کمک کنند.</p>
<p><strong>پاسخ ۳ (از تمرین ۳)</strong><br>
تکنولوژی پایین (Low-tech) به کمک می‌آید! چند کارتون (نقاشی ساده) با ماژیک روی وایت‌برد بکشید—یک ماشین، یک تلفن و یک خانه. لازم نیست هنرِ عالی باشد؛ طرح‌های آدم‌خطی (Stick-figure) هم خوبند. روی نواحی قابل کلیک، کاغذهای یادداشت (Post-it) بچسبانید که محتویات صفحات مقصد را توضیح می‌دهند. با پیشرفت جلسه، می‌توانید نقاشی‌ها و محل قرارگیری کاغذهای یادداشت را اصلاح کنید.</p>
<p><strong>پاسخ ۴ (از تمرین ۴)</strong><br>
چون می‌خواهیم زبان را قابل گسترش کنیم، پارسر (Parser) را <strong>جدول‌محور</strong> (Table driven) می‌سازیم. هر ورودی در جدول شامل حرفِ فرمان، یک پرچم (Flag) برای اینکه بگوید آیا آرگومان لازم است یا نه، و نام روتینی که باید برای مدیریت آن فرمانِ خاص فراخوانی شود، می‌باشد.</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/turtle.c</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">char</span> cmd;             <span class="hljs-comment">/* the command letter */</span>
    <span class="hljs-type">int</span> hasArg;           <span class="hljs-comment">/* does it take an argument */</span>
    <span class="hljs-type">void</span> (*func)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">/* routine to call */</span>
} Command;

<span class="hljs-type">static</span> Command cmds[] = {
    { <span class="hljs-string">&#x27;P&#x27;</span>, ARG, doSelectPen },
    { <span class="hljs-string">&#x27;U&#x27;</span>, NO_ARG, doPenUp },
    { <span class="hljs-string">&#x27;D&#x27;</span>, NO_ARG, doPenDown },
    { <span class="hljs-string">&#x27;N&#x27;</span>, ARG, doPenDir },
    { <span class="hljs-string">&#x27;E&#x27;</span>, ARG, doPenDir },
    { <span class="hljs-string">&#x27;S&#x27;</span>, ARG, doPenDir },
    { <span class="hljs-string">&#x27;W&#x27;</span>, ARG, doPenDir }
};
</code></pre>
<p>برنامه اصلی (Main) بسیار ساده است: یک خط را بخوان، فرمان را جستجو کن، اگر لازم بود آرگومان را بگیر، سپس تابعِ هندلر (Handler) را صدا بزن.</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/turtle.c</span>
<span class="hljs-keyword">while</span> (fgets(buff, <span class="hljs-keyword">sizeof</span>(buff), <span class="hljs-built_in">stdin</span>)) {
    Command *cmd = findCommand(*buff);
    <span class="hljs-keyword">if</span> (cmd) {
        <span class="hljs-type">int</span> arg = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (cmd-&gt;hasArg &amp;&amp; !getArg(buff+<span class="hljs-number">1</span>, &amp;arg)) {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;&#x27;%c&#x27; needs an argument\n&quot;</span>, *buff);
            <span class="hljs-keyword">continue</span>;
        }
        cmd-&gt;func(*buff, arg);
    }
}
</code></pre>
<p>تابعی که دنبال یک فرمان می‌گردد، یک جستجوی خطی در جدول انجام می‌دهد و یا ورودی منطبق را برمی‌گرداند یا <code>NULL</code>.</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/turtle.c</span>
Command *<span class="hljs-title function_">findCommand</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd)</span> {
    <span class="hljs-type">int</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ARRAY_SIZE(cmds); i++) {
        <span class="hljs-keyword">if</span> (cmds[i].cmd == cmd)
            <span class="hljs-keyword">return</span> cmds + i;
    }
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unknown command &#x27;%c&#x27;\n&quot;</span>, cmd);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>در نهایت، خواندن آرگومان عددی با استفاده از <code>sscanf</code> بسیار ساده است.</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/turtle.c</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">getArg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buff, <span class="hljs-type">int</span> *result)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sscanf</span>(buff, <span class="hljs-string">&quot;%d&quot;</span>, result) == <span class="hljs-number">1</span>;
}
</code></pre>
<p><strong>پاسخ ۵ (از تمرین ۵)</strong><br>
در واقع، شما قبلاً این مسئله را در تمرین قبلی حل کرده‌اید. جایی که مفسر (Interpreter) را برای زبان خارجی نوشتید، همان مفسر داخلی را در بر خواهد داشت. در مورد کد نمونه ما، این همان توابع <code>doXxx</code> هستند.</p>
<p><strong>پاسخ ۶ (از تمرین ۶)</strong><br>
با استفاده از فرمت BNF، مشخصات زمان (Time specification) می‌تواند چنین باشد:</p>
<pre class="hljs"><code>time  ::= hour ampm | hour : minute ampm | hour : minute
ampm  ::= am | pm
hour  ::= digit | digit digit
minute ::= digit digit
digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p>یک تعریف بهتر برای ساعت و دقیقه، در نظر می‌گیرد که ساعت فقط می‌تواند از ۰۰ تا ۲۳ باشد، و دقیقه از ۰۰ تا ۵۹:</p>
<pre class="hljs"><code>hour   ::= h-tens digit | digit
minute ::= m-tens digit
h-tens ::= 0 | 1
m-tens ::= 0 | 1 | 2 | 3 | 4 | 5
digit  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p><strong>پاسخ ۷ (از تمرین ۷)</strong><br>
این هم پارسر که با استفاده از کتابخانه جاوااسکریپت <code>Pegjs</code> نوشته شده است:</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/peg_parser/time_parser.pegjs</span>
time
  = <span class="hljs-attr">h</span>:hour <span class="hljs-attr">offset</span>:ampm { <span class="hljs-keyword">return</span> h + offset }
  / <span class="hljs-attr">h</span>:hour <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-attr">m</span>:minute <span class="hljs-attr">offset</span>:ampm { <span class="hljs-keyword">return</span> h + m + offset }
  / <span class="hljs-attr">h</span>:hour <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-attr">m</span>:minute { <span class="hljs-keyword">return</span> h + m }

ampm
  = <span class="hljs-string">&quot;am&quot;</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> }
  / <span class="hljs-string">&quot;pm&quot;</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>*<span class="hljs-number">60</span> }

hour
  = <span class="hljs-attr">h</span>:two_hour_digits { <span class="hljs-keyword">return</span> h*<span class="hljs-number">60</span> }
  / <span class="hljs-attr">h</span>:digit { <span class="hljs-keyword">return</span> h*<span class="hljs-number">60</span> }

minute
  = <span class="hljs-attr">d1</span>:[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>] <span class="hljs-attr">d2</span>:[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] { <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(d1+d2, <span class="hljs-number">10</span>); }

digit
  = <span class="hljs-attr">digit</span>:[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] { <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(digit, <span class="hljs-number">10</span>); }

two_hour_digits
  = <span class="hljs-attr">d1</span>:[<span class="hljs-number">01</span>] <span class="hljs-attr">d2</span>:[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] { <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(d1+d2, <span class="hljs-number">10</span>); }
  / <span class="hljs-attr">d1</span>:[<span class="hljs-number">2</span>] <span class="hljs-attr">d2</span>:[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>] { <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(d1+d2, <span class="hljs-number">10</span>); }
</code></pre>
<p>تست‌ها استفاده از آن را نشان می‌دهند:</p>
<pre class="hljs"><code><span class="hljs-comment">// lang/peg_parser/test_time_parser.js</span>
<span class="hljs-keyword">let</span> test = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;tape&#x27;</span>);
<span class="hljs-keyword">let</span> time_parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./time_parser.js&#x27;</span>);

<span class="hljs-comment">// (توضیحات BNF در اینجا تکرار شده است)</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">h</span> = (<span class="hljs-params">val</span>) =&gt; val*<span class="hljs-number">60</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">m</span> = (<span class="hljs-params">val</span>) =&gt; val;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">am</span> = (<span class="hljs-params">val</span>) =&gt; val;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pm</span> = (<span class="hljs-params">val</span>) =&gt; val + <span class="hljs-title function_">h</span>(<span class="hljs-number">12</span>);

<span class="hljs-keyword">let</span> tests = {
    <span class="hljs-string">&quot;1am&quot;</span>: <span class="hljs-title function_">h</span>(<span class="hljs-number">1</span>),
    <span class="hljs-string">&quot;1pm&quot;</span>: <span class="hljs-title function_">pm</span>(<span class="hljs-title function_">h</span>(<span class="hljs-number">1</span>)),
    <span class="hljs-string">&quot;2:30&quot;</span>: <span class="hljs-title function_">h</span>(<span class="hljs-number">2</span>) + <span class="hljs-title function_">m</span>(<span class="hljs-number">30</span>),
    <span class="hljs-string">&quot;14:30&quot;</span>: <span class="hljs-title function_">pm</span>(<span class="hljs-title function_">h</span>(<span class="hljs-number">2</span>)) + <span class="hljs-title function_">m</span>(<span class="hljs-number">30</span>),
    <span class="hljs-string">&quot;2:30pm&quot;</span>: <span class="hljs-title function_">pm</span>(<span class="hljs-title function_">h</span>(<span class="hljs-number">2</span>)) + <span class="hljs-title function_">m</span>(<span class="hljs-number">30</span>),
}

<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;time parsing&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string <span class="hljs-keyword">in</span> tests) {
        <span class="hljs-keyword">let</span> result = time_parser.<span class="hljs-title function_">parse</span>(string)
        t.<span class="hljs-title function_">equal</span>(result, tests[string], string);
    }
    t.<span class="hljs-title function_">end</span>()
});
</code></pre>
<p><strong>پاسخ ۸ (از تمرین ۸)</strong><br>
این هم یک راه‌حل ممکن در روبی:</p>
<pre class="hljs"><code><span class="hljs-comment"># lang/re_parser/time_parser.rb</span>
<span class="hljs-variable constant_">TIME_RE</span> = <span class="hljs-regexp">%r{ (?
</span></code></pre>
<p>این هم ادامه کد و پایانِ پاسخ تمرین ۸:</p>
<pre class="hljs"><code>  (<span class="hljs-string">?&lt;</span>hour&gt; \d{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>} )      <span class="hljs-comment"># Get the hour</span>
  (<span class="hljs-string">?:</span>                     <span class="hljs-comment"># Optional minute part</span>
    :
    (<span class="hljs-string">?&lt;</span>minute&gt; \d{<span class="hljs-number">2</span>} )
  )?
  \s*                     <span class="hljs-comment"># Optional whitespace</span>
  (<span class="hljs-string">?&lt;</span>ampm&gt; am |<span class="hljs-params"> pm )?     # Optional am/pm string
}xi

def parse_time(string)
  m = TIME_RE.match(string)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">unless</span> m
  hour = m[:hour].to_i
  minute = (m[:minute] </span>||<span class="hljs-params"> &#x27;0&#x27;).to_i
  ampm = (m[:ampm] </span>||<span class="hljs-params"> &#x27;&#x27;).downcase

  hour = hour + 12 <span class="hljs-keyword">if</span> ampm == &#x27;pm&#x27; &amp;&amp; hour != 12
  hour = 0         <span class="hljs-keyword">if</span> ampm == &#x27;am&#x27; &amp;&amp; hour == 12

  hour * 60 + minute
<span class="hljs-keyword">end</span>

# Test it
puts parse_time(&quot;1am&quot;)    # =&gt; 60
puts parse_time(&quot;2:30&quot;)   # =&gt; 150
puts parse_time(&quot;2:30pm&quot;) # =&gt; 870
</span></code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — تمامی حقوق محفوظ است.
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
  
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
